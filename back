// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *            animation.cpp - EXILE Animation Objects File               *
// *************************************************************************

#include "revenant.h"
#include "display.h"
#include "bitmap.h"
#include "graphics.h"
#include "resource.h"
#include "animation.h"

TAnimation::TAnimation()
{
}

TAnimation::~TAnimation()
{
}

PTAnimation TAnimation::Load(int resource)
{
	return (PTAnimation)LoadResource("animation", resource);
}	 

BOOL TAnimation::Decompress(PSDrawBlock db, int frame, BOOL Transparent)
{
	return TRUE;
}

void TAnimation::Put(PTSurface surface, void *decbuf, int frame, PSDrawParam dp)
{
	SDrawBlock  db;
	SDrawParam  dp2 = *dp;

	if (surface == NULL || (decbuf == NULL && (flags & AF_INTERFRAME))) 
		return;

	if (frame > numframes) 
		return;

	PTBitmap framebmp = frames[frame].bitmap;
	surface->ParamDraw(dp, framebmp);
	return;
	
	if (flags & AF_INTERFRAME) 
	{

		framebmp      = (PTBitmap)(frames[frame].bitmap.ptr());

		db.sbufwidth  = db.dbufwidth  = framebmp->width;
		db.sbufheight = db.dbufheight = framebmp->height;
		db.sstride    = db.dstride    = framebmp->width;

		db.source     = &framebmp->data16;
		db.dest		  = decbuf;

		db.szbuffer   = (WORD *)framebmp->zbuffer.ptr();
		db.snormals   = (WORD *)framebmp->normal.ptr();

		db.dzbuffer   = db.dnormals = NULL;
		
		db.palette    = (WORD *)framebmp->palette.ptr();
		db.alpha      = (BYTE *)framebmp->alpha.ptr();
		db.alias      = (BYTE *)framebmp->alias.ptr();

		db.keycolor   = framebmp->keycolor;

		dp2.sx        = 0;	
		dp2.sy        = 0;

		dp2.dx       += frames[frame].x;	
		dp2.dy       += frames[frame].y;

		dp2.swidth    = framebmp->width;
		dp2.sheight   = framebmp->height;

		dp2.drawmode  = drawmode | DM_NORESTORE;

		Draw(&db, &dp2);

		surface->GetOrigin(dp->originx, dp->originy);
		surface->GetClipRect(dp->clipx, dp->clipy, dp->clipwidth, dp->clipheight);

		db.source     = decbuf;
		db.dest       = surface->Lock();
		surface->Unlock();

		db.dbufwidth  = surface->Width();
		db.dbufheight = surface->Height();
		db.dstride    = surface->Stride();
		Draw(&db, dp);
	}
}

void TAnimation::Stretch(PTSurface surface, PTSurface decbuf, int x, int y, int size, 
						 int frame)
{
}

int TAnimation::NumFrames()
{
	int n = numframes;

//	if (flags & AF_HALFSPEED) // Not supported
//		n <<= 1;
//	else if (flags & AF_THIRDSPEED)
//		n *= 3;
//	else if (flags & AF_QUARTERSPEED)
//		n <<= 2;

	return n;
}

PTBitmap TAnimation::GetFrame(int frame)
{
//	if (flags & AF_HALFSPEED)		// Not supported
//		frame >>= 1;
//	else if (flags & AF_THIRDSPEED)
//		frame /= 3;
//	else if (flags & AF_QUARTERSPEED)
//		frame >>= 2;

	if (frame >= numframes)
		return NULL;

	return frames[frame].bitmap;
}

void TAnimation::Move(int &x, int &y, int frame, int orientation)
{
}

void TAnimation::SizeMove(int &x, int &y, int size, int frame, int orientation)
{
}

// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                 display.cpp  - Display Object File                    *
// *************************************************************************

#include <windows.h>
#include <ddraw.h>
#include <d3drmwin.h>

#include "revenant.h"
#include "directdraw.h"
#include "graphics.h"
#include "mainwnd.h"
#include "bitmap.h"
#include "multisurface.h"
#include "display.h"

LPDIRECTDRAWSURFACE front;		// Pointer to DirectDraw Surfaces for the display.   
LPDIRECTDRAWSURFACE back;
LPDIRECTDRAWCLIPPER clipper;	
LPDIRECTDRAWSURFACE zbuffer;

extern DWORD ZBufferBitDepth;
extern LPDIRECTDRAW	        DirectDraw;       // DirectDraw pointer

// Initializes Color Tables
extern BOOL  Hardware3D;
extern BOOL  UsingHardware;
extern void  MakeColorTables();

// These functions are used to record a list of update ares on the screen.
// The low level graphics functions all are passed the address of a function called
// 'callback' in their drawparam structures.  For the display, this funciton is set
// to AddUpdateCallback(), which logs the rectangle drawn in a list.  When all the 
// drawing is complete, the low level draw functions return, and the list is added
// to the display dirty rectangle update list with a call to ProcessUpdateCallbacks().

void ResetUpdateCallbacks();
void ProcessUpdateCallbacks();
void AddUpdateCallback(PSDrawBlock db, PSDrawParam dp);

TDisplay::TDisplay()
{
	Front = Back = NULL;

	clipx  = clipy  = 0;
	currentpage     = 0;

	clipmode        = CLIP_EDGES; 
}

BOOL TDisplay::Initialize(int dwidth, int dheight, int dbitsperpixel)
{
	if (Front)
		return TRUE;

	DDSURFACEDESC ddsd;
    DDSCAPS ddscaps;

	SaveZBuffer = NULL;

	ResetUpdateCallbacks();	// Make sure our update list is reset

	InitDirectDraw();

	if (Windowed)
	{
		SetNormalMode();

		// First, create complex flipping primary surface

		memset(&ddsd, sizeof(DDSURFACEDESC), 0);
		ddsd.dwSize            = sizeof(DDSURFACEDESC);
		ddsd.dwFlags           = DDSD_CAPS;
		ddsd.ddsCaps.dwCaps    = DDSCAPS_PRIMARYSURFACE;

		// Create the primary surface
		TRY_DD(DirectDraw->CreateSurface(&ddsd, &front, NULL))

    	ddsd.dwFlags = DDSD_WIDTH | DDSD_HEIGHT | DDSD_CAPS;
    	ddsd.dwWidth = WIDTH;
    	ddsd.dwHeight = HEIGHT;
    	ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN | DDSCAPS_3DDEVICE;
		if (UsingHardware)
			ddsd.ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
		else
			ddsd.ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;

		TRY_DD(DirectDraw->CreateSurface(&ddsd, &back, NULL))

		ddsd.dwSize  = sizeof (ddsd);
		ddsd.dwFlags = DDSD_PIXELFORMAT;
		TRY_DD(back->GetSurfaceDesc(&ddsd))

		if (ddsd.ddpfPixelFormat.dwRGBBitCount != 16)
			FatalError("Game must run in a 16 bit per pixel mode");

		TRY_DD(DirectDraw->CreateClipper(0, &clipper, NULL))
		TRY_DD(clipper->SetHWnd(0, MainWindow.Hwnd()))
		TRY_DD(front->SetClipper(clipper))
	}
	else  // Exclusive full screen mode
	{

		SetExclusiveMode();
		EnterVideoMode(dwidth, dheight, dbitsperpixel);

		// First, create complex flipping primary surface

		memset(&ddsd, sizeof(DDSURFACEDESC), 0);
		ddsd.dwSize            = sizeof(DDSURFACEDESC);
		ddsd.dwFlags           = DDSD_CAPS | DDSD_BACKBUFFERCOUNT;
		ddsd.ddsCaps.dwCaps    = DDSCAPS_PRIMARYSURFACE | DDSCAPS_FLIP | 
												  DDSCAPS_COMPLEX | DDSCAPS_3DDEVICE;
		ddsd.dwBackBufferCount = 1;

		// Create the primary surface with 1 back buffer
		TRY_DD(DirectDraw->CreateSurface(&ddsd, &front, NULL))

		// Get pointer to back buffer
		ddscaps.dwCaps = DDSCAPS_BACKBUFFER;
    
		TRY_DD(front->GetAttachedSurface(&ddscaps, &back))
	}

	Front = new TDDSurface(front);
	Back  = new TDDSurface(back);

	surface      = back;
	flags        = Back->flags;
    stride		 = Back->Stride();
    originx	     = 0;
    originy	     = 0;
    clipmode	 = CLIP_EDGES;
	clipx		 = 0;
	clipy		 = 0;
	width        = dwidth;
	height       = dheight;
	clipwidth    = dwidth;
	clipheight   = dheight;

	ddsd.dwSize  = sizeof (ddsd);
	ddsd.dwFlags = DDSD_PIXELFORMAT;
	TRY_DD(Back->GetDDSurface()->GetSurfaceDesc(&ddsd))

	if (Force15Bit)
		bitsperpixel = 15;
	else if (Force16Bit)
		bitsperpixel = 16;
	else if (ddsd.ddpfPixelFormat.dwRBitMask == 0xf800)
		bitsperpixel = 16;
	else 
		bitsperpixel = 15;

	// Only create a zbuffer if ZBufferBitDepth > 0
    if (ZBufferBitDepth) 
    {
        // Then, create Z-Buffer. The ZBufferMemType and ZBufferBitDepth variables
        // are set up when the Direct3D device enumeration is done at runtime
        memset(&ddsd, sizeof(DDSURFACEDESC), 0);
        ddsd.dwSize   = sizeof(DDSURFACEDESC);
        ddsd.dwFlags  = DDSD_WIDTH | DDSD_HEIGHT | DDSD_CAPS | DDSD_ZBUFFERBITDEPTH;
        ddsd.dwWidth  = dwidth;
        ddsd.dwHeight = dheight;

        // If a hardware device is present allocate zbuffer in VRAM else use
        // system ram.

        if (UsingHardware == TRUE)
			ddsd.ddsCaps.dwCaps = DDSCAPS_VIDEOMEMORY | DDSCAPS_ZBUFFER;
        
		else
			ddsd.ddsCaps.dwCaps = DDSCAPS_SYSTEMMEMORY | DDSCAPS_ZBUFFER;

		ddsd.dwZBufferBitDepth  = ZBufferBitDepth;

        // Create the zbuffer
        TRY_DD(DirectDraw->CreateSurface(&ddsd, &zbuffer, NULL))
		
        // Attach ZBuffer to the back buffer
        TRY_DD(Back->GetDDSurface()->AddAttachedSurface(zbuffer))

	    ZBuffer = new TDDSurface(zbuffer);
	}

    Setup3D(dwidth, dheight);

	if (UseClearZBuffer)
		InitClearZBuffer();

	Front->Clear();
	Back->Clear();

	return TRUE;
}

BOOL TDisplay::Close()
{
	if (!Front)
		return TRUE;

	if (Front && Front->GetDDSurface() == back)
	{
		PTDDSurface tmp = Front;
		Front = Back;
		Back = tmp;
	}
	
	CloseClearZBuffer();
	Close3D();

    if (Back && Back->GetDDSurface())
    {
        Back->GetDDSurface()->Release();

		delete Back;
		Back    = NULL;
		back    = NULL;
		surface = NULL;
    }

    // Destroy zbuffer surface
    if (ZBuffer && ZBuffer->GetDDSurface())
    {
        ZBuffer->GetDDSurface()->Release();

        delete ZBuffer;
		ZBuffer = NULL;
        zbuffer = NULL;
    }

    // Destroy front surface
    if (Front && Front->GetDDSurface())
    {
        Front->GetDDSurface()->Release();

		delete Front;
		Front = NULL;
		front = NULL;
    }

	CloseDirectDraw();

	width = height = 0;

	return TRUE;
}

TDisplay::~TDisplay()
{
	Close();
}

BOOL TDisplay::Restore()
{
	if (!Front)
		return FALSE;
	
	if (Windowed)
		return TRUE;

	SetExclusiveMode();
	EnterVideoMode(width, height, (bitsperpixel == 15) ? 16 : bitsperpixel);

	if (front->IsLost() == DDERR_SURFACELOST)
	{
		TRY_DD(front->Restore());
	}

	if (back->IsLost() == DDERR_SURFACELOST)
	{
		TRY_DD(front->Restore());
	}

	Front->Clear();
	Back->Clear();

	return TRUE;
}

// Initializes a secondary zbuffer for use with the Viewport->Clear() function
void TDisplay::InitClearZBuffer()
{
    PTDDSurface s = new TDDSurface(width, height, VSURF_SYSTEMMEM);
	if (!s)
		FatalError("Unable to allocate clear ZBuffer");
	
	SaveZBuffer = ZBuffer;
	ZBuffer = s;
}

// Closes the secondary zbuffer
void TDisplay::CloseClearZBuffer()
{
	if (!SaveZBuffer)
		return;

	delete ZBuffer;
	ZBuffer = SaveZBuffer;
	SaveZBuffer = NULL;
}

// Flips the front/back buffer
BOOL TDisplay::FlipPage(BOOL Wait)
{
	if (!DoPageFlip)
		return TRUE;

	if (!Front || !Front->GetDDSurface() || (front->IsLost() == DDERR_SURFACELOST))
		return FALSE;

	if (Windowed)
	{
		RECT r;
		GetClientRect(MainWindow.Hwnd(), &r);
		ClientToScreen(MainWindow.Hwnd(), (LPPOINT)&r);
		Front->Blit(r.left - MonitorX, r.top - MonitorY, Back, 0, 0, min(r.right, WIDTH), min(r.bottom, HEIGHT));	
	}
	else
	{
		while(front->GetFlipStatus(DDGFS_ISFLIPDONE) == DDERR_WASSTILLDRAWING)
			Sleep(1);

		TRY_DD(front->Flip(NULL, (Wait ? DDFLIP_WAIT : NULL)))
	}

	if (!Windowed)				// do NOT switch when in windowed
		currentpage = !currentpage;

  // Show drawing (this shows drawing).. causes drawing to be shown >*
	if ((ShowDrawing == FALSE && Front->GetDDSurface() == back) ||
		(ShowDrawing == TRUE && Front->GetDDSurface() == front))
	{		
		PTDDSurface tmp = Front;
		Front = Back;
		Back  = tmp;
	}

	return TRUE;
}

// Copies contents of back buffer to front buffer or window so it is immediately displayed
BOOL TDisplay::PutToScreen(int x, int y, int width, int height)
{
	SClipState cs;
	SaveClipState(cs);
	Reset();

	if (Windowed)
	{
		RECT r;
		GetClientRect(MainWindow.Hwnd(), &r);
		ClientToScreen(MainWindow.Hwnd(), (LPPOINT)&r);
		Front->Blit(r.left - MonitorX + x, r.top - MonitorY + y, Back, x, y, width, height);	
	}
	else
	{
		Front->Blit(x, y, Back, x, y, width, height);
	}

	RestoreClipState(cs);

	return TRUE;
}

// ****************************************	
// * Call Dirty Rectangle Update Routines *
// ****************************************

// These functions are used to record a list of update ares on the screen.
// The low level graphics functions all are passed the address of a function called
// 'callback' in their drawparam structures.  For the display, this funciton is set
// to AddUpdateCallback(), which logs the rectangle drawn in a list.  When all the 
// drawing is complete, the low level draw functions return, and the list is added
// to the display dirty rectangle update list with a call to ProcessUpdateCallbacks().

  // Copies specified bitmap to current bitmap
BOOL TDisplay::ParamDraw(PSDrawParam dp, PTBitmap bitmap)
{
	if (front->IsLost() == DDERR_SURFACELOST)
		return FALSE;

  // Set update rectangles to 0	
	ResetUpdateCallbacks();

	BOOL ret = TDDSurface::ParamDraw(dp, bitmap);

  // Process update rectangles returned by draw routines
	ProcessUpdateCallbacks();

	return ret;
}

  // Blits from surface to this surface. RECT sets size of blit. 
  // X & Y specifies dest origin.  If no hardware available, uses software
  // blitting
BOOL TDisplay::ParamBlit(PSDrawParam dp, PTSurface surface, int flags, LPDDBLTFX fx)
{
 	if (front->IsLost() == DDERR_SURFACELOST)
		return FALSE;

 // Set update rectangles to 0	
	ResetUpdateCallbacks();

	BOOL ret = TDDSurface::ParamBlit(dp, surface, flags, fx);
	
  // Process update rectangles returned by draw routines
	ProcessUpdateCallbacks();

	return ret;
}

  // Blits from this surface to surface. RECT sets size of blit. 
  // X & Y specifies dest origin.  If no hardware available, uses software
  // blitting.  Called by ParamBlit when blitting from a complex surface
  // to an ordinary surface.
BOOL TDisplay::ParamGetBlit(PSDrawParam dp, PTSurface surface, int flags, LPDDBLTFX fx)
{
 	if (front->IsLost() == DDERR_SURFACELOST)
		return FALSE;

  // Set update rectangles to 0	
	ResetUpdateCallbacks();

	BOOL ret = TDDSurface::ParamGetBlit(dp, surface, flags, fx);
	
  // Process update rectangles returned by draw routines
	ProcessUpdateCallbacks();

	return ret;
}

// ******************************	
// * Background system routines *
// ******************************

typedef struct updaterect
{
	int x, y;
	int width, height;
	int flags;
} UpdateRect;

#define MAXRESTORERECTS 128

struct RestoreBuf
{
	int x;						// Starting position of Background Buffer on screen.
	int y;						
	int originx;				// Starting position of Background Buffer on restore 
	int originy;				// buffer.
	int oldoriginx;				// Old origins
	int oldoriginy;				// 
	int width;					// Size of Background Buffer
	int height;

	PTSurface surface;			// Video surface for restore buffer

	BOOL        deletesurface;	// BOOL to determine if surfaces are deleted on exit

	UpdateRect  *rects[2];		// Update rect list for front and back surface
	int          numrects[2];   // Number of rects in the list

	int          start[2];		// Start of rect list
	int          emptystart[2];	// Next empty space in rect list
};

RestoreBuf RestoreBufs[MAXRESTOREBUFS];

BOOL TDisplay::InitBackgroundSystem()
{
	for (int loop = 0; loop < MAXRESTOREBUFS; loop++)
	{
		RestoreBufs[loop].x = 0;
		RestoreBufs[loop].y = 0;
		
		RestoreBufs[loop].originx = 0;
		RestoreBufs[loop].originy = 0;

		RestoreBufs[loop].oldoriginx = 0;
		RestoreBufs[loop].oldoriginy = 0;
		
		RestoreBufs[loop].width   = 0;
		RestoreBufs[loop].height  = 0;

		RestoreBufs[loop].surface       = NULL;

		RestoreBufs[loop].deletesurface = FALSE;

		RestoreBufs[loop].rects[0]      = NULL;
		RestoreBufs[loop].numrects[0]   = 0;

		RestoreBufs[loop].rects[1]      = NULL;
		RestoreBufs[loop].numrects[1]   = 0;

		RestoreBufs[loop].start[0]      = 0;
		RestoreBufs[loop].emptystart[0] = 0;
	
		RestoreBufs[loop].start[1]      = 0;
		RestoreBufs[loop].emptystart[1] = 0;
	}

	updateenabled = TRUE;

	return TRUE;
}

BOOL TDisplay::CloseBackgroundSystem()
{
	ClearBackgroundAreas();
	updateenabled = FALSE;
	
	return TRUE;
}

void TDisplay::FreeBackgroundArea(int index)
{
	if (RestoreBufs[index].width == 0) 
		return;

	if (RestoreBufs[index].surface && RestoreBufs[index].deletesurface)
		  delete RestoreBufs[index].surface;

	delete(RestoreBufs[index].rects[0]);
	delete(RestoreBufs[index].rects[1]);

	memset(&RestoreBufs[index], 0, sizeof(RestoreBuf));
}

BOOL TDisplay::ClearBackgroundAreas()
{
	for (int loop = 0; loop < MAXRESTOREBUFS; loop++)
		FreeBackgroundArea(loop);

	return TRUE;
}

int TDisplay::CreateBackgroundArea(int x, int y, int width, int height, BOOL createzbuf, int vsflags)
{
	PTSurface surface;
	if (createzbuf)
	{
		PTSurface zbuf = new TDDSurface(width, height, vsflags);
		if (!zbuf)
			return NULL;
		PTSurface graphics = new TDDSurface(width, height, vsflags);
		if (!graphics)
			return NULL;
		surface = new TMultiSurface(graphics, zbuf, NULL, TRUE);
	}
	else
	{
		surface = new TDDSurface(width, height, vsflags);
	}

	int buf = UseBackgroundArea(x, y, width, height, surface);
	
	RestoreBufs[buf].deletesurface = TRUE;

	return buf;
}

int TDisplay::UseBackgroundArea(int x, int y, int width, int height, PTSurface surface)
{
	if (surface == NULL) return FALSE;

	for (int loop = 0; loop < MAXRESTOREBUFS; loop++)
	{
		if (RestoreBufs[loop].width == 0) 
			break;
	}

	if (loop == MAXRESTOREBUFS)
		return -1;

	RestoreBufs[loop].originx = 0;
	RestoreBufs[loop].originy = 0;

	RestoreBufs[loop].oldoriginx = 0;
	RestoreBufs[loop].oldoriginy = 0;

	RestoreBufs[loop].x = x;
	RestoreBufs[loop].y = y;

	RestoreBufs[loop].width  = width;
	RestoreBufs[loop].height = height;

	RestoreBufs[loop].surface		= surface;
	RestoreBufs[loop].deletesurface = FALSE;

	RestoreBufs[loop].rects[0]   = new UpdateRect[MAXRESTORERECTS];
	RestoreBufs[loop].rects[1]   = new UpdateRect[MAXRESTORERECTS];

	RestoreBufs[loop].start[0]      = 0;
	RestoreBufs[loop].emptystart[0] = 0;
	
	RestoreBufs[loop].start[1]      = 0;
	RestoreBufs[loop].emptystart[1] = 0;
	
	return loop;
}

BOOL TDisplay::RestoreBackgroundAreas()
{
	for (int loop = 0; loop < MAXRESTOREBUFS; loop++)
	{
		if (RestoreBufs[loop].width == 0) 
			break;

		RestoreBuf *rbuf = &RestoreBufs[loop];

		for (int loop2 = 0; loop2 < rbuf->numrects[currentpage]; loop2++)
		{
			UpdateRect *ur = &rbuf->rects[currentpage][loop2]; 

			int drawmode = DM_WRAPCLIPSRC | DM_NORESTORE;
			if (!NoScrollZBuffer)
				drawmode |= DM_ZBUFFER;

			DrawRestoreRect(loop, ur->x, ur->y, ur->width, ur->height, drawmode);
		}

		rbuf->numrects[currentpage]   = 0;
		rbuf->start[currentpage]      = 0;
		rbuf->emptystart[currentpage] = 0;
	}

	return TRUE;
}

BOOL TDisplay::DrawRestoreRect(int index, int x, int y, int width, int height, DWORD drawmode)
{
	int saveoriginx, saveoriginy;
	int saveclipx, saveclipy, saveclipwidth, saveclipheight;
	int saveclipmode;

	GetOrigin(saveoriginx, saveoriginy);
	GetClipRect(saveclipx, saveclipy, saveclipwidth, saveclipheight);
	GetClipMode(saveclipmode);

	RestoreBuf *rbuf = &RestoreBufs[index];

	Reset();
	SetOrigin(0, 0);
	SetClipRect(rbuf->x, rbuf->y, rbuf->width, rbuf->height);

	Blit(x - rbuf->originx + rbuf->x,
		 y - rbuf->originy + rbuf->y,
		 rbuf->surface,
	     x % rbuf->surface->Width(), y % rbuf->surface->Height(), 
		 width, height, drawmode | DM_WRAPCLIPSRC | DM_NORESTORE);

	SetOrigin(saveoriginx, saveoriginy);
	SetClipRect(saveclipx, saveclipy, saveclipwidth, saveclipheight);
	SetClipMode(saveclipmode);

	return TRUE;
}

BOOL TDisplay::ScrollBackground(int index, int originx, int originy)
{
	RestoreBuf &rb = RestoreBufs[index];

	if (index > MAXRESTOREBUFS) 
		return FALSE;

	rb.oldoriginx = rb.originx;	
	rb.oldoriginy = rb.originy;	

	if (rb.originx == originx && 
		rb.originy == originy)	
		return TRUE;

	rb.originx = originx;	
	rb.originy = originy;	

	rb.rects[0]->x      = rb.originx;
	rb.rects[0]->y      = rb.originy;
	rb.rects[0]->width  = rb.surface->Width();
	rb.rects[0]->height = rb.surface->Height();
	rb.numrects[0]		= 1;
	rb.start[0]			= 0;
	rb.emptystart[0]	= 1;

	rb.rects[1]->x      = rb.originx;
	rb.rects[1]->y      = rb.originy;
	rb.rects[1]->width  = rb.surface->Width();
	rb.rects[1]->height = rb.surface->Height();
	rb.numrects[1]		= 1;
	rb.start[1]			= 0;
	rb.emptystart[1]	= 1;

	return TRUE;
}

// ****************************	
// * Dirty rectangle routines *
// ****************************

#define MERGELIMITX    10
#define MERGELIMITY    10
#define MARKMERGED(r)  r.x = -10000
#define RECTMERGED(r) (r.x == -10000)

// ******* Display Update Functions *******

// Adds update rectangle for display (display coordinates relative to 0,0 of screen)
void TDisplay::AddUpdateRect(int x, int y, int width, int height, int flags)
{
 	RestoreBuf *rb = RestoreBufs;

	for (int loop = 0; loop < MAXRESTOREBUFS; loop++, rb++)
	{
		if (rb->width == 0)
			continue;
	  // Clip to screen rect	
		if (x >= rb->x + rb->width || y >= rb->y + rb->height ||
			x + width <= rb->x || y + height <= rb->y)
				continue;

		int cx = x;
		int cy = y;
		int cw = width;
		int ch = height;

		if (cx < rb->x)
		{
			cw += cx - rb->x;
			cx = rb->x;
		}

		if (cy < rb->y)
		{
			ch += cy - rb->y;
			cy = rb->y;
		}

		if (cx + cw > rb->x + rb->width)
		   cw = (rb->x + rb->width) - cx;
		if (cy + ch > rb->y + rb->height)
		   ch = (rb->y + rb->height) - cy;

		Display->AddBackgroundUpdateRect(loop, 
			cx - rb->x + rb->originx,	// Convert from screen to buffer pos X
			cy - rb->y + rb->originy,	// Convert from screen to buffer pos Y
			cw, ch, flags);
	}
}

// These functions are used to record a list of update ares on the screen.
// The low level graphics functions all are passed the address of a function called
// 'callback' in their drawparam structures.  For the display, this funciton is set
// to AddUpdateCallback(), which logs the rectangle drawn in a list.  When all the 
// drawing is complete, the low level draw functions return, and the list is added
// to the display dirty rectangle update list with a call to ProcessUpdateCallbacks().

struct SUpdateCallbackRec
{
	int x, y, w, h, flags;
};

// 64 should be more than adequate
#define MAXCALLBACKRECS 64
static int numcallbacks;
static SUpdateCallbackRec callbacks[MAXCALLBACKRECS];

void ResetUpdateCallbacks()
{
	numcallbacks = 0;
}

void ProcessUpdateCallbacks()
{
	SUpdateCallbackRec *r = callbacks;
	for (int c = 0; c < numcallbacks; c++, r++)
		Display->AddUpdateRect(r->x, r->y, r->w, r->h, r->flags);
	numcallbacks = 0;
}

void AddUpdateCallback(PSDrawBlock db, PSDrawParam dp)
{
	if (dp->drawmode & DM_NORESTORE)
		return;

	if (numcallbacks >= MAXCALLBACKRECS)
	{
#ifdef _DEBUG
		FatalError("Too many callback recs"); // Should never happen
#endif
		return;
	}

	SUpdateCallbackRec *r = &(callbacks[numcallbacks]);

	r->x = dp->dx + dp->originx;
	r->y = dp->dy + dp->originy;
	r->w = dp->dwidth;
	r->h = dp->dheight;
	r->flags = (dp->drawmode & DM_BACKGROUND) ? (UPDATE_BACKGROUND) : (UPDATE_RESTORE);

	numcallbacks++;
}

// Returns the AddUpdateRect() function as a draw callback to the Draw() routine
DRAWCALLBACK TDisplay::GetDrawCallBack()
{
	if (updateenabled)
		return (DRAWCALLBACK)AddUpdateCallback;

	return NULL;
}

// ******* Buffer Update Functions *******

inline void TDisplay::AddSubRect(int index, int x1, int y1, int x2, int y2, int flags)
{
	AddBackgroundUpdateRect(index, x1, y1, x2 - x1 + 1, y2 - y1 + 1, flags);
}

// Adds update rectangle (uses buffer coordinates based on origin of buffer)
BOOL TDisplay::AddBackgroundUpdateRect(int index, int x, int y, int width, int height, int flags)
{
	RestoreBuf &rb = RestoreBufs[index];
	
	int cx = rb.originx;
	int cy = rb.originy;
	int cw = rb.surface->Width();
	int ch = rb.surface->Height();

  // Clip x and y
	if ((x >= cx + cw) || (x + width <= cx) ||
		(y >= cy + ch) || (y + height <= cy))
	   return FALSE;

  // Prevent two threads at once from entering the update rectangle area	
	BEGIN_CRITICAL();  // REMEMBER: MUST NOT RETURN BETWEEN HERE AND
					   // END CRITICAL SECTION BELOW OR PROGRAM WILL
					   // LOCK UP!! !!!!! !!!!! ((!!!!) ****!!!!***

	if (x < cx)
	{
		width -= cx - x;
		x = cx;
	}

	if (y < cy)
	{
		height -= cy - y;
		y = cy;
	}

	if ((x + width) > (cx + cw))
		width = (cx + cw) - x;	
	
	if ((y + height) > (cy + ch))
		height = (cy + ch) - y; 

  // Update whatever we drew to the screen to the background..
	if (flags & UPDATE_SCREENTOBUFFER)
	{
		SRect saveclip;
		rb.surface->GetClipRect(saveclip);
		rb.surface->SetClipRect(
						  rb.originx, rb.originy,
						  rb.width, rb.height);
		rb.surface->Blit(
			x, y,
			Back,
			rb.x + (x - rb.originx), rb.y + (y - rb.originy),
			width, height, DM_WRAPCLIP | DM_NORESTORE);

		rb.surface->SetClipRect(saveclip);
	}
	flags &= ~UPDATE_SCREENTOBUFFER;  // Done.. now clear flag

  // Don't bother copying while scrolling - whole thing will update anyway
	if (flags & UPDATE_BUFFERTOSCREEN &&
		rb.originx == rb.oldoriginx && rb.originy == rb.oldoriginy)
	{
		SRect saveclip;
		Back->GetClipRect(saveclip);
		Back->SetClipRect(rb.x, rb.y, rb.width, rb.height);
		Back->Blit(
			rb.x + (x - rb.originx), rb.y + (y - rb.originy),
			rb.surface,
			x, y,
			width, height, DM_WRAPCLIPSRC | DM_NORESTORE);
		Back->SetClipRect(saveclip);
	}
	flags &= ~UPDATE_BUFFERTOSCREEN;  // Done.. now clear flag

  // Ok, now handle just the UPDATE_THISFRAME, UPDATE_NEXTFRAME flags by adding
  // dirty rectangles to the update rectangle list for each display page...
	for (int p = 0; p < 2; p++)
	{							   
		int f, page;

      // What page are we adding update rectangle rectange to...
		if (p == 0)
		{
			page = currentpage;
			if (!(flags & UPDATE_THISFRAME))
				continue;
	
			else
				f = UPDATE_THISFRAME;
		}
	
		else
		{
			page = !currentpage;
			if (!(flags & UPDATE_NEXTFRAME))
				continue;
	
			else
				f = UPDATE_NEXTFRAME;
		}

		BOOL merged = FALSE;

	  // Hey.. there's too many rectangles for this page!!
	  // Just make one rectangle for the whole buffer and forget it...
		if (rb.numrects[page] >= (MAXRESTORERECTS - 4)) // Leave at least four rects
		{
			// out of restore rects - nuke them all and just make one for the entire restore buf
			rb.numrects[page] = 0;
			rb.start[page] = 0;
			rb.emptystart[page] = 0;
			x = rb.originx;
			y = rb.originy;
			width = rb.surface->Width();
			height = rb.surface->Height();
		}

	  // Otherwise, let's try to merge any overlapping rectangles (to save time)
		else if (!(flags & UPDATE_NOMERGERECT))
		{
			int sx1 = x;
			int sx2 = x + width - 1;
			int sy1 = y;
			int sy2 = y + height - 1;

			int c = rb.start[page];
			while (c != rb.emptystart[page])
			{
			  UpdateRect &r = rb.rects[page][c];

			  if (!(r.flags & UPDATE_NOMERGERECT))
			  {
				int dx1 = r.x;
				int dx2 = r.x + r.width - 1;
				int dy1 = r.y;
				int dy2 = r.y + r.height - 1;

              // Make merge tolerance smaller for larger block sizes
				int minmergex = 16 - (min(256, r.height) >> 4);
				int minmergey = 16 - (min(256, r.width) >> 4);

			  // Check if intersects at all
				if (!(sx1 > dx2 || sy1 > dy2 || sx2 < dx1 || sy2 < dy1))
				{
					int in = 0;
					if (sx1 >= dx1 - minmergex) // Left line in
					{
						dx1 = min(dx1, sx1);
						in |= 1;
					}
					if (sx2 <= dx2 + minmergex) // Right line in
					{
						dx2 = max(dx2, sx2);
						in |= 2;
					}
					if (sy1 >= dy1 - minmergey) // Top line in
					{
						dy1 = min(dy1, sy1);
						in |= 4;
					}
					if (sy2 <= dy2 + minmergey) // Bottom line in
					{
						dy2 = max(dy2, sy2);
						in |= 8;
					}

					r.x = dx1;
					r.y = dy1;
					r.width = dx2 - dx1 + 1;
					r.height = dy2 - dy1 + 1;

					switch (in)
					{
					  case 0: // Source encompasses dest
						r.x = sx1;
						r.y = sy1;
						r.width = sx2 - sx1 + 1;
						r.height = sy2 - sy1 + 1;
						break;
					  case 1: // Left line in
						AddSubRect(index, sx1, sy1, sx2, dy1 - 1, f);
						AddSubRect(index, dx2 + 1, dy1, sx2, dy2, f);
						AddSubRect(index, sx1, dy2 + 1, sx2, sy2, f);
						break;
					  case 2: // Right line in
						AddSubRect(index, sx1, sy1, sx2, dy1 - 1, f);
						AddSubRect(index, sx1, dy1, dx1 - 1, dy2, f);
						AddSubRect(index, sx1, dy2 + 1, sx2, sy2, f);
						break;
					  case 3: // Left and right line in
						AddSubRect(index, sx1, sy1, sx2, dy1 - 1, f);
						AddSubRect(index, sx1, dy2 + 1, sx2, sy2, f);
						break;
					  case 4: // Top line in
						AddSubRect(index, sx1, sy1, dx1 - 1, dy2, f);
						AddSubRect(index, dx2 + 1, sy1, sx2, dy2, f);
						AddSubRect(index, sx1, dy2 + 1, sx2, sy2, f);
						break;
					  case 5: // Top and left line in
						AddSubRect(index, dx2 + 1, sy1, sx2, dy2, f);
						AddSubRect(index, sx1, dy2 + 1, sx2, sy2, f);
						break;
					  case 6: // Top and right line in
						AddSubRect(index, sx1, sy1, dx1 - 1, dy2, f);
						AddSubRect(index, sx1, dy2 + 1, sx2, sy2, f);
						break;
					  case 7: // Top, left, and right line in
						AddSubRect(index, sx1, dy2 + 1, sx2, sy2, f);
						break;
					  case 8: // Bottom line in
						AddSubRect(index, sx1, sy1, sx2, dy1 - 1, f);
						AddSubRect(index, sx1, dy1, dx1 - 1, sy2, f);
						AddSubRect(index, dx2 + 1, dy1, sx2, sy2, f);
						break;
					  case 9: // Bottom and left in
						AddSubRect(index, sx1, sy1, sx2, dy1 - 1, f);
						AddSubRect(index, dx2 + 1, dy1, sx2, sy2, f);
						break;
					  case 10: // Bottom and right in
						AddSubRect(index, sx1, sy1, sx2, dy1 - 1, f);
						AddSubRect(index, sx1, dy1, dx1 - 1, sy2, f);
						break;
					  case 11: // Bottom, left and right in
						AddSubRect(index, sx1, sy1, sx2, dy1 - 1, f);
						break;
					  case 12: // Top, bottom in
						AddSubRect(index, sx1, sy1, dx1 - 1, sy2, f);
						AddSubRect(index, dx2 + 1, sy1, sx2, sy2, f);
						break;
					  case 13: // Top, bottom and left in
						AddSubRect(index, dx2 + 1, sy1, sx2, sy2, f);
						break;
					  case 14: // Top, bottom and right in
						AddSubRect(index, sx1, sy1, dx1 - 1, sy2, f);
						break;
					  case 15: // All in!!
						break;
					}

					merged = TRUE;
					break;
				}
			  }
				
			  c++;
			  if (c >= MAXRESTORERECTS)
			      c = 0;
			}
		}

		if (merged)
			continue;
		
	  // Add to array
		UpdateRect &r = rb.rects[page][rb.emptystart[page]];

		if (width > 0)
		{
			r.x        = x;
			r.y        = y;
			r.width    = width;
			r.height   = height;
			r.flags	   = flags;
		}

		rb.numrects[page]++;
		rb.emptystart[page]++;

		if (rb.emptystart[page] >= MAXRESTORERECTS)
			rb.emptystart[page] = 0;
	}

   // If you've returned before this... you've screwed up the system!!	
	END_CRITICAL();

	return TRUE;
}

#if 0

// Stuck this code into surface.cpp's ParamDraw function

// *******************************************
// * Workaround function for crazy Monster3D *
// *******************************************

BOOL TDisplay::ZPut(int x, int y, int z, PTBitmap bitmap, DWORD drawmode)
{
	if (!bitmap)
		return FALSE;

	static int status = 0;
	static PTSurface multi = NULL;

	if (status == 0)
	{
		// this is the first call, so determine what the status is
		void *zbuf = GetZBuffer()->Lock();
		GetZBuffer()->Unlock();

		void *graphics = Lock();
		Unlock();

		if (!graphics || !zbuf)
			return FALSE;

		if (graphics == zbuf)
		{
			status = 1;			// dang, gotta use the workaround
#if 0
			PTDDSurface zbuffer = new TDDSurface(WIDTH, HEIGHT, VSURF_SYSTEMMEM);
			multi = new TMultiSurface(Back, zbuffer, NULL, TRUE);
#endif
		}
		else
			status = 2;			// good, it's a normal card
	}

	if (status == 1)
	{
		return TDDSurface::Put(x, y, bitmap, drawmode & ~DM_ZBUFFER);
#if 0
		int saveoriginx, saveoriginy;
		int saveclipx, saveclipy, saveclipwidth, saveclipheight;
		int saveclipmode;

		GetOrigin(saveoriginx, saveoriginy);
		GetClipRect(saveclipx, saveclipy, saveclipwidth, saveclipheight);
		GetClipMode(saveclipmode);

		RestoreBuf *rbuf = &RestoreBufs[4];

		Reset();
		SetOrigin(0, 0);
		SetClipRect(rbuf->x, rbuf->y, rbuf->width, rbuf->height);

		multi->Reset();

		multi->Blit(x - rbuf->originx + rbuf->x,
					y - rbuf->originy + rbuf->y,
					rbuf->surface,
					x % rbuf->surface->Width(), y % rbuf->surface->Height(), 
					width, height,
					DM_WRAPCLIPSRC | DM_NORESTORE | DM_NODRAW | DM_ZBUFFER | DM_NOHARDWARE);

		SetOrigin(saveoriginx, saveoriginy);
		SetClipRect(saveclipx, saveclipy, saveclipwidth, saveclipheight);
		SetClipMode(saveclipmode);

		PTSurface tmp = (PTSurface)ZBuffer;
		ZBuffer = (PTDDSurface)multi->GetZBuffer();

		ZPut(x, y, z, bitmap, drawmode);

		ZBuffer = (PTDDSurface)tmp;

		Reset();
		SetOrigin(0, 0);
		SetClipRect(rbuf->x, rbuf->y, rbuf->width, rbuf->height);

		rbuf->surface->Blit(x - rbuf->originx + rbuf->x,
							y - rbuf->originy + rbuf->y,
							multi,
							x - rbuf->originx + rbuf->x, y - rbuf->originy + rbuf->y,
							width, height,
							DM_NORESTORE | DM_NODRAW | DM_ZBUFFER);

		SetOrigin(saveoriginx, saveoriginy);
		SetClipRect(saveclipx, saveclipy, saveclipwidth, saveclipheight);
		SetClipMode(saveclipmode);
#endif
#if 0
		// special case - monster3d which can't lock zbuffer and graphics at the same time
		//PTDDSurface graphics = new TDDSurface(bitmap->width, bitmap->height, VSURF_SYSTEMMEM);
		//PTDDSurface zbuffer = new TDDSurface(bitmap->width, bitmap->height, VSURF_SYSTEMMEM);
		//PTMultiSurface multi = new TMultiSurface(Back, zbuffer, NULL, TRUE);
		//multi->SetClipRect(0, 0, bitmap->width, bitmap->height);

		if (drawmode & DM_USEREG)
		{
			// handle registration points ourselves
			x -= bitmap->regx;
			y -= bitmap->regy;
			drawmode &= ~DM_USEREG;
		}

		// first copy from the card
		//graphics->Blit(0, 0, Back, x, y, bitmap->width, bitmap->height, 0);

		// then the zbuffer, manually
		SDrawParam dp;
		MakeDP(dp, 0, 0, x, y, bitmap->width, bitmap->height, 0);
		dp.drawmode = DM_WRAPCLIPSRC;
		//BackgroundZBuffer->GetOrigin(dp.originx, dp.originy);
		BackgroundZBuffer->GetClipRect(dp.clipx, dp.clipy, dp.clipwidth, dp.clipheight);

		SDrawBlock db;
		memset(&db, 0, sizeof(SDrawBlock));

		db.dest = zbuffer->Lock();
		zbuffer->Unlock();

		db.dstbitmapflags = BM_16BIT;
		db.dbufwidth      = bitmap->width;
		db.dbufheight     = bitmap->height;
		db.dstride        = bitmap->width;

		db.source = BackgroundZBuffer->Lock();
		BackgroundZBuffer->Unlock();

		db.srcbitmapflags = BM_16BIT;
		db.sbufwidth  = BackgroundZBuffer->Width();
		db.sbufheight = BackgroundZBuffer->Height();
		db.sstride    = BackgroundZBuffer->Stride();

		Draw(&db, &dp);

		//zbuffer->Put(0, 0, BackgroundZBuffer, x, y, bitmap->width, bitmap->height, 0);

		// now do the blit to our temporary surface
		multi->ZPut(0, 0, z, bitmap, drawmode);

		// now copy that multisurface back to the display, one surface at a time
		drawmode &= ~(DM_ZBUFFER | DM_ZSTATIC);
		Blit(x, y, graphics, 0, 0, bitmap->width, bitmap->height, drawmode);
		GetZBuffer()->Blit(x, y, zbuffer, 0, 0, bitmap->width, bitmap->height, drawmode);

		// kill the temporary buffer
		delete multi;
#endif
//		return TRUE;
	}
	
	// otherwise, just do it like normal
	return TDDSurface::ZPut(x, y, z, bitmap, drawmode);
}

#endif
// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                   3dImage.cpp - 3D image module                       *
// *************************************************************************

#include <windows.h>
#include <ddraw.h>
#include <d3d.h>
#include <d3drmwin.h>
#include <math.h>
#include "d3dmacs.h"
#include "d3dmath.h"

#include "revenant.h"
#include "3dimage.h"
#include "3dscene.h"
#include "directdraw.h"
#include "display.h"
#include "mappane.h"
#include "playscreen.h"
#include "multi.h"
#include "bitmap.h"
#include "animation.h"
#include "complexobj.h"
#include "sound.h"

T3DAnimatorBuilder T3DAnimatorBuilderInstance;  // Register default builder

// **********************
// * 3DImagery Funtions *
// **********************

REGISTER_IMAGERYBUILDER(T3DImagery);

T3DImagery::T3DImagery(int imageryid) : TObjectImagery(imageryid)
{
	meshinitialized = FALSE;
	executebuf = NULL;
	cacheexbuf = FALSE;
	shadow = TRUE;
}

T3DImagery::~T3DImagery()
{
	ClearMesh();
}

// ****************** DIRECT3D IMAGERY STUFF **********************

void replace(char *buf, char *str, char *rep)
{
	char save[RESNAMELEN];
	char *ptr = strstr(buf, str);
	if (!ptr)
		return;

	int pos = (int)((DWORD)ptr - (DWORD)buf);
	int slen = strlen(str);
	int rlen = strlen(rep);
	strcpy(save, buf);
	strcpy(buf + pos, rep);
	strcpy(buf + pos + rlen, save + pos + slen);
}

BOOL T3DImagery::OldInitializeMesh(PSOld3DImageryBody mesh)
{
	int c;

	if (meshinitialized)
		return TRUE;

	if (executebuf)
	{
		delete executebuf;
		executebuf = NULL;
	}

	/*
	 * General Mesh Data
	 */

	flags = mesh->flags;
	version = 0;

//	/*
//	 * Fix names hack-o-matic
//	 */
//
//	for (c = 0; c < NumStates(); c++)
//	{
//		replace(GetHeader()->states[c].animname, "stand", "walk");
//		replace(GetHeader()->states[c].animname, "swing", "attack1");
//		replace(GetHeader()->states[c].animname, "thrust", "attack2");
//	}

    /*
     * Setup morph vertice lists
     */

	numverts = mesh->numverts;

	int vertstates;
	if (!(flags & I3D_ISMORPH))
		vertstates = 1;
	else
		vertstates = NumStates();

	verts = new LPD3DVERTEX*[vertstates];

	for (c = 0; c < vertstates; c++)
	{
		int vertframes;
		if (!(flags & I3D_ISMORPH))
			vertframes = 1;
		else
			vertframes = GetAniLength(c);

		verts[c] = new LPD3DVERTEX[vertframes];
		for (int fr = 0; fr < vertframes; fr++)
		{
			verts[c][fr] = new D3DVERTEX[numverts];
			OFFSET *meshverts = (OFFSET *)((void *)mesh->verts[c]);
			memcpy(verts[c][fr], (void *)meshverts[fr], sizeof(D3DVERTEX) * numverts);
		}
	}

    /*
     * Setup faces lists
     */

	numfaces = mesh->numfaces;
	faces = (S3DFace *)new WORD[mesh->numfaces * 3];
	memcpy(faces, (void *)mesh->faces, sizeof(WORD) * mesh->numfaces * 3);

	/*
	 * Setup objects
	 */

	// sanity checking
	if (mesh->numobjects > 5000 || mesh->numobjects <= 0)
		return FALSE;

	for (c = 0; c < mesh->numobjects; c++)
	{
		S3DObj obj;
		int d;

		memcpy(obj.name, mesh->objname[c], RESNAMELEN);
		obj.material = mesh->objmaterial[c];
		obj.numverts = mesh->objvertnum[c];
		obj.startvert = mesh->objvertpos[c];
		obj.numfaces = 0;
		obj.startface = mesh->objfacepos[c][0];
		obj.numtexfaces = new int[mesh->numtextures + 1];
		obj.texfaces = new int[mesh->numtextures + 1];
		for (d = 0; d < mesh->numtextures + 1; d++)
		{
			obj.numfaces += mesh->objfacenum[c][d];
			obj.numtexfaces[d] = mesh->objfacenum[c][d];
			obj.texfaces[d] = mesh->objfacepos[c][d] - obj.startface;
		}

		obj.parent = new int[NumStates()];
	    if (mesh->flags & I3D_HASHIERARCHY)
		{
			unsigned char *objparent = (unsigned char *)mesh->objparent[c].ptr();
			for (int d = 0; d < NumStates(); d++)
				obj.parent[d] = objparent[d];
		}
		else
		{
			for (d = 0; d < NumStates(); d++)
				obj.parent[d] = -1;
		}

		obj.anikeys = new SAniKey*[NumStates()];
		for (d = 0; d < NumStates(); d++)
		{
			obj.anikeys[d] = new SAniKey[GetAniLength(d)];
			memcpy(obj.anikeys[d], 
				((PSAniKey)mesh->anikeys[d].ptr()) + GetAniLength(d) * c,
				sizeof(SAniKey) * GetAniLength(d));
		}

		AddObject(&obj);
	}

    /*
     * Setup animation keys and motion data
     */

	motion = new SMotionData*[NumStates()];
	memset(motion, 0, sizeof(SMotionData*) * NumStates());
	if (!(flags & I3D_ISMORPH))
	{
		for (c = 0; c < NumStates(); c++)
		{
			if (mesh->motion[c] == NULL)
			{
				motion[c] = NULL;
				GetHeader()->states[c].aniflags |= AF_NOMOTION; // Make sure this flag is set
			}
			else
			{
				motion[c] = new SMotionData[GetAniLength(c)];
				memcpy(motion[c], (void *)mesh->motion[c], sizeof(SMotionData) * GetAniLength(c));
			}
		}
	}

    /*
     * Setup textures
     */

	hastextures = mesh->numtextures != 0;
	textures.Clear();
	if (UseTextures)
	{
		for (c = 0; c < mesh->numtextures; c++)
		{
			AddTexture(
				&mesh->texturedesc[c],
				(OFFSET *)((void *)mesh->texturebits[c]),
				mesh->textureframes[c],
				(LPPALETTEENTRY)(void *)mesh->texturepals[c]);
		}
	}

    /*
     * Setup a materials
     */

	materials.Clear();
	for (c = 0; c < mesh->nummaterials; c++)
	{
		AddMaterial(&mesh->material[c], (int)mesh->material[c].hTexture);
	}

	/*
	 * Setup icons
	 */

	icons = NULL;
	if (flags & I3D_HASICONS)
	{
		for (c = 0; c < NumStates(); c++)
		{
			PS3DStateImagery im = (PS3DStateImagery)((void *)mesh->imagery[c]);
			if (!im)
				continue;

			if (im->invsize > 0)
			{
				if (!icons)
					icons = new S3DImageryIcons[NumStates()];
				memset(icons, 0, sizeof(S3DImageryIcons) * NumStates());

				BYTE *icon = new BYTE[im->invsize];
				if ((void *)im->invitem)
				{
					memcpy(icon, im->invitem, im->invsize);
					icons[c].invitem = (PTBitmap)icon;
				}
				else if ((void *)im->invanim)
				{
					memcpy(icon, im->invanim, im->invsize);
					icons[c].invanim = (PTAnimation)icon;
				}
			}
		}
	}

	FreeBody(); // Causes the body resource object to be deleted

	meshinitialized = TRUE;

    return TRUE;
}

BOOL T3DImagery::InitializeMesh(PS3DImageryBody mesh)
{
	int c;

	if (meshinitialized)
		return TRUE;

	if (!(mesh->flags & I3D_3DIMAGEBODY2))
		return OldInitializeMesh((PSOld3DImageryBody)mesh);

	if (executebuf)
	{
		delete executebuf;
		executebuf = NULL;
	}

	/*
	 * General Mesh Data
	 */

	flags = mesh->flags;
	version = mesh->version;

	/*
	 * Fix names hack-o-matic
	 */

//	for (c = 0; c < NumStates(); c++)
//	{
//		replace(GetHeader()->states[c].animname, "stand", "walk");
//		replace(GetHeader()->states[c].animname, "swing", "attack1");
//		replace(GetHeader()->states[c].animname, "thrust", "attack2");
//	}

    /*
     * Setup morph vertice lists
     */

	numverts = mesh->numverts;

	int vertstates;
	if (!(flags & I3D_ISMORPH))
		vertstates = 1;
	else
		vertstates = NumStates();

	verts = new LPD3DVERTEX*[vertstates];

	for (c = 0; c < vertstates; c++)
	{
		int vertframes;
		if (!(flags & I3D_ISMORPH))
			vertframes = 1;
		else
			vertframes = GetAniLength(c);

		verts[c] = new LPD3DVERTEX[vertframes];
		for (int fr = 0; fr < vertframes; fr++)
		{
			verts[c][fr] = new D3DVERTEX[numverts];
			LPD3DVERTEX meshverts = mesh->verts[c][fr];
			memcpy(verts[c][fr], meshverts, sizeof(D3DVERTEX) * numverts);
		}
	}

    /*
     * Setup faces lists
     */

	numfaces = mesh->numfaces;
	faces = (S3DFace *)new WORD[mesh->numfaces * 3];
	memcpy(faces, (void *)mesh->faces, sizeof(WORD) * mesh->numfaces * 3);

	/*
	 * Setup objects
	 */

	// sanity checking
	if (mesh->numobjects > 5000 || mesh->numobjects <= 0)
		return FALSE;

	for (c = 0; c < mesh->numobjects; c++)
	{
		S3DObj obj;
		int d;

		memcpy(obj.name, mesh->objects[c].name, RESNAMELEN);
		obj.material = mesh->objects[c].material;
		obj.numverts = mesh->objects[c].vertnum;
		obj.startvert = mesh->objects[c].vertpos;
		obj.numfaces = 0;
		obj.startface = mesh->objects[c].textures[0].facepos;
		obj.numtexfaces = new int[mesh->numtextures + 1];
		obj.texfaces = new int[mesh->numtextures + 1];
		for (d = 0; d < mesh->numtextures + 1; d++)
		{
			obj.numfaces += mesh->objects[c].textures[d].facenum;
			obj.numtexfaces[d] = mesh->objects[c].textures[d].facenum;
			obj.texfaces[d] = mesh->objects[c].textures[d].facepos - obj.startface;
		}

		obj.parent = new int[NumStates()];
	    if (mesh->flags & I3D_HASHIERARCHY)
		{
			for (int d = 0; d < NumStates(); d++)
				obj.parent[d] = mesh->objects[c].states[d].parent;
		}
		else
		{
			for (d = 0; d < NumStates(); d++)
				obj.parent[d] = -1;
		}

		obj.anikeys = new SAniKey*[NumStates()];
		for (d = 0; d < NumStates(); d++)
		{
			obj.anikeys[d] = new SAniKey[GetAniLength(d)];
			memcpy(obj.anikeys[d], mesh->objects[c].states[d].anikeys.ptr(),
				sizeof(SAniKey) * GetAniLength(d));
		}

		AddObject(&obj);
	}

    /*
     * Setup animation keys and motion data
     */

	motion = new SMotionData*[NumStates()];
	memset(motion, 0, sizeof(SMotionData*) * NumStates());
	if (!(flags & I3D_ISMORPH))
	{
		for (c = 0; c < NumStates(); c++)
		{
			if (mesh->statedata[c].motion == NULL)
			{
				motion[c] = NULL;
				GetHeader()->states[c].aniflags |= AF_NOMOTION; // Make sure this flag is set
			}
			else
			{
				motion[c] = new SMotionData[GetAniLength(c)];
				memcpy(motion[c], mesh->statedata[c].motion.ptr(), sizeof(SMotionData) * GetAniLength(c));
			}
		}
	}

    /*
     * Setup textures
     */

	hastextures = mesh->numtextures != 0;
	textures.Clear();
	if (UseTextures)
	{
		for (c = 0; c < mesh->numtextures; c++)
		{
			AddTexture(
				&mesh->textures[c].desc,
				(OFFSET *)((void *)mesh->textures[c].bits),
				mesh->textures[c].frames,
				(LPPALETTEENTRY)(void *)mesh->textures[c].pals);
		}
	}

    /*
     * Setup a materials
     */

	materials.Clear();
	for (c = 0; c < mesh->nummaterials; c++)
	{
		AddMaterial(&mesh->materials[c], (int)mesh->materials[c].hTexture);
	}

	/*
	 * Setup icons
	 */

	icons = NULL;
	if (flags & I3D_HASICONS)
	{
		for (c = 0; c < NumStates(); c++)
		{
			PS3DImageryState im = &(mesh->statedata[c]);

			if (im->invsize > 0)
			{
				if (!icons)
					icons = new S3DImageryIcons[NumStates()];
				memset(icons, 0, sizeof(S3DImageryIcons) * NumStates());

				BYTE *icon = new BYTE[im->invsize];
				if ((void *)im->invitem)
				{
					memcpy(icon, im->invitem, im->invsize);
					icons[c].invitem = (PTBitmap)icon;
				}
				else if ((void *)im->invanim)
				{
					memcpy(icon, im->invanim, im->invsize);
					icons[c].invanim = (PTAnimation)icon;
				}
			}
		}
	}

	/*
	 * Setup sound play list
	 */
	
	numplaysounds = 0;
	playsounds = NULL;
	if (mesh->flags & I3D_HASPLAYSOUND)
	{
		numplaysounds = mesh->numplaysounds;
		playsounds = new S3DImageryPlaySound[numplaysounds];
		memcpy(playsounds, mesh->playsounds, sizeof(S3DImageryPlaySound) * numplaysounds);
		for (int ps = 0; ps < numplaysounds; ps++)
		{
			if (playsounds[ps].mount)
			{
				int num = listnum(playsounds[ps].sounds);  // Get number of sounds in list
				for (int n = 0; n < num; n++)
					SoundPlayer.Mount(listget(playsounds[ps].sounds, n));
			}
		}
	}

	FreeBody(); // Causes the body resource object to be deleted

	meshinitialized = TRUE;

    return TRUE;
}

void T3DImagery::ClearMesh()
{
	int i;

	if (!meshinitialized)
		return;

  // Clear the execute buffer
	if (executebuf)
	{
		delete executebuf;
		executebuf = NULL;
		cacheexbuf = FALSE;
	}

  // Clear all objects
	ClearObjects();

  // Clear all textures
	ClearTextures();

  // Clear all materials
	ClearMaterials();

  // Delete animation keys (if not morph)
	for (i = 0; i < NumStates(); i++)
	{
		if (motion[i])
			delete motion[i];
	}
	delete motion;
	motion = NULL;

  // Delete morph verts (if is morph)
	int vstates;
	if (!(flags & I3D_ISMORPH))
		vstates = 1;
	else
		vstates = NumStates();
	for (i = 0; i < vstates; i++)
	{
		int vframes;
		if (!(flags & I3D_ISMORPH))
			vframes = 1;
		else
			vframes = GetAniLength(i);
		for (int j = 0; j < vframes; j++)
		{
			delete verts[i][j];
		}
		delete verts[i];
	}
	delete verts;
	verts = NULL;
	numverts = 0;

  // Delete faces
	delete faces;
	faces = NULL;

  // Delete icons
	if (icons)
	{
		for (int c = 0; c < NumStates(); c++)
		{
			if (icons[c].invitem)
			{
				delete icons[c].invitem;
				icons[c].invitem = NULL;
			}
			if (icons[c].invanim)
			{
				delete icons[c].invanim;
				icons[c].invanim = NULL;
			}
		}
		delete icons;
	}
	icons = NULL;

  // Delete and unmount sounds
	if (numplaysounds > 0)
	{
		for (int ps = 0; ps < numplaysounds; ps++)
		{
			if (playsounds[ps].mount)
			{
				int num = listnum(playsounds[ps].sounds);  // Get number of sounds in list
				for (int n = 0; n < num; n++)
					SoundPlayer.Unmount(listget(playsounds[ps].sounds, n));
			}
		}
		delete playsounds;
		playsounds = NULL;
	}

	meshinitialized = FALSE;
}

// Restores lost surfaces, textures, etc.
BOOL T3DImagery::Restore()
{
	if (SurfacesLost())
	{
		ClearMesh();
		if (!InitializeMesh((PS3DImageryBody)GetBody()))
			return FALSE;
	}

	return TRUE;
}

// *****************************
// * Verts and Faces Functions *
// *****************************

// Returns number of vertex in the vertex array for a single frame
int T3DImagery::NumVerts()
{
	return numverts;
}

// Copies single frame of vertices (default is state 0, frame 0)
void T3DImagery::GetVerts(LPVOID vertbuf, int state, int frame, D3DVERTEXTYPE verttype,
	int beg, int len)
{
	int c;

	if (beg < 0)
		beg = 0;
	if (len < 0)
		len = numverts;

	LPD3DVERTEX v;
	if (flags & I3D_ISMORPH)
		v = verts[state][frame];
	else
		v = verts[0][0];

	if (verttype == D3DVT_VERTEX)
		memcpy(vertbuf, v + beg, sizeof(D3DVERTEX) * len);
	else if (verttype == D3DVT_LVERTEX)						// Convert to LVERTEX
	{
		LPD3DVERTEX s = v + beg;
		LPD3DLVERTEX d = (LPD3DLVERTEX)vertbuf;
		for (c = 0; c < len; c++, s++, d++)
		{
			d->x = s->x;
			d->y = s->y;
			d->z = s->z;
			d->color = D3DRGBA(8.0, 8.0, 8.0, 1.0);
			d->specular = D3DRGBA(0, 0, 0, 0);
			d->tu = s->tu;
			d->tv = s->tv;
		}
	}
	else if (verttype == D3DVT_TLVERTEX)					// Convert to TLVERTEX
	{
		LPD3DVERTEX s = v + beg;
		LPD3DTLVERTEX d = (LPD3DTLVERTEX)vertbuf;
		for (c = 0; c < len; c++, s++, d++)
		{
			d->sx = (D3DVALUE)100 + s->x;
			d->sy = (D3DVALUE)100 + s->y;
			d->sz = (D3DVALUE)500 + s->z;
			d->rhw = (D3DVALUE)1.0;
			d->color = D3DRGBA(1.0, 1.0, 1.0, 1.0);
			d->specular = D3DRGBA(0, 0, 0, 0);
			d->tu = s->tu;
			d->tv = s->tv;
		}
	}
}

int T3DImagery::NumObjVerts(int objnum)
{
  // Sanity check for object num
	if (objnum < 0 || objnum > objects.NumItems() || !objects.Used(objnum))
		return 0;

	return objects[objnum].numverts;
}

// Copies single frame of vertices (default is state 0, frame 0)
void T3DImagery::GetObjVerts(int objnum, LPVOID vertbuf, int state, int frame, D3DVERTEXTYPE verttype)
{
	GetVerts(vertbuf, state, frame, verttype, objects[objnum].startvert, objects[objnum].numverts);
}


// Returns the number of faces for this imagery object
int T3DImagery::NumFaces()
{
	return numfaces;
}

// Copies all faces for this imagery object
void T3DImagery::GetFaces(PS3DFace facesbuf)
{
	memcpy(facesbuf, faces, sizeof(S3DFace) * numfaces);
}

// Returns the size of the face buffer for a particular object
int T3DImagery::NumObjFaces(int objnum)
{
  // Sanity check for object num
	if (objnum < 0 || objnum > objects.NumItems() || !objects.Used(objnum))
		return 0;

	return objects[objnum].numfaces;
}

// Copies all object faces
void T3DImagery::GetObjFaces(int objnum, PS3DFace facesbuf, int *texfaces, int *numtexfaces)
{
  // Sanity check for object num
	if (objnum < 0 || objnum > objects.NumItems() || !objects.Used(objnum))
		return;

	memcpy(facesbuf, faces + objects[objnum].startface, sizeof(S3DFace) * objects[objnum].numfaces);

	if (texfaces)
		memcpy(texfaces, objects[objnum].texfaces, sizeof(int) * min(MAXTEXTURES, textures.NumItems()));

	if (numtexfaces)
		memcpy(numtexfaces, objects[objnum].numtexfaces, sizeof(int) * min(MAXTEXTURES, textures.NumItems()));
}

// ********************
// * Object functions *
// ********************

// Returns number of objects in object list
int T3DImagery::NumObjects()
{
	return objects.NumItems();
}

// Adds a new object to object list
int T3DImagery::AddObject(PS3DObj obj)
{
	return objects.Add(*obj);
}

// Removes object from object list
void T3DImagery::RemoveObject(int objnum)
{
  // Sanity check for object rendering
	if (objnum < 0 || objnum > objects.NumItems() || !objects.Used(objnum))
		return;

	PS3DObj obj = &(objects[objnum]);

	delete obj->numtexfaces;
	delete obj->texfaces;
	delete obj->parent;

	for (int c = 0; c < NumStates(); c++)
		delete obj->anikeys[c];
	delete obj->anikeys;

	objects.Remove(objnum);
}

// Clears all objects
void T3DImagery::ClearObjects()
{
	for (int c = 0; c < objects.NumItems(); c++)
	{
		RemoveObject(c);
	}
	objects.Clear();
}

// Gets the object number given the object name
int T3DImagery::GetObjectNum(char *objname)
{
	for (int c = 0; c < objects.NumItems(); c++)
	{
		if (objects.Used(c) && !stricmp(objects[c].name, objname))
			return c;
	}
	return -1;
}

// Gets the name of an object
char *T3DImagery::GetObjectName(int objnum)
{
  // Sanity check for object rendering
	if (objnum < 0 || objnum > objects.NumItems() || !objects.Used(objnum))
		return NULL;

	return objects[objnum].name;
}

// Gets data for the given object
void T3DImagery::GetObject(int objnum, PS3DObj objbuf)
{
  // Sanity check for object rendering
	if (objnum < 0 || objnum > objects.NumItems() || !objects.Used(objnum))
		return;

	memcpy(objbuf, &objects[objnum], sizeof(S3DObj));
}

// Calculates a matrix based on the given position, rotation, and scale

void MakeMatrix(D3DMATRIX &m, D3DVECTOR &pos, D3DVECTOR &rot, D3DVECTOR &scl)
{
	if (rot.x != (D3DVALUE)0.0)
		D3DMATRIXRotateX(&m, rot.x);
	if (rot.y != (D3DVALUE)0.0)
		D3DMATRIXRotateY(&m, rot.y);
	if (rot.z != (D3DVALUE)0.0)
		D3DMATRIXRotateZ(&m, rot.z);
	if (pos.x != (D3DVALUE)0.0 || pos.y != (D3DVALUE)0.0 || pos.z != (D3DVALUE)0.0)
		D3DMATRIXTranslate(&m, &pos);
	if (scl.x != (D3DVALUE)1.0 || scl.y != (D3DVALUE)1.0 || scl.z != (D3DVALUE)1.0)
		D3DMATRIXScale(&m, &scl);
}

// Gets the position, rotation, and scale for the given state and frame, or returns FALSE
// if there is no animation for that frame.  This is the uninterpolated version.

BOOL T3DImagery::GetUninterpolatedAniKey(int objnum, int state, int frame, 
	D3DVECTOR &pos, D3DVECTOR &rot, D3DVECTOR &scl)
{
	int numaniframes = GetAniLength(state);
	if ((DWORD)state > (DWORD)NumStates() || (DWORD)frame >= (DWORD)GetAniLength(state))
		return FALSE;

	// Set animation matrices for object
	SAniKey &ak = objects[objnum].anikeys[state][frame];
	rot.x = (D3DVALUE)ak_rx(ak) / (D3DVALUE)ANIKEY_ANGSCALE;
	rot.y = (D3DVALUE)ak_ry(ak) / (D3DVALUE)ANIKEY_ANGSCALE;
	rot.z = (D3DVALUE)ak_rz(ak) / (D3DVALUE)ANIKEY_ANGSCALE;
	pos.x = (D3DVALUE)ak_x(ak) / (D3DVALUE)ANIKEY_POSSCALE;
	pos.y = (D3DVALUE)ak_y(ak) / (D3DVALUE)ANIKEY_POSSCALE;
	pos.z = (D3DVALUE)ak_z(ak) / (D3DVALUE)ANIKEY_POSSCALE;
	scl.x = scl.y = scl.z = (D3DVALUE)1.0;

	return TRUE;
}


// Gets the position, rotation, and scale for the given state and frame, or returns FALSE
// if there is no animation for that frame.  This is the interpolated version

#define INTERFRAMES 8

void InterpolatePoints(D3DVECTOR &v1, D3DVECTOR &v2, D3DVALUE &i)
{
	if (v1.x != v2.x || v1.y != v2.y || v1.z != v2.z)
	{
		v1.x = v1.x * i + v2.x * ((D3DVALUE)1.0 - i);
		v1.y = v1.y * i + v2.y * ((D3DVALUE)1.0 - i);
		v1.z = v1.z * i + v2.z * ((D3DVALUE)1.0 - i);
	}
}

// Adjusts differences in rotations so that all rotations are less than 180 degrees
void NormalizeRot(D3DVECTOR &v1, D3DVECTOR &v2)
{
	if (v2.x - v1.x > M_PI)			// Greater than 180
		v2.x -= (float)M_2PI;
	else if (v2.x - v1.x < -M_PI)	// Less than -180
		v2.x += (float)M_2PI;
	if (v2.y - v1.y > M_PI)			// Greater than 180
		v2.y -= (float)M_2PI;
	else if (v2.y - v1.y < -M_PI)	// Less than -180
		v2.y += (float)M_2PI;
	if (v2.z - v1.z > M_PI)			// Greater than 180
		v2.z -= (float)M_2PI;
	else if (v2.z - v1.z < -M_PI)	// Less than -180
		v2.z += (float)M_2PI;

	if (abs(v2.x - v1.x) > M_PI / 2 ||
		abs(v2.y - v1.y) > M_PI / 2 ||
		abs(v2.z - v1.z) > M_PI / 2)
	{
		v2 = v1; // Quaternion interpolation goes here
	}
}

BOOL T3DImagery::GetAniKey(int objnum, int state, int frame, 
	D3DVECTOR &pos, D3DVECTOR &rot, D3DVECTOR &scl)
{
	if (!GetUninterpolatedAniKey(objnum, state, frame, pos, rot, scl))
		return FALSE;

	PS3DObj obj = &objects[objnum];

	if (!stricmp(obj->name, "hips"))
	{
		if (pos.z < 30)
			pos.z = pos.z * 1;
	}

	if (!Interpolate ||													// Interpolation off
		(GetHeader()->states[state].flags & AF_NOINTERPOLATION) ||		// No interpolation this state
		(((DWORD)prevstate <= (DWORD)GetHeader()->numstates) &&			// No interpolation next state
		(GetHeader()->states[prevstate].flags & AF_NOINTERPOLATION)))
		return TRUE;

	int iframes = INTERFRAMES;
	int anilength = GetAniLength(state);

	D3DVALUE i = (D3DVALUE)1.0;
	D3DVECTOR ipos, irot, iscl;
	if (prevstate >= 0 && frame < iframes)   // From previous state
	{
		i = (D3DVALUE)(frame + 1) / (D3DVALUE)iframes;
		GetUninterpolatedAniKey(objnum, prevstate, GetHeader()->states[prevstate].frames - 1, ipos, irot, iscl);
		NormalizeRot(rot, irot); // Makes sure rotations are all less than 180 degrees
		InterpolatePoints(pos, ipos, i);
		InterpolatePoints(rot, irot, i);
		InterpolatePoints(scl, iscl, i);
	}

	return TRUE;
}

// Renders an object individually
BOOL T3DImagery::RenderObject(PS3DAnimObj animobj, int state, int frame, LPD3DMATRIX pos, 
	int tex, BOOL uselastmatrix)
{
	int t;
	int objnum = animobj->objnum;

  // Sanity check for object rendering
	if (objnum < 0 || objnum > objects.NumItems() || !objects.Used(objnum))
		return FALSE;

  // Sanity check for state
	if (state >= NumStates())
		return FALSE;

  // If textures turned off, reload mesh
	if (hastextures) // Turn textures on/off
	{
		if ((!UseTextures && textures.NumItems() > 0) || (UseTextures && textures.NumItems() <= 0))
			ClearMesh();
	}

  // If mesh not initialized, attempt to initialize it now
	if (!meshinitialized)
		if (!InitializeMesh((PS3DImageryBody)GetBody()))
			return FALSE;

	PS3DObj obj = &objects[objnum];

  // **** CALCULATE POSITION ****

  // Make the objects matrix if object isn't morph, and we aren't using the last matrix 
	D3DMATRIX &m = animobj->matrix;
	if (!(animobj->flags & OBJ3D_MATRIX) && !uselastmatrix)
	{
		D3DMATRIXClear(&m);

		BOOL hastrans = animobj->flags & (OBJ3D_ROTMASK | OBJ3D_POSMASK | OBJ3D_SCLMASK);

		if (!(flags & I3D_ISMORPH) && (!hastrans || animobj->flags & OBJ3D_ADDTOANI))
		{
			int animtrack;
			if (animobj->flags & OBJ3D_ANIMTRACK)
				animtrack = animobj->animtrack;
			else
				animtrack = animobj->objnum;

			if (GetAniKey(animtrack, state, frame, animobj->pos, animobj->rot, animobj->scl))
				MakeMatrix(m, animobj->pos, animobj->rot, animobj->scl);
		}

		if (hastrans)  // One of the object transform flags was set, so do the pos, rot, scl
		{
		  // Do first transform
			if ((animobj->flags & OBJ3D_POSMASK) == OBJ3D_POS1)
				D3DMATRIXTranslate(&m, &animobj->pos);
			else if ((animobj->flags & OBJ3D_ROTMASK) == OBJ3D_ROT1)
			{
				D3DMATRIXRotateX(&m, animobj->rot.x);
				D3DMATRIXRotateY(&m, animobj->rot.y);
				D3DMATRIXRotateZ(&m, animobj->rot.z);
			}
			else if ((animobj->flags & OBJ3D_SCLMASK) == OBJ3D_SCL1)
				D3DMATRIXScale(&m, &animobj->scl);

		  // Do second transform
			if ((animobj->flags & OBJ3D_POSMASK) == OBJ3D_POS2)
				D3DMATRIXTranslate(&m, &animobj->pos);
			else if ((animobj->flags & OBJ3D_ROTMASK) == OBJ3D_ROT2)
			{
				D3DMATRIXRotateX(&m, animobj->rot.x);
				D3DMATRIXRotateY(&m, animobj->rot.y);
				D3DMATRIXRotateZ(&m, animobj->rot.z);
			}
			else if ((animobj->flags & OBJ3D_SCLMASK) == OBJ3D_SCL2)
				D3DMATRIXScale(&m, &animobj->scl);

		  // Do third transform
			if ((animobj->flags & OBJ3D_POSMASK) == OBJ3D_POS3)
				D3DMATRIXTranslate(&m, &animobj->pos);
			else if ((animobj->flags & OBJ3D_ROTMASK) == OBJ3D_ROT3)
			{
				D3DMATRIXRotateX(&m, animobj->rot.x);
				D3DMATRIXRotateY(&m, animobj->rot.y);
				D3DMATRIXRotateZ(&m, animobj->rot.z);
			}
			else if ((animobj->flags & OBJ3D_SCLMASK) == OBJ3D_SCL3)
				D3DMATRIXScale(&m, &animobj->scl);
		}

      // If has parent, concatenate local position with parents position..
		if (animobj->parent)
			MultiplyD3DMATRIX(&m, &m, &animobj->parent->matrix);
	}

  // This is where we check to see if we're hidden (after calculating position and
  // before we change any render states)
	if (animobj->flags & OBJ3D_HIDE)
		return TRUE;
 
  // **** SET RENDER STATES ****

  // Ok, we have the object matrix, now multiply it by the world, and set it into
  // the D3D render state
	if (!(flags & I3D_ISMORPH) ||  // If not a morph (uses animation keys)
		(animobj->flags & (OBJ3D_POSMASK | OBJ3D_ROTMASK | OBJ3D_SCLMASK | OBJ3D_MATRIX)))
		 // Or is morph but overriding pos or matrix
	{
        // See if we need to transform the position to the objects world space position
        if (animobj->flags & OBJ3D_ABSPOS)
            TRY_D3D(Scene3D.SetTransform(D3DTRANSFORMSTATE_WORLD, &animobj->matrix))
        else
        {
            D3DMATRIX world;

			if (Double3D || Triple3D)
			{
				D3DMATRIX temp;
				memcpy(&temp, &animobj->matrix, sizeof(D3DMATRIX));
				D3DVECTOR s;
				s.x = s.y = s.z = Triple3D ? 3.0f : 2.0f;
				D3DMATRIXScale(&temp, &s);

		        MultiplyD3DMATRIX(&world, &temp, pos);
			    TRY_D3D(Scene3D.SetTransform(D3DTRANSFORMSTATE_WORLD, &world))
			}
			else
			{
		        MultiplyD3DMATRIX(&world, &animobj->matrix, pos);
			    TRY_D3D(Scene3D.SetTransform(D3DTRANSFORMSTATE_WORLD, &world))
			}

//			D3DVECTOR v1, v2;			// Test if hip position less than 0!!!!
//			v1.x = v1.y = v1.z = 0.0f;
//			D3DMATRIXTransform(&world, &v1, &v2);
//			if (v2.z < 30.0f && !stricmp(obj->name, "hips"))
//			{
//				v2.z = v2.z * 1.0f;
//			} 

        }
	}
	else
	{
		TRY_D3D(Scene3D.SetTransform(D3DTRANSFORMSTATE_WORLD, pos))
	}

  // If we have already cached an execute buffer, we can leave right here after matrix stuff	
	if (cacheexbuf && executebuf != NULL)
		return TRUE;

  // Set the object material
	D3DMATERIALHANDLE hmaterial;
	if (animobj->flags & OBJ3D_MAT)
		hmaterial = animobj->hmaterial;
	else
		hmaterial = materials[obj->material].hmaterial;
	D3DMATERIALHANDLE holdmat;
	TRY_D3D(Scene3D.GetLightState(D3DLIGHTSTATE_MATERIAL, &holdmat));
	if (holdmat != hmaterial)
		TRY_D3D(Scene3D.SetLightState(D3DLIGHTSTATE_MATERIAL, hmaterial))

  // Now draw the objects faces by texture
	for (t = 0; t < textures.NumItems() + 1; t++)
	{
		int numvrt;
		D3DVERTEXTYPE vrttype;
		LPVOID vrt;
		int numfac;
		S3DFace *fac;

		if (tex >= 0 && tex != t) // Do only textures specified in the command line
			continue;

	  // Get vertices to draw
		if (animobj->flags & OBJ3D_VERTS)
		{
			numvrt = animobj->numverts;						// Use override vertex array
			vrttype = animobj->verttype;
			vrt = animobj->verts;
		}
		else
		{
			numvrt = obj->numverts;
			vrttype = D3DVT_VERTEX;
			if (flags & I3D_ISMORPH)
				vrt = &verts[state][frame] + obj->startvert;
			else
				vrt = verts[0][0] + obj->startvert;
		}

	  // Get faces to draw
		if (animobj->flags & OBJ3D_FACES)
		{
			numfac = animobj->numtexfaces[t];				// Use override face array
			fac = animobj->faces + animobj->texfaces[t];
		}
		else
		{
			numfac = obj->numtexfaces[t];
			fac = &faces[obj->startface + obj->texfaces[t]];
		}

	  // Nothing to do!
		if (numvrt <= 0 || numfac <= 0)
				continue;

	  // Set multiframe texture frame (does nothing if overriding texture handles)
		if (hastextures && UseTextures &&
			t > 0 && !(animobj->flags & OBJ3D_TEX)) // Can't have custom textures and control frames
		{
			int texframe;
			if (animobj->flags & OBJ3D_TEXFRAME)
				texframe = animobj->textureframe[t];
			else
				texframe = frame;
			SetTextureFrame(t - 1, texframe);
		}

      // Set texture
		D3DTEXTUREHANDLE htexture;
		if (!hastextures || !UseTextures)
		{
			htexture = NULL;
		}
		else if (animobj->flags & OBJ3D_TEX)
		{
			htexture = animobj->htextures[t];
		}
		else
		{
			if (t == 0)
				htexture = NULL;
			else
				htexture = textures[t - 1].htexture;
		}
		D3DTEXTUREHANDLE holdtex;
		TRY_D3D(Scene3D.GetRenderState(D3DRENDERSTATE_TEXTUREHANDLE, &holdtex));
		if (materials[obj->material].matdesc.hTexture != htexture)
		{
			materials[obj->material].matdesc.hTexture = htexture;
			materials[obj->material].material->SetMaterial(&materials[obj->material].matdesc);
		}
 		if (holdtex != htexture)
		{
			TRY_D3D(Scene3D.SetRenderState(D3DRENDERSTATE_TEXTUREHANDLE, htexture));
		}

	  // Uhhhh.... ok, draw it now..
		TRY_D3D(Scene3D.DrawIndexedPrimitive(
			D3DPT_TRIANGLELIST,
			vrttype,
			vrt,
			numvrt,
			(WORD *)fac,
			numfac * 3,
			/*D3DDP_DONOTUPDATEEXTENTS | D3DDP_DONOTCLIP*/ 0));
	}

	return TRUE;
}

void T3DImagery::BeginRender(BOOL cachebuf, BOOL clearbuf)
{
	if (clearbuf && executebuf != NULL)
	{
		delete executebuf;
		executebuf = NULL;
	}

	cacheexbuf = cachebuf && !UseDrawPrimitive && CacheExBufs;	// Only attempt to cache if we can

	if (cacheexbuf && executebuf != NULL)
		Scene3D.UseExecuteBuf(executebuf);	// Tell scene we want to use this buf..
		
  // Initialize rendering stuff for scene (sets up execute buf stuff, etc.)
	Scene3D.BeginRender();
}


void T3DImagery::EndRender()
{
  // Tell scene we're done rendering (wraps up execute buffer stuff, etc.)	
	Scene3D.EndRender();

  // If we want to cache a buf, and we haven't yet, and there were no calls to 
  // GetExtents() from within the previous render, copy the previous execute
  // buffer into our cache.
	if (cacheexbuf && !executebuf && !Scene3D.WasRenderFlushed())
		executebuf = Scene3D.CopyExecuteBuf();
}

void T3DImagery::PlaySound(int state, int frame)
{
	if (numplaysounds < 0)
		return;

	PS3DImageryPlaySound ps = playsounds;
	for (int c = 0; c < numplaysounds; c++, ps++)
	{
		if (ps->state == state && ps->frame == frame)
		{
			PLAY(listrnd(ps->sounds));
			return;
		}
	}
}

// **********************
// * Material Functions *
// **********************

int T3DImagery::AddMaterial(LPD3DMATERIAL newmat, int tex)
{
	S3DMat mat;
	D3DMATERIAL &m = mat.matdesc;
	memcpy(&m, newmat, sizeof(D3DMATERIAL));

	TRY_D3D(Direct3D->CreateMaterial(&mat.material, NULL));

	BOOL isalpha = FALSE;
	if (tex >= 0 && textures[tex].ddsd.ddpfPixelFormat.dwRGBAlphaBitMask != 0)
		isalpha = TRUE;

	if (UseTextures && tex >= 0 && tex < textures.NumItems() &&
		textures.Used(tex) && textures[tex].htexture)
	{
		if (isalpha)
		{
			m.ambient.r = m.ambient.g = m.ambient.b = 0.0f;
			m.ambient.a = 1.0f;
			m.diffuse.r = m.diffuse.g = m.diffuse.b = 0.0f;
			m.diffuse.a = 1.0f;
			m.specular.r = m.specular.g = m.specular.b = 0.0f;
			m.specular.a = 1.0f;
		}
/*		m.ambient.r = D3DVAL(1.0);
		m.ambient.g = D3DVAL(1.0);
		m.ambient.b = D3DVAL(1.0);
		m.ambient.a = D3DVAL(1.0);
		m.diffuse.r = D3DVAL(1.0);
		m.diffuse.g = D3DVAL(1.0);
		m.diffuse.b = D3DVAL(1.0);
		m.diffuse.a = D3DVAL(1.0);
		m.specular.r = D3DVAL(1.0);
		m.specular.g = D3DVAL(1.0);
		m.specular.b = D3DVAL(1.0);
		m.specular.a = D3DVAL(1.0);
*/		m.hTexture = textures[tex].htexture;
		mat.texture = tex;
	}
	else
	{
		m.hTexture = NULL;
		mat.texture = -1;
	}

//	m.power = D3DVAL(30.0);
	mat.material->SetMaterial(&m);
	mat.material->GetHandle(Device, &(mat.hmaterial));

	return materials.Add(mat);
}

void T3DImagery::GetMaterial(int matnum, PS3DMat mat)
{
	if (matnum < 0 || matnum >= materials.NumItems() || !materials.Used(matnum))
		return;

	memcpy(mat, &materials[matnum], sizeof(S3DMat));
}

D3DMATERIALHANDLE T3DImagery::GetMaterialHandle(int matnum)
{
	if (matnum < 0 || matnum >= materials.NumItems() || !materials.Used(matnum))
		return NULL;

	return materials[matnum].hmaterial;
}

void T3DImagery::SetMaterial(int matnum, PS3DMat mat)
{
	if (matnum < 0 || matnum >= materials.NumItems() || !materials.Used(matnum))
		return;

	memcpy(&materials[matnum].matdesc, &mat->matdesc, sizeof(D3DMATERIAL));
	if (mat->texture < 0 || mat->texture >= textures.NumItems() || !textures.Used(mat->texture))
	{
		materials[matnum].matdesc.hTexture = NULL;
		materials[matnum].texture = -1;
	}
	else
	{
		materials[matnum].matdesc.hTexture = textures[mat->texture].htexture;
		materials[matnum].texture = mat->texture;
	}
	materials[matnum].material->SetMaterial(&materials[matnum].matdesc);
}

void T3DImagery::RemoveMaterial(int matnum)
{
	if (!materials.Used(matnum) || !materials[matnum].material)
		 return;
    RELEASE(materials[matnum].material);
	materials[matnum].material = NULL;
	materials[matnum].hmaterial = NULL;

	materials.Remove(matnum);
}

// Release materials
void T3DImagery::ClearMaterials()
{
	for (int c = 0; c < materials.NumItems(); c++)
	{
		RemoveMaterial(c);
	}
	materials.Clear();
}

// *********************
// * Texture Functions *
// *********************

/*
 * NewTexture
 * Loads a pixel buffer into a texture map DD surface of the given format.  If
 * lpTexture is not NULL, the source texture will be reloaded into lpTexture.
 */

extern LPDIRECTDRAWSURFACE back;

int T3DImagery::AddTexture(LPDDSURFACEDESC srcsd,
	OFFSET *pixels, int frames, LPPALETTEENTRY palette)
{
	S3DTex tex;
	memset(&tex, 0, sizeof(S3DTex));
	if (!LoadTexture(&tex, srcsd, pixels, frames, palette, FALSE))
		return -1;

	return textures.Add(tex);
}

BOOL T3DImagery::LoadTexture(PS3DTex tex,
	LPDDSURFACEDESC srcsd, OFFSET *pixels, int frames, LPPALETTEENTRY palette,
	BOOL copyframes)
{
    DDSURFACEDESC ddsd;
    PALETTEENTRY *dstpal = NULL;
    DWORD pcaps;

//	if (texnum <= 0) // Use back surface as texture.. COOL!
//	{
//	    TRY_D3D(back->QueryInterface(IID_IDirect3DTexture, (LPVOID*)&texture[texnum]));
//	    TRY_D3D(texture[texnum]->GetHandle(Device, &htexture[texnum]));
//		return TRUE;
//	}

	DDSURFACEDESC dstsd;
	Scene3D.GetClosestTextureFormat(srcsd, &dstsd);

  // Setup palette
	int dstpalcolors = 0;
	if (dstsd.ddpfPixelFormat.dwFlags & (DDPF_PALETTEINDEXED8 | DDPF_PALETTEINDEXEDTO8))
		dstpalcolors = 256;
	else if (dstsd.ddpfPixelFormat.dwFlags &
		(DDPF_PALETTEINDEXED1 | DDPF_PALETTEINDEXED2 | DDPF_PALETTEINDEXED4))
		dstpalcolors = 1 << dstsd.ddpfPixelFormat.dwRGBBitCount;

  // Setup surface descs
	srcsd->lPitch = srcsd->dwWidth;

	dstsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PITCH | DDSD_PIXELFORMAT;
	dstsd.ddsCaps.dwCaps = DDSCAPS_TEXTURE;
	dstsd.dwWidth = srcsd->dwWidth;
	dstsd.lPitch = srcsd->lPitch;
	dstsd.dwHeight = srcsd->dwHeight;

  // Save a copy of the surface desc in texture array
	memcpy(&tex->ddsd, &dstsd, sizeof(DDSURFACEDESC));

  // Allocate palette
	if (dstpalcolors > 0)
		dstpal = new PALETTEENTRY[dstpalcolors];
	else
		dstpal = NULL;

  // Check for memory!
	int bufsize = (dstsd.ddpfPixelFormat.dwRGBBitCount * dstsd.lPitch * dstsd.dwHeight) >> 3;
	int mem = GetFreeTextureMem();
//	if (mem - bufsize < 10 * 1024)    // Not enough video memory for texture
//		return FALSE;				  // Don't use because some video cards don't support this function!!
	int animsize = bufsize * frames;
	if (mem - animsize < 100 * 1024)
		copyframes = TRUE;				// Forces copyframes to be true if not enough memory

  // ***** Do Texture Frames *****
	if (frames <= 1)
		copyframes = FALSE;  // Can't copy frames if there's only one frame
 	tex->copyframes = copyframes;
	tex->numframes = frames;
	tex->framenum = 0;
	if (frames > 1)
	{
		tex->framesurfs = new LPDIRECTDRAWSURFACE[frames];
		tex->frametexs = new LPDIRECT3DTEXTURE[frames];
		tex->framehtexs = new D3DTEXTUREHANDLE[frames];
	}
	else
	{
		tex->framesurfs = NULL;
		tex->frametexs = NULL;
		tex->framehtexs = NULL;
	}
	tex->surface = NULL;
	tex->texture = NULL;
	tex->htexture = NULL;

	LPDIRECTDRAWSURFACE memsurf = NULL;
	LPDIRECT3DTEXTURE memtex = NULL;
	D3DTEXTUREHANDLE memhtex = NULL;
    LPDIRECTDRAWPALETTE mempal = NULL;

	LPDIRECTDRAWSURFACE vidsurf = NULL;
	LPDIRECT3DTEXTURE vidtex = NULL;
	D3DTEXTUREHANDLE vidhtex = NULL;
	LPDIRECTDRAWPALETTE vidpal = NULL;

	for (int f = 0; f < frames; f++)
	{
	  // Create the memory surface
		if (memsurf == NULL)
		{
			dstsd.ddsCaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_SYSTEMMEMORY;
			DirectDraw->CreateSurface(&dstsd, &memsurf, NULL);
			if (memsurf == NULL)
				return FALSE;
		}

	  // Convert the surface
		memset(&ddsd, 0, sizeof(DDSURFACEDESC));
		ddsd.dwSize = sizeof(DDSURFACEDESC);
 		TRY_DD(memsurf->Lock(NULL, &ddsd, DDLOCK_NOSYSLOCK | DDLOCK_WAIT, NULL));
		BYTE *dstpixels = (BYTE *)ddsd.lpSurface;
		Scene3D.ConvertTexture(srcsd, pixels[f], palette, &dstsd, dstpixels, dstpal); // Should already have keycolor encoded as 1 bit alpha
		TRY_DD(memsurf->Unlock(NULL));

	  // Create palette (if needed)
		if (dstpal)
		{
			if (dstsd.ddpfPixelFormat.dwFlags & (DDPF_PALETTEINDEXED8 | DDPF_PALETTEINDEXEDTO8))
				pcaps = DDPCAPS_8BIT | DDPCAPS_ALLOW256;
			else if (dstsd.ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED4)
				pcaps = DDPCAPS_4BIT;
			else if (dstsd.ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED2)
				pcaps = DDPCAPS_2BIT;
			else if (dstsd.ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED1)
				pcaps = DDPCAPS_1BIT;
			TRY_DD(DirectDraw->CreatePalette(DDPCAPS_INITIALIZE | pcaps, dstpal, &mempal, NULL));
			TRY_DD(memsurf->SetPalette(mempal));
		}

		TRY_D3D(memsurf->QueryInterface(IID_IDirect3DTexture, (LPVOID*)&memtex));
		TRY_D3D(memtex->GetHandle(Device, &memhtex));

      // Setup primary texture buffer
		if (!vidsurf)
		{

			memset(&ddsd, 0, sizeof(DDSURFACEDESC));
			ddsd.dwSize = sizeof(DDSURFACEDESC);
			TRY_D3D(memsurf->GetSurfaceDesc(&ddsd));
			ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT;
			ddsd.ddsCaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_ALLOCONLOAD;
			if (!IsUsingHardware())
				ddsd.ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
			DirectDraw->CreateSurface(&ddsd, &vidsurf, NULL);
			if (vidsurf == NULL)
				return FALSE;

			if (ddsd.ddpfPixelFormat.dwFlags & (DDPF_PALETTEINDEXED8 | DDPF_PALETTEINDEXEDTO8))
				pcaps = DDPCAPS_8BIT | DDPCAPS_ALLOW256;
			else if (ddsd.ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED4)
				pcaps = DDPCAPS_4BIT;
			else if (ddsd.ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED2)
				pcaps = DDPCAPS_2BIT;
			else if (ddsd.ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED1)
				pcaps = DDPCAPS_1BIT;
			else
				pcaps = 0;

			if (pcaps) {
				TRY_D3D(DirectDraw->CreatePalette(pcaps, dstpal, &vidpal, NULL));
				TRY_D3D(vidsurf->SetPalette(vidpal));
			}

			TRY_D3D(vidsurf->QueryInterface(IID_IDirect3DTexture, (LPVOID*)&vidtex));
			HRESULT err = vidtex->Load(memtex);
			if (err != DD_OK)
				return FALSE;
			TRY_D3D(vidtex->GetHandle(Device, &vidhtex));

			// Set pointer to buffer in frame array (if more than one frame)
		}

		if (frames <= 1)	// If only one frame, put only video surface into main pointers and go
		{
			tex->surface = vidsurf;  // Sets to only vidsurf.. no frame array
			tex->texture = vidtex;
			tex->htexture = vidhtex;
			// Only 1 memsurf will be allocated, then freed after loop
		}
		else if (copyframes && tex->framesurfs)	// If multiframe and using copy, put multi mem surf to array, and only one vid to main
		{
			tex->framesurfs[f] = memsurf;
			tex->frametexs[f] = memtex;
			tex->framehtexs[f] = memhtex;
			memsurf = NULL;		// Causes memsurf to be reallocated next frame
			memtex = NULL;
			memhtex = NULL;
			tex->surface = vidsurf;	// Sets to single vidsurf allocated
			tex->texture = vidtex;
			tex->htexture = vidhtex;
		}
		else if (tex->framesurfs)			// If multiframe and not copy, put multi vid surf to array and first vid surf to main
		{
			tex->framesurfs[f] = vidsurf;
			tex->frametexs[f] = vidtex;
			tex->framehtexs[f] = vidhtex;
			vidsurf = NULL;		// Causes new vidsurf to be reallocated next frame
			vidtex = NULL;
			vidhtex = NULL;
			tex->surface = tex->framesurfs[0];	// Set to very first vidsurf
			tex->texture = tex->frametexs[0];
			tex->htexture = tex->framehtexs[0];
			// Only 1 memsurf will be allocated, then freed after loop
		}
	}

	if (memtex)		// If these are still here now, delete them
	{
		RELEASE(memtex);
		RELEASE(memsurf);
	}

	if (dstpal)
		delete dstpal;

    return TRUE;
}

// Releases texture surface and texture object
void T3DImagery::RemoveTexture(int texnum)
{
	PS3DTex t = &textures[texnum];

	if (t->numframes <= 1 || t->copyframes)
	{
	    RELEASE(t->texture);
		RELEASE(t->surface);
	}
	t->texture = NULL;
	t->surface = NULL;
	t->htexture = NULL;
	if (t->framesurfs)
	{
		for (int c = 0; c < t->numframes; c++)
		{
		    RELEASE(t->frametexs[c]);
			RELEASE(t->framesurfs[c]);
		}
		delete t->framesurfs;
		delete t->frametexs;
		delete t->framehtexs;
		t->framesurfs = NULL;
		t->frametexs = NULL;
		t->framehtexs = NULL;
	}
	t->numframes = 0;
	t->framenum = 0;

	textures.Remove(texnum);
}

// Returns number of textures
int T3DImagery::NumTextures()
{
	return textures.NumItems();
}

// Gets the current texture info
void T3DImagery::GetTexture(int texnum, PS3DTex tex)
{
	if (texnum < 0 || texnum >= textures.NumItems() || !textures.Used(texnum))
		return;

	memcpy(tex, &textures[texnum], sizeof(S3DTex));
}

D3DTEXTUREHANDLE T3DImagery::GetTextureHandle(int texnum)
{
	if (texnum < 0 || texnum >= textures.NumItems() || !textures.Used(texnum))
		return NULL;

	return textures[texnum].htexture;
}

// Kill the textures
void T3DImagery::ClearTextures()
{
	for (int c = 0; c < textures.NumItems(); c++)
	{
		RemoveTexture(c);
	}

	textures.Clear();
}

// Gets the current texture frame
int T3DImagery::GetTextureFrame(int texnum)
{
	if (texnum < 0 || texnum >= textures.NumItems() || !textures.Used(texnum))
		return 0;

	return textures[texnum].framenum;
}

// Copies texture data for given texture frame
BOOL T3DImagery::SetTextureFrame(int texnum, int framenum)
{
	if (texnum < 0 || texnum >= textures.NumItems() || !textures.Used(texnum))
		return FALSE;

	if (textures[texnum].numframes <= 1)
		return TRUE;

	if (framenum > textures[texnum].numframes)
		framenum = framenum % textures[texnum].numframes;

	if (textures[texnum].framenum == framenum) // Texture already set to correct frame
		return TRUE;

	if (!textures[texnum].copyframes)
	{
		textures[texnum].surface = textures[texnum].framesurfs[framenum];
		textures[texnum].texture = textures[texnum].frametexs[framenum];
		textures[texnum].htexture = textures[texnum].framehtexs[framenum];
		textures[texnum].framenum = framenum;
		return TRUE;
	}

	HRESULT err = textures[texnum].texture->Load(textures[texnum].frametexs[framenum]);
	if (err != DD_OK)
		return FALSE;

	textures[texnum].framenum = framenum;

	return TRUE;
}

// Returns TRUE if any surfaces are lost
BOOL T3DImagery::SurfacesLost()
{
	for (int c = 0; c < textures.NumItems(); c++)
	{
		if (textures.Used(c) && 
			textures[c].surface && 
			textures[c].surface->IsLost() == DDERR_SURFACELOST)
			  return TRUE;
	}

	return FALSE;
}

// If SurfacesLost() reports TRUE, is called to cause the surfaces to be reloaded.
void T3DImagery::RestoreSurfaces()
{
	if (!SurfacesLost())
		return;

	Restore();
}

// *****************************
// * General Purpose Functions *
// *****************************

// Resets the extents registers in the 3D renderer to default values
void T3DImagery::ResetExtents()
{
	D3DCLIPSTATUS cs;
	cs.dwFlags = D3DCLIPSTATUS_EXTENTS2;
	cs.dwStatus = 0;
	cs.minx = cs.miny = cs.minz  = 2048.0;
	cs.maxx = cs.maxy = cs.maxz = 0.0;
	HRESULT ok = Scene3D.SetClipStatus(&cs);
}

// Retrieves the extents of the imagery drawn since the ClearExtents() function was called
void T3DImagery::GetExtents(LPD3DRECT extents)
{
	D3DCLIPSTATUS cs;
	cs.dwFlags = D3DCLIPSTATUS_EXTENTS2;
	Scene3D.GetClipStatus(&cs);

	extents->x1 = (long)cs.minx;
	extents->y1 = (long)cs.miny;
	extents->x2 = (long)cs.maxx;
	extents->y2 = (long)cs.maxy;
}

void T3DImagery::AddUpdateRect(LPD3DRECT extents, int uflags)
{
	if (extents->x2 < 0 || extents->x1 >= WIDTH ||
	    extents->y2 < 0 || extents->y1 >= HEIGHT ||
	    extents->x2 - extents->x1 <= 0 ||
		extents->y2 - extents->y1 <= 0)
		return;

	SRect r;
	r.left = (int)extents->x1;
	r.top = (int)extents->y1;
	r.right = (int)extents->x2;
	r.bottom = (int)extents->y2;

	if (!NoUpdateRects)
		Display->AddUpdateRect(r.left, r.top, r.right - r.left + 1, r.bottom - r.top + 1, uflags);
}

// This function sets the maximum bounding box for a state given the latest extents rect
void T3DImagery::UpdateBoundingRect(PTObjectInstance oi, int state, LPD3DRECT extents)
{
	if (extents->x2 <= 0 || extents->x1 <= 0 || extents->x1 >= WIDTH ||
		extents->y2 <= 0 || extents->y1 <= 0 || extents->y1 >= HEIGHT ||
		extents->x2 - extents->x1 <= 0 ||
		extents->y2 - extents->y1 <= 0)
		return;

	S3DPoint p;
	oi->GetScreenPos(p);
	SRect nr, r;
	p.x = p.x - MapPane.GetScrollX() + MapPane.GetPosX(); // Get screen relative position
	p.y = p.y - MapPane.GetScrollY() + MapPane.GetPosY();
	r.left = -GetRegX(state);
	r.top = -GetRegY(state);
	r.right = r.left + GetWidth(state) - 1;
	r.bottom = r.top + GetHeight(state) - 1;
	nr.left = (int)extents->x1 - p.x;
	nr.top = (int)extents->y1 - p.y;
	nr.right = (int)extents->x2 - p.x;
	nr.bottom = (int)extents->y2 - p.y;
	if (nr.left < r.left)
		r.left = nr.left;
	if (nr.top < r.top)
		r.top = nr.top;
	if (nr.right > r.right)
		r.right = nr.right;
	if (nr.bottom > r.bottom)
		r.bottom = nr.bottom;
	SetReg(state, -r.left, -r.top, 0);
	SetWidthHeight(state, r.right - r.left + 1, r.bottom - r.top + 1);
}

// Refreshes Z buffer
void T3DImagery::RefreshZBuffer(PTObjectInstance oi)
{
	SRect r;

  // Draw ZBuffer behind character when NoScrollZBuffer is on.
  // NoScrollZBuffer causes the update system to NOT update the screen ZBuffer, which
  // means that there is garbage in there when the 3D objects draw to it.  This little
  // function copies only the rectangle of the ZBuffer that this 3D object needs to the
  // screen so that the zbuffer is correct for the object when it draws.
	GetScreenRect(oi, r);
	Scene3D.RestoreZBuffer(r);
}

void T3DImagery::DrawShadow(PTObjectInstance oi)
{
	if (oi->Flags() & OF_INVISIBLE)
		return;

	if (DrawRealtimeShadows && shadow && oi->DrawShadow())
	{
		S3DPoint pos;
		oi->GetPos(pos);

		int bz = MapPane.GetWalkHeight(pos);
		if (absval(bz - pos.z) > 16)
			pos.z = bz;

		int x, y;
		WorldToScreen(pos, x, y);
		PTBitmap bitmap = GameData->Bitmap("shadow");

		Display->PutDim(x - (bitmap->width / 2),
						y - (bitmap->height / 2), bitmap, DM_ALPHA, 5);
	}
}

// Gets the current motion for the given state,frame or returns FALSE if invalid
// state,frame or no motion available.
BOOL T3DImagery::GetMotion(int state, int frame, int &dist, int &ang, int &face)
{
	if ((DWORD)state >= (DWORD)GetHeader()->numstates ||
		(DWORD)frame >= (DWORD)GetHeader()->states[state].frames ||
		!motion[state])
	{
		dist = 0;
		ang = 0;
		face = 0;
		return FALSE;
	}

	RSMotionData md = motion[state][frame]; 

	if (flags & I3D_FACINGMOTION)
	{
		dist = md_dist(md);
		ang = md_ang(md);
		face = md_face(md);
	}
	else
	{
		dist = md_old_dist(md);
		ang = md_old_ang(md);
		face = 0;
	}

	return TRUE;
}

// Sets the motion for an object based on its state, frame, and 3D motion data
void T3DImagery::SetObjectMotion(PTObjectInstance inst)
{
	int state = inst->GetState();
	int frame = inst->GetFrame();
	int oldstate = inst->GetPrevState();
	int oldframe = inst->GetPrevFrame();

	if (MeshInitialized() && 
		!(GetAniFlags(state) & AF_NOMOTION) && 
		(frame != oldframe || state != oldstate))
	{
		if ((state != oldstate) && (GetAniFlags(state) & AF_ROOT))
			inst->ClearAccum();	// Clear accumulator if we went to the root state

		int dist, ang, face;
		BOOL motion = GetMotion(state, frame, dist, ang, face);
		if (GetAniFlags(state) & AF_LINEARMOTION)
			ang = 0;
		if (motion)
		{
			ang = (ang + inst->GetMoveAngle()) & 255;
			face = (face + inst->GetFace()) & 255;
			S3DPoint movement;
			ConvertToVector(ang, dist, movement);
			inst->SetNextMove(movement);
			inst->FaceOnly(face); // Use FaceOnly, and not Face, so movement dir won't be changed
		}
	}
	else
		inst->Halt();
}

// ****************** NORMAL IMAGERY STUFF **********************

// Returns the inventory image for the item
PTBitmap T3DImagery::GetInvImage(int state, int num)
{
	if (!icons)
		return NULL;
	else
		return icons[state].invitem;
}

// Get inventory animation for state
PTAnimation T3DImagery::GetInvAnimation(int state)
{
	if (!icons)
		return NULL;
	else
		return icons[state].invanim;
}

PTObjectAnimator T3DImagery::NewObjectAnimator(PTObjectInstance oi)
{
  // If mesh not initialized, attempt to initialize it now
	if (!meshinitialized)
		if (!InitializeMesh((PS3DImageryBody)GetBody()))
			FatalError("Unable to initialize 3D imagery for %s", oi->GetName());

  // Create the animator
	char *name = oi->GetTypeName();
	PT3DAnimatorBuilder builder = T3DAnimatorBuilder::GetBuilder(name);

	if (builder == &T3DAnimatorBuilderInstance)
	{
		name = oi->GetClassName();
		builder = T3DAnimatorBuilder::GetBuilder(name);
	}

	return (PTObjectAnimator)builder->Build(oi);
}

// Returns whether or not an animator is necessary
BOOL T3DImagery::NeedsAnimator(PTObjectInstance)
{
	return TRUE;  // 3D imagery always needs an animator
}

void T3DAnimator::RecordNewExtents(PTObjectInstance oi, int state)
{
	if (state < 0)
	{
		for (int i = 0; i < oi->NumStates(); i++)
		{
			PSImageryStateHeader st = image->GetState(i);
			st->regx = st->regy = 0;
			st->width = st->height = 0;
		}

		flags |= ANI3D_UPDATEALLSTATES;
		state = 0;
	}
	else
	{
		PSImageryStateHeader st = image->GetState(state);
		st->regx = st->regy = 0;
		st->width = st->height = 0;
	}

	oi->Face(0);
	oi->SetState(state);
	flags |= ANI3D_UPDATEBOUNDRECT;

	NoFrameSkip = TRUE;
	DisableTimer = TRUE;
	UpdatingBoundingRect = TRUE;

	// from here on out the Animate() function will handle the updates
}

// *******************************
// * T3DAnimatorBuilder Funtions *
// *******************************

int T3DAnimatorBuilder::numanimtypes = 0;
PT3DAnimatorBuilder T3DAnimatorBuilder::builders[MAX3DANIMATORTYPES];

T3DAnimatorBuilder::T3DAnimatorBuilder(char *name)
{
	if (numanimtypes < MAX3DANIMATORTYPES)
		builders[numanimtypes++] = this;

	animatorname = _strdup(name);
}

T3DAnimatorBuilder::T3DAnimatorBuilder()
{
	if (numanimtypes < MAX3DANIMATORTYPES)
		builders[numanimtypes++] = this;

	animatorname = "default";
}

PT3DAnimator T3DAnimatorBuilder::Build(PTObjectInstance oi)
{
	return new T3DAnimator(oi);
}

PT3DAnimatorBuilder T3DAnimatorBuilder::GetBuilder(char *name)
{
	for (int i = 0; i < numanimtypes; i++)
		if (stricmp(name, builders[i]->animatorname) == 0)
			return builders[i];

	return &T3DAnimatorBuilderInstance;  // Return default builder (for T3DAnimator object)
}

// ************************
// * T3DAnimator Funtions *
// ************************

T3DAnimator::~T3DAnimator()
{
	Close();
}

// Initializes animator and calls the SetupObjects() function to setup
void T3DAnimator::Initialize()
{
	TObjectAnimator::Initialize();

	pos.x = D3DVAL(100000.0);
	pos.y = D3DVAL(100000.0);
	pos.z = D3DVAL(100000.0);
	rot.x = D3DVAL(0.0);
	rot.y = D3DVAL(0.0);
	rot.z = D3DVAL(0.0);
	changed = TRUE;
//	memset(&worldextents, 0, sizeof(S3DRect));
//	bpsaved = FALSE;

	flags = ANI3D_ADDUPDATERECT | ANI3D_CACHEEXECUTEBUFFER;

	inst->SetFlags(OF_MOVING);			// don't bother refreshing background

	SetupObjects();

	animid = Scene3D.AddAnimator(this);
}

// Deletes all objects, etc.
void T3DAnimator::Close()
{
	Scene3D.RemoveAnimator(animid);

	for (int c = 0; c < animobjs.NumItems(); c++)
	{
		RemoveObject(c);
	}

	animobjs.DeleteAll();

	TObjectAnimator::Close();
}

void T3DAnimator::AnimateResetBoundRect()
{
	inst->Face(inst->GetFace() + 0x20);
	if (inst->GetFace() < 1 || inst->GetFace() >= 0x100)
	{
		if (flags & ANI3D_UPDATEALLSTATES)
		{
			inst->Face(0);

			if (!inst->SetState(state + 1))
			{
				flags &= ~ANI3D_UPDATEALLSTATES;
				flags &= ~ANI3D_UPDATEBOUNDRECT;
				image->SetHeaderDirty(TRUE);
				UpdatingBoundingRect = FALSE;
			}
		}
		else
		{
			flags &= ~ANI3D_UPDATEBOUNDRECT;
			UpdatingBoundingRect = FALSE;
		}

		image->SetHeaderDirty(TRUE);
	}

	inst->SetCommandDone(FALSE);
	ResetState();
}

void T3DAnimator::Animate(BOOL draw)
{
	int oldframe = frame;
	int oldstate = state;
//	bpsaved = FALSE;

	TObjectAnimator::Animate(draw);

	S3DPoint p;
	inst->GetPos(p);

	changed = FALSE;
	if (pos.x != D3DVAL(p.x) || pos.y != D3DVAL(p.y) || pos.z != D3DVAL(p.z))
	{
		pos.x = D3DVAL(p.x);
		pos.y = D3DVAL(p.y);
        pos.z = FIX_Z_VALUE(p.z);
		changed = TRUE;
	}

	D3DVALUE newrotz = D3DVAL(inst->GetFace()) / D3DVAL(256.0) * D3DVAL(M_2PI);
	if (abs(rot.z - newrotz) > 0.0001)
	{
		rot.z = newrotz;
		changed = TRUE;
	}

	// Set object motion
	Get3DImagery()->SetObjectMotion(inst);

	// if recording extents, continue spinning 'em around
	if (flags & ANI3D_UPDATEBOUNDRECT && inst->CommandDone())
		AnimateResetBoundRect();

  // Now try to play a sound
	((PT3DImagery)image)->PlaySound(state, frame);
}

// Returns TRUE if any surfaces are lost for this animator
BOOL T3DAnimator::SurfacesLost()
{
	return ((PT3DImagery)image)->SurfacesLost();
}

// If SurfacesLost() reports TRUE, is called to cause the surfaces to be reloaded.
void T3DAnimator::RestoreSurfaces()
{
	((PT3DImagery)image)->RestoreSurfaces();
}

// Called to set up lighting, model, etc. for this object before virtual Render called
void T3DAnimator::PreRender()
{
    /*
     * Execute the instruction buffer
     */
	S3DPoint curpos;
	inst->GetPos(curpos);
	Scene3D.LightAffectObject(curpos.x, curpos.y, curpos.z + LIGHTINGCHARHEIGHT); // Add 50 to get middle of guy

	if (changed)
	{
		D3DMATRIX m2;

		D3DMATRIXClear(&matrix);
		D3DMATRIXRotateZ(&matrix, rot.z);	// Yaw rotation
		D3DMATRIXClear(&m2);
		D3DMATRIXRotateX(&m2, rot.x);		// Pitch rotation
		MultiplyD3DMATRIX(&matrix, &matrix, &m2);
		D3DMATRIXClear(&m2);
		D3DMATRIXRotateY(&m2, rot.y);		// Roll rotation
		MultiplyD3DMATRIX(&matrix, &matrix, &m2);
		D3DMATRIXClear(&m2);
		D3DMATRIXTranslate(&m2, &pos);		// Translate
		MultiplyD3DMATRIX(&matrix, &matrix, &m2);
	}

  // Sets the state info for next render (so interpolation will work)
	((PT3DImagery)image)->SetPrevState(prevstate);

  // Begins rendering
	((PT3DImagery)image)->BeginRender((flags & ANI3D_CACHEEXECUTEBUFFER) != 0, FALSE);

  // Resets the render extents rectangle so user can get size of object he just drew.
	ResetExtents();
}

// Causes the 3D imagery to be rendered to the screen.  Called between Pre and Post Render
BOOL T3DAnimator::Render()
{
	PS3DAnimObj objstack[MAXOBJECTS];  // Use this stack instead of a recursive function
	int stackpos;

  // Reset parents for this state (NOTE: assumes object order is same as 3DImage object order)
	for (int c = 0; c < animobjs.NumItems(); c++)
	{
		if (!(animobjs[c]->flags & OBJ3D_PARENT))  // Don't reset if parent is being overrided
		{
			int parent = ((PT3DImagery)image)->GetObjectParent(animobjs[c]->objnum, state);
			if ((DWORD)parent < (DWORD)animobjs.NumItems() && animobjs[parent]->objnum == parent)
				animobjs[c]->parent = animobjs[parent];
			else
				animobjs[c]->parent = NULL;
		}
	}

  // Render mesh by textures..
	for (int t = 0; t < Get3DImagery()->NumTextures() + 1; t++)
	{
	  for (int c = 0; c < animobjs.NumItems(); c++)
		animobjs[c]->flags &= ~OBJ3D_RENDERED;

    // Render objects by parent..
	  for (c = 0; c < animobjs.NumItems(); c++)  // Go through all objects
	  {
		if (!animobjs[c] || (animobjs[c]->flags & OBJ3D_RENDERED))
			continue;  // Already drawn this

		objstack[0] = animobjs[c];  // Current object is always the bottom of stack
		stackpos = 1;

	   // Get the objects furthest undrawn parent
	    PS3DAnimObj parent = animobjs[c]->parent;
		while (parent && !(parent->flags & OBJ3D_RENDERED) && stackpos < MAXOBJECTS)
		{
			objstack[stackpos++] = parent;
			parent = parent->parent;
		}

      // Draw from the undrawn parent down to the current object  
		while (stackpos)
		{
			stackpos--;
			PS3DAnimObj obj = objstack[stackpos];
			Get3DImagery()->RenderObject(obj, state, frame, &matrix, t, t > 0);
			obj->flags |= OBJ3D_RENDERED;
		}

	  }
	}

	return TRUE;
}

// Called to restore lighting state, etc. etc.
void T3DAnimator::PostRender()
{
  // End rendering (save cached buffer if flags are set for it)
	((PT3DImagery)image)->EndRender();

  // Update extents (if they haven't been updated yet)
  // NOTE: Extents need to be updated AFTER EndRender() is called so we don't reset the
  // execute buffer while it is being recorded.  If UpdateExtents is called during the
  // render, it will cause the current execute buffer to be rendered (flushed), and a fresh
  // empty one to be created, which is ok if we're just drawing stuff, but bad if we're
  // trying to build a cachable buffer.
	if (!WasUpdated())
		UpdateExtents();

  // Reset lights	
	Scene3D.ResetAllLights();
}

// *****************************
// * Animator Object Functions *
// *****************************

// Sets up the objects to animate (simply uses whatever objects are in the imagery)
// Override this function to set up whatever objects you need for your effect, etc.
void T3DAnimator::SetupObjects()
{
	for (int c = 0; c < Get3DImagery()->NumObjects(); c++)
	{
		PS3DAnimObj o = NewObject(c);
//		GetVerts(o, D3DVT_LVERTEX);
		AddObject(o);
	}

  // Initialize mesh hierarchy
	for (c = 0; c < animobjs.NumItems(); c++)
	{
		int parent = ((PT3DImagery)image)->GetObjectParent(animobjs[c]->objnum, 0);
		if ((DWORD)parent < (DWORD)animobjs.NumItems() && animobjs[parent]->objnum == parent)
			animobjs[c]->parent = animobjs[parent];
		else
			animobjs[c]->parent = NULL;
	}
}

// Creates a 3DAnimObj structure to be used with the T3DImagery RenderObject() function
// and initializes
PS3DAnimObj T3DAnimator::NewObject(int objnum, int flags)
{
	PS3DAnimObj obj = new S3DAnimObj;
	memset(obj, 0, sizeof(S3DAnimObj));
	obj->objnum = objnum;
	obj->parent = NULL;

	S3DObj o;
	Get3DImagery()->GetObject(objnum, &o);

	obj->animtrack = min(objnum, Get3DImagery()->NumObjects() - 1);
	obj->primtype = D3DPT_TRIANGLELIST;
	obj->verttype = D3DVT_VERTEX;
	obj->hmaterial = Get3DImagery()->GetMaterialHandle(o.material);
	for (int c = 0; c < MAXTEXTURES; c++)
		obj->htextures[c] = Get3DImagery()->GetTextureHandle(c);

	if (flags & OBJ3D_COPYVERTS)
		GetVerts(obj, obj->verttype);
		
	if (flags & OBJ3D_COPYFACES)
		GetFaces(obj);

	return obj;
}

void T3DAnimator::GetVerts(PS3DAnimObj obj, D3DVERTEXTYPE verttype)
{
	obj->flags |= (OBJ3D_VERTS | OBJ3D_COPYVERTS | OBJ3D_OWNSVERTS);
	obj->verttype = verttype;

	obj->numverts = Get3DImagery()->NumObjVerts(obj->objnum);
	if (obj->verttype == D3DVT_VERTEX)
		obj->verts = new D3DVERTEX[obj->numverts];
	else if (obj->verttype == D3DVT_LVERTEX)
		obj->lverts = new D3DLVERTEX[obj->numverts];
	else if (obj->verttype == D3DVT_TLVERTEX)
		obj->tlverts = new D3DTLVERTEX[obj->numverts];
	Get3DImagery()->GetObjVerts(obj->objnum, obj->verts, 0, 0, obj->verttype);
}

void T3DAnimator::GetFaces(PS3DAnimObj obj)
{
	obj->flags |= (OBJ3D_FACES | OBJ3D_COPYFACES | OBJ3D_OWNSFACES);

	obj->numfaces = Get3DImagery()->NumObjFaces(obj->objnum);
	obj->faces = new S3DFace[obj->numfaces];
	Get3DImagery()->GetObjFaces(obj->objnum, obj->faces);
}

// Adds a S3DAnimObj to this animators internal object array
// Note that the array owns the objects data, and will attempt to delete it
int T3DAnimator::AddObject(PS3DAnimObj obj)
{
	return animobjs.Add(obj);
}

void T3DAnimator::RemoveObject(int objnum)
{
	if (objnum < 0 || objnum >= MAX3DANIMOBJECTS || animobjs[objnum] == NULL)
		return;

	if ((animobjs[objnum]->flags & OBJ3D_OWNSVERTS) && animobjs[objnum]->verts)
		delete animobjs[objnum]->verts;

	if ((animobjs[objnum]->flags & OBJ3D_OWNSFACES) && animobjs[objnum]->faces)
		delete animobjs[objnum]->faces;

	animobjs.Delete(objnum);
}

// Returns object number for first object based on the imagery object with given name
// For default SetupObjects(), the animator and imagery obj num will be the same.
int T3DAnimator::GetObjectNum(char *name)
{
	for (int c = 0; c < animobjs.NumItems(); c++)
	{
		if (animobjs[c] &&
		  !stricmp(Get3DImagery()->GetObjectName(animobjs[c]->objnum), name))
			return c;
	}
	return -1;
}

// Returns object override data
PS3DAnimObj T3DAnimator::GetObject(int objnum)
{
	if (objnum < 0 || objnum >= MAX3DANIMOBJECTS || animobjs[objnum] == NULL)
		return NULL;

	return animobjs[objnum];
}

// Returns true if object is enabled
BOOL T3DAnimator::IsObjectEnabled(int objnum)
{
	if (objnum < 0 || objnum >= MAX3DANIMOBJECTS || animobjs[objnum] == NULL)
		return FALSE;

	return !(animobjs[objnum]->flags & OBJ3D_HIDE);
}


// Enables or disables object
void T3DAnimator::EnableObject(int objnum, BOOL enable)
{
	if (objnum < 0 || objnum >= MAX3DANIMOBJECTS || animobjs[objnum] == NULL)
		return;

	if (enable)
		animobjs[objnum]->flags &= ~OBJ3D_HIDE;
	else
		animobjs[objnum]->flags |= OBJ3D_HIDE;
}

// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                   3dScene.cpp - 3D Scene module                       *
// *************************************************************************

#include <windows.h>
#include <ddraw.h>
#include <d3drmwin.h>
#include <math.h>

#include "d3dmacs.h"
#include "3dimage.h"
#include "3dscene.h"
#include "d3dmath.h"

#include "revenant.h"
#include "directdraw.h"
#include "display.h"
#include "mainwnd.h"
#include "resource.h"
#include "mappane.h"

// 3D Render State Flags
BOOL FlatShade = FALSE;
BOOL SimpleLight = FALSE;
BOOL UseTextures = TRUE;
BOOL DitherEnable = TRUE;
BOOL BlendEnable = TRUE;
BOOL SpecularEnable = TRUE;
BOOL ZEnable = TRUE; 
BOOL BilinearFilter = FALSE;
BOOL NoUpdateRects = FALSE;
BOOL MaxLights = 1;
BOOL Double3D, Triple3D;		// Doubles or tripples 3D objects

// quick hacks
// rotate x coords
float RotateX(float h, float k, float x, float y, float angle)
{ return (float)(h + (x - h) * cos(angle) - (y - k) * sin(angle)); }
// rotate y coords
float RotateY(float h, float k, float x, float y, float angle)
{ return (float)(k + (y - k) * cos(angle) + (x - h) * sin(angle)); }
// add z rotation here

// DLS brightness routine (gives brightness given distance)
extern double GetLightBrightness(int dist, int intensity, int multiplier);

// ************************************************************
// * T3DLight - Information for an light in a 3D scene object *
// ************************************************************

_CLASSDEF(T3DLight)
class T3DLight
{
  public:
	LPDIRECT3DLIGHT light;
	D3DLIGHT lightdata;
	BOOL lighton;
	int intensity;
	int multiplier;

	T3DLight(D3DLIGHT &newlight, int newintensity, int newmultiplier);
	~T3DLight();

	BOOL Initialize();
	BOOL Close();

	void SetIntensity(int intensity);
	void SetMultiplier(int multiplier);
	void SetColor(D3DVALUE red, D3DVALUE green, D3DVALUE blue);
	void SetPosition(D3DVALUE x, D3DVALUE y, D3DVALUE z);
	D3DVALUE DistanceToObject(D3DVALUE x, D3DVALUE y, D3DVALUE z);
	BOOL AffectObject(D3DVALUE x, D3DVALUE y, D3DVALUE z);
	BOOL LightOff();
};

// ***************************************
// * T3DScene - 3DScene global variables *
// ***************************************

static SColor Ambient;						// Ambient Light Value
static S3DPoint CameraPos;					// Camera source pos

static int scenex, sceney, scenewidth, sceneheight; // Scene screen position

static int dirlight;

#define MAX3DANIMATORS 128
typedef TPointerArray<T3DAnimator, MAX3DANIMATORS> T3DAnimatorArray;
static T3DAnimatorArray AnimatorArray;

#define MAX3DLIGHTS 64
typedef TPointerArray<T3DLight, MAX3DLIGHTS> T3DLightArray;
static T3DLightArray LightArray;

static D3DMATRIX proj = {
    D3DVAL(1.0/65536.0), D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(1.0/65536.0), D3DVAL(0.0), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(0.0), D3DVAL(1.0/65536.0/ZSCALE), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0), D3DVAL(1.0)
};

static D3DMATRIX view = {
    D3DVAL(1.0), D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(1.0), D3DVAL(0.0), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(0.0), D3DVAL(1.0), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(0.0), D3DVAL(200.0), D3DVAL(1.0)
};

static D3DMATRIX world;

D3DMATRIX identity = {
    D3DVAL(1.0), D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(1.0), D3DVAL(0.0), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(0.0), D3DVAL(1.0), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0), D3DVAL(1.0)
};

D3DMATRIXHANDLE hProj, hView, hWorld;

static LPDIRECT3DLIGHT lpD3DLight;
static D3DEXECUTEDATA d3dExData;
static D3DEXECUTEBUFFERDESC debDesc;
static LPDIRECT3DMATERIAL lpBmat;
static int AmbientValue;
static SColor AmbientColor256;
static D3DCOLOR AmbientColor;

// Variables used by texture format info thingy
#define MAXTEXFORMATS 64
static int numtexformats;
static DDSURFACEDESC texformats[MAXTEXFORMATS];

// **********************
// * T3DLight Functions *
// **********************

T3DLight::T3DLight(D3DLIGHT &newlight, int newintensity, int newmultiplier)
{
	memcpy(&lightdata, &newlight, sizeof(D3DLIGHT));
	intensity = newintensity;
	multiplier = newmultiplier;
	
	Initialize();
}

T3DLight::~T3DLight()
{
	Close();
}

BOOL T3DLight::Initialize()
{
    TRY_D3D(Direct3D->CreateLight(&light, NULL));
    TRY_D3D(light->SetLight(&lightdata));
	lighton = FALSE;

	D3DVALUE lm = (D3DVALUE)1.0 / max(lightdata.dcvColor.r, 
		max(lightdata.dcvColor.g, lightdata.dcvColor.b));
	lightdata.dcvColor.r = lightdata.dcvColor.r * lm;
	lightdata.dcvColor.g = lightdata.dcvColor.g * lm;
	lightdata.dcvColor.b = lightdata.dcvColor.b * lm;

	return TRUE;
}

BOOL T3DLight::Close()
{
	LightOff();
	RELEASE(light);

	return TRUE;
}		

void T3DLight::SetIntensity(int newintensity)
{
	intensity = newintensity;
}

void T3DLight::SetMultiplier(int newmultiplier)
{
	multiplier = newmultiplier;
}

void T3DLight::SetColor(D3DVALUE red, D3DVALUE green, D3DVALUE blue)
{
    lightdata.dcvColor.r = red;
    lightdata.dcvColor.g = green;
    lightdata.dcvColor.b = blue;
    lightdata.dcvColor.a = D3DVAL(1.0);

	D3DVALUE lm = (D3DVALUE)1.0 / max(lightdata.dcvColor.r, 
		max(lightdata.dcvColor.g, lightdata.dcvColor.b));
	lightdata.dcvColor.r = lightdata.dcvColor.r * lm;
	lightdata.dcvColor.g = lightdata.dcvColor.g * lm;
	lightdata.dcvColor.b = lightdata.dcvColor.b * lm;

    light->SetLight(&lightdata);
}

void T3DLight::SetPosition(D3DVALUE x, D3DVALUE y, D3DVALUE z)
{
	lightdata.dvPosition.x = x;
	lightdata.dvPosition.y = y;
	lightdata.dvPosition.z = z;

    light->SetLight(&lightdata);
}

D3DVALUE T3DLight::DistanceToObject(D3DVALUE x, D3DVALUE y, D3DVALUE z)
{
	x -= lightdata.dvPosition.x;
	y -= lightdata.dvPosition.y;
	z -= lightdata.dvPosition.z;

	D3DVALUE d = (float)sqrt((double)(x * x + y * y));
	return (float)sqrt((double)(d * d + z * z));
}

BOOL T3DLight::AffectObject(D3DVALUE x, D3DVALUE y, D3DVALUE z)
{
	x -= lightdata.dvPosition.x;
	y -= lightdata.dvPosition.y;
	z -= lightdata.dvPosition.z;

	D3DVALUE d = (float)sqrt((double)(x * x + y * y));
	d = (float)sqrt((double)(d * d + z * z));

	D3DVALUE r, g, b;
	if (d < intensity)
	{
		D3DVALUE i = min((D3DVALUE)GetLightBrightness((int)d, intensity, multiplier), (D3DVALUE)1.0);

		r = lightdata.dcvColor.r;
		lightdata.dcvColor.r = lightdata.dcvColor.r * i;
		g = lightdata.dcvColor.g;
		lightdata.dcvColor.g = lightdata.dcvColor.g * i;
		b = lightdata.dcvColor.b;
		lightdata.dcvColor.b = lightdata.dcvColor.b * i;
	    lightdata.dcvColor.a = D3DVAL(1.0);

		light->SetLight(&lightdata);

		lightdata.dcvColor.r = r;
		lightdata.dcvColor.g = g;
		lightdata.dcvColor.b = b;
		
		if (!lighton)
		{
			TRY_D3D(Viewport->AddLight(light));
			lighton = TRUE;
		}
		
		return TRUE;
	}
	return FALSE;
}

BOOL T3DLight::LightOff()
{
	if (!lighton)
		return TRUE;

	TRY_D3D(Viewport->DeleteLight(light));
	
	lighton = FALSE;

	return TRUE;
}

// *********************************
// * 3DScene - Main 3D interface!! *
// *********************************

// Constructor. Marks all frames and light free
T3DScene::T3DScene()
{
	initialized = FALSE;
}

T3DScene::~T3DScene()
{
	Close();
}

// Initialize 3D scene
BOOL T3DScene::Initialize()
{
	if (initialized || Ignore3D)
		return TRUE;

	initialized = TRUE;

	// 3D units per pixel is equal to the total screen pixels for the hypotenuse of a tile
    // from the left screen corner to the right screen corner (512.0) divided by the actual
	// 3D width of the hypotenuse in 3D units.
	float unitsperpixel = (float)512.0 / (float)sqrt(256.0 * 256.0 + 256.0 * 256.0);

	// Create the scene (parent) frame
	if (UseDirect3D2)
	{
	    TRY_D3D(Direct3D2->CreateViewport(&Viewport2, NULL));
		TRY_D3D(Viewport2->QueryInterface(IID_IDirect3DViewport, (LPVOID *)&Viewport));
		TRY_D3D(Device2->AddViewport(Viewport2));
		TRY_D3D(Device2->SetCurrentViewport(Viewport2));
	}
	else
	{
	    TRY_D3D(Direct3D->CreateViewport(&Viewport, NULL));
		TRY_D3D(Device->AddViewport(Viewport));
	}

	SetSize(0, 0, Display->Width(), Display->Height());

	TExecuteBuf::Initialize();  // Initializes execute buffer stuff

	CreateMatrixList();			// Creates the buffer system matrix list

	D3DMATERIAL bmat;
    memset(&bmat, 0, sizeof(D3DMATERIAL));
    bmat.dwSize = sizeof(D3DMATERIAL);
    bmat.diffuse.r = (D3DVALUE)0.0;
    bmat.diffuse.g = (D3DVALUE)0.0;
    bmat.diffuse.b = (D3DVALUE)0.0;
    bmat.ambient.r = (D3DVALUE)0.0;
    bmat.ambient.g = (D3DVALUE)0.0;
    bmat.ambient.b = (D3DVALUE)0.0;
    bmat.hTexture = NULL;
    bmat.dwRampSize = 1;

	D3DMATERIALHANDLE hBmat;
    TRY_D3D(Direct3D->CreateMaterial(&lpBmat, NULL));
    TRY_D3D(lpBmat->SetMaterial(&bmat));
    TRY_D3D(lpBmat->GetHandle(Device, &hBmat));
    TRY_D3D(Viewport->SetBackground(hBmat));

	if (Display->UsingClearZBuffer())
	{
		TRY_D3D(Viewport->SetBackgroundDepth(Display->GetZBuffer()->GetDDSurface()));
	}

    /*
     * Setup view, projection, world, and pos matrices
     */
	InitializeMatrices();

    /*
     * Setup ambient directional light
     */
    D3DLIGHT lightdata;
    memset(&lightdata, 0, sizeof(D3DLIGHT));
    lightdata.dwSize = sizeof(D3DLIGHT);
    lightdata.dltType = D3DLIGHT_DIRECTIONAL;
    lightdata.dcvColor.r = D3DVAL(1.0);
    lightdata.dcvColor.g = D3DVAL(1.0);
    lightdata.dcvColor.b = D3DVAL(1.0);
    lightdata.dcvColor.a = D3DVAL(1.0);
	lightdata.dvPosition.x = D3DVAL(0.0);
	lightdata.dvPosition.y = D3DVAL(0.0);
	lightdata.dvPosition.z = D3DVAL(200.0);
	lightdata.dvDirection.x = D3DVAL(1.0);
	lightdata.dvDirection.y = D3DVAL(-1.0);
	lightdata.dvDirection.z = D3DVAL(-1.0);

//	dirlight = LightArray.Add(new T3DLight(lightdata));

	/*
	 * Get the texture formats
	 */

	GetTextureFormats();

	return TRUE;
}

BOOL T3DScene::SetSize(int x, int y, int width, int height)
{
	if (!initialized || Ignore3D)
		return TRUE;

    scenex      = x;
	sceney      = y;
	scenewidth  = width;
	sceneheight = height;

	// 3D units per pixel is equal to the total screen pixels for the hypotenuse of a tile
    // from the left screen corner to the right screen corner (512.0) divided by the actual
	// 3D width of the hypotenuse in 3D units.
	float unitsperpixel = (float)512.0 / (float)sqrt(256.0 * 256.0 + 256.0 * 256.0);

    D3DVIEWPORT viewData;
    memset(&viewData, 0, sizeof(D3DVIEWPORT));
    viewData.dwSize = sizeof(D3DVIEWPORT);
    viewData.dwX = x;
	viewData.dwY = y;
    viewData.dwWidth = width;
    viewData.dwHeight = height;
    viewData.dvScaleX = D3DVAL(65536.0 * unitsperpixel);
    viewData.dvScaleY = D3DVAL(65536.0 * unitsperpixel);
    viewData.dvMaxX = D3DVAL(1.0);
    viewData.dvMaxY = D3DVAL(1.0);

    TRY_D3D(Viewport->SetViewport(&viewData));

	return TRUE;
}

BOOL T3DScene::InitializeMatrices()
{
    /*
     * Set the view, world and projection matrices
     * Create a buffer for matrix set commands etc.
     */
    MAKE_MATRIX(Device, hView, identity);
    MAKE_MATRIX(Device, hProj, proj);
    MAKE_MATRIX(Device, hWorld, identity);

	TExecuteBuf exbuf;

	exbuf.BeginRecord();
	exbuf.SetTransform(D3DTRANSFORMSTATE_VIEW, hView);
	exbuf.SetTransform(D3DTRANSFORMSTATE_PROJECTION, hProj);
	exbuf.SetTransform(D3DTRANSFORMSTATE_WORLD, hWorld);
	exbuf.SetLightState(D3DLIGHTSTATE_AMBIENT, RGBA_MAKE(64, 64, 64, 64));
	exbuf.EndRecord();
	BeginScene();
	exbuf.Render();
	EndScene();

	return TRUE;
}

BOOL T3DScene::Close()
{
	if (!initialized)
		return FALSE;

  // Release execute buffer buffers and matrices
	TExecuteBuf::Close();

	AnimatorArray.Clear();
	LightArray.DeleteAll();

    RELEASE(lpBmat);

	TRY_D3D(Device->DeleteViewport(Viewport));
	RELEASE(Viewport);
	Viewport = NULL;
	Viewport2 = NULL;

	initialized = FALSE;

	return TRUE;
}

// Clears a rectangle in the screen zbuffer... uses either DrawRestoreRect, or
// Viewport->Clear() depending on whether the display has a secondary background zbuffer
// set for it or not.  
void T3DScene::RestoreZBuffer(SRect &r)
{
	if (NoScrollZBuffer)
		MapPane.DrawRestoreRect(r.x(), r.y(), r.w(), r.h(),
			DM_WRAPCLIPSRC | DM_NORESTORE | DM_ZBUFFER | DM_NODRAW);
	if (Display->UsingClearZBuffer())
	{
		SRect sr, pr;
		sr = r;
		MapPane.PaneToScreen(sr);
		MapPane.GetRect(pr);
		if (!ClipRect(sr, pr, sr))
			return;
		Display->GetRealZBuffer()->Blit(sr.x(), sr.y(), 
			Display->GetZBuffer(), sr.x(), sr.y(), sr.w(), sr.h());
	}
}

void T3DScene::SetCameraPos(RS3DPoint pos, int zdist)
{
	if (!initialized)
		return;

	CameraPos = pos;

	D3DVECTOR v1;//, v2;

	
	D3DMATRIX view;
	D3DMATRIXClear(&view);

	v1.x = D3DVAL(CameraPos.x);
	v1.y = D3DVAL(CameraPos.y);
	v1.z = D3DVAL(CameraPos.z);
	D3DMATRIXMove(&view, &v1); 

	D3DMATRIXRotateZ(&view, D3DVAL(45.0 * TORADIAN));
	D3DMATRIXRotateX(&view, D3DVAL(-(90.0 + CAMERAANGLE) * TORADIAN));

	v1.x = D3DVAL(0.0);
	v1.y = D3DVAL(0.0);
	v1.z = D3DVAL(-zdist);
	D3DMATRIXMove(&view, &v1); 

    Device->SetMatrix(hView, &view);
}

void T3DScene::RefreshZBuffer()
{
  // Draw ZBuffer behind objects
	for (int c = 0; c < AnimatorArray.NumItems(); c++)
		if (AnimatorArray[c] != NULL)
			AnimatorArray[c]->RefreshZBuffer();
}

BOOL T3DScene::DrawScene()
{
	int c;

	if (!initialized )
		return FALSE;

	if (!Show3D)
		return TRUE;

	static BOOL oldFlatShade, oldDitherEnable, oldBlendEnable, oldSpecularEnable, oldZEnable, oldBilinearFilter;
	static D3DCOLOR oldAmbientColor;
	static BOOL b = FALSE;
	HRESULT DirectDrawReturn;

	if (FlatShade != oldFlatShade ||				// Render state has changed?
	    DitherEnable != oldDitherEnable ||
		BlendEnable != oldBlendEnable ||
		SpecularEnable != oldSpecularEnable ||
		ZEnable != oldZEnable ||
		BilinearFilter != oldBilinearFilter ||
		oldAmbientColor != AmbientColor)
	{
	    oldFlatShade = FlatShade;
	    oldDitherEnable = DitherEnable;
	    oldBlendEnable = BlendEnable;
	    oldSpecularEnable = SpecularEnable;
	    oldZEnable = ZEnable;
	    oldBilinearFilter = BilinearFilter;
	    oldAmbientColor = AmbientColor;

	  // Reset scene params
		BeginScene();
		BeginRender();

		TRY_D3D(SetRenderState(D3DRENDERSTATE_ZENABLE, ZEnable));
		TRY_D3D(SetRenderState(D3DRENDERSTATE_SHADEMODE, (FlatShade ? D3DSHADE_FLAT : D3DSHADE_GOURAUD)));
		TRY_D3D(SetRenderState(D3DRENDERSTATE_DITHERENABLE, DitherEnable));
		TRY_D3D(SetRenderState(D3DRENDERSTATE_BLENDENABLE, BlendEnable));
		TRY_D3D(SetRenderState(D3DRENDERSTATE_SPECULARENABLE, SpecularEnable));
		TRY_D3D(SetRenderState(D3DRENDERSTATE_TEXTUREMAG, (BilinearFilter ? D3DFILTER_LINEAR : D3DFILTER_NEAREST)));
		TRY_D3D(SetRenderState(D3DRENDERSTATE_TEXTUREMIN, (BilinearFilter ? D3DFILTER_LINEAR : D3DFILTER_NEAREST)));

		TRY_D3D(SetLightState(D3DLIGHTSTATE_AMBIENT, AmbientColor));

		EndRender();
		EndScene();
	}

    // Verify both surfaces
	if (!front) 
		return FALSE;

    if (!zbuffer) 
		return FALSE;

    if (b) 
	{
		b = FALSE;
    }

    // Restore the primary surface if it has been lost
    if (front->IsLost())
    {
		DirectDrawReturn = front->Restore();
		
		if (DirectDrawReturn != DD_OK) 
			return FALSE;

        b = TRUE;
    }
    
    // Restore the ZBuffer if it has been lost
    if (zbuffer->IsLost())
    {
        DirectDrawReturn = zbuffer->Restore();

        if (DirectDrawReturn != DD_OK) 
			return FALSE;

        b = TRUE;
    }

  // Draw shaodws
	for (c = 0; c < AnimatorArray.NumItems(); c++)
		if (AnimatorArray[c] != NULL)
			AnimatorArray[c]->DrawShadow();

  // Draw objects
	BeginScene();

	for (c = 0; c < AnimatorArray.NumItems(); c++)
	{
		if (AnimatorArray[c] != NULL)
		{
			PTObjectInstance inst = AnimatorArray[c]->GetObjInst();
			PTObjectImagery imagery = AnimatorArray[c]->GetImagery();

			if (inst->GetFlags() & OF_INVISIBLE ||
			  (DWORD)inst->GetState() >= (DWORD)imagery->GetHeader()->numstates ||
			  (DWORD)inst->GetFrame() >= (DWORD)imagery->GetHeader()->states[inst->GetState()].frames)
				continue;

			TRY_D3D(SetRenderState(D3DRENDERSTATE_BLENDENABLE, BlendEnable));
			TRY_D3D(SetRenderState(D3DRENDERSTATE_TEXTUREMAPBLEND, D3DTBLEND_MODULATE));
			TRY_D3D(SetRenderState(D3DRENDERSTATE_SRCBLEND, D3DBLEND_SRCALPHA));
			TRY_D3D(SetRenderState(D3DRENDERSTATE_DESTBLEND, D3DBLEND_INVSRCALPHA));
			TRY_D3D(SetRenderState(D3DRENDERSTATE_FILLMODE, D3DFILL_SOLID));

			AnimatorArray[c]->PreRender();		// Start rendering
			AnimatorArray[c]->Render();			// Object Render
			AnimatorArray[c]->PostRender();		// End rendering
		}
	}

	EndScene();

	return TRUE;
}

void T3DScene::SetAmbientLight(int ambient)  // What the heck 
{
	if (!initialized)
		return;

	AmbientValue = min((ambient * 6), 255);

	int red = AmbientColor256.red * AmbientValue / 256;
	int green = AmbientColor256.green * AmbientValue / 256;
	int blue = AmbientColor256.blue * AmbientValue / 256;
	
	AmbientColor = RGBA_MAKE(red, green, blue, 255);
}

void T3DScene::SetAmbientColor(SColor &color)
{
	if (!initialized)
		return;

	AmbientColor256 = color;

	int red = AmbientColor256.red * AmbientValue / 256;
	int green = AmbientColor256.green * AmbientValue / 256;
	int blue = AmbientColor256.blue * AmbientValue / 256;
	
	AmbientColor = RGBA_MAKE(red, green, blue, 255);
}

// ************ Light Functions **************

int T3DScene::AddLight(RS3DPoint pos, SColor color, int intensity, int multiplier)
{
	if (!initialized)
		return -1;

    /*
     * Setup lights
     */
    D3DLIGHT lightdata;
    memset(&lightdata, 0, sizeof(D3DLIGHT));
    lightdata.dwSize = sizeof(D3DLIGHT);
    lightdata.dltType = D3DLIGHT_POINT;
    lightdata.dcvColor.r = D3DVAL(color.red) / D3DVAL(256.0);
    lightdata.dcvColor.g = D3DVAL(color.green) / D3DVAL(256.0);
    lightdata.dcvColor.b = D3DVAL(color.blue) / D3DVAL(256.0);
    lightdata.dcvColor.a = D3DVAL(1.0);
	lightdata.dvPosition.x = D3DVAL(pos.x);
	lightdata.dvPosition.y = D3DVAL(pos.y);
	lightdata.dvPosition.z = D3DVAL(pos.z);
	lightdata.dvDirection.x = D3DVAL(0.0);
	lightdata.dvDirection.y = D3DVAL(0.0);
	lightdata.dvDirection.z = D3DVAL(0.0);
	lightdata.dvRange = D3DVAL(1000000.0);
	lightdata.dvFalloff = D3DVAL(0.0);
//	lightdata.dvAttenuation0 = D3DVAL(1.0);
//	lightdata.dvAttenuation1 = D3DVAL(1.0/(D3DVALUE)intensity);
//	lightdata.dvAttenuation2 = D3DVAL(0.0);
	lightdata.dvTheta = D3DVAL(0.0);
	lightdata.dvPhi = D3DVAL(0.0);

	return LightArray.Add(new T3DLight(lightdata, intensity, multiplier));
}

BOOL T3DScene::DeleteLight(int lightid)
{
    if (!initialized || lightid < 0 || lightid >= LightArray.NumItems())
		return FALSE;
		
	LightArray.Delete(lightid);

	return TRUE;
}

BOOL T3DScene::SetLightIntensity(int lightid, int intensity)
{
    if (!initialized || lightid < 0 || 
	  lightid >= LightArray.NumItems() ||
	  LightArray[lightid] == NULL)
		return FALSE;

	LightArray[lightid]->SetIntensity(intensity);

	return TRUE;
}

BOOL T3DScene::SetLightMultiplier(int lightid, int multiplier)
{
    if (!initialized || lightid < 0 || 
	  lightid >= LightArray.NumItems() ||
	  LightArray[lightid] == NULL)
		return FALSE;

	LightArray[lightid]->SetMultiplier(multiplier);

	return TRUE;
}

BOOL T3DScene::SetLightColor(int lightid, SColor color)
{
    if (!initialized || lightid < 0 || 
	  lightid >= LightArray.NumItems() ||
	  LightArray[lightid] == NULL)
		return FALSE;

	// Change light in the frame
	LightArray[lightid]->SetColor(
			D3DVAL(color.red) / D3DVAL(256.0),
			D3DVAL(color.green) / D3DVAL(256.0),
			D3DVAL(color.blue) / D3DVAL(256.0));

	return TRUE;
}

BOOL T3DScene::SetLightPosition(int lightid, RS3DPoint pos)
{
	if (!initialized)
		return FALSE;

    if (!initialized || lightid < 0 || 
	  lightid >= LightArray.NumItems() ||
	  LightArray[lightid] == NULL)
		return FALSE;

	// Change light in the frame
	LightArray[lightid]->SetPosition(
			D3DVAL(pos.x),
			D3DVAL(pos.y),
			D3DVAL(pos.z));

	return TRUE;
}

int T3DScene::GetNumLights()
{
	if (!initialized)
		return 0;

	return LightArray.NumItems();
}

  // The following functions are called by the character system to do lighting

BOOL T3DScene::LightAffectObject(int x, int y, int z)
{
	if (!initialized)
		return FALSE;

	D3DVALUE mindist = (D3DVALUE)10000.0;
	int minlight = -1;
	D3DVALUE mindist2 = (D3DVALUE)10000.0;
	int minlight2 = -1;
	D3DVALUE mindist3 = (D3DVALUE)10000.0;
	int minlight3 = -1;
	for (int c = 0; c < LightArray.NumItems(); c++)
	{
		if (LightArray[c] == NULL)
			continue;

		D3DVALUE dist = LightArray[c]->DistanceToObject((D3DVALUE)x, (D3DVALUE)y, (D3DVALUE)z);
		if (dist < mindist)
		{
			mindist3 = mindist2;
			minlight3 = minlight2;
			mindist2 = mindist;
			minlight2 = minlight;
			mindist = dist;
			minlight = c;
		}
		else if (dist < mindist2)
		{
			mindist3 = mindist2;
			minlight3 = minlight2;
			mindist2 = dist;
			minlight2 = c;
		}
		else if (dist < mindist3)
		{
			mindist3 = dist;
			minlight3 = c;
		}
	}

	if (minlight >= 0)
		if (!LightArray[minlight]->AffectObject((D3DVALUE)x, (D3DVALUE)y, (D3DVALUE)z))
			return FALSE;
	if (MaxLights > 1 && minlight2 >= 0)
		if (!LightArray[minlight2]->AffectObject((D3DVALUE)x, (D3DVALUE)y, (D3DVALUE)z))
			return FALSE;
	if (MaxLights > 2 && minlight3 >= 0)
		if (!LightArray[minlight3]->AffectObject((D3DVALUE)x, (D3DVALUE)y, (D3DVALUE)z))
			return FALSE;

	return FALSE;
}

void T3DScene::ResetAllLights()
{
	if (!initialized)
		return;

	for (int c = 0; c < LightArray.NumItems(); c++)
	{
		if (LightArray[c] != NULL)  // Stop on first light that affects char
			LightArray[c]->LightOff();
	}
}

// ************ Object Functions **************

int T3DScene::AddAnimator(PT3DAnimator animator)
{
	if (!initialized)
		return -1;

	return AnimatorArray.Add(animator);
}
        
BOOL T3DScene::RemoveAnimator(DWORD animid)
{
	if (!initialized || animid >= (DWORD)AnimatorArray.NumItems() || AnimatorArray[animid] == NULL)
		return FALSE;

	AnimatorArray.Remove(animid);	
	
	return TRUE;
}

int T3DScene::GetNumAnimators()
{
	if (!initialized)
		return 0;

	return AnimatorArray.NumItems();
}

// ************************
// * Texture Format Stuff *
// ************************

HRESULT CALLBACK EnumTextureFormatsCallback(LPDDSURFACEDESC lpDDSD, LPVOID lpContext)
{
	PT3DScene scene = (PT3DScene)lpContext;

	if (numtexformats < MAXTEXFORMATS)
	{
		memcpy(&texformats[numtexformats], lpDDSD, sizeof(DDSURFACEDESC));
		numtexformats++;
	}

    return DDENUMRET_OK;
}

void T3DScene::GetTextureFormats()
{
	numtexformats = 0;

    Device->EnumTextureFormats(EnumTextureFormatsCallback, (LPVOID)this);
}

inline int countbits(DWORD d)
{
	int numbits = 0;
	for (int c = 0; c < 32; c++)
	{
		if (d & (1 << c))
			numbits++;
	}
	return numbits;
}	

void T3DScene::GetClosestTextureFormat(LPDDSURFACEDESC srcsd, LPDDSURFACEDESC dstsd)
{
	if (!initialized)
		return;

	LPDDPIXELFORMAT spf = &srcsd->ddpfPixelFormat;

	int redbits, greenbits, bluebits, alphabits; // Yum.. Alphabits is a tasty part of a
												 // balanced breakfast
	if (srcsd->ddpfPixelFormat.dwFlags & DDPF_RGB)
	{	
		redbits = countbits(srcsd->ddpfPixelFormat.dwRBitMask);
		greenbits = countbits(srcsd->ddpfPixelFormat.dwGBitMask);
		bluebits = countbits(srcsd->ddpfPixelFormat.dwBBitMask);
		alphabits = countbits(srcsd->ddpfPixelFormat.dwRGBAlphaBitMask);
	}
	else if (srcsd->ddpfPixelFormat.dwFlags & 
		(DDPF_PALETTEINDEXED8 | DDPF_PALETTEINDEXED4 | DDPF_PALETTEINDEXED2 | DDPF_PALETTEINDEXED1))
	{
		redbits = 5;	// Allows match system to find an RGB format if no matching
		greenbits = 6;	// palettized format can be found
		bluebits = 5;
		alphabits = 0;
	}	

	int diff;
	int closest = 0;
	int closestdiff = 10000;
	LPDDSURFACEDESC sd = texformats;
	for (int c = 0; c < numtexformats; c++, sd++)
	{
		LPDDPIXELFORMAT pf = &sd->ddpfPixelFormat;

	  // If palettized format exactly matches, return immediately
		if ((pf->dwFlags & (DDPF_PALETTEINDEXED8 | DDPF_PALETTEINDEXED4 
		  | DDPF_PALETTEINDEXED2 | DDPF_PALETTEINDEXED1)) != 0 &&
			(pf->dwFlags & (DDPF_PALETTEINDEXED8 | DDPF_PALETTEINDEXED4 
		  | DDPF_PALETTEINDEXED2 | DDPF_PALETTEINDEXED1)) ==
			(spf->dwFlags & (DDPF_PALETTEINDEXED8 | DDPF_PALETTEINDEXED4 
		  | DDPF_PALETTEINDEXED2 | DDPF_PALETTEINDEXED1)) &&
			(pf->dwRGBBitCount == spf->dwRGBBitCount))
		{
			closest = c;
			closestdiff = 0;
			break;
		}

		int dredbits, dgreenbits, dbluebits, dalphabits;
		if (pf->dwFlags & DDPF_PALETTEINDEXED8)
		{
		  // Rank palettized 8 bit above 434 RGB 8 bit, but below everything else
			dredbits = dgreenbits = dbluebits = 4; 
			dalphabits = 0;
		}
		else if (pf->dwFlags & DDPF_PALETTEINDEXED4)
		{
		  // Rank palettized 4 bit above palettized 2 bit
			dredbits = dgreenbits = dbluebits = 2; 
			dalphabits = 0;
		}
		else if (pf->dwFlags & DDPF_PALETTEINDEXED2)
		{
		  // Rank palettized 2 bit above palettized 1 bit
			dredbits = dgreenbits = dbluebits = 1; 
			dalphabits = 0;
		}
		else if (pf->dwFlags & DDPF_PALETTEINDEXED1)
		{
		  // Rank palettized 1 bit below everything else
			dredbits = 1;
			dgreenbits = dbluebits = dalphabits = 0;
		}
		else if (pf->dwFlags & DDPF_RGB)
		{
			dredbits = countbits(pf->dwRBitMask);
			dgreenbits = countbits(pf->dwGBitMask);
			dbluebits = countbits(pf->dwBBitMask);
			dalphabits = countbits(pf->dwRGBAlphaBitMask);
		}
		else
			dredbits = dgreenbits = dbluebits = dalphabits = 10000; // Forget it

		diff = abs(redbits - dredbits) + 
			   abs(greenbits - dgreenbits) +
			   abs(bluebits - dbluebits) +
			   abs(alphabits - dalphabits);

		if (diff < closestdiff)
		{	
			closest = c;
			closestdiff = diff;
		}
	}

	memcpy(dstsd, &texformats[closest], sizeof(DDSURFACEDESC));
}

inline int getmaskshift(DWORD mask)
{
	if (!mask)
		return 0;

	int shift = 0;
	while (!(mask & 1) && shift < 32)
	{
		mask = mask >> 1;
		shift++;
	}
	return shift;
}

inline int getmaskbits(DWORD mask)
{
	if (!mask)
		return 0;

	int bits = 0;
	for (int c = 0; c < 32; c++)
	{
		if (mask & (1 << c))
			bits++;
	}
	return bits;
}

void T3DScene::ConvertTexture(
	LPDDSURFACEDESC srcsd, LPVOID srcpixels, LPPALETTEENTRY srcpal,  
	LPDDSURFACEDESC dstsd, LPVOID dstpixels, LPPALETTEENTRY dstpal)
{
	if (!initialized)
		return;

  // How many colors do our palettes have
	int srcbufsize = (srcsd->ddpfPixelFormat.dwRGBBitCount * srcsd->lPitch * srcsd->dwHeight) >> 3;
	int srcpalcolors = 0;
	if (srcsd->ddpfPixelFormat.dwFlags & (DDPF_PALETTEINDEXED8 | DDPF_PALETTEINDEXEDTO8 |
	  DDPF_PALETTEINDEXED4 | DDPF_PALETTEINDEXED2 | DDPF_PALETTEINDEXED1))
		srcpalcolors = 1 << srcsd->ddpfPixelFormat.dwRGBBitCount;

	int dstbufsize = (dstsd->ddpfPixelFormat.dwRGBBitCount * dstsd->lPitch * dstsd->dwHeight) >> 3;
	int dstpalcolors = 0;
	if (dstsd->ddpfPixelFormat.dwFlags & (DDPF_PALETTEINDEXED8 | DDPF_PALETTEINDEXEDTO8 |
	  DDPF_PALETTEINDEXED4 | DDPF_PALETTEINDEXED2 | DDPF_PALETTEINDEXED1))
		dstpalcolors = 1 << dstsd->ddpfPixelFormat.dwRGBBitCount;
	int dstnumcolors = 0; // How many colors are in dst palette right now

  // Copy surface and return if it is already in the correct format (QUICK)
	if ( srcsd->dwWidth == dstsd->dwWidth && srcsd->dwHeight == dstsd->dwHeight && 
		 srcsd->lPitch == dstsd->lPitch &&
		 !memcmp(&srcsd->ddpfPixelFormat, &dstsd->ddpfPixelFormat, sizeof(DDPIXELFORMAT)) )
	{
		memcpy(dstpixels, srcpixels, dstbufsize);
		memcpy(dstpal, srcpal, sizeof(PALETTEENTRY) * dstpalcolors);
		return;
	}
	
  // Get shifts/etc. for source
	int srcbits = srcsd->ddpfPixelFormat.dwRGBBitCount;
	DWORD srcredshift, srcredmask, srcredbits,
		  srcgreenshift, srcgreenmask, srcgreenbits,
		  srcblueshift, srcbluemask, srcbluebits;
	DWORD srcalphashift, srcalphamask, srcalphabits;
	BOOL srcisrgb = !(srcsd->ddpfPixelFormat.dwFlags & (DDPF_PALETTEINDEXED8 | DDPF_PALETTEINDEXEDTO8 |
	  DDPF_PALETTEINDEXED4 | DDPF_PALETTEINDEXED2 | DDPF_PALETTEINDEXED1));
	BOOL srchasalpha = srcsd->ddpfPixelFormat.dwRGBAlphaBitMask != 0;
	if (srcisrgb)
	{
		srcredmask = srcsd->ddpfPixelFormat.dwRBitMask;
		srcredshift = getmaskshift(srcredmask);
		srcredbits = 8 - getmaskbits(srcredmask);
		srcgreenmask = srcsd->ddpfPixelFormat.dwGBitMask;
		srcgreenshift = getmaskshift(srcgreenmask);
		srcgreenbits = 8 - getmaskbits(srcgreenmask);
		srcbluemask = srcsd->ddpfPixelFormat.dwBBitMask;
		srcblueshift = getmaskshift(srcbluemask);
		srcbluebits = 8 - getmaskbits(srcbluemask);
		if (srchasalpha)
		{
			srcalphamask = srcsd->ddpfPixelFormat.dwRGBAlphaBitMask;
			srcalphashift = getmaskshift(srcalphamask);
			srcalphabits = 8 - getmaskbits(srcalphamask);
		}
		else
			srcalphamask = srcalphashift = srcalphabits = 0;
	}

  // Get shifts/etc. for dest
	int dstbits = dstsd->ddpfPixelFormat.dwRGBBitCount;
	DWORD dstredshift, dstredmask, dstredbits,
		  dstgreenshift, dstgreenmask, dstgreenbits,
		  dstblueshift, dstbluemask, dstbluebits;
	DWORD dstalphashift, dstalphamask, dstalphabits;
	BOOL dstisrgb = !(dstsd->ddpfPixelFormat.dwFlags & (DDPF_PALETTEINDEXED8 | DDPF_PALETTEINDEXEDTO8 |
	  DDPF_PALETTEINDEXED4 | DDPF_PALETTEINDEXED2 | DDPF_PALETTEINDEXED1));
	BOOL dsthasalpha = dstsd->ddpfPixelFormat.dwRGBAlphaBitMask != 0;
	if (dstisrgb)
	{
		dstredmask = dstsd->ddpfPixelFormat.dwRBitMask;
		dstredshift = getmaskshift(dstredmask);
		dstredbits = 8 - getmaskbits(dstredmask);
		dstgreenmask = dstsd->ddpfPixelFormat.dwGBitMask;
		dstgreenshift = getmaskshift(dstgreenmask);
		dstgreenbits = 8 - getmaskbits(dstgreenmask);
		dstbluemask = dstsd->ddpfPixelFormat.dwBBitMask;
		dstblueshift = getmaskshift(dstbluemask);
		dstbluebits = 8 - getmaskbits(dstbluemask);
		if (dsthasalpha)
		{
			dstalphamask = dstsd->ddpfPixelFormat.dwRGBAlphaBitMask;
			dstalphashift = getmaskshift(dstalphamask);
			dstalphabits = 8 - getmaskbits(dstalphamask);
		}
		else
		{
			dstalphamask = dstalphashift = 0;
			dstalphabits = 8; // Don't use alpha!
		}
	}

	BYTE *sline = (BYTE *)srcpixels;
	BYTE *dline = (BYTE *)dstpixels;

	for (int l = 0; l < (long)srcsd->dwHeight; l++,
		 sline += (srcsd->lPitch * srcbits) >> 3,
		 dline += (dstsd->lPitch * dstbits) >> 3)
	{
	  int srcbitpos = 0;
	  int dstbitpos = 0;
	  for (int c = 0; c < (int)srcsd->dwWidth; c++, srcbitpos += srcbits, dstbitpos += dstbits)
	  {
		BYTE *s = sline + (srcbitpos >> 3);	
		BYTE *d = dline + (dstbitpos >> 3);	
		DWORD r, g, b, a;
		int clrindex;

		clrindex = 0;

		if (srcisrgb)  // Do rgba extraction of any 8-32 bit pixel (including alpha/mask data)
		{
			DWORD s32;
			if (srcbits == 32)
			{
				s32 = *(DWORD *)s;
			}
			else if (srcbits == 24)
			{
				s32 = 0;
				*(((BYTE *)&s32) + 0) = *(s + 0);
				*(((BYTE *)&s32) + 1) = *(s + 1);
				*(((BYTE *)&s32) + 2) = *(s + 2);
			}
			else if (srcbits == 16)
			{
				s32 = *(WORD *)s;
			}
			else if (srcbits <= 8)
			{	
				s32 = *s;
			}
			r = ((s32 >> srcredshift) << srcredbits) & 0xFF;
			g = ((s32 >> srcgreenshift) << srcgreenbits) & 0xFF;
			b = ((s32 >> srcblueshift) << srcbluebits) & 0xFF;
			if (srchasalpha)
				a = ((s32 >> srcalphashift) << srcalphabits) & 0xFF;
			else
				a = 255;
		}
		else  // This is a palettized image.. get rgba info if dest is rgba, otherwise get clrindex
		{
			clrindex = *(BYTE *)s; // All indexed formats are less than 8 bits (duh)
			if (srcbits < 8)
				clrindex = clrindex >> (8 - ((srcbitpos & 7) + srcbits));
			if (dstisrgb)
			{
				r = srcpal[clrindex].peRed;
				g = srcpal[clrindex].peGreen;
				b = srcpal[clrindex].peBlue;
			}
			a = 255;
		}

		if (dstisrgb)	// Put rgba data back into dest pixel
		{
			DWORD d32 =
				((r >> dstredbits) << dstredshift) |
				((g >> dstgreenbits) << dstgreenshift) |
				((b >> dstbluebits) << dstblueshift) |
				((a >> dstalphabits) << dstalphashift);
			if (dstbits == 32)
			{
				*(DWORD *)d = d32;
			}
			else if (dstbits == 24)
			{
				*(d + 0) = *(((BYTE *)&d32) + 0);
				*(d + 1) = *(((BYTE *)&d32) + 1);
				*(d + 2) = *(((BYTE *)&d32) + 2);
			}
			else if (dstbits == 16)
			{
				*(WORD *)d = (WORD)d32;
			}
			else if (dstbits == 8)
			{
				*(BYTE *)d = (BYTE)d32;
			}
			else if (dstbits < 8)
			{
				if (!(dstbitpos & 7))
					*(BYTE *)d = (BYTE)d32;
				else 
					*(BYTE *)d |= (BYTE)d32;
			}
		}
		else  // clrindex dest.. put clrindex into bits, build palette if necessary
		{
			if (srcisrgb)  // Build palette	(note: doesn't do 16->8 or 24->8 color remapping!!)
			{
				PALETTEENTRY pe;
				pe.peRed = (BYTE)r;
				pe.peGreen = (BYTE)g;
				pe.peBlue = (BYTE)b;
				pe.peFlags = 0;
				for (clrindex = 0; clrindex < dstnumcolors; clrindex++)
				{
					if (*(DWORD *)&pe == *(DWORD *)&dstpal[clrindex])
						break;
				}
				if (clrindex >= dstnumcolors && clrindex < dstpalcolors)
				{
					dstpal[clrindex] = pe;
					dstnumcolors++;
				}
			}

			if (dstbits < 8)
				clrindex = clrindex << (8 - ((dstbitpos & 7) + dstbits));
			
			if (!(dstbitpos & 7)) 
				*d = (BYTE)clrindex;
			else
				*d |= (BYTE)clrindex;
		}
	  }
	}
}	

// ************************************
// * 3DScene Draw Primitive Functions *
// ************************************

// The functions below are a subset of the D3D Device interface, and are used to 
// map calls to that interface into calls to the execute buffer recorder object
// if UseDrawPrimitive is FALSE.  The theory is that a good D3DEXECUTEBUFFER is
// substantially faster than the DrawPrimitive functions.

// Current execute buffer
static TExecuteBuf InternalExecuteBuf;	// Internal execute buffer used by 3DScene
static PTExecuteBuf ExecuteBuf;			// Pointer to current execute buffer (records only if points to Internal)
static BOOL InRecord, WasRendered;		// Did we render this buffer yet?
static D3DCLIPSTATUS ClipStatus;		// Current clip status
static BOOL WasFlushed;					// Was this render reset by a call to GetClipStatus()

// Arrays to store current states...
static DWORD currenderstate[63]; // These ranges should be good for the life of this program
static DWORD curlightstate[16];
static D3DMATRIX curtransmatrix[4];

// Matrix lists
#define EXBUF_MAXMATRICES	  128
static D3DMATRIXHANDLE matrixlist[EXBUF_MAXMATRICES];
static int curmatrix;	// This is incremented on each call to SetTransform()

void T3DScene::CreateMatrixList()
{
	for (int c = 0; c < EXBUF_MAXMATRICES; c++)
	{
		TRY_D3D(Device->CreateMatrix(&matrixlist[c]));
	}
	curmatrix = 0;
}

void T3DScene::ClearMatrixList()
{
	for (int c = 0; c > EXBUF_MAXMATRICES; c++)
	{
		TRY_D3D(Device->DeleteMatrix(matrixlist[c]));
	}
	curmatrix = 0;
}

D3DMATRIXHANDLE T3DScene::GetMatrix(int matrixnum)
{
	return matrixlist[matrixnum];
}

int T3DScene::GetCurMatrix()
{
	return curmatrix;
}

HRESULT T3DScene::BeginRender()
{
	if (InRecord)
		return DD_OK;

	curmatrix = 0; // Set current matrix in matrix list to 0

	if (!UseDrawPrimitive && ExecuteBuf == &InternalExecuteBuf)
		ExecuteBuf->BeginRecord();	// Record if set to internal buf, otherwise just render

	WasRendered = FALSE;
	WasFlushed = FALSE;
	InRecord = TRUE;

	currenderstate[D3DRENDERSTATE_TEXTUREHANDLE] = 0xFFFFFFFF;
	curlightstate[D3DLIGHTSTATE_MATERIAL] = 0;

	return DD_OK;
}

HRESULT T3DScene::EndRender()
{
	if (!InRecord)
		return DD_OK;

	if (!UseDrawPrimitive)
	{
		if (ExecuteBuf == &InternalExecuteBuf)
			ExecuteBuf->EndRecord();// End record if doing internal buf, otherwise just render

		if (WasRendered == FALSE)	// Prevent object from being rendered in both EndMesh & EndScene
		{
			ExecuteBuf->Render(&ClipStatus);
			WasRendered = TRUE;
		}
	}

	ExecuteBuf = &InternalExecuteBuf;
	InternalExecuteBuf.EndRecord(); // Make sure internal buffer isn't recording

	curmatrix = 0;	// Clear matrix list counter to 0
	
	InRecord = FALSE;

	return DD_OK;
}

HRESULT T3DScene::BeginScene()
{
	HRESULT err;

	if (UseDrawPrimitive)
		err = Device2->BeginScene();
	else
		err = Device->BeginScene();

	if (err != DD_OK)
		return err;

	ExecuteBuf = &InternalExecuteBuf;

	return DD_OK;
}

HRESULT T3DScene::EndScene()
{
	HRESULT err;

	err = EndRender();
	if (err != DD_OK)
		return err;
		
	if (UseDrawPrimitive)
		return Device2->EndScene();
	else
		return Device->EndScene();
}

HRESULT T3DScene::SetClipStatus(LPD3DCLIPSTATUS cs)
{
	if (UseDrawPrimitive)
		return Device2->SetClipStatus(cs);

	if (ExecuteBuf == &InternalExecuteBuf)
		return ExecuteBuf->SetClipStatus(cs);
	else
		return DD_OK;
}

// Note: the GetClipStatus function forces the current execute buffer to be rendered, and a new
// one started!!!  If this is NOT what you want, don't call this function, or any derived function
// such as GetExtents() or UpdateExtents().  Also note that animations with complex extents
// calculations can NOT be buffered.

HRESULT T3DScene::GetClipStatus(LPD3DCLIPSTATUS cs)
{
	if (UseDrawPrimitive)
		return Device2->GetClipStatus(cs);

	BOOL isrecording = ExecuteBuf->IsRecording();

	if (isrecording)
		EndRender(); // Force whatever mesh was last recording to be drawn to screen

	memcpy(cs, &ClipStatus, sizeof(D3DCLIPSTATUS));

	if (isrecording)
	{
		BeginRender();
		WasFlushed = TRUE;	// Flag that we had to flush the buffer in the middle of a render
	}

	return DD_OK;
}

HRESULT T3DScene::SetRenderState(D3DRENDERSTATETYPE rs, DWORD data)
{
	if (UseDrawPrimitive)
		return Device2->SetRenderState(rs, data);

	currenderstate[rs] = data;

	if (ExecuteBuf == &InternalExecuteBuf)
		return ExecuteBuf->SetRenderState(rs, data);
	else 
		return DD_OK;
}                  

HRESULT T3DScene::GetRenderState(D3DRENDERSTATETYPE rs, DWORD *data)
{
	if (UseDrawPrimitive)
		return Device2->GetRenderState(rs, data);

	*data = currenderstate[rs];
	return DD_OK;
}

HRESULT T3DScene::SetLightState(D3DLIGHTSTATETYPE ls, DWORD data)
{
	if (UseDrawPrimitive)
		return Device2->SetLightState(ls, data);

	curlightstate[ls] = data;

	if (ExecuteBuf == &InternalExecuteBuf)
		return ExecuteBuf->SetLightState(ls, data);
	else
		return DD_OK;
}

HRESULT T3DScene::GetLightState(D3DLIGHTSTATETYPE ls, DWORD *data)
{
	if (UseDrawPrimitive)
		return Device2->GetLightState(ls, data);

	*data = curlightstate[ls];
	return DD_OK;
}

HRESULT T3DScene::SetTransform(D3DTRANSFORMSTATETYPE ts, LPD3DMATRIX matrix)
{
	if (UseDrawPrimitive)
		return Device2->SetTransform(ts, matrix);

	if (curmatrix >= EXBUF_MAXMATRICES)
		return D3DERR_MATRIX_SETDATA_FAILED;
	Device->SetMatrix(matrixlist[curmatrix], matrix);
	curmatrix++;

	memcpy(&curtransmatrix[ts], matrix, sizeof(D3DMATRIX)); // Save matrix for later

	if (ExecuteBuf == &InternalExecuteBuf)
		return ExecuteBuf->SetTransform(ts, matrixlist[curmatrix - 1]);
	else
		return DD_OK;
}

HRESULT T3DScene::GetTransform(D3DTRANSFORMSTATETYPE ts, LPD3DMATRIX matrix)
{
	if (UseDrawPrimitive)
		return Device2->GetTransform(ts, matrix);

	memcpy(matrix, &curtransmatrix[ts], sizeof(D3DMATRIX));

	return DD_OK;
}

HRESULT T3DScene::DrawIndexedPrimitive(
	D3DPRIMITIVETYPE pt, D3DVERTEXTYPE vt, LPVOID v, DWORD vc, LPWORD i, DWORD ic, DWORD f)
{
	if (UseDrawPrimitive)
		return Device2->DrawIndexedPrimitive(pt, vt, v, vc, i, ic, f);
	
	if (ExecuteBuf == &InternalExecuteBuf)
		return ExecuteBuf->DrawIndexedPrimitive(pt, vt, v, vc, i, ic, f);
	else
		return DD_OK;
}

HRESULT T3DScene::DrawPrimitive(
	D3DPRIMITIVETYPE pt, D3DVERTEXTYPE vt, LPVOID v, DWORD vc, DWORD f)
{
	if (UseDrawPrimitive)
		return Device2->DrawPrimitive(pt, vt, v, vc, f);

	if (ExecuteBuf == &InternalExecuteBuf)
		return ExecuteBuf->DrawPrimitive(pt, vt, v, vc, f);
	else
		return DD_OK;
}

// Returns TRUE if we had to flush the current execute buffer in the middle of a Render() so
// we could get the extents.  This means we won't be able to cache this render.
BOOL T3DScene::WasRenderFlushed()
{
	return WasFlushed;
}

// Returns a pointer to the current execute buffer
PTExecuteBuf T3DScene::GetExecuteBuf()
{
	return ExecuteBuf;

}

// Gets a copy of the previously recorded execute buffer
PTExecuteBuf T3DScene::CopyExecuteBuf()
{
	return new TExecuteBuf(*ExecuteBuf);
}

// Ignores all calls to DrawPrimitive functions, and just renders the supplied buffer
// to render when EndMesh() or EndScene() is called.
void T3DScene::UseExecuteBuf(PTExecuteBuf usebuf)
{
	if (InRecord) // Can't be recording when we set the buffer
		return;

	ExecuteBuf = usebuf;	
}

// **************************************
// * TExecuteBuf - Execute buffer stuff *
// **************************************

// The TExecuteBuf object basically contains a pointer to an execute buffer.  When BeginRecord()
// is called, the object will begin recording DrawPrimitive calls to the execute buffer.
// When EndRecord() is called, the data is copied into the execute buffer, and the execute buffer
// pointer is set.  After this, Render() can be called as many times as the user wants without
// having to re-record the buffer.

#define EXBUF_MAXRENDERSTATES 32
#define EXBUF_MAXLIGHTSTATES  32
#define EXBUF_MAXTRANSSTATES  32
#define EXBUF_BUFGROWSIZE	  8192	

struct STATEDATA
{
	DWORD state;
	DWORD data;
};

// General stuff
static PTExecuteBuf recording;	// Points to buffer we are currently recording

// Vertex values	
static DWORD vertmode;
static int vertsize;

// Vertex buffer
static int vertbufsize;		// Current vertex buf size
static BYTE *vertbuf, *vertptr; // Buffer
static LPVOID vb;			// Current vertex pointer
static int numverts;		// Current number of vertices 

// Transform op buffer (For vertices)
static int transbufsize;	// Current buf size
static BYTE *transbuf, *transptr; // Buffer
static LPVOID tb;			// Current op pointer
static LPVOID lasttb;		// Pointer to previous op
static DWORD tblastop;		// Id of previous op

// Face op buffer (For triangles)
static int facebufsize;	// Current buf size
static BYTE *facebuf, *faceptr; // Buffer
static LPVOID fb;			// Current op pointer
static LPVOID lastfb;		// Pointer to previous op
static DWORD fblastop;		// Id of previous op

// State lists
static int numrenderstates;
static STATEDATA renderstates[EXBUF_MAXRENDERSTATES];
static int numlightstates;
static STATEDATA lightstates[EXBUF_MAXLIGHTSTATES];
static int numtransstates;
static STATEDATA transstates[EXBUF_MAXTRANSSTATES];

TExecuteBuf::TExecuteBuf()
{
	exBuf = NULL;
	verttype = -1;
}

TExecuteBuf::TExecuteBuf(TExecuteBuf &eb) // Copy another execute buffer
{
	exBuf = NULL;
	verttype = -1;

	if (eb.exBuf == NULL)
		return;

  // Copy vert type
	verttype = eb.verttype;
	exBuf = eb.exBuf;
	memcpy(&debDesc, &eb.debDesc, sizeof(D3DEXECUTEBUFFERDESC));

  // Delete source
	eb.verttype = -1;
	eb.exBuf = NULL;
	memset(&eb.debDesc, 0, sizeof(D3DEXECUTEBUFFERDESC));
}

TExecuteBuf::~TExecuteBuf()
{
	if (recording == this)
		EndRecord();
	if (exBuf)
		exBuf->Release();
}

void TExecuteBuf::BeginRecord()
{
	if (recording && recording != this)
		FatalError("Can only record 1 execute buffer at a time");
	if (recording == this)
		return;

	if (exBuf)
		exBuf->Release();
	exBuf = NULL;

  // Initialize vertex stuff
	verttype = -1;
	vertmode = 0;
	vertsize = 0;
	numverts = 0;
	CheckVertBufSize(128);	// Make sure we have some space to record to
	vb = vertbuf;			// Vertbuf pointer

  // Initialize buffers
	CheckTransBufSize(128);	// Make sure we have some space to record to
	lasttb = tb = transbuf;	// Set current pos
	tblastop = 0xFFFFFFFF;	// Set last op to crazy
	CheckFaceBufSize(128);	// Make sure we have some space to record to
	lastfb = fb = facebuf;	// Set current pos
	fblastop = 0xFFFFFFFF;	// Set last op to crazy

  // Initialize states
	numrenderstates = numlightstates = numtransstates = 0;

  // Initialize matrices
	curmatrix = 0;

	recording = this;
}

void TExecuteBuf::EndRecord()
{
	if (recording != this)  // Not recording.. no big deal..
		return;

  // Put last instructions into buffer
	FlushStates();	// Make sure all states have been flushed to buffers
	OP_EXIT(fb);	// Put exit instruction after faces

  // Kill old execute buf
	if (exBuf)
		exBuf->Release();
	exBuf = NULL;

  // Get sizes
	int vbufsize = (numverts * vertsize + 7) & 0xFFFFFFF8;
	int bufsize = (char *)tb - (char *)transbuf + (char *)fb - (char *)facebuf;

  // Make new buf
	size_t size = vbufsize + bufsize + 8; // Allow extra space for alignment
	debDesc;
	memset(&debDesc, 0, sizeof(D3DEXECUTEBUFFERDESC));
	debDesc.dwSize = sizeof(D3DEXECUTEBUFFERDESC);
	debDesc.dwFlags = D3DDEB_BUFSIZE;
	debDesc.dwBufferSize = size;
	TRY_D3D(Device->CreateExecuteBuffer(&debDesc, &exBuf, NULL));

  // Lock it so it can be filled
 	TRY_D3D(exBuf->Lock(&debDesc));

  // Grab verts 
	LPVOID lpBufStart = debDesc.lpData;
	memset(lpBufStart, 0, size);
	LPVOID lpPointer = lpBufStart;
	memcpy(lpPointer, vertbuf, numverts * vertsize);
	lpPointer = (char *)lpPointer + vbufsize;

  // Do transform and face buffers
	LPVOID lpInsStart = lpPointer;
	if (!QWORD_ALIGNED(lpPointer))		// Make sure quadword aligned
	{
		OP_NOP(lpPointer);
	}
	memcpy(lpPointer, transbuf, (char *)tb - (char *)transbuf);	// Transform buffer
	lpPointer = (char *)lpPointer + (int)((char *)tb - (char *)transbuf);
	if (!QWORD_ALIGNED(lpPointer))		// Make sure quadword aligned
	{
		OP_NOP(lpPointer);
	}
	memcpy(lpPointer, facebuf, (char *)fb - (char *)facebuf);
	lpPointer = (char *)lpPointer + (int)((char *)fb - (char *)facebuf);

  // Setup the execute data describing the buffer
	exBuf->Unlock();
	D3DEXECUTEDATA d3dExData;
	memset(&d3dExData, 0, sizeof(D3DEXECUTEDATA));
	d3dExData.dwSize = sizeof(D3DEXECUTEDATA);
	d3dExData.dwVertexOffset = 0;
	d3dExData.dwVertexCount = numverts;
	d3dExData.dwInstructionOffset = (ULONG) ((char *)lpInsStart - (char *)lpBufStart);
	d3dExData.dwInstructionLength = (ULONG) ((char *)lpPointer  - (char *)lpInsStart);
	d3dExData.dwHVertexOffset = 0;
	exBuf->SetExecuteData(&d3dExData);

  // End recording
	recording = NULL;
	curmatrix = 0;
}

BOOL TExecuteBuf::IsRecording()
{
	return (recording == this);
}

void TExecuteBuf::Render(LPD3DCLIPSTATUS cs)
{
	if (recording || !exBuf) // Can't render while we're recording (stupid! stupid!)
		return;

  // Execute the buffer
	Device->Execute(exBuf, Viewport, D3DEXECUTE_UNCLIPPED);

  // Get bounding rectangle
	if (cs)
	{
		D3DEXECUTEDATA d3dExData;
		d3dExData.dwSize = sizeof(D3DEXECUTEDATA);
		TRY_D3D(exBuf->GetExecuteData(&d3dExData));
		cs->dwFlags = D3DCLIPSTATUS_EXTENTS2;
		cs->dwStatus = d3dExData.dsStatus.dwStatus;
		cs->minx = (float)d3dExData.dsStatus.drExtent.x1;
		cs->miny = (float)d3dExData.dsStatus.drExtent.y1;
		cs->minz = (float)0;
		cs->maxx = (float)d3dExData.dsStatus.drExtent.x2;
		cs->maxy = (float)d3dExData.dsStatus.drExtent.y2;
		cs->maxz = (float)65535;
	}
}

void TExecuteBuf::CheckVertBufSize(int size)
{
	if ((int)((DWORD)vb - (DWORD)vertbuf) + size < vertbufsize)
		return;

	BYTE *ptr = new BYTE[vertbufsize + EXBUF_BUFGROWSIZE + 16]; // Extra 16 bytes for alignment
	BYTE *buf = (BYTE *)(((DWORD)ptr + 15) & 0xFFFFFFF0); // Paragraph aligned!
	if (vertbuf)
	{
		int cursize = numverts * vertsize;
		memcpy(buf, vertbuf, cursize);
		delete vertptr;
	}
	vertptr = ptr;
	vertbuf = buf;
	vertbufsize += EXBUF_BUFGROWSIZE;
}

void TExecuteBuf::CheckTransBufSize(int size)
{
	if ((int)((DWORD)tb - (DWORD)transbuf) + size < transbufsize)
		return;

	BYTE *ptr = new BYTE[transbufsize + EXBUF_BUFGROWSIZE + 16]; // Extra 16 bytes for alignment
	BYTE *buf = (BYTE *)(((DWORD)ptr + 15) & 0xFFFFFFF0); // Paragraph aligned!
	if (transbuf)
	{
		int cursize = (char *)tb - (char *)transbuf;
		memcpy(buf, transbuf, cursize);
		delete transptr;
		tb = buf + cursize;
	}
	transptr = ptr;
	transbuf = buf;
	transbufsize += EXBUF_BUFGROWSIZE;
	if (!tb)
		tb = transbuf;
}

void TExecuteBuf::CheckFaceBufSize(int size)
{
	if ((int)((DWORD)fb - (DWORD)facebuf) + size < facebufsize)
		return;

	BYTE *ptr = new BYTE[facebufsize + EXBUF_BUFGROWSIZE + 16]; // Extra 16 bytes for alignment
	BYTE *buf = (BYTE *)(((DWORD)ptr + 15) & 0xFFFFFFF0); // Paragraph aligned!
	if (facebuf)
	{
		int cursize = (char *)fb - (char *)facebuf;
		memcpy(buf, facebuf, cursize);
		delete faceptr;
		fb = buf + cursize;
	}
	faceptr = ptr;
	facebuf = buf;
	facebufsize += EXBUF_BUFGROWSIZE;
	if (!fb)
		fb = facebuf;
}

void TExecuteBuf::Initialize()
{
  // Set initial values to 0 (just in case)
	vertbuf = vertptr = NULL;
	numverts = vertsize = vertbufsize = 0;
	transbuf = transptr = NULL;
	tb = NULL;
	transbufsize = 0;
	facebuf = faceptr = NULL;
	fb = NULL;
	facebufsize = 0;
}

void TExecuteBuf::Close()
{
	if (vertbuf)
		delete vertptr;
	vertbuf = vertptr = NULL;
	numverts = vertsize = vertbufsize = 0;
	if (transbuf)
		delete transptr;
	transbuf = transptr = NULL;
	tb = NULL;
	transbufsize = 0;
	if (facebuf)
		delete faceptr;
	facebuf = faceptr = NULL;
	fb = NULL;
	facebufsize = 0;
}

HRESULT TExecuteBuf::SetClipStatus(LPD3DCLIPSTATUS cs)
{
	if (recording != this)
		return D3DERR_NOTINBEGIN;

  // Flush out any pending state changes
	FlushStates();

  // Setup clipping status
	if (cs)
	{
		DWORD flags = 0;
		if (cs->dwFlags == D3DCLIPSTATUS_STATUS && 
			(cs->dwFlags == D3DCLIPSTATUS_EXTENTS2 || cs->dwFlags == D3DCLIPSTATUS_EXTENTS3))
			flags = D3DSETSTATUS_ALL;
		else if (cs->dwFlags == D3DCLIPSTATUS_STATUS)
			flags = D3DSETSTATUS_STATUS;
		else if (cs->dwFlags == D3DCLIPSTATUS_EXTENTS2 || cs->dwFlags == D3DCLIPSTATUS_EXTENTS3)
			flags = D3DSETSTATUS_EXTENTS;

		lasttb = tb;
		tblastop = D3DOP_SETSTATUS;
		OP_SET_STATUS(flags, cs->dwStatus, (long)cs->minx, (long)cs->miny, (long)cs->maxx, (long)cs->maxy, tb);
	}

	return DD_OK;
}

HRESULT TExecuteBuf::SetRenderState(D3DRENDERSTATETYPE rs, DWORD data)                    
{
	if (recording != this)
		return D3DERR_NOTINBEGIN;

	if (numrenderstates >= EXBUF_MAXRENDERSTATES)
		FlushStates();

	int c;
	for (c = 0; c < numrenderstates; c++)  // Never set the same render state twice!
	{
		if ((D3DRENDERSTATETYPE)renderstates[c].state == rs)
			break;
	}

	renderstates[c].state = rs;
	renderstates[c].data = data;

	if (numrenderstates < c + 1)
		numrenderstates = c + 1;

	return DD_OK;
}

HRESULT TExecuteBuf::SetLightState(D3DLIGHTSTATETYPE ls, DWORD data)
{
	if (recording != this)
		return D3DERR_NOTINBEGIN;

	if (numlightstates >= EXBUF_MAXLIGHTSTATES)
		FlushStates();

	int c;
	for (c = 0; c < numlightstates; c++)  // Never set the same light state twice!
	{
		if ((D3DLIGHTSTATETYPE)lightstates[c].state == ls)
			break;
	}

	lightstates[c].state = ls;
	lightstates[c].data = data;

	if (numlightstates < c + 1)
		numlightstates = c + 1;

	return DD_OK;
}

HRESULT TExecuteBuf::SetTransform(D3DTRANSFORMSTATETYPE ts, D3DMATRIXHANDLE matrix)
{
	if (recording != this)
		return D3DERR_NOTINBEGIN;

	if (numtransstates >= EXBUF_MAXTRANSSTATES)
		FlushStates();

	int c;
	for (c = 0; c < numtransstates; c++)  // Never set the same light state twice!
	{
		if ((D3DTRANSFORMSTATETYPE)transstates[c].state == ts)
			break;
	}

	transstates[c].state = ts;
	transstates[c].data = (DWORD)matrix;

	if (numtransstates < c + 1)
		numtransstates = c + 1;

	return DD_OK;
}

void TExecuteBuf::FlushStates()
{
  // Spew out any changes in the light state.. append to previous light state if possible
	if (numlightstates > 0)
	{
		if (tblastop == D3DOP_STATELIGHT)
		{
			((LPD3DINSTRUCTION)lasttb)->wCount += numlightstates;
		}
		else 
		{
			lasttb = tb;
			tblastop = D3DOP_STATELIGHT;
			OP_STATE_LIGHT(numlightstates, tb);
		}
		for (int c = 0; c < numlightstates; c++)
		{
		  STATE_DATA(lightstates[c].state, lightstates[c].data, tb);
		}
		numlightstates = 0;
	}

  // Spew out any changes in the transform state.. append to previous transform state if possible
	if (numtransstates > 0)
	{
		if (tblastop == D3DOP_STATETRANSFORM)
		{
			((LPD3DINSTRUCTION)lasttb)->wCount += numtransstates;
		}
		else 
		{
			lasttb = tb;
			tblastop = D3DOP_STATETRANSFORM;
			OP_STATE_TRANSFORM(numtransstates, tb);
		}
		for (int c = 0; c < numtransstates; c++)
		{
		  STATE_DATA(transstates[c].state, transstates[c].data, tb);
		}
		numtransstates = 0;
	}

  // Spew out any changes in the light state.. append to previous light state if possible
	if (numrenderstates > 0)
	{
		if (fblastop == D3DOP_STATERENDER)
		{
			((LPD3DINSTRUCTION)lastfb)->wCount += numrenderstates;
		}
		else 
		{
			lastfb = fb;
			fblastop = D3DOP_STATELIGHT;
			OP_STATE_LIGHT(numrenderstates, fb);
		}
		for (int c = 0; c < numrenderstates; c++)
		{
		  STATE_DATA(renderstates[c].state, renderstates[c].data, fb);
		}
		numrenderstates = 0;
	}
}

HRESULT TExecuteBuf::DrawIndexedPrimitive(
	D3DPRIMITIVETYPE pt, D3DVERTEXTYPE vt, LPVOID v, DWORD vc, LPWORD i, DWORD ic, DWORD f)
{
	if (recording != this)
		return D3DERR_NOTINBEGIN;

	if (vc == 0)
		return DD_OK;

	int c;

  // Set the vertex type for this execute buffer if we don't know it yet
	if (verttype != -1 && verttype != vt)
		FatalError("Unable to create execute buffer with more than one type of vertex");
	else if (verttype == -1)
	{
		verttype = vt;
		if (verttype == D3DVT_VERTEX)
		{
			vertmode = D3DPROCESSVERTICES_TRANSFORMLIGHT | D3DPROCESSVERTICES_UPDATEEXTENTS;
			vertsize = sizeof(D3DVERTEX);
		}
		else if (verttype == D3DVT_LVERTEX)
		{
			vertmode = D3DPROCESSVERTICES_TRANSFORM | D3DPROCESSVERTICES_UPDATEEXTENTS;
			vertsize = sizeof(D3DLVERTEX);
		}
		else if (verttype == D3DVT_TLVERTEX)
		{
			vertmode = D3DPROCESSVERTICES_COPY | D3DPROCESSVERTICES_UPDATEEXTENTS;
			vertsize = sizeof(D3DTLVERTEX);
		}
	}

  // Flush all states
	FlushStates();
	
  // Get triangle indices if no index array is provided
	int startvert = numverts;
	if (!i)
		ic = vc;
	int numtri = ic / 3;

  // Spew the verts
	int size = vertsize * vc;
	CheckVertBufSize(size + 128);
	memcpy(vb, v, size);
	numverts += vc;
	vb = (char *)vb + size;

  // Spew the process vert op
	CheckTransBufSize(128);
	if (tblastop == D3DOP_PROCESSVERTICES) // Add to previous op
	{
		((LPD3DPROCESSVERTICES)((BYTE *)lasttb + sizeof(D3DINSTRUCTION)))->dwCount += vc;
	}
	else									// Make new op
	{
		lasttb = tb;
		tblastop = D3DOP_PROCESSVERTICES;
		OP_PROCESS_VERTICES(1, tb);
			PROCESSVERTICES_DATA(vertmode, startvert, vc, tb);
	}

  // Spew the triangle list op
	CheckFaceBufSize(sizeof(D3DTRIANGLE) * numtri + 128);

	if (fblastop == D3DOP_TRIANGLE)
	{
		((LPD3DINSTRUCTION)lastfb)->wCount += (WORD)numtri;
	}
	else 
	{
		if (QWORD_ALIGNED(fb))
			 OP_NOP(fb);
		lastfb = fb;
		fblastop = D3DOP_TRIANGLE;
		OP_TRIANGLE_LIST((WORD)numtri, fb);
	}

	LPD3DTRIANGLE t = (LPD3DTRIANGLE)fb;
	int vi = startvert; // Uses vert index if 'i' is NULL
	for (c = 0; c < numtri; c++, t++)
	{
		if (i)
		{
			t->v1 = *(i++) + startvert;
			t->v2 = *(i++) + startvert;
			t->v3 = *(i++) + startvert;
		}
		else
		{
			t->v1 = vi++;
			t->v2 = vi++;
			t->v3 = vi++;
		}
		t->wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
	}
	fb = (char *)fb + (sizeof(D3DTRIANGLE) * numtri);

	return DD_OK;
}

// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                       ammo.cpp - TAmmo module                         *
// *************************************************************************

#include "revenant.h"
#include "ammo.h"
#include "bitmap.h"
#include "imagery.h"
#include "mappane.h"
#include "inventory.h"
#include "character.h"
#include "sound.h"

REGISTER_BUILDER(TAmmo)
TObjectClass AmmoClass("AMMO", OBJCLASS_AMMO, 0);

// Hard coded class stats
DEFSTAT(Ammo, EqSlot,		EQSL, 0, 7, 0, 8)
DEFSTAT(Ammo, Value,		VAL,  1, 0, 0, 1000000)

// Hard coded object stats
DEFOBJSTAT(Ammo, Amount,	AMT,  0, 0, 0, 1000)


// These were originally static members of TAmmo but the compiler wasn't
// very hip on that, so they are now here.
PTBitmap ammoinvitem[MAXAMMOTYPES][MAXAMMOIMAGE];	// Bitmaps built on the fly
int ammoinvusecount[MAXAMMOTYPES][MAXAMMOIMAGE];		// Use count for each image

PTBitmap ammogrounditem[MAXAMMOTYPES][MAXAMMOIMAGE];	// Ground images
int ammogroundusecount[MAXAMMOTYPES][MAXAMMOIMAGE];	// Use count for ground

#define IMGAMOUNT(x)	((x) < MAXAMMOIMAGE ? (x) : ((x) - (MAXAMMOIMAGE/2)) % (MAXAMMOIMAGE/2) + (MAXAMMOIMAGE/2))

struct { int num, x, y; } AmmoPos[MAXAMMOIMAGE] =
{ { 0, 4, 4 }, { 0, 5, 7 }, { 0, 1, 5 },
  { 0, 4, 6 }, { 0, 3, 2 }, { 0, 8, 5 },
  { 0, 3, 0 }, { 0, 8, 8 }, { 0, 5, 2 },
  { 0, 7, 8 }, { 0, 6, 4 }, { 0, 2, 6 },
  { 0, 6, 3 }, { 0, 2, 0 }, { 0, 1, 5 },
  { 0, 5, 1 },
  { 0, 4, 4 }, { 0, 5, 7 }, { 0, 1, 5 },
  { 0, 4, 6 }, { 0, 3, 2 }, { 0, 8, 5 },
  { 0, 3, 0 }, { 0, 8, 8 }, { 0, 5, 2 },
  { 0, 7, 8 }, { 0, 6, 4 }, { 0, 2, 6 },
  { 0, 6, 3 }, { 0, 2, 0 }, { 0, 1, 5 },
  { 0, 5, 1 }
};

BOOL TAmmo::Initialize()
{
	for (int t = 0; t < MAXAMMOTYPES; t++)
		for (int i = 0; i < MAXAMMOIMAGE; i++)
		{
			ammoinvitem[t][i] = ammogrounditem[t][i] = NULL;
			ammoinvusecount[t][i] = ammogroundusecount[t][i] = 0;
		}

	return TRUE;
}

void TAmmo::Close()
{
	for (int t = 0; t < MAXAMMOTYPES; t++)
		for (int i = 0; i < MAXAMMOIMAGE; i++)
		{
			if (ammoinvusecount[t][i])
			{
				ammoinvusecount[t][i] = 1;
				FreeInvItem(t, i);
			}

			if (ammogroundusecount[t][i])
			{
				ammogroundusecount[t][i] = 1;
				FreeGroundItem(t, i);
			}
		}
}

TAmmo::~TAmmo()
{
	int count = IMGAMOUNT(Amount());

	if (ammoinvusecount[objtype][count] && GetOwner() == Inventory.GetContainer())
		FreeInvItem(objtype, count);

	if (ammogroundusecount[objtype][count])
		FreeGroundItem(objtype, count);
}

void TAmmo::SignalAddedToInventory()
{
	TObjectInstance::SignalAddedToInventory();

	if (GetOwner() == Inventory.GetContainer() && imagery)
		AllocInvItem(imagery, state, objtype, Amount());
}

void TAmmo::RemoveFromInventory()
{
	TObjectInstance::RemoveFromInventory();

	if (GetOwner() == Inventory.GetContainer())
		FreeInvItem(objtype, Amount());
}

void TAmmo::SetAmount(int amt)
{
	if (Amount() == amt || amt < 1)
		return;

	if (GetOwner() == Inventory.GetContainer())
	{
		FreeInvItem(objtype, Amount());
		if (imagery)
			AllocInvItem(imagery, state, objtype, amt);
	}

	if (!GetOwner())
	{
		FreeGroundItem(objtype, Amount());
		if (imagery)
			AllocGroundItem(imagery, state, objtype, amt);
	}

	SetStat(se_Amount.id, amt);
}


void TAmmo::Load(RTInputStream is, int version, int objversion)
{
	TObjectInstance::Load(is, version, objversion);

	if (version < 5)
	{
		int amount;
		is >> amount;
		amount++;
		SetStat("Amount", amount);
	}
}

void TAmmo::Save(RTOutputStream os)
{
	TObjectInstance::Save(os);
}

void TAmmo::AllocInvItem(PTObjectImagery img, int state, int type, int count)
{
	if (!img)
		return;

	count = min(count, MAXAMMOIMAGE-1);

	if (ammoinvusecount[type][count] < 1)
	{
		ammoinvitem[type][count] = TBitmap::NewBitmap(INVITEMREALWIDTH, INVITEMREALHEIGHT, BM_15BIT);

		memset(ammoinvitem[type][count]->data16, 0, INVITEMREALWIDTH*INVITEMREALHEIGHT*2);

		for (int i = 0; i < count+1; i++)
			ammoinvitem[type][count]->Put(AmmoPos[i].x, AmmoPos[i].y, img->GetInvImage(state, AmmoPos[i].num), DM_TRANSPARENT);

		ammoinvusecount[type][count] = 1;
	}
	else
		ammoinvusecount[type][count]++;
}

void TAmmo::FreeInvItem(int type, int count)
{
	count = min(count, MAXAMMOIMAGE-1);

	if (ammoinvusecount[type][count] == 0)
		return;

	if (--(ammoinvusecount[type][count]) < 1 && ammoinvitem[count])
	{
		delete ammoinvitem[type][count];
		ammoinvitem[type][count] = NULL;
	}
}

void TAmmo::AllocGroundItem(PTObjectImagery img, int state, int type, int count)
{
	if (!img)
		return;

	count = min(count, MAXAMMOIMAGE-1);

	if (ammogroundusecount[type][count] < 1)
	{
		ammogrounditem[type][count] = TBitmap::NewBitmap(INVITEMREALWIDTH/2, INVITEMREALHEIGHT/2, BM_8BIT | BM_PALETTE);

		memset(ammogrounditem[type][count]->data16, 0, (INVITEMREALWIDTH/2)*(INVITEMREALHEIGHT/2));
		memcpy(ammogrounditem[type][count]->palette.ptr(), img->GetStillImage(state)->palette.ptr(), img->GetStillImage(state)->palettesize);

		for (int i = 0; i < count+1; i++)
			ammogrounditem[type][count]->Put(AmmoPos[i].x >> 1, AmmoPos[i].y >> 1, img->GetStillImage(state, AmmoPos[i].num), DM_TRANSPARENT);

		ammogroundusecount[type][count] = 1;
	}
	else
		ammogroundusecount[type][count]++;
}

void TAmmo::FreeGroundItem(int type, int count)
{
	count = min(count, MAXAMMOIMAGE-1);

	if (ammogroundusecount[type][count] == 0)
		return;

	if (--(ammogroundusecount[type][count]) < 1 && ammogrounditem[count])
	{
		delete ammogrounditem[type][count];
		ammogrounditem[type][count] = NULL;
	}
}

void TAmmo::DrawInvItem(int x, int y)
{
	int count = IMGAMOUNT(Amount());

	if (ammoinvusecount[objtype][count] < 1 && imagery)
		AllocInvItem(imagery, state, objtype, count);

	imagery->DrawInvItem(this, x, y);
}

PTBitmap TAmmo::InventoryImage()
{
	return ammoinvitem[objtype][IMGAMOUNT(Amount())];
}

void TAmmo::GetScreenRect(SRect &r)
{
	if (imagery)
	{
		PSImageryStateHeader st = imagery->GetState(GetState());

		int x, y;
		WorldToScreen(pos, x, y);

		r.left   = x - st->regx;
		r.right  = r.left + (INVITEMREALWIDTH / 2) - 1;
		r.top    = y - st->regy;
		r.bottom = r.top + (INVITEMREALHEIGHT / 2) - 1;
	}
}

void TAmmo::DrawUnlit(PTSurface surface)
{
	int count = IMGAMOUNT(Amount());

	if (ammogroundusecount[objtype][count] < 1 && imagery)
		AllocGroundItem(imagery, state, objtype, count);

	imagery->DrawUnlit(this, surface);
}

PTBitmap TAmmo::GetStillImage(int ostate)
{
	return ammogrounditem[objtype][IMGAMOUNT(Amount())];
}


// ************
// * TArrow3D *
// ************

_CLASSDEF(TArrow3D)
class TArrow3D : public TObjectInstance
{
  public:
	TArrow3D(PTObjectImagery newim) : TObjectInstance(newim) {}
	TArrow3D(PSObjectDef def, PTObjectImagery newim) : TObjectInstance(def, newim) {}

	virtual DWORD Move();
};

DEFINE_BUILDER("Arrow3D", TArrow3D)
REGISTER_BUILDER(TArrow3D)

DWORD TArrow3D::Move()
{
	DWORD bits = TObjectInstance::Move();

	PTObjectInstance inst = (PTObjectInstance)TCharacter::CharBlocking(this, pos);

	if ((bits & MOVE_BLOCKED) || inst)
	{
		// collision!

		PLAY("arrow impact");		// play sound

		if (inst)
		{
			// hit character
			inst->Damage(random(20, 50), DAMAGE_PIERCING);
		}

		if (inst || (facing >= 0x20 && facing <= 0xA0))
		{
			// delete self if facing invisible wall or hitting character
			SetFlags(OF_KILL);
		}
	}
	else if (!(bits & MOVE_MOVED))
	{
		// no need to stick around, we're not going anywhere
		SetFlags(OF_KILL);
	}

	return bits;
}


// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                 animimage.cpp - TAnimImagery module                   *
// *************************************************************************

#include "revenant.h"
#include "animimage.h"
#include "graphics.h"
#include "animation.h"
#include "bitmap.h"
#include "surface.h"
#include "display.h"
#include "mappane.h"
#include "playscreen.h"
#include "inventory.h"

REGISTER_IMAGERYBUILDER(TAnimImagery);

BOOL TAnimImagery::AlwaysOnTop(PTObjectInstance oi)
{
	int state = oi->GetState();

	if (state >= NumStates())
		return FALSE;

	PTBitmap bm = oi->GetStillImage();
	if (!bm)
		return FALSE;

	if (bm->flags & BM_ZBUFFER)
		return FALSE;

	return (GetImageFlags(state) & ANIIM_LIT) != 0;
}

void TAnimImagery::CacheImagery()
{
	for (int state = 0; state < NumStates(); state++)
	{
		PTBitmap bm = GetStillImage(state);
		if (bm)
			bm->CacheChunks();
	}
}

void TAnimImagery::DrawLit(PTObjectInstance oi, PTSurface surface)
{
	int state = oi->GetState();

	if (state >= NumStates() || (oi->GetFlags() & OF_SELDRAW))
		return;

	/*
	if (GetImageFlags(state) & ANIIM_CUTOFF && !Editor)
	{
		if (SmoothScroll)
			return;				// never show trees on smoothscrolling mode

		// make sure the bitmap is cut off at the top of the screen
		SRect r;
		oi->GetScreenRect(r);
		if (r.top > MapPane.GetScrollY())
			return;
	}
	*/

	PTBitmap bm = oi->GetStillImage();

	DWORD flags = DM_TRANSPARENT;
	if (oi->GetFlags() & OF_DRAWFLIP)
		flags |= DM_REVERSEHORZ;

	if (GetImageFlags(state) & ANIIM_LIT && bm)
	{
		S3DPoint screenpos;
		oi->GetScreenPos(screenpos);

		if (bm->flags & BM_ALPHA)
			flags |= DM_ALPHA;

		if (bm->flags & BM_ZBUFFER)
		{
			int dim = 0;
			flags |= DM_ZBUFFER;
			surface->ZPutDim(screenpos.x - GetRegX(state),
							 screenpos.y - GetRegY(state),
							 screenpos.z - GetRegZ(state), bm, flags, dim);
		}
		else
			surface->Put(screenpos.x - GetRegX(state), screenpos.y - GetRegY(state), bm, flags);
	}
}		

void TAnimImagery::DrawUnlit(PTObjectInstance oi, PTSurface surface)
{
	int state = oi->GetState();

	if (state >= NumStates() || (oi->GetFlags() & OF_SELDRAW))
		return;

	/*
	if (GetImageFlags(state) & ANIIM_CUTOFF && !Editor)
	{
		if (SmoothScroll)
			return;				// never show trees on smoothscrolling mode

		// make sure the bitmap is cut off at the top of the screen
		SRect r;
		oi->GetScreenRect(r);
		if (r.top > MapPane.GetScrollY())
			return;
	}
	*/

	PTBitmap bm = oi->GetStillImage();
	if (!bm)
		return;

	S3DPoint screenpos;
	oi->GetScreenPos(screenpos);

	DWORD flags = DM_TRANSPARENT;

	if (bm->flags & BM_ALPHA)
		flags |= DM_ALPHA;
	else
	{
		if (bm->flags & BM_ZBUFFER)
			flags |= DM_ZBUFFER; 
		else
			flags |= DM_ZSTATIC;
	}

	if (bm->flags & BM_NORMALS && !NoNormals)
		flags |= DM_NORMALS; 
	
	if (oi->GetFlags() & OF_DRAWFLIP)
		flags |= DM_REVERSEHORZ;

	if (oi->GetFlags() & OF_REVEAL)
		flags |= DM_SHUTTER;

	if (GetImageFlags(state) & ANIIM_UNLIT && bm)
		surface->ZPut(screenpos.x - GetRegX(state),
					  screenpos.y - GetRegY(state),
					  screenpos.z - GetRegZ(state), bm, flags);
}

BOOL TAnimImagery::GetZ(PTObjectInstance oi, PTSurface surface)
{
	int state = oi->GetState();

	if (state >= NumStates())
		return FALSE;

	/*
	if (GetImageFlags(state) & ANIIM_CUTOFF && !Editor)
	{
		if (SmoothScroll)
			return FALSE;				// never show trees on smoothscrolling mode

		// make sure the bitmap is cut off at the top of the screen
		SRect r;
		oi->GetScreenRect(r);
		if (r.top > MapPane.GetScrollY())
			return FALSE;
	}
	*/

	PTBitmap bm = oi->GetStillImage();
	if (!bm)
		return FALSE;

	S3DPoint screenpos;
	oi->GetScreenPos(screenpos);

	DWORD stateflags = GetImageFlags(state);

	if (stateflags & ANIIM_LIT)
	{
		if (!(bm->flags & BM_ZBUFFER))
			return TRUE;
	}
	else if (!(stateflags & ANIIM_UNLIT))
		return Editor;

	DWORD flags = DM_TRANSPARENT;

	if (bm->flags & BM_ZBUFFER)
		flags |= DM_ZBUFFER;
	else if (bm->flags & BM_ALPHA)
		return Editor;
	else	
		flags |= DM_ZSTATIC;

	if (oi->GetFlags() & OF_DRAWFLIP)
		flags |= DM_REVERSEHORZ;

	return surface->ZFind(screenpos.x - GetRegX(state),
						  screenpos.y - GetRegY(state),
						  screenpos.z - GetRegZ(state), bm, flags);
}

void TAnimImagery::DrawSelected(PTObjectInstance oi, PTSurface surface)
{
	int state = oi->GetState();

	// find selected imagery, if any
	for (int i = 0; i < NumStates(); i++)
	{
		if (GetImageFlags(i) & ANIIM_SELECTED)
		{
			state = i;
			break;
		}
	}

	if (state >= NumStates())
		return;

	PTBitmap bm = oi->GetStillImage(state);

	if (!bm)
		return;

	S3DPoint screenpos;
	oi->GetScreenPos(screenpos);

	DWORD flags = DM_TRANSPARENT;
	if (oi->GetFlags() & OF_DRAWFLIP)
		flags |= DM_REVERSEHORZ;

	if (bm->flags & BM_ALPHA)
		flags |= DM_ALPHA;

	if (bm->flags & BM_ZBUFFER)
		flags |= DM_ZBUFFER;
	else
		flags |= DM_ZSTATIC;

	if (!(oi->GetFlags() & OF_SELDRAW))
	{
		if (!(GetImageFlags(state) & ANIIM_SELECTED))
			flags |= DM_SELECTED;

		surface->ZPut(screenpos.x - GetRegX(state),
					  screenpos.y - GetRegY(state),
					  screenpos.z - GetRegZ(state), bm, flags);
	}
	else
	{
		if (NoScrollZBuffer)
		{
			flags &= ~(DM_ZBUFFER | DM_ZSTATIC);
			surface->Put(screenpos.x - GetRegX(state),
						 screenpos.y - GetRegY(state), bm, flags);
		}
		else
		{
			surface->ZPut(screenpos.x - GetRegX(state),
						  screenpos.y - GetRegY(state),
						  screenpos.z - GetRegZ(state), bm, flags);
		}
	}
}

void TAnimImagery::DrawInvItem(PTObjectInstance oi, int x, int y)
{
	int state = oi->GetState();

	if (state >= NumStates())
		return;

	PTBitmap invitem = oi->InventoryImage();
	if (!invitem)
		return;

	Display->Put(x, y, invitem, DM_TRANSPARENT | DM_BACKGROUND);
}

BOOL TAnimImagery::SaveBitmap(char *path, int state, BOOL zbuffer)
{
	char basename[FILENAMELEN];
	char name[FILENAMELEN];

	strcpy(basename, path);
	char *ptr = strchr(basename, '.');
	if (ptr)
		*ptr = NULL;

	if (state >= NumStates())
		return FALSE;

	PTBitmap bm = GetStillImage(state);

	int flags;
	if (Display->BitsPerPixel() == 16)
		flags = BM_16BIT;
	else
		flags = BM_15BIT;

	PTBitmap bigbm = TBitmap::NewBitmap(640, 480, flags | BM_ZBUFFER);

	SColor c;
	c.red = c.green = c.blue = 0;
	bigbm->Clear(c);

	bigbm->ZPut((640 - bm->width) / 2, (480 - bm->height) / 2, 0, bm, DM_ZBUFFER);

	strcpy(name, basename);
	strcat(name, ".BMP");
	if (!bigbm->SaveBMP(name))
	{
		delete bigbm;
		return FALSE;
	}

	if (zbuffer)
	{
		strcpy(name, basename);
		strcat(name, ".ZBF");
		if (!bigbm->SaveZBF(name))
		{
			delete bigbm;
			return FALSE;
		}
	}

	delete bigbm;

	return TRUE;
}

BOOL TAnimImagery::NeedsAnimator(PTObjectInstance oi)
{
	int state = oi->GetState();

	if (state < NumStates() && (GetAnimation(state) != NULL ||
		(oi->IsInInventory() && GetInvAnimation(state) != NULL)))
		return TRUE;

	return FALSE;
}

PTObjectAnimator TAnimImagery::NewObjectAnimator(PTObjectInstance oi)
{
	return (PTObjectAnimator)new TAnimAnimator(oi);
}

// *********************************
// * Anim Object Animator Funtions *
// *********************************

TAnimAnimator::TAnimAnimator(PTObjectInstance oi) : TObjectAnimator(oi) 
{
}

void TAnimAnimator::Animate(BOOL draw)
{
	if (state != inst->GetState() && inst->GetState() < inst->NumStates())
	{
		if (((PTAnimImagery)image)->GetAnimation(inst->GetState()) != NULL &&
			((PTAnimImagery)image)->GetStillImage(inst->GetState()) == NULL)
		{
			inst->SetFlags(OF_MOVING);
		}
		else
		{
			inst->ResetFlags(inst->GetFlags() & ~(OF_MOVING));
		}
	}

	TObjectAnimator::Animate(draw);

	if (draw && !complete)
	{
		PTAnimation anim;

		if (inst->IsInInventory())
			anim = (PTAnimation)(image->GetInvAnimation(state));
		else
			anim = (PTAnimation)(image->GetAnimation(state));

		if (anim == NULL)
			return;

		PTBitmap bm = anim->GetFrame(frame);
		if (bm)
		{
			if (inst->IsInInventory())
				Inventory.DrawAnim(inst, bm);
			else
			{
				DWORD drawmode = DM_TRANSPARENT | DM_USEREG;

				if (bm->flags & BM_ALPHA)
					drawmode |= DM_ALPHA;

				S3DPoint pos, spos;
				inst->GetPos(pos);
				WorldToScreen(pos, spos);
				spos.x += image->GetAnimRegX(state);
				spos.y += image->GetAnimRegY(state);
				spos.z -= image->GetAnimRegZ(state);

				if (NoScrollZBuffer)
					MapPane.DrawRestoreRect(spos.x, spos.y, bm->width, bm->height, DM_WRAPCLIPSRC | DM_NORESTORE | DM_ZBUFFER | DM_NODRAW);

				if (bm->flags & BM_ZBUFFER)
					Display->ZPut(spos.x, spos.y, spos.z, bm, drawmode | DM_ZBUFFER);
				else
					PlayScreen.AddPostCharAnim(spos.x, spos.y, spos.z, bm, drawmode | DM_ZSTATIC);
			}
		}
	}
}

TAnimAnimator::~TAnimAnimator()
{
	if (inst->GetState() < inst->NumStates() &&
		((PTAnimImagery)image)->GetStillImage(inst->GetState()) != NULL)
	{
		inst->ResetFlags(inst->GetFlags() & ~(OF_MOVING));
	}
}

// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                     area.h - Game Area Manager                        *
// *************************************************************************

#include "revenant.h"
#include "parse.h"
#include "sound.h"
#include "mappane.h"
#include "textbar.h"
#include "script.h"
#include "player.h"
#include "playscreen.h"
#include "textbar.h"
#include "area.h"

// *****************************
// * TArea - Basic area object *
// *****************************

static S3DPoint lastpos;
static int lastlevel;
static int lastdaylight;
static int lastdayflag;

// Initializes and loads an area
TArea::TArea()
{
	flags = 0;
	name[0] = NULL;
	rects.Clear();
	scriptfile[0] = NULL;
	amblight = 30;
	nightamblight = 10;
	ambcolor.red = ambcolor.green = ambcolor.blue = 255;
	nightambcolor.red = nightambcolor.green = nightambcolor.blue = 255;
	level = -1; // All levels
	rects.Clear();

  // CD audio music playing
	cdplaynum = 0;
	cdplaylistsize = 0;
	cdplayisrandom = FALSE;
	cdplaypause = 0;
}

// Gets rid of area
TArea::~TArea()
{
	Exit();
}

// Loads the area from the "AREA.DEF" file
BOOL TArea::Load(char *aname, TToken &t)
{
	strncpyz(name, aname, MAXNAMELEN);

	t.SkipBlanks();
	if (!t.Is("BEGIN"))
		t.Error("Area block BEGIN expected");
	
  // Now get first trigger token
	t.LineGet();
	
  // Iterate through the triggers and setup trigger list
	while (t.Type() != TKN_EOF && !t.Is("END"))
	{
	  // Parse trigger tags now
		if (t.Type() != TKN_IDENT)
			t.Error("Area keyword expected");

      // Tags...
		if (t.Is("LEVEL"))
		{
			t.WhiteGet();

			if (t.Type() == TKN_NUMBER)
			{
				level = t.Index();
				t.WhiteGet();
			}
			else if (t.Is("ALL"))
			{
				level = -1;
				t.WhiteGet();
			}
			
			if (t.Type() != TKN_RETURN)
				t.Error("'LEVEL <ALL|level>' expected");
			
			t.LineGet();
		}
		else if (t.Is("RECT"))
		{
			SRect r;
			if (!Parse(t, "RECT %i, %i, %i, %i\n", &r.left, &r.top, &r.right, &r.bottom))
				t.Error("'RECT left top right bottom' expected");
			rects.Add(r);
		}
		else if (t.Is("SCRIPT"))
		{
			if (!Parse(t, "SCRIPT %s\n", scriptfile))
				t.Error("'SCRIPT \"filename\"' expected");
			flags |= AREA_LOADSCRIPTS;
		}
		else if (t.Is("AMBLIGHT"))
		{
			if (!Parse(t, "AMBLIGHT %i\n", &amblight))
				t.Error("'AMBLIGHT light' expected");

			flags |= AREA_SETAMBIENT;
		}
		else if (t.Is("AMBCOLOR"))
		{
			if (!Parse(t, "AMBCOLOR %b, %b, %b\n", &ambcolor.red, &ambcolor.green, &ambcolor.blue))
				t.Error("'AMBCOLOR red green blue' expected");

			flags |= AREA_SETAMBIENT;
		}
		else if (t.Is("NIGHTAMBLIGHT"))
		{
			if (!Parse(t, "NIGHTAMBLIGHT %i\n", &nightamblight))
				t.Error("'NIGHTAMBLIGHT light' expected");

			flags |= AREA_DONIGHT;
		}
		else if (t.Is("NIGHTAMBCOLOR"))
		{
			if (!Parse(t, "NIGHTAMBCOLOR %b, %b, %b\n", &nightambcolor.red, &nightambcolor.green, &nightambcolor.blue))
				t.Error("'NIGHTAMBCOLOR red green blue' expected");

			flags |= AREA_DONIGHT;
		}
		else if (t.Is("CDPLAYLIST"))
		{
			char *cdplaylisterr = "'CDPLAYLIST <RANDOM> <PAUSE pause> TRACKS track1 track2 track3 ...' expected";

			t.WhiteGet();
			if (t.Is("RANDOM"))
			{
				cdplayisrandom = TRUE;
				t.WhiteGet();
			}
			else 
				cdplayisrandom = FALSE;

			if (t.Is("PAUSE"))
			{
				if (!Parse(t, "PAUSE %d", &cdplaypause))
					t.Error(cdplaylisterr);
			}

			if (!t.Is("TRACKS"))
					t.Error(cdplaylisterr);

			t.WhiteGet();

			cdplaylistsize = 0;
			while (t.Type() != TKN_RETURN && t.Type() != TKN_EOF)
			{
				if (cdplaylistsize >= MAXPLAYLISTSIZE)
					t.Error("CDPLAYLIST too many tracks");

				if (t.Type() != TKN_NUMBER)
					t.Error(cdplaylisterr);

				cdplaylist[cdplaylistsize] = t.Index();
				cdplaylistsize++;
			}
			t.LineGet();

			flags |= AREA_PLAYCDMUSIC;
		}
		else
		{
			char buf[80];
			sprintf(buf, "Invalid area tag %s", t.Text());
			t.Error(buf);
		}
	}

	if (!t.Is("END"))
		t.Error("Area block END expected");

  // If no rects for area, add a default super huge rect
	if (rects.NumItems() <= 0)
	{
		SRect r;
		r.left = -1000000000;
		r.top = -1000000000;
		r.right = 1000000000;
		r.bottom = 1000000000;
		rects.Add(r);
	}

	return TRUE;
}

BOOL TArea::In(S3DPoint &pos, int lev)
{
	if (level != -1 && lev != level)
		return FALSE;

	SPoint p;
	p.x = pos.x;
	p.y = pos.y;

	for (int c = 0; c < rects.NumItems(); c++)
	{
		if (rects[c].In(p))
			return TRUE;
	}

	return FALSE;
}

// Initializes ambient sounds for area
void TArea::InitAmbientSounds()
{
}

// Deinitializes ambient sounds for area
void TArea::CloseAmbientSounds()
{
}

void TArea::PlayAmbientSounds()
{
	// Play ambient sound effects here
}

// Initializes data needed to play CD tracks
void TArea::InitCDMusic()
{
  // Initialize CD play params
	if (CDPlaying())
		CDStop();	

  // Initialize play params
	cdplaynum = 0;
	cdplaystart = tickcount();
	cdplaywait = 0;
	cdplaylength = 0;
}

// Deinitializes CD play system
void TArea::CloseCDMusic()
{
	// Do nothing (allow music to continue playing)
}

// Plays CD music tracks
void TArea::PlayCDMusic()
{
	if ((int)tickcount() - cdplaystart >= cdplaywait)
	{
		if (cdplayisrandom)
		{
			int newplaynum;
			do {
				newplaynum = random(0, cdplaylistsize - 1);
			} while (newplaynum == cdplaynum);
			cdplaynum = newplaynum;
		}
		else
		{
			cdplaynum++;
			if (cdplaynum >= cdplaylistsize)
				cdplaynum = 0;
		}

		cdplaynum++;
		cdplaylength = CDTrackLength(cdplaylist[cdplaynum]);
		cdplaywait = cdplaylength + cdplaypause * 1000;
		CDPlayTrack(cdplaylist[cdplaynum]);
		cdplaystart = tickcount();
	}
	else if ((int)tickcount() - cdplaystart >= cdplaylength)
		PlayAmbientSounds();
}

// Gets the current ambient colors based on the time of day
void TArea::GetCurrentAmbient(int &ambient, SColor &color)
{
	if (flags & AREA_DONIGHT)
	{
		int daylight = PlayScreen.Daylight();

		if (daylight == 0)
		{
			ambient = nightamblight;
			color = nightambcolor;
		}
		else if (daylight == 255)
		{
			ambient = amblight;
			color = ambcolor;
		}
		else
		{

			ambient = amblight * daylight / 255 + nightamblight * (255 - daylight) / 255;
			color.red = (BYTE)((int)((int)ambcolor.red * daylight / 255 + 
				(int)nightambcolor.red * (255 - daylight) / 255));
			color.green = (BYTE)((int)((int)ambcolor.green * daylight / 255 + 
				(int)nightambcolor.green * (255 - daylight) / 255));
			color.blue = (BYTE)((int)((int)ambcolor.blue * daylight / 255 + 
				(int)nightambcolor.blue * (255 - daylight) / 255));
		}
	}
	else
	{
		ambient = amblight;
		color = ambcolor;
	}
}

// Called by the game screen Pulse() function to update area stuff
void TArea::Pulse()
{
	if ((flags & AREA_PLAYCDMUSIC) && cdplaylistsize > 0)
		PlayCDMusic();

	if (flags & AREA_PLAYAMBIENT)
		PlayAmbientSounds();

	int dayflag = PlayScreen.DayTimeFlag();
	if (flags & AREA_DONIGHT)
	{
		if ((dayflag != lastdayflag) &&	!(dayflag == DAY_DAYTIME) && !(dayflag == DAY_NIGHT)) 
		{
			char *daynames[6] = {"midnight", "morning", "daytime", "noon", "evening", "night"};
			TextBar.Print("It was %s", daynames[dayflag]);
		}

		int daylight = PlayScreen.Daylight();
		if (daylight != lastdaylight)
		{
			int ambient;
			SColor color;

			GetCurrentAmbient(ambient, color);
			MapPane.SetAmbient(ambient, color, FALSE); // FALSE=Allow fading to continue

			lastdaylight = daylight;
		}
	}
	lastdayflag = dayflag;
}

// Called by the game screen Animate() function to update area stuff
void TArea::Animate(BOOL draw)
{

}

// Called when the player enters the area
void TArea::Enter()
{
	S3DPoint pos;
	int level;

	MapPane.GetMapPos(pos);
	level = MapPane.GetMapLevel();

	if (flags & AREA_PLAYERIN)
		return;

	flags |= AREA_PLAYERIN;

  // Initialize cd play music
	if (flags & AREA_PLAYCDMUSIC)
		InitCDMusic();

  // Initialize ambient sounds
	if (flags & AREA_PLAYAMBIENT)
		InitAmbientSounds();

  // Set ambient values
	if (flags & AREA_SETAMBIENT)
	{
		int ambient;
		SColor color;
		GetCurrentAmbient(ambient, color);

		if (level != lastlevel || dist(pos.x, pos.y, lastpos.x, lastpos.y) > 1024)
			MapPane.SetAmbient(ambient, color);
		else
			MapPane.FadeAmbient(ambient, color, FRAMERATE * 3, 10);
	}

  // Load local scripts
	if (flags & AREA_LOADSCRIPTS)
		ScriptManager.Load(scriptfile, this);

  // Put "Entered" line in the status line
	if (Player)
		TextBar.Print("%s entered %s", Player->GetName(), name);
}

// Called when the player exits the area
void TArea::Exit()
{
	if (!(flags & AREA_PLAYERIN))
		return;

	flags &= ~AREA_PLAYERIN;

  // Close cd play music
	if (flags & AREA_PLAYCDMUSIC)
		CloseCDMusic();

  // Close ambient sounds
	if (flags & AREA_PLAYAMBIENT)
		CloseAmbientSounds();

  // Eliminate local scripts
	if (flags & AREA_LOADSCRIPTS)
		ScriptManager.Clear(this);
}

// **************************************
// * TAreaManager - Area manager object *
// **************************************

// Initialize the area manager
BOOL TAreaManager::Initialize()
{
	if (initialized)
		return TRUE;

	areas.DeleteAll();

  // Clear global last values
	lastpos.x = -100000; lastpos.y = -100000; lastpos.z = -100000;
	lastlevel = 255;
	lastdaylight = -1;
	lastdayflag = -1;

	if (!Load())
		return FALSE;

	initialized = TRUE;

	return TRUE;
}

// Closes the area manager
void TAreaManager::Close()
{
	areas.DeleteAll();
}

// Loads all areas from the "AREA.DEF" file
BOOL TAreaManager::Load()
{
	char fname[MAX_PATH];
	sprintf(fname, "%s%s", ClassDefPath, "area.def");

	FILE *fp = popen(fname, "rb");
	if (!fp)
		FatalError("Unable to find game area file AREA.DEF");

	TFileParseStream s(fp, fname);
	TToken t(s);

	if (!t.DefineGet())
		t.Error("Syntax error in header");

	while (t.Type() != TKN_EOF)
	{

		char areaname[MAXNAMELEN];
		if (!Parse(t, "AREA %s\n", areaname))
			t.Error("AREA \"name\" expected");

		PTArea area = new TArea;

		if (!area->Load(areaname, t))
			t.Error("Error loading area");
		
		areas.Add(area);

		if (!t.DefineGet())
			t.Error("Syntax error between area blocks");
	}
	
	fclose(fp);

	return TRUE;
}

// Called by the game screen Pulse() function to update area stuff
void TAreaManager::Pulse()
{
	S3DPoint pos;
	int level;
	int c;

	MapPane.GetMapPos(pos);
	level = MapPane.GetMapLevel();

	for (c = 0; c < areas.NumItems(); c++)
	{
		PTArea area = areas[c];

		BOOL in = area->In(pos, level);
		
		if (in && !(area->GetFlags() & AREA_PLAYERIN))
			area->Enter(); // In with the new
		else if (!in && (area->GetFlags() & AREA_PLAYERIN))
			area->Exit();  // This should never happen!  But just in case..
	}
	
	for (c = 0; c < areas.NumItems(); c++)
	{
		PTArea area = areas[c];

		if (area->GetFlags() & AREA_PLAYERIN)
			area->Pulse();
	}

  // Save last pos/level
	lastpos = pos;
	lastlevel = level;
}

// Called by the game screen Animate() function to update area stuff
void TAreaManager::Animate(BOOL draw)
{
	for (int c = 0; c < areas.NumItems(); c++)
	{
		PTArea area = areas[c];

		if (area->GetFlags() & AREA_PLAYERIN)
			area->Animate(draw);
	}
}
// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                      armor.cpp - TArmor module                        *
// *************************************************************************

#include "revenant.h"
#include "armor.h"
#include "object.h"
#include "mappane.h"
#include "player.h"

REGISTER_BUILDER(TArmor)

TObjectClass ArmorClass("ARMOR", OBJCLASS_ARMOR, 0);

DEFSTAT(Armor, EqSlot,			EQSL, 0, 4, 0, 8)
DEFSTAT(Armor, Value,			VAL,  1, 0, 0, 1000000)
DEFSTAT(Armor, Protection,		PROT, 2, 1, 1, 10)
DEFSTAT(Armor, Combining,		COMB, 3, 0, 0, 16)
DEFSTAT(Armor, ResistPoison,	RPSN, 4, 0, -100, 100)
DEFSTAT(Armor, Stealth,			STLH, 5, 0, -100, 100)
// Support functions for array classes go here!

// !!! BEN - REMEMBER TO PUT FUNCTIONS HERE !!!
// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                 automap.cpp  - EXILE Automapper File                  *
// *************************************************************************

#include "revenant.h"
#include "bitmap.h"
#include "mappane.h"
#include "automap.h"
#include "display.h"
#include "playscreen.h"
#include "multi.h"
#include "cursor.h"
#include "player.h"

#define FILTER_SIZE 5
#define FILTER_PERCENT 90
#define FILTER_CUTOFF FILTER_SIZE * FILTER_SIZE * FILTER_PERCENT / 100


extern PTBitmap PointerCursor;
extern PTBitmap HandCursor;
extern BYTE  ColorTableUpperHi[32 * 256];
extern BYTE  ColorTableUpperLo[32 * 256];
extern BYTE  ColorTableLower[32 * 256];


//============================================================================
// Function : Initialize.
//----------------------------------------------------------------------------
//     Desc : This will load all the maps needed and create a bitmap to
//            draw the map to be shown.
//
//  Returns : Returns TRUE if successful, FALSE if not.
//
//============================================================================

BOOL TAutoMap::Initialize()
{
	TPane::Initialize();

    BOOL Success = FALSE;

	// Flag that there is no current map
    CurrentMap = 0xFFFF;

    // Set the position variables
    ScrollX = ScrollY = 0;
    OldPlayerX = OldPlayerY = 0xFFFF;
    OldScrollX = OldScrollY = 0xFFFF;
    DraggingMap = FALSE;
	ScrollToTarget = FALSE;

    // Initialize all the pointers for the graphics
    MapGrfx = NULL;
    DisplayMap = NULL;
    ActiveBuf = NULL;

    // Load the map list
	MapList = (PTAutoMapList)LoadResource("AutoMap.DAT", -1);

    // Make sure the map list loaded correctly
    if (MapList != NULL)
    {
        // Create the arrays to hold which colors are Active in the MaskMaps
        ActiveBuf = (BYTE *)calloc(MapList->NumMaps, 256);
        if (ActiveBuf != NULL)
        {
            // Read the Active information from the saved game

            Success = TRUE;
        }
    }

	SetDirty(TRUE);

    return Success;
}



//============================================================================
// Function : Close.
//----------------------------------------------------------------------------
//     Desc : This will perform any cleanup needed.
//
//============================================================================

void TAutoMap::Close()
{
    free(MapList);
    MapList = NULL;

    free(ActiveBuf);
    ActiveBuf = NULL;

    FreeMapGraphics();
}



//============================================================================
// Function : DrawBackground.
//----------------------------------------------------------------------------
//     Desc : This will draw the current set of maps merged appropriately
//            showning the discovered areas pulled from the aftermap on the
//            beforemap background.
//
//============================================================================

void TAutoMap::DrawBackground()
{
	int d;
    int PaneWidth = GetWidth();
    int PaneHeight = GetHeight();
    int PlayerX;
    int PlayerY;
    BOOL Update = FALSE;

	if (!DisplayMap)
		return;

	// Make sure that the maps are loaded
    if (MapGrfx == NULL)
	    CheckMaps();

	GetPlayerOnAutoMap(PlayerX, PlayerY);

	// See if the map is automatically scrolling to show the player
	if (ScrollToTarget)
	{
		d = abs(TargetScrollX - ScrollX);
		if (d < abs(MapScrollDx))
			ScrollX = TargetScrollX;
		else
			ScrollX += MapScrollDx;

		d = abs(TargetScrollY - ScrollY);
		if (d < abs(MapScrollDy))
			ScrollY = TargetScrollY;
		else
			ScrollY += MapScrollDy;

		// See if we've reached the target scroll position
		if ((ScrollX == TargetScrollX) && (ScrollY == TargetScrollY))
			ScrollToTarget = FALSE;
	}

	// Make sure we don't scroll negative
    if (ScrollX < 0)
        ScrollX = 0;
    if (ScrollY < 0)
        ScrollY = 0;

	// Make sure we don't scroll past the right / bottom of the map
    if (ScrollX + PaneWidth > DisplayMap->width)
        ScrollX = DisplayMap->width - PaneWidth;
    if (ScrollY + PaneHeight > DisplayMap->height)
        ScrollY = DisplayMap->height - PaneHeight;

	// Check if the entire pane is dirty or if the player has moved
    if ((IsDirty()) || (PlayerX != OldPlayerX) || (PlayerY != OldPlayerY))
	{
		// Restore the pixel where he was
		RestorePlayerMarker();

		// Draw the Marker where the player is
		DrawPlayerMarker(PlayerX, PlayerY);
        Update = TRUE;
	}
	else
	// Check if the pane has scrolled
    if ((ScrollX != OldScrollX) || (ScrollY != OldScrollY))
        Update = TRUE;

	// See if we need to update the pane to the screen
    if (Update)
	{
        Display->Put(0, 0, DisplayMap, ScrollX, ScrollY, DisplayMap->width, DisplayMap->height, DM_BACKGROUND);
        OldScrollX = ScrollX;
        OldScrollY = ScrollY;
        OldPlayerX = PlayerX;
        OldPlayerY = PlayerY;
		SetDirty(FALSE);
		PlayScreen.MultiUpdate();
	}
}



//============================================================================
// Function : DrawPlayerMarker.
//----------------------------------------------------------------------------
//     Desc : This will draw the marker on the DisplayMap signifying where
//            the player is on the map. This will also save the area under
//            the players marker so it can be restored by RestorePlayerMarker.
//
//    Entry : PlayerX = x coordinate of the player relative to DisplayMap
//            PlayerY = y coordinate of the player relative to DisplayMap
//
//============================================================================

void TAutoMap::DrawPlayerMarker(int PlayerX, int PlayerY)
{
	int Offset = PlayerX + PlayerY * DisplayMap->width;

	MarkerX = PlayerX;
	MarkerY = PlayerY;

	// Set the pixel where he is
	SavePlayerPixel = DisplayMap->data16[Offset];
	DisplayMap->data16[Offset] = 0xFFFF;
}



//============================================================================
// Function : RestorePlayerMarker.
//----------------------------------------------------------------------------
//     Desc : This will restore the graphics underneath the players marker.
//
//============================================================================

void TAutoMap::RestorePlayerMarker()
{
	// Restore the pixel where he was
	if (MarkerX != 0xFFFF)
        DisplayMap->data16[MarkerX + MarkerY * DisplayMap->width] = SavePlayerPixel;
}



//============================================================================
// Function : DrawAutoMap.
//----------------------------------------------------------------------------
//     Desc : This will draw the DisplayMap by laying down the beforemap
//            first and then pulling pixels from the aftermap depending on
//            if the area has been discovered or not.
//
//============================================================================

void TAutoMap::DrawAutoMap()
{
	int Filter[FILTER_SIZE];
	int *EndFilter = Filter + FILTER_SIZE;
	int *c;
	int FilterTotal;
	int x, y;
    int Width = MapGrfx->Background->width;
    int Height = MapGrfx->Background->height;
	int RightClip = Width - FILTER_SIZE / 2 - 1;
    WORD *b = MapGrfx->Background->data16;
    WORD *o = MapGrfx->OverlayMap->data16;
    BYTE *m = MapGrfx->MaskMap->data8;
    WORD *d = DisplayMap->data16;

    // See if we're can display the background or not depending on if the
	// player has the map in his inventory or not
    if (HasMap)
	{
		//--------------------------------------------------------------------
		//                    Top & Right Clipping Version
		//--------------------------------------------------------------------

		for (y = 0; y < FILTER_SIZE / 2; y++)
		{
			// Keep track of the total number of pixels set in FilterTotal
			FilterTotal = 0;

			// Set up the initial state of the Filter
			memset(Filter, 0, FILTER_SIZE);

			for (c = Filter + FILTER_SIZE / 2; c < EndFilter; c++, m++)
			{
				if (y > 1)
					*c += Active[*(m - (Width << 1))];
				if (y > 0)
					*c += Active[*(m - Width)];
				*c += Active[*m];
				*c += Active[*(m + Width)];
				*c += Active[*(m + (Width << 1))];

				// Add the column total to the FilterTotal
				FilterTotal += *c;
			}

			// Reset the column total pointer to the beginning of the filter
			c = Filter;

			// Do all the pixels until we would need to right clip
			for (x = 0; x < RightClip; x++, b++, o++, d++, m++)
			{
				// See if any of the pixels are set
				if (FilterTotal)
				{
					// See if the total number of pixels set is above the
					// visible cutoff
					if (FilterTotal < FILTER_CUTOFF)
					{
						// The total number of pixels set was below the
						// cutoff for it to be completely visible, so set
						// the pixel as a percentage based on how many
						// pixels were set
						*d = MergePixel(b, o, FilterTotal, FILTER_CUTOFF);
					}
					else
						*d = *o;
				}


				// Subtract the previous contents of the column total from
				// the FilterTotal
				FilterTotal -= *c;

				// Reset the column total
				*c = 0;

				// Calculate the new column total
				if (y > 1)
					*c += Active[*(m - (Width << 1))];
				if (y > 0)
					*c += Active[*(m - Width)];
				*c += Active[*m];
				*c += Active[*(m + Width)];
				*c += Active[*(m + (Width << 1))];

				// Add the column total to the FilterTotal
				FilterTotal += *c;

				// Get the next column to work on
				c++;
				if (c == EndFilter)
					c = Filter;
			}

			// Finish off the line, but just clear the column totals since
			// they are off the right side of the image
			for (; x < Width; x++, b++, o++, d++)
			{
				// See if any of the pixels are set
				if (FilterTotal)
				{
					// See if the total number of pixels set is above the
					// visible cutoff
					if (FilterTotal < FILTER_CUTOFF)
					{
						// The total number of pixels set was below the
						// cutoff for it to be completely visible, so set
						// the pixel as a percentage based on how many
						// pixels were set
						*d = MergePixel(b, o, FilterTotal, FILTER_CUTOFF);
					}
					else
						*d = *o;
				}

				// Subtract the previous contents of the column total from
				// the FilterTotal
				FilterTotal -= *c;

				// Get the next column to work on
				c++;
				if (c == EndFilter)
					c = Filter;
			}
		}


		//--------------------------------------------------------------------
		//                     Only Right Clipping Version
		//--------------------------------------------------------------------

		for (; y < Height - FILTER_SIZE / 2; y++)
		{
			// Keep track of the total number of pixels set in FilterTotal
			FilterTotal = 0;

			// Set up the initial state of the Filter
			memset(Filter, 0, FILTER_SIZE);

			for (c = Filter + FILTER_SIZE / 2; c < EndFilter; c++, m++)
			{
				*c += Active[*(m - (Width << 1))];
				*c += Active[*(m - Width)];
				*c += Active[*m];
				*c += Active[*(m + Width)];
				*c += Active[*(m + (Width << 1))];

				// Add the column total to the FilterTotal
				FilterTotal += *c;
			}

			// Reset the column total pointer to the beginning of the filter
			c = Filter;

			// Do all the pixels until we would need to right clip
			for (x = 0; x < RightClip; x++, b++, o++, d++, m++)
			{
				// See if any of the pixels are set
				if (FilterTotal)
				{
					// See if the total number of pixels set is above the
					// visible cutoff
					if (FilterTotal < FILTER_CUTOFF)
					{
						// The total number of pixels set was below the
						// cutoff for it to be completely visible, so set
						// the pixel as a percentage based on how many
						// pixels were set
						*d = MergePixel(b, o, FilterTotal, FILTER_CUTOFF);
					}
					else
						*d = *o;
				}


				// Subtract the previous contents of the column total from
				// the FilterTotal
				FilterTotal -= *c;

				// Reset the column total
				*c = 0;

				// Calculate the new column total
				*c += Active[*(m - (Width << 1))];
				*c += Active[*(m - Width)];
				*c += Active[*m];
				*c += Active[*(m + Width)];
				*c += Active[*(m + (Width << 1))];

				// Add the column total to the FilterTotal
				FilterTotal += *c;

				// Get the next column to work on
				c++;
				if (c == EndFilter)
					c = Filter;
			}

			// Finish off the line, but just clear the column totals since
			// they are off the right side of the image
			for (; x < Width; x++, b++, o++, d++)
			{
				// See if any of the pixels are set
				if (FilterTotal)
				{
					// See if the total number of pixels set is above the
					// visible cutoff
					if (FilterTotal < FILTER_CUTOFF)
					{
						// The total number of pixels set was below the
						// cutoff for it to be completely visible, so set
						// the pixel as a percentage based on how many
						// pixels were set
						*d = MergePixel(b, o, FilterTotal, FILTER_CUTOFF);
					}
					else
						*d = *o;
				}

				// Subtract the previous contents of the column total from
				// the FilterTotal
				FilterTotal -= *c;

				// Get the next column to work on
				c++;
				if (c == EndFilter)
					c = Filter;
			}
		}


		//--------------------------------------------------------------------
		//                  Bottom & Right Clipping Version
		//--------------------------------------------------------------------

		for (; y < Height; y++)
		{

			// Set up the initial state of the Filter
			memset(Filter, 0, FILTER_SIZE);

			for (c = Filter + FILTER_SIZE / 2; c < EndFilter; c++, m++)
			{
				*c += Active[*(m - (Width << 1))];
				*c += Active[*(m - Width)];
				*c += Active[*m];
				if (y < Height - 1)
					*c += Active[*(m + Width)];
				if (y < Height - 2)
					*c += Active[*(m + (Width << 1))];

				// Add the column total to the FilterTotal
				FilterTotal += *c;
			}

			// Reset the column total pointer to the beginning of the filter
			c = Filter;

			// Do all the pixels until we would need to right clip
			for (x = 0; x < RightClip; x++, b++, o++, d++, m++)
			{
				// See if any of the pixels are set
				if (FilterTotal)
				{
					// See if the total number of pixels set is above the
					// visible cutoff
					if (FilterTotal < FILTER_CUTOFF)
					{
						// The total number of pixels set was below the
						// cutoff for it to be completely visible, so set
						// the pixel as a percentage based on how many
						// pixels were set
						*d = MergePixel(b, o, FilterTotal, FILTER_CUTOFF);
					}
					else
						*d = *o;
				}

				// Subtract the previous contents of the column total from
				// the FilterTotal
				FilterTotal -= *c;

				// Reset the column total
				*c = 0;

				// Calculate the new column total
				*c += Active[*(m - (Width << 1))];
				*c += Active[*(m - Width)];
				*c += Active[*m];
				if (y < Height - 1)
					*c += Active[*(m + Width)];
				if (y < Height - 2)
					*c += Active[*(m + (Width << 1))];

				// Add the column total to the FilterTotal
				FilterTotal += *c;

				// Get the next column to work on
				c++;
				if (c == EndFilter)
					c = Filter;
			}

			// Finish off the line, but just clear the column totals since
			// they are off the right side of the image
			for (; x < Width; x++, b++, o++, d++)
			{
				// See if any of the pixels are set
				if (FilterTotal)
				{
					// See if the total number of pixels set is above the
					// visible cutoff
					if (FilterTotal < FILTER_CUTOFF)
					{
						// The total number of pixels set was below the
						// cutoff for it to be completely visible, so set
						// the pixel as a percentage based on how many
						// pixels were set
						*d = MergePixel(b, o, FilterTotal, FILTER_CUTOFF);
					}
					else
						*d = *o;
				}


				// Subtract the previous contents of the column total from
				// the FilterTotal
				FilterTotal -= *c;

				// Get the next column to work on
				c++;
				if (c == EndFilter)
					c = Filter;
			}
		}
	}
	else
	{
		//--------------------------------------------------------------------
		//                  No Map Top & Right Clipping Version
		//--------------------------------------------------------------------

		for (y = 0; y < FILTER_SIZE / 2; y++)
		{
			// Keep track of the total number of pixels set in FilterTotal
			FilterTotal = 0;

			// Set up the initial state of the Filter
			memset(Filter, 0, FILTER_SIZE);

			for (c = Filter + FILTER_SIZE / 2; c < EndFilter; c++, m++)
			{
				if (y > 1)
					*c += Active[*(m - (Width << 1))];
				if (y > 0)
					*c += Active[*(m - Width)];
				*c += Active[*m];
				*c += Active[*(m + Width)];
				*c += Active[*(m + (Width << 1))];

				// Add the column total to the FilterTotal
				FilterTotal += *c;
			}

			// Reset the column total pointer to the beginning of the filter
			c = Filter;

			// Do all the pixels until we would need to right clip
			for (x = 0; x < RightClip; x++, b++, o++, d++, m++)
			{
				// See if any of the pixels are set
				if (FilterTotal)
				{
					// See if the total number of pixels set is above the
					// visible cutoff
					if (FilterTotal < FILTER_CUTOFF)
					{
						// The total number of pixels set was below the
						// cutoff for it to be completely visible, so set
						// the pixel as a percentage based on how many
						// pixels were set
						*d = MergePixelToBlack(o, FilterTotal, FILTER_CUTOFF);
					}
					else
						*d = *o;
				}


				// Subtract the previous contents of the column total from
				// the FilterTotal
				FilterTotal -= *c;

				// Reset the column total
				*c = 0;

				// Calculate the new column total
				if (y > 1)
					*c += Active[*(m - (Width << 1))];
				if (y > 0)
					*c += Active[*(m - Width)];
				*c += Active[*m];
				*c += Active[*(m + Width)];
				*c += Active[*(m + (Width << 1))];

				// Add the column total to the FilterTotal
				FilterTotal += *c;

				// Get the next column to work on
				c++;
				if (c == EndFilter)
					c = Filter;
			}

			// Finish off the line, but just clear the column totals since
			// they are off the right side of the image
			for (; x < Width; x++, b++, o++, d++)
			{
				// See if any of the pixels are set
				if (FilterTotal)
				{
					// See if the total number of pixels set is above the
					// visible cutoff
					if (FilterTotal < FILTER_CUTOFF)
					{
						// The total number of pixels set was below the
						// cutoff for it to be completely visible, so set
						// the pixel as a percentage based on how many
						// pixels were set
						*d = MergePixelToBlack(o, FilterTotal, FILTER_CUTOFF);
					}
					else
						*d = *o;
				}

				// Subtract the previous contents of the column total from
				// the FilterTotal
				FilterTotal -= *c;

				// Get the next column to work on
				c++;
				if (c == EndFilter)
					c = Filter;
			}
		}


		//--------------------------------------------------------------------
		//                  No Map Only Right Clipping Version
		//--------------------------------------------------------------------

		for (; y < Height - FILTER_SIZE / 2; y++)
		{
			// Keep track of the total number of pixels set in FilterTotal
			FilterTotal = 0;

			// Set up the initial state of the Filter
			memset(Filter, 0, FILTER_SIZE);

			for (c = Filter + FILTER_SIZE / 2; c < EndFilter; c++, m++)
			{
				*c += Active[*(m - (Width << 1))];
				*c += Active[*(m - Width)];
				*c += Active[*m];
				*c += Active[*(m + Width)];
				*c += Active[*(m + (Width << 1))];

				// Add the column total to the FilterTotal
				FilterTotal += *c;
			}

			// Reset the column total pointer to the beginning of the filter
			c = Filter;

			// Do all the pixels until we would need to right clip
			for (x = 0; x < RightClip; x++, b++, o++, d++, m++)
			{
				// See if any of the pixels are set
				if (FilterTotal)
				{
					// See if the total number of pixels set is above the
					// visible cutoff
					if (FilterTotal < FILTER_CUTOFF)
					{
						// The total number of pixels set was below the
						// cutoff for it to be completely visible, so set
						// the pixel as a percentage based on how many
						// pixels were set
						*d = MergePixelToBlack(o, FilterTotal, FILTER_CUTOFF);
					}
					else
						*d = *o;
				}


				// Subtract the previous contents of the column total from
				// the FilterTotal
				FilterTotal -= *c;

				// Reset the column total
				*c = 0;

				// Calculate the new column total
				*c += Active[*(m - (Width << 1))];
				*c += Active[*(m - Width)];
				*c += Active[*m];
				*c += Active[*(m + Width)];
				*c += Active[*(m + (Width << 1))];

				// Add the column total to the FilterTotal
				FilterTotal += *c;

				// Get the next column to work on
				c++;
				if (c == EndFilter)
					c = Filter;
			}

			// Finish off the line, but just clear the column totals since
			// they are off the right side of the image
			for (; x < Width; x++, b++, o++, d++)
			{
				// See if any of the pixels are set
				if (FilterTotal)
				{
					// See if the total number of pixels set is above the
					// visible cutoff
					if (FilterTotal < FILTER_CUTOFF)
					{
						// The total number of pixels set was below the
						// cutoff for it to be completely visible, so set
						// the pixel as a percentage based on how many
						// pixels were set
						*d = MergePixelToBlack(o, FilterTotal, FILTER_CUTOFF);
					}
					else
						*d = *o;
				}

				// Subtract the previous contents of the column total from
				// the FilterTotal
				FilterTotal -= *c;

				// Get the next column to work on
				c++;
				if (c == EndFilter)
					c = Filter;
			}
		}


		//--------------------------------------------------------------------
		//                No Map Bottom & Right Clipping Version
		//--------------------------------------------------------------------

		for (; y < Height; y++)
		{

			// Set up the initial state of the Filter
			memset(Filter, 0, FILTER_SIZE);

			for (c = Filter + FILTER_SIZE / 2; c < EndFilter; c++, m++)
			{
				*c += Active[*(m - (Width << 1))];
				*c += Active[*(m - Width)];
				*c += Active[*m];
				if (y < Height - 1)
					*c += Active[*(m + Width)];
				if (y < Height - 2)
					*c += Active[*(m + (Width << 1))];

				// Add the column total to the FilterTotal
				FilterTotal += *c;
			}

			// Reset the column total pointer to the beginning of the filter
			c = Filter;

			// Do all the pixels until we would need to right clip
			for (x = 0; x < RightClip; x++, b++, o++, d++, m++)
			{
				// See if any of the pixels are set
				if (FilterTotal)
				{
					// See if the total number of pixels set is above the
					// visible cutoff
					if (FilterTotal < FILTER_CUTOFF)
					{
						// The total number of pixels set was below the
						// cutoff for it to be completely visible, so set
						// the pixel as a percentage based on how many
						// pixels were set
						*d = MergePixelToBlack(o, FilterTotal, FILTER_CUTOFF);
					}
					else
						*d = *o;
				}

				// Subtract the previous contents of the column total from
				// the FilterTotal
				FilterTotal -= *c;

				// Reset the column total
				*c = 0;

				// Calculate the new column total
				*c += Active[*(m - (Width << 1))];
				*c += Active[*(m - Width)];
				*c += Active[*m];
				if (y < Height - 1)
					*c += Active[*(m + Width)];
				if (y < Height - 2)
					*c += Active[*(m + (Width << 1))];

				// Add the column total to the FilterTotal
				FilterTotal += *c;

				// Get the next column to work on
				c++;
				if (c == EndFilter)
					c = Filter;
			}

			// Finish off the line, but just clear the column totals since
			// they are off the right side of the image
			for (; x < Width; x++, b++, o++, d++)
			{
				// See if any of the pixels are set
				if (FilterTotal)
				{
					// See if the total number of pixels set is above the
					// visible cutoff
					if (FilterTotal < FILTER_CUTOFF)
					{
						// The total number of pixels set was below the
						// cutoff for it to be completely visible, so set
						// the pixel as a percentage based on how many
						// pixels were set
						*d = MergePixelToBlack(o, FilterTotal, FILTER_CUTOFF);
					}
					else
						*d = *o;
				}


				// Subtract the previous contents of the column total from
				// the FilterTotal
				FilterTotal -= *c;

				// Get the next column to work on
				c++;
				if (c == EndFilter)
					c = Filter;
			}
		}
	}

	// Draw any graphics that are Overlayed on the map
    for (x = 0; x < MapGrfx->NumOverlays; x++)
    {
        if (Active[MapGrfx->Overlays[x].ActiveColor])
        {
            DisplayMap->Put(MapGrfx->Overlays[x].XOffset, MapGrfx->Overlays[x].YOffset,
                MapGrfx->Overlays[x].Image);
        }
    }
}




//============================================================================
// Function : MergePixel.
//----------------------------------------------------------------------------
//     Desc : This will return the Overlay pixel faded onto the Background
//            pixel with the translucent percentage defined by Mul / Div.
//
//============================================================================

inline WORD TAutoMap::MergePixel(WORD *Background, WORD *Overlay, int Mul, int Div)
{
	BYTE Alpha = (BYTE)((Mul << 5) / Div);
	WORD Result;

	__asm
	{
		xor  edx, edx

	    mov  esi, [Background]
	    mov  edi, [Overlay]

		mov	 dh, [Alpha]

		mov	 dl, BYTE PTR [edi + 1]
		mov	 ah, [ColorTableUpperHi + edx]
		mov	 al, [ColorTableUpperLo + edx]
		mov	 dl, BYTE PTR [edi]
		add	 al, [ColorTableLower + edx]
		adc  ah, 0

		mov  dh, 31
		sub	 dh, [Alpha]

		mov	 dl, BYTE PTR [esi + 1]
		mov	 bh, [ColorTableUpperHi + edx]
		mov	 bl, [ColorTableUpperLo + edx]
		mov	 dl, BYTE PTR [esi]
		add	 bl, [ColorTableLower + edx]
		adc  bh, 0

		add	 ax, bx

	    mov  [Result], ax
	}

	return Result;
}



//============================================================================
// Function : MergePixelToBlack.
//----------------------------------------------------------------------------
//     Desc : This is the same as MergePixel except that the Overlayed pixel
//            is faded to black depending on the Mul / Div.
//
//============================================================================

inline WORD TAutoMap::MergePixelToBlack(WORD *Overlay, int Mul, int Div)
{
	BYTE Alpha = (BYTE)((Mul << 5) / Div);
	WORD Result;

	__asm
	{
		xor  edx, edx

	    mov  edi, [Overlay]

		mov	 dh, [Alpha]

		mov	 dl, BYTE PTR [edi + 1]
		mov	 ah, [ColorTableUpperHi + edx]
		mov	 al, [ColorTableUpperLo + edx]
		mov	 dl, BYTE PTR [edi]
		add	 al, [ColorTableLower + edx]
		adc  ah, 0

	    mov  [Result], ax
	}

	return Result;
}



//============================================================================
// Function : LoadMapGraphics.
//----------------------------------------------------------------------------
//     Desc : This will load the map graphics needed to display the automap
//            for the map specified.
//
//    Entry : MapNum = number of the automap to load.
//
//  Returns : Returns TRUE if successful, FALSE if not.
//
//============================================================================

BOOL TAutoMap::LoadMapGraphics(int MapNum)
{
	// If they are trying to load the map that's already loaded, return immediately
    if (MapNum == CurrentMap)
		return TRUE;

    // Make sure the MapNum is valid
    if ((MapNum < 0) || (MapNum >= MapList->NumMaps))
       return FALSE;

    // Clear out the old map graphics
    FreeMapGraphics();

    // Load all the graphics for the map from the specified AUTOMAP resource
    int ResID = MapList->MapList[MapNum].ResID;
    MapGrfx = (PTAutoMapGraphics)LoadResource("AUTOMAP", ResID);
    if (MapGrfx == NULL)
        return FALSE;

    // Create another bitmap to draw the map that's going to be displayed
    DisplayMap = TBitmap::NewBitmap(MapGrfx->Background->width,
        MapGrfx->Background->height, MapGrfx->Background->flags);
    if (DisplayMap == NULL)
		return FALSE;

    // Point the Active pointer to the correct section of the ActiveBuf to
    // correspond to the map we've just loaded
    Active = ActiveBuf + MapNum * 256;

    // Reset the position variables
    ScrollX = ScrollY = 0;
    OldPlayerX = OldPlayerY = 0xFFFF;
    OldScrollX = OldScrollY = 0xFFFF;

	// Keep track of the map we just loaded
    CurrentMap = MapNum;

	// Draw the initial state of the map

	// Clear the DisplayMap to the Background or black if the player doesn't
	// have the appropriate map in his inventory
	if (HasMap)
		DisplayMap->Put(0, 0, MapGrfx->Background);
	else
	{
		SColor black = { 0, 0, 0 };
		DisplayMap->Clear(black);
	}

	DrawAutoMap();

	SetDirty(TRUE);

	return TRUE;
}



//============================================================================
// Function : FreeMapGraphics.
//----------------------------------------------------------------------------
//     Desc : This will free up the memory allocated for graphics used by
//            the current automap.
//
//============================================================================

void TAutoMap::FreeMapGraphics()
{
    free(MapGrfx);
    MapGrfx = NULL;

    delete DisplayMap;
    DisplayMap = NULL;
}



//============================================================================
// Function : RecordTravels.
//----------------------------------------------------------------------------
//     Desc : This checks the players position against the MaskMap and
//            sets the area underneath him as active.
//
//============================================================================

void TAutoMap::RecordTravels()
{
    int PlayerX;
    int PlayerY;
    int Width;
    int Height;
    int Offset;
    int Color;

	// Make sure that the maps are loaded
    if (MapGrfx == NULL)
		CheckMaps();

    if (MapGrfx == NULL)
		return;

	GetPlayerOnAutoMap(PlayerX, PlayerY);

    if ((PlayerX != OldPlayerX) || (PlayerY != OldPlayerY))
	{
        int Left   = PlayerX - AUTOMAP_VIEW_WIDTH / 2;
        int Top    = PlayerY - AUTOMAP_VIEW_HEIGHT / 2;
        int Right  = Left + AUTOMAP_VIEW_WIDTH;
        int Bottom = Top + AUTOMAP_VIEW_HEIGHT;

		CheckMaps();

	    if (MapGrfx == NULL)
			return;

        Width = MapGrfx->Background->width;
        Height = MapGrfx->Background->height;

		// Make sure that the players coordinates are in the map
        if (Left < 0)
            Left = 0;
        if (Top < 0)
            Top = 0;
        if (Right >= Width)
            Right = Width - 1;
        if (Bottom >= Height)
            Bottom = Height - 1;

        for (int y = Top; y < Bottom; y++)
		{
            for (int x = Left; x < Right; x++)
			{
				// Check if this area of the map is active or not
                Offset = x + y * Width;
                Color = MapGrfx->MaskMap->data8[Offset];
                if (!Active[Color])
				{
					// The player has just revealed this area.
                    Active[Color] = 1;

					DrawAutoMap();

					// Draw the Marker where the player is
					DrawPlayerMarker(PlayerX, PlayerY);

					SetDirty(TRUE);

					// If there are any scripting things to be done, do them here
				}
			}
		}

		// If the player has started moving and the map is not centered
		// on the player and the player is not dragging the map around
		// then we can start moving the map to show the player
		if ((!DraggingMap) && (!ScrollToTarget))
		{
		    int PaneWidth = GetWidth();
		    int PaneHeight = GetHeight();

		    TargetScrollX = PlayerX - PaneWidth / 2;
		    TargetScrollY = PlayerY - PaneHeight / 2;

			// Make sure we don't scroll negative
		    if (TargetScrollX < 0)
		        TargetScrollX = 0;
		    if (TargetScrollY < 0)
		        TargetScrollY = 0;

			// Make sure we don't scroll past the right / bottom of the map
		    if (TargetScrollX + PaneWidth > DisplayMap->width)
		        TargetScrollX = DisplayMap->width - PaneWidth;
		    if (TargetScrollY + PaneHeight > DisplayMap->height)
		        TargetScrollY = DisplayMap->height - PaneHeight;

			if ((TargetScrollX != ScrollX) || (TargetScrollY != ScrollY))
			{
				// Calculate the distance each axis must move
				MapScrollDx = TargetScrollX - ScrollX;
				MapScrollDy = TargetScrollY - ScrollY;

				// Determine which is larger and set the Deltas accordingly
				if (abs(MapScrollDx) > abs(MapScrollDy))
				{
					if (abs(MapScrollDx) >= MAX_AUTOMAP_SCROLL_SPEED)
					{
						MapScrollDy /= abs(MapScrollDx / MAX_AUTOMAP_SCROLL_SPEED);
						MapScrollDx = MAX_AUTOMAP_SCROLL_SPEED * MapScrollDx / abs(MapScrollDx);
					}
				}
				else
				{
					if (abs(MapScrollDy) >= MAX_AUTOMAP_SCROLL_SPEED)
					{
						MapScrollDx /= abs(MapScrollDy / MAX_AUTOMAP_SCROLL_SPEED);
						MapScrollDy = MAX_AUTOMAP_SCROLL_SPEED * MapScrollDy / abs(MapScrollDy);
					}
				}

				ScrollToTarget = TRUE;
			}
		}
	}
}



//============================================================================
// Function : CheckMaps.
//----------------------------------------------------------------------------
//     Desc : This sees which set of before and after maps are needed for
//            the map section that we're currently tracking and loads them
//            if necessary.
//
//============================================================================

void TAutoMap::CheckMaps()
{
    S3DPoint Pos;
    MapPane.GetMapPos(Pos);
    int PlayerX;
    int PlayerY;
    int Level = MapPane.GetMapLevel();
    int MapNum = 0;
	int n;
    BOOL Found = FALSE;
    SAutoMapData *ml = MapList->MapList;

    // Look for which auto map to use
    for (n = 0; n < MapList->NumMaps; n++, ml++)
	{
		// Check the map level
        if (ml->Level == Level)
		{
            // Check if the Right & Bottom are both 0 (this signifies the
            // entire level is used for the map)
            if ((ml->Right == 0) && (ml->Bottom == 0))
			{
				MapArea.left   = 0;
				MapArea.top    = 0;
				MapArea.right  = MAXMAPWIDTH - 1;
				MapArea.bottom = MAXMAPHEIGHT - 1;

                Found = TRUE;
			}
            else
            // See if the player is in the map area (in World coords.)
            if ((Pos.x >= ml->Left) && (Pos.x <= ml->Right) &&
                (Pos.y >= ml->Top) && (Pos.y <= ml->Bottom))
			{
				MapArea.left   = ml->Left;
				MapArea.top    = ml->Top;
				MapArea.right  = ml->Right;
				MapArea.bottom = ml->Bottom;

                Found = TRUE;
			}

            if (Found)
            {
                MapNum = n;

				// See if the MapNum has changed
				if (MapNum != CurrentMap)
				{
	                // Check to see if the player has the appropriate map in his
	                // inventory or not
					if (Player && Player->FindObjInventory(ml->MapName))
	                	HasMap = TRUE;
					else
	                	HasMap = FALSE;
					HasMap = TRUE;

					// Load the graphics for the map we're going to display
				    LoadMapGraphics(MapNum);

					GetPlayerOnAutoMap(PlayerX, PlayerY);

					// Draw the Marker where the player is
					DrawPlayerMarker(PlayerX, PlayerY);
				}

                return;
            }
		}
	}

}



//============================================================================
// Function : GetMapNumber.
//----------------------------------------------------------------------------
//     Desc : This will return which MapNumber in the MapList matches the
//            map specified by MapName.
//
//    Entry : MapName = Name of the map whose mask info we're getting.
//
//  Returns : Returns which MapNumber in the MapList matches MapName
//            or -1 if the MapName was not found in the list.
//
//============================================================================

int TAutoMap::GetMapNumber(char *MapName)
{
	// Find the MapNum by checking the MapName against the MapList
	for (int n = 0; n < MapList->NumMaps; n++)
		if (!stricmp(MapList->MapList[n].MapName, MapName))
			return n;

	return -1;
}



//============================================================================
// Function : GetMaskColorActive.
//----------------------------------------------------------------------------
//     Desc : This will return whether a specific color in a specific map
//            has been activated or not.
//
//    Entry : MapNum = Number of the map whose mask info we're getting.
//            Color  = Index of the color we wish to check.
//
//  Returns : Returns TRUE if the color is active, FALSE if not.
//
//============================================================================

BOOL TAutoMap::GetMaskColorActive(int MapNum, int Color)
{
	// Make sure the MapNum & Color are valid
	if ((MapNum < 0) || (MapNum >= MapList->NumMaps) ||
		(Color < 0) || (Color > 255))
		return FALSE;

	return (ActiveBuf[MapNum * 256 + Color]);
}



//============================================================================
// Function : GetMaskColorActive.
//----------------------------------------------------------------------------
//     Desc : This will return whether a specific color in a specific map
//            has been activated or not.
//
//    Entry : MapName = Name of the map whose mask info we're getting.
//            Color   = Index of the color we wish to check.
//
//  Returns : Returns TRUE if the color is active, FALSE if not.
//
//============================================================================

BOOL TAutoMap::GetMaskColorActive(char *MapName, int Color)
{
	return GetMaskColorActive(GetMapNumber(MapName), Color);
}



//============================================================================
// Function : SetMaskColorActive.
//----------------------------------------------------------------------------
//     Desc : This will set a specific color in a specific map to be active
//            or not.
//
//    Entry : MapNum = Number of the map whose mask info we're setting.
//            Color  = Index of the color we wish to set.
//            Active = State to set the color to.
//
//============================================================================

void TAutoMap::SetMaskColorActive(int MapNum, int Color, BYTE Active)
{
	// Make sure the MapNum & Color are valid
	if ((MapNum < 0) || (MapNum >= MapList->NumMaps) ||
		(Color < 0) || (Color > 255))
		return;

	int Index = MapNum * 256 + Color;

	// See if the new active state is different than the current state
    if (ActiveBuf[Index] != Active)
	{
        ActiveBuf[Index] = Active;

		// If the map that's being affected is the current map, redraw the
		// automap pane
		if (MapNum == CurrentMap)
			SetDirty(TRUE);

		// If there are any scripting things to be done, do them here
	}
}



//============================================================================
// Function : SetMaskColorActive.
//----------------------------------------------------------------------------
//     Desc : This will set a specific color in a specific map to be active
//            or not.
//
//    Entry : MapName = Name of the map whose mask info we're setting.
//            Color   = Index of the color we wish to set.
//            Active  = State to set the color to.
//
//============================================================================

void TAutoMap::SetMaskColorActive(char *MapName, int Color, BYTE Active)
{
	SetMaskColorActive(GetMapNumber(MapName), Color, Active);
}



//============================================================================
// Function : MouseClick.
//----------------------------------------------------------------------------
//     Desc : This handles any mouse clicks over the automap pane.
//
//    Entry : button = state of the mouse buttons
//            x      = mouse x coordinate
//            y      = mouse y coordinate
//
//============================================================================

void TAutoMap::MouseClick(int button, int x, int y)
{
	// See if we need tp turn of the dragging of the mouse
    if ((button == MB_RIGHTUP) && (DraggingMap))
	{
        DraggingMap = FALSE;
		SetMouseBitmap(PointerCursor);
	}

	// See if they are beginning to drag the map
	if ((button == MB_RIGHTDOWN) && (!DraggingMap) && (InPane(x, y)))
	{
		// The right mouse button is down and over the automap pane, so we
		// can start dragging the map around
		DragMouseX = x;
		DragMouseY = y;
		DragScrollX = ScrollX;
		DragScrollY = ScrollY;
		DraggingMap = TRUE;
		SetMouseBitmap(HandCursor);
		ScrollToTarget = FALSE;
	}

	// See if they are trying to bring up a menu
	if (button == MB_LEFTUP)
	{

	}
}



//============================================================================
// Function : MouseMove.
//----------------------------------------------------------------------------
//     Desc : This handles any mouse movement over the automap pane.
//
//    Entry : button = state of the mouse buttons
//            x      = mouse x coordinate
//            y      = mouse y coordinate
//
//============================================================================

void TAutoMap::MouseMove(int button, int x, int y)
{
	// See if the right mouse button is down
    if (button == MB_RIGHTDOWN)
	{
		// Check if we have already started dragging it
		if (DraggingMap)
		{
			// Get the offset of the mouse from where it began
			int dx = x - DragMouseX;
			int dy = y - DragMouseY;

			// Update the scroll position and redraw the pane
			ScrollX = DragScrollX - dx;
			ScrollY = DragScrollY - dy;
		}
		else
		// Check if the mouse is over the automap pane
		if (InPane(x, y))
		{
			// The right mouse button is down and over the automap pane, so we
			// can start dragging the map around
			DragMouseX = x;
			DragMouseY = y;
			DragScrollX = ScrollX;
			DragScrollY = ScrollY;
			DraggingMap = TRUE;
			SetMouseBitmap(HandCursor);
			ScrollToTarget = FALSE;
		}
    }
	else
	{
		// If they were dragging the map around and just let go, reset our variables
		if (DraggingMap)
		{
			DraggingMap = FALSE;
			SetMouseBitmap(PointerCursor);
		}
	}
}



//============================================================================
// Function : WriteAutoMapData.
//----------------------------------------------------------------------------
//     Desc : This will compact the ActiveBuf to a bit array and write it
//            out to the file passed in.
//
//    Entry : File = File to write the data out to
//
//  Returns : Returns how many bytes were written to the file
//            or -1 if it fails.
//
//============================================================================

size_t TAutoMap::WriteAutoMapData(FILE *fp)
{
	BYTE *Buf;
	BYTE *s = ActiveBuf;
	BYTE *d;
	size_t Size = MapList->NumMaps * 32;

	// Allocate the bit array
	if ((Buf = (BYTE *)malloc(Size)) == NULL)
		return -1;

	// Pack the ActiveBuf into a bit array for storage
	d = Buf;
	for (size_t n = 0; n < Size; n++, s += 8, d++)
	{
		*d  = *s;
		*d |= *(s + 1) << 1;
		*d |= *(s + 2) << 2;
		*d |= *(s + 3) << 3;
		*d |= *(s + 4) << 4;
		*d |= *(s + 5) << 5;
		*d |= *(s + 6) << 6;
		*d |= *(s + 7) << 7;
	}

	// Write it out
	if (fwrite(Buf, 1, Size, fp) != Size)
		Size = -1;

	free(Buf);

	return Size;
}



//============================================================================
// Function : ReadAutoMapData.
//----------------------------------------------------------------------------
//     Desc : This will load the compacted ActiveBuf from the file passed in
//            and then uncompress the bit array back to ActiveBuf.
//
//    Entry : File = File to read the data from.
//
//  Returns : Returns how many bytes were read from the file
//            or -1 if it fails.
//
//============================================================================

size_t TAutoMap::ReadAutoMapData(FILE *fp)
{
	BYTE *Buf;
	BYTE *d = ActiveBuf;
	BYTE *s;
	size_t Size = MapList->NumMaps * 32;

	// Allocate the bit array
	if ((Buf = (BYTE *)malloc(Size)) == NULL)
		return -1;

	// Try to read the packed ActiveBuf into the temp buffer
	if (fread(Buf, 1, Size, fp) != Size)
		Size = -1;
	else
	{
		// Unpack the bit array back into the ActiveBuf
		s = Buf;
		for (size_t n = 0; n < Size; n++, s++)
		{
			*d = (*s) & 1;
			d++;
			*d = (*s >> 1) & 1;
			d++;
			*d = (*s >> 2) & 1;
			d++;
			*d = (*s >> 3) & 1;
			d++;
			*d = (*s >> 4) & 1;
			d++;
			*d = (*s >> 5) & 1;
			d++;
			*d = (*s >> 6) & 1;
			d++;
			*d = *s >> 7;
			d++;
		}
	}

	free(Buf);

	return Size;
}



//============================================================================
// Function : GetPlayerOnAutoMap.
//----------------------------------------------------------------------------
//     Desc : This will convert from the players current position in World
//            coordinates to the (x, y) position on the AutoMap graphic.
//
//    Entry : PlayerX = Ref. to the variable to recieve the players x coord.
//            PlayerY = Ref. to the variable to recieve the players y coord.
//
//============================================================================

void TAutoMap::GetPlayerOnAutoMap(int &PlayerX, int &PlayerY)
{
    S3DPoint Pos;
    MapPane.GetMapPos(Pos);

	PlayerX = (Pos.x - MapArea.left) * DisplayMap->width / (MapArea.right - MapArea.left + 1);
	PlayerX = max(0, min(PlayerX, DisplayMap->width));
	PlayerY = (Pos.y - MapArea.top) * DisplayMap->height / (MapArea.bottom - MapArea.top + 1);
	PlayerY = max(0, min(PlayerY, DisplayMap->height));
}
// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                     bitmap.cpp - Bitmap objects                       *
// *************************************************************************

#include <windows.h>
#include <stdio.h>

#include "revenant.h"
#include "display.h"
#include "bitmapdata.h"
#include "bitmap.h"
#include "graphics.h"
#include "resource.h"
#include "font.h"
#include "chunkcache.h"
#include "decompdata.h"

PTBitmap TBitmap::NewBitmap(int width, int height, int bmflags, 
	int aliasbufsize)
{
	int bytesperpixel;

	switch (bmflags & (BM_8BIT + BM_15BIT + BM_16BIT + BM_24BIT +
		BM_32BIT))
	{
		case BM_8BIT:
		bytesperpixel=1;
		break;
	
		case BM_15BIT:
		case BM_16BIT:
		bytesperpixel=2;
		break;

		case BM_24BIT:
		bytesperpixel=3;
		break;

		case BM_32BIT:
		bytesperpixel=4;
		break;

		default:
		return NULL;
		break;
	}	

	int allocval = (bytesperpixel * width * height) + sizeof(TBitmap) - 
		4 + aliasbufsize;
	
	int zbuffersize = 0;
	int normalsize  = 0;
    int alphasize   = 0;
    int palettesize = 0;

	if (bmflags & BM_ZBUFFER) 
	{
		allocval   += (width << 1) * height;
        zbuffersize = (width << 1) * height;
	}
	
	if (bmflags & BM_NORMALS)
	{
		allocval  += (width << 1) * height;
        normalsize = (width << 1) * height;
	}

	if (bmflags & BM_ALPHA)
	{
		allocval += (width << 1) * height;
        alphasize = (width << 1) * height;
	}
	
	if (bmflags & BM_PALETTE) 
	{
		allocval   += sizeof(SPalette);
        palettesize = sizeof(SPalette);
	}
	
	PTBitmap bitmap = (PTBitmap) new BYTE[allocval];
	if (bitmap == NULL) return NULL;
	
	bitmap->width  = width;
	bitmap->height = height;
	bitmap->flags  = bmflags;

	int drawmode = 0;

	if (bmflags & BM_ZBUFFER) 
		drawmode |= DM_ZBUFFER;
	
	if (bmflags & BM_NORMALS) 
		drawmode |= DM_NORMALS;

	if (bmflags & BM_ALIAS) 
		drawmode |= DM_ALIAS;

	if (bmflags & BM_ALPHA) 
		drawmode |= DM_ALPHA;

	bitmap->drawmode    = drawmode;
	bitmap->keycolor    = 0;

	bitmap->aliassize   = aliasbufsize;
	if (aliasbufsize)
	  bitmap->alias.set((void *)((BYTE*)bitmap + bytesperpixel * width * height + sizeof(TBitmap) - 4));
	else
	  bitmap->alias.set(0);

	bitmap->alphasize   = alphasize;
	if (alphasize)
	  bitmap->alpha.set((void *)((BYTE*)bitmap + bytesperpixel * width * height + sizeof(TBitmap) 
						+ aliasbufsize - 4));
	else
	  bitmap->alpha.set(0);

	bitmap->zbuffersize = zbuffersize;
	if (zbuffersize)
	  bitmap->zbuffer.set((void *)((BYTE*)bitmap + bytesperpixel * width * height 
						+ sizeof(TBitmap) + aliasbufsize + alphasize - 4));
	else
	  bitmap->zbuffer.set(0);

	bitmap->normalsize  = normalsize;
	if (normalsize)
	  bitmap->normal.set((void *)((BYTE*)bitmap + bytesperpixel * width * height 
						+ sizeof(TBitmap) + aliasbufsize + alphasize + zbuffersize - 4));
	else
	  bitmap->normal.set(0);

	bitmap->palettesize = palettesize;
	if (palettesize)
	  bitmap->palette.set((void *)((BYTE*)bitmap + bytesperpixel * width * height + sizeof(TBitmap) + aliasbufsize
					    + alphasize + zbuffersize + normalsize - 4));
	else
	  bitmap->palette.set(0);

	bitmap->datasize    = bytesperpixel * width * height;

	return bitmap;
}

PTBitmap TBitmap::Load(int resource)
{
	PTBitmap bitmap = (PTBitmap)LoadResource("bitmap", resource);
	return bitmap;
}

// ****************************
// * Bitmap Drawing Functions *
// ****************************

void TBitmap::WriteText(char *text, int x, int y, int lines, PTFont font, PSColor color, DWORD drawmode)
{
	SDrawBlock db;
	SDrawParam dp;
	STextParam tp;

	memset(&db, 0, sizeof(SDrawBlock));
	memset(&dp, 0, sizeof(SDrawParam));
	memset(&tp, 0, sizeof(STextParam));

	db.srcbitmapflags = BM_15BIT | BM_ALIAS;
	db.dstbitmapflags = flags;

	db.dest = &data16;
	if (db.dest == NULL) 
		return;

	db.dbufwidth  = width;
	db.dbufheight = height;
	db.dstride    = width;
	db.keycolor   = 0;

	dp.func = TextDraw;

	if (drawmode == DM_USEDEFAULT)
		dp.drawmode = FONT_DRAWMODE;
	else
		dp.drawmode = drawmode;

	dp.originx    = 0;
	dp.originy    = 0;
				   
	dp.clipx      = 0;
	dp.clipy      = 0;
	dp.clipwidth  = width;
	dp.clipheight = height;

	dp.data = (void *)&tp;

	if (color)
	{
		dp.drawmode |= DM_CHANGECOLOR;
		dp.color = TranslateColor(*color);
	}
	else
		dp.color = 0;

	dp.sx         = 0;
	dp.sy         = 0;

	dp.dx         = x;
	dp.dy         = y;

	dp.dwidth  = width;
	dp.dheight = height;

	tp.text = text;
	tp.numlines = lines;
	tp.font = font;
	tp.wrapwidth = width;
	tp.startline = 0;
	tp.justify = 0;
	tp.length = 0; // Length of text drawn

	Draw(&db, &dp);
};

// **********************************
// * Bitmap Decompressing Functions *
// **********************************

// *********** Chunk Bitmap Transfer Routines *********
BOOL TBitmap::CacheChunks()
{
	if (!(flags & BM_CHUNKED))
		return FALSE;

	PSChunkHeader hdr  = (PSChunkHeader)(void *)data8;
	PSChunkHeader zhdr = (PSChunkHeader)(void *)zbuffer;
	PSChunkHeader nhdr = (PSChunkHeader)(void *)normal;

	int type   = hdr->type;
	int width  = hdr->width;
	int height = hdr->height;

	for (int outerloop = 0; outerloop < hdr->height; outerloop++)
	{
		for (int innerloop = 0; innerloop < hdr->width; innerloop++)
		{
			ChunkCache.AddChunk(hdr->block[outerloop * width + innerloop].ptr(), 1);
			
			if (zhdr)
				ChunkCache.AddChunkZ(zhdr->block[outerloop * width + innerloop].ptr(), 2);

			if (nhdr)
				ChunkCache.AddChunk16(nhdr->block[outerloop * width + innerloop].ptr(), 1);
		}
	}

	return TRUE;
}

// **************************
// * Misc. Bitmap Functions *
// **************************

BOOL TBitmap::Clear(SColor &color, DWORD bmdrawmode, WORD zpos)
{
	if (width < 1 || height < 1) return FALSE;

	if (datasize < 1)
		return FALSE;

	if (bmdrawmode == DM_USEDEFAULT)
		bmdrawmode = DM_ZBUFFER | DM_NORMALS;

    SDrawBlock	db;
	memset(&db, 0, sizeof(SDrawBlock));

    SDrawParam	dp;
	MakeDP(dp, 0, 0, 0, 0, width, height, bmdrawmode);

	db.dest       = (WORD *)data16;
	db.dzbuffer   = (WORD *)zbuffer.ptr();
	db.dzstride   = width;
	db.dnormals   = (WORD *)normal.ptr();

	db.dbufwidth  = width;
	db.dbufheight = height;
	db.dstride    = width;

	DWORD bytesperpixel;

	switch (flags & (BM_8BIT | BM_15BIT | BM_16BIT | BM_24BIT | BM_32BIT))
	{
		case BM_8BIT:
			db.dstbitmapflags = BM_8BIT;
			bytesperpixel = 1;
			return FALSE;
		break;
	
		case BM_15BIT:
		case BM_16BIT:
			db.dstbitmapflags = BM_16BIT;
			bytesperpixel = 2;
		break;

		case BM_24BIT:
			db.dstbitmapflags = BM_24BIT;
			bytesperpixel = 3;
		break;

		case BM_32BIT:
			db.dstbitmapflags = BM_32BIT;
			bytesperpixel = 4;
			break;

		default:
			return FALSE;
		break;
	}	

	DWORD newcolor;

	if (bytesperpixel == 2) 
	{
		newcolor  = TranslateColor(color);
		newcolor  = (newcolor << 16) | newcolor;
	}

	else
		newcolor  = (color.red << 24) | (color.green << 16) | (color.blue << 8);
	
	dp.func		  = ::Box;
	dp.intensity  = newcolor;
	dp.zpos       = zpos;

	dp.clipx      = 0;
	dp.clipy      = 0;
	dp.clipwidth  = width;
	dp.clipheight = height;
	dp.color      = newcolor;

	return Draw(&db, &dp);
}

// Copies one bitmap to another 

BOOL TBitmap::RawPut(int x, int y, 
				  PTBitmap bitmap, int srcx, int srcy, int srcw, int srch, int drawmode,
				  DWORD color, int intensity, WORD zpos, DRAWFUNCTION func, void *data)
{
	if (!bitmap)
		return FALSE;

	SDrawBlock  db;
	SDrawParam  dp;

	memset(&db, 0, sizeof(SDrawBlock));
	memset(&dp, 0, sizeof(SDrawParam));

	db.srcbitmapflags = bitmap->flags;
	db.dstbitmapflags = flags;

	db.dest = &data16;
	if (db.dest == NULL) 
		return FALSE;

	db.source = &bitmap->data16;
	if (db.source == NULL) 
		return FALSE;

	db.sbufwidth  = bitmap->width;
	db.sbufheight = bitmap->height;
	db.sstride    = db.sbufwidth;

	db.dbufwidth  = width;
	db.dbufheight = height;
	db.dstride    = width;

    db.szbuffer   = (WORD *)bitmap->zbuffer.ptr();
	db.szstride   = bitmap->width;
    db.dzbuffer   = (WORD *)zbuffer.ptr();
	db.dzstride   = width;

    db.snormals   = (WORD *)bitmap->normal.ptr();
    db.dnormals   = (WORD *)normal.ptr();

	db.palette    = (WORD *)bitmap->palette.ptr();
    db.alpha      = (BYTE *)bitmap->alpha.ptr();
    db.alias      = (BYTE *)bitmap->alias.ptr();

	db.keycolor   = bitmap->keycolor;

    if (drawmode == DM_USEDEFAULT)
        drawmode = bitmap->drawmode;

	dp.drawmode   = drawmode | DM_NORESTORE;
	dp.originx    = 0;
	dp.originy    = 0;
				   
	dp.clipx      = 0;
	dp.clipy      = 0;
	dp.clipwidth  = width;
	dp.clipheight = height;

	dp.sx         = srcx;
	dp.sy         = srcy;

	dp.dx         = x;
	dp.dy         = y;

	if (drawmode & DM_USEREG)
	{
		dp.dx -= bitmap->regx;
		dp.dy -= bitmap->regy;
	}

	dp.swidth     = dp.dwidth  = srcw;
	dp.sheight    = dp.dheight = srch;

	dp.func       = func;
	dp.data       = data;
	dp.color	  = color;
	dp.intensity  = intensity;
	dp.zpos       = zpos;

	return Draw(&db, &dp);
}

BOOL TBitmap::Put(int x, int y, PTSurface surface, int srcx, int srcy, int srcw, 
	int srch, int drawmode, int intensity)
{
	SDrawBlock  db;
	SDrawParam  dp;

	memset(&db, 0, sizeof(SDrawBlock));
	memset(&dp, 0, sizeof(SDrawParam));

	db.srcbitmapflags = surface->flags;
	db.dstbitmapflags = flags;

	db.dest = &data16;
	db.source = surface->Lock();
	surface->Unlock();

	if (!db.source || !db.dest) 
		return FALSE;

	db.sbufwidth  = surface->Width();
	db.sbufheight = surface->Height();
	db.sstride    = surface->Stride();

	db.dbufwidth  = width;
	db.dbufheight = height;
	db.dstride    = width;

    db.szbuffer   = (WORD *)surface->GetZBuffer();
	db.szstride   = surface->Stride();
    db.dzbuffer   = (WORD *)zbuffer.ptr();
	db.dzstride   = width;

    db.snormals   = (WORD *)surface->GetNormalBuffer();
    db.dnormals   = (WORD *)normal.ptr();

	db.palette    = NULL;
    db.alpha      = (BYTE *)NULL;
    db.alias      = (BYTE *)NULL;

	dp.drawmode   = drawmode | DM_NORESTORE;
	dp.drawmode   = dp.drawmode & ~DM_ALIAS;
	dp.drawmode   = dp.drawmode & ~DM_ALPHA;
	dp.originx    = 0;
	dp.originy    = 0;
				   
	dp.clipx      = 0;
	dp.clipy      = 0;
	dp.clipwidth  = width;
	dp.clipheight = height;

	dp.sx         = srcx;
	dp.sy         = srcy;

	dp.dx         = x;
	dp.dy         = y;

	dp.swidth     = dp.dwidth  = srcw;
	dp.sheight    = dp.dheight = srch;

	dp.intensity  = intensity;

 	return Draw(&db, &dp);
}

BOOL TBitmap::SaveBMP(char *filename)
{
    if (this->width < 1 || this->height < 1 || !(flags & (BM_15BIT | BM_16BIT)))
		return FALSE;
    
    int dstwidth = (width + 3) & 0xFFFFFFFC; // Round up to even 4 pixels

	FILE *f = fopen(filename, "wb");
	if (!f)
		return FALSE;

  // Bitmap file header
    BITMAPFILEHEADER header;
	memset(&header, 0, sizeof(BITMAPFILEHEADER));
    BITMAPINFOHEADER info;
	memset(&info, 0, sizeof(BITMAPINFOHEADER));

    header.bfType = ((WORD)'M' << 8U) + (WORD)'B';
    header.bfSize = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + (dstwidth * 3) * height;
    header.bfReserved1 = 0;
    header.bfReserved2 = 0;
    header.bfOffBits = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER);
    
	if (fwrite(&header, sizeof(header), 1, f) != 1)
	{
		fclose(f);
		return FALSE;
	}

  // Bitmap info header
	info.biSize = sizeof(BITMAPINFOHEADER);
	info.biWidth = dstwidth;
	info.biHeight = height;
	info.biPlanes = 1;
    info.biBitCount = 24;
	info.biCompression = BI_RGB;
//	info.biSizeImage = (dstwidth * 3) * (DWORD)height;
	
	if (fwrite(&info, sizeof(info), 1, f) != 1)
	{
		fclose(f);
		return FALSE;
	}

	BYTE *line = new BYTE[dstwidth * 3];
	if (!line)
	{
		fclose(f);
		return FALSE;
	}

	memset(line, 0, dstwidth * 3);

    WORD *src = ((WORD *)data16) + (width * (height - 1));

	for (int loop = 0; loop < height; loop++)
	{
		WORD *s = src;
		BYTE *d = line;
		for (int x = 0; x < width; x++)
		{
			BYTE red, green, blue;
			if (flags & BM_16BIT)
			{
				red = (BYTE)((*s & 0xF800) >> 8);
				green = (BYTE)((*s & 0x07E0) >> 3);
				blue = (BYTE)((*s & 0x001F) << 3);
			}
			else
			{
				red = (BYTE)((*s & 0x7C00) >> 7);
				green = (BYTE)((*s & 0x03E0) >> 2);
				blue = (BYTE)((*s & 0x001F) << 3);
			}
			s++;
			*d++ = blue;
			*d++ = green;
			*d++ = red;
		}
		
		if (fwrite(line, dstwidth * 3, 1, f) != 1)
		{
			delete line;
			fclose(f);
			return FALSE;
		}

        src -= width;
	}

	delete line;

	fclose(f);

	return TRUE;
}

BOOL TBitmap::SaveZBF(char *filename)
{
    if (this->width < 1 || 
		this->height < 1 || 
		!(flags & BM_ZBUFFER) ||
		zbuffer.ptr() == NULL)
			return FALSE;
    
	FILE *f = fopen(filename, "wb");
	if (!f)
		return FALSE;

	if (fwrite(zbuffer.ptr(), width * height * 2, 1, f) != 1)
	{
		fclose(f);
		return FALSE;
	}

	return TRUE;
}

BOOL TBitmap::OnPixel(int x, int y)
{
	if (x < 0 || y < 0 || x >= width || y >= height)
		return FALSE;

	if (flags & (BM_15BIT | BM_16BIT))
	{
		WORD pixel = *(data16 + (y * width) + x);
		return pixel != keycolor;
	}

	if (flags & BM_8BIT)
	{
		BYTE pixel = *(data8 + (y * width) + x);
		return pixel != keycolor;
	}

	return TRUE;
}

// *************************
// * Bitmap only functions *
// *************************

// ********** Line Drawing Routines **********
BOOL TBitmap::Line(int x1, int y1, int x2, int y2, SColor &color)
{
    int width = this->width;
    int height = this->height;

    TBitmap bitmap = *this;
    WORD *data=bitmap.data16;

	int bytesperpixel;

	switch (bitmap.flags & (BM_8BIT + BM_15BIT + BM_16BIT + BM_24BIT))
	{
		case BM_8BIT:
			return FALSE;
		break;
	
		case BM_15BIT:
		case BM_16BIT:
			bytesperpixel=2;
		break;

		case BM_24BIT:
			bytesperpixel=3;
		break;

		default:
			return FALSE;
		break;
	}	

    __asm
    {
        mov eax, x1
        cmp eax, x2
        jne noswap   
       
        xchg eax, x2
        mov x1, eax
        mov eax, y1
        xchg eax, y2
        mov y1, eax
noswap:
	}   
	
    if (x2 < 0 || x1 >= width || max(y1,y2) < 0 || min(y1,y2) >= height)
        return FALSE;

	int dx = x2 - x1;
	int dy = y2 - y1;

	if (x1 < 0)
	{
		y1 += -x1 * dy / dx;
		x1 = 0;
	}
	if (x2 >= width)
	{
		y2 += (width - x2 - 1) * dy / dx;
		x2 = width - 1;
	}

	if (y1 < 0)
	{
		x1 += -y1 * dx / dy;
		y1 = 0;
	}
	
    else if (y1 >= height)
	{
		x1 += (height - y1 - 1) * dx / dy;
		y1 = height - 1;
	}

	if (y2 < 0)
	{
		x2 += -y2 * dx / dy;
		y2 = 0;
	}

	else if (y2 >= height)
	{
		x2 += (height - y2 - 1) * dx / dy;
		y2 = height - 1;
	}

    return TRUE;
}

// ********** Fill Rectangle Routines **********

BOOL TBitmap::Box(int x1, int y1, int x2, int y2, SColor &color)
{
	int fillwidth = x2 - x1 + 1;
	int fillheight = y2 - y1 + 1;

  // Get offset/add stuff
	long dstoff = (y1 * width) + x1 ;
	long dstadd = width - fillwidth;

    TBitmap bitmap=*this;
    WORD *data=bitmap.data16;

    __asm
    {
        cld

  // Load destination
        mov     edi, DWORD PTR [data]
        add     edi, dstoff

        mov     eax, color
        shl     eax, 16
        or      eax, color

  // Load lines
        mov     edx, fillheight

forward:

  // Get Color int AX
        mov     ecx, fillwidth
        shr     ecx, 1
fillloop:
        mov     [edi], eax
        add     edi, 4
        dec     ecx
        jne     fillloop

        mov     ecx, fillwidth
        and     ecx, 1
        je      notodd

        mov     [edi], ax
        add     edi, 2

notodd:
        add     edi, dstadd
        dec     ecx
        jne     forward
    
        dec     edx
        jne     forward
    }
    
    return TRUE;
}

WORD TranslateColor(SColor &color)
{
	WORD red, green, blue, result;

	red = color.red;
	red = red >> 3;
	green = color.green;
	blue = color.blue;
	blue = blue >> 3;
	
	if (Display->BitsPerPixel() == 16)
	{
		green = green >> 2;
		result = (red <<11) | (green << 5) | blue;
	}

	else
	{
		green = green >> 3;
		result = (red <<10) | (green << 5) | blue;
	}
	
	return result;
}

// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                bmsurface.cpp - EXILE Surface Object                   *
// *************************************************************************

#include "revenant.h"
#include "bitmap.h"
#include "bmsurface.h"

TBitmapSurface::TBitmapSurface()
{
}

TBitmapSurface::~TBitmapSurface()
{
	if (ownsbitmap && bitmap)
		delete bitmap;
}

void TBitmapSurface::Initialize(int bmwidth, int bmheight, int bmflags)
{
	bitmap = TBitmap::NewBitmap(bmwidth, bmheight, bmflags);
	width  = bitmap->width;
	height = bitmap->height;
	flags  = bmflags;
	stride = width;

	if (bitmap->flags & BM_8BIT)
	{
		bitsperpixel = 8;
	}

	else if (bitmap->flags & BM_15BIT)
	{
		bitsperpixel = 15;
	}
	
	else if (bitmap->flags & BM_16BIT)
	{
		bitsperpixel = 16;
	}
	
	else if (bitmap->flags & BM_24BIT)
	{
		bitsperpixel = 24;
	}
	
	else if (bitmap->flags & BM_32BIT)
	{
		bitsperpixel = 32;
	}
	
	ownsbitmap = TRUE;
}

void TBitmapSurface::Initialize(PTBitmap newbitmap)
{
    bitmap     = newbitmap;
	ownsbitmap = FALSE;

	width      = bitmap->width;
	height     = bitmap->height;
	flags      = bitmap->flags;
	stride     = width;

	if (bitmap->flags & BM_8BIT)
	{
		bitsperpixel = 8;
	}

	else if (bitmap->flags & BM_15BIT)
	{
		bitsperpixel = 15;
	}
	
	else if (bitmap->flags & BM_16BIT)
	{
		bitsperpixel = 16;
	}
	
	else if (bitmap->flags & BM_24BIT)
	{
		bitsperpixel = 24;
	}
	
	else if (bitmap->flags & BM_32BIT)
	{
		bitsperpixel = 32;
	}
}

BOOL TBitmapSurface::Rect(int x, int y, int w, int h, SColor &color)
{
	return TRUE;
}

BOOL TBitmapSurface::Rect(SRect r, SColor &color)
{
	return TRUE;
}

BOOL TBitmapSurface::Box(int x, int y, int w, int h, SColor &color)
{
	return TRUE;
}

BOOL TBitmapSurface::Line(int x1, int y1, int x2, int y2, SColor &color)
{
	return TRUE;
}

BOOL TBitmapSurface::Copy(PTBitmap bitmap)
{
	return TRUE;
}

BOOL TBitmapSurface::BlitPrimary(PSDrawParam dp, PTSurface surface, int flags)
{
	return TRUE;
}
// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                     button.cpp - TButton object                       *
// *************************************************************************

#include <ctype.h>

#include "revenant.h"
#include "display.h"
#include "button.h"
#include "font.h"

// ***********
// * TButton *
// ***********

void DrawFrame(PTSurface surface, int x, int y, int w, int h, BOOL down)
{
	int topcolor = 216, bottomcolor = 40, leftcolor = 196, rightcolor = 70;
	int centercolor = 128;
	SColor color;

	if (down)
	{
		int tmp;
		tmp = topcolor; topcolor = bottomcolor; bottomcolor = tmp;
		tmp = leftcolor; leftcolor = rightcolor; rightcolor = tmp;
	}

	// center
	color.red = color.green = color.blue = centercolor;
	surface->Box(x + 1, y + 1, w - 2, h - 2, TranslateColor(color), 0, 0, DM_BACKGROUND);
	// top
	color.red = color.green = color.blue = topcolor;
	surface->Box(x, y, w, 1, TranslateColor(color), 0, 0, DM_BACKGROUND);
	// left
	color.red = color.green = color.blue = leftcolor;
	surface->Box(x, y + 1, 1, h - 1, TranslateColor(color), 0, 0, DM_BACKGROUND);
	// right
	color.red = color.green = color.blue = rightcolor;
	surface->Box(x + w - 1, y + 1, 1, h - 2, TranslateColor(color), 0, 0, DM_BACKGROUND);
	// bottom
	color.red = color.green = color.blue = bottomcolor;
	surface->Box(x + 1, y + h - 1, w - 1, 1, TranslateColor(color), 0, 0, DM_BACKGROUND);
}

TButton::TButton(char *bname, int bx, int by, int bw, int bh, WORD keypr,
				 void (*bfunc)(), PTBitmap dbm, PTBitmap ubm, BOOL rad,
				 BOOL tog, BOOL notsquare, int group, int repeat)
{
	strcpy(name, bname);
	x = bx;
	y = by;
	w = bw;
	h = bh;
	key = keypr;
	radial = rad;
	toggle = tog;
	buttonfunc = bfunc;
	down = FALSE;
	dirty = TRUE;
	hidden = FALSE;
	pixelcheck = notsquare && (ubm != NULL);
	level = 0;
	radiogroup = group;
	repeatrate = repeat;
	if (radiogroup >= 0)
		toggle = TRUE;

	downbitmap = dbm;
	if (downbitmap && rad)
	{
		downbitmap->flags |= BM_REGPOINT;
		downbitmap->regx = w + 1;
		downbitmap->regy = w;
	}

	upbitmap = ubm;
	if (upbitmap && rad)
	{
		downbitmap->flags |= BM_REGPOINT;
		upbitmap->regx = w + 1;
		upbitmap->regy = w;
	}
}

void TButton::Draw()
{
	if (hidden)
		return;

	if (downbitmap)
	{
		if (pixelcheck)
			//Display->PutSV(x, y, down ? downbitmap : upbitmap, DM_USEREG | DM_BACKGROUND | DM_TRANSPARENT, level * 2, level);
			Display->Put(x, y, down ? downbitmap : upbitmap, DM_USEREG | DM_BACKGROUND | DM_TRANSPARENT);
		else
			Display->Put(x, y, down ? downbitmap : upbitmap, DM_USEREG | DM_BACKGROUND);
	}
	else
	{
		// generate a generic button
		int add = down ? 1 : 0;
		int nx = x + (w / 2) - ((strlen(name) * SystemFont->GetChar(SystemFont->FirstChar())->width) / 2);
		int ny = y + (h / 2) - (SystemFont->height / 2) - 3;
		DrawFrame(Display, x, y, w, h, down);
		SColor color;
		color.red = color.blue = color.green = 40;
		Display->WriteText(name, nx + add, ny + add, 1, SystemFont, &color, DM_TRANSPARENT | DM_ALIAS | DM_BACKGROUND);
		Display->AddUpdateRect(x, y, w, h, UPDATE_RESTORE);
	}

	dirty = FALSE;
}

#define REPEATWAIT		7

void TButton::Animate(BOOL draw)
{
	if (hidden)
		return;

	if (repeatrate > 0 && down)
		if (counter++ >= REPEATWAIT && (counter % (FRAMERATE / repeatrate)) == 0)
			ButtonFunc();
}

BOOL TButton::OnButton(int bx, int by)
{
	if (hidden || (radiogroup >= 0 && down))
		return FALSE;

	if (radial)
		return ((sqr(absval(x - bx)) + sqr(absval(y - by))) <= sqr(w));
	else
	{
		BOOL insquare = (bx >= x && by >= y && bx <= (x + w) && by <= (y + h));
		if (!pixelcheck || !insquare)
			return insquare;

		return upbitmap->OnPixel(bx - x, by - y);
	}
}

inline BOOL TButton::IsKey(int keypr, BOOL keydown)
{
	if (hidden || (radiogroup >= 0 && down))
		return FALSE;

	if (Editor)
		return (keypr == key && (key < 'A' || key > 'Z' || CtrlDown || !keydown));
	else
		return (keypr == key && !CtrlDown);
}

// ***************
// * TButtonPane *
// ***************

BOOL TButtonPane::Initialize()
{
	TPane::Initialize();

	Buttons.Clear();
	SetDirty(TRUE);
	clicked = -1;
	return TRUE;
}

void TButtonPane::Close()
{
	TPointerIterator<TButton> i(&Buttons);
	
	while (i)
	{
		if (i.Item() == NULL)
			i++;
		else
		{
			delete i.Item();
			Buttons.Remove(i);
		}
	}
}

void TButtonPane::DrawBackground()
{
	for (TPointerIterator<TButton> i(&Buttons); i; i++)
		if (i.Item() && i.Item()->IsDirty())
			i.Item()->Draw();
}

void TButtonPane::Animate(BOOL draw)
{
	for (TPointerIterator<TButton> i(&Buttons); i; i++)
		if (i.Item())
			i.Item()->Animate(draw);
}

void TButtonPane::RedrawButtons()
{
	for (TPointerIterator<TButton> i(&Buttons); i; i++)
		if (i.Item())
			i.Item()->SetDirty();
}

void TButtonPane::KeyPress(int key, BOOL down)
{
	if (down)
	{
		for (TPointerIterator<TButton> i(&Buttons); i; i++)
			if (i.Item() && i.Item()->IsKey(key, down) &&
				(i.Item()->GetState() == FALSE || i.ItemNum() != clicked) &&
				(i.Item()->RadioGroup() < 0 || i.Item()->GetState() == FALSE))
			{
				if (i.Item()->IsToggle())
				{
					ClearGroup(i.Item()->RadioGroup());
					i.Item()->SetState(!(i.Item()->GetState()));
					i.Item()->ButtonFunc();
				}
				else
					i.Item()->SetState(TRUE);

				if (i.Item()->Repeats())
					i.Item()->ButtonFunc();
				break;
			}
	}
	else
	{
		for (TPointerIterator<TButton> i(&Buttons); i; i++)
			if (i.Item() && i.Item()->IsKey(key, down) && i.Item()->GetState() == TRUE &&
				i.ItemNum() != clicked)
			{
				if (!i.Item()->IsToggle())
					i.Item()->SetState(FALSE);

				if (!i.Item()->Repeats())
					i.Item()->ButtonFunc();
			}
	}
}

void TButtonPane::MouseClick(int button, int x, int y)
{
	if (button == MB_LEFTDOWN)
	{
		for (TPointerIterator<TButton> i(&Buttons); i; i++)
			if (i.Item() && i.Item()->OnButton(x, y) &&
				(i.Item()->GetState() == FALSE || i.Item()->IsToggle()) &&
				(i.Item()->RadioGroup() < 0 || i.Item()->GetState() == FALSE))
			{
				if (i.Item()->IsToggle())
				{
					ClearGroup(i.Item()->RadioGroup());
					i.Item()->Invert();
					i.Item()->ButtonFunc();
				}
				else
				{
					i.Item()->SetState(TRUE);
					clicked = i.ItemNum();
				}

				if (i.Item()->Repeats())
					i.Item()->ButtonFunc();
				break;
			}
	}
	else if (button == MB_LEFTUP)
	{
		if (clicked >= 0 && Buttons[clicked]->OnButton(x, y) &&
			!Buttons[clicked]->IsToggle())
		{
			if (!Buttons[clicked]->IsToggle())
				Buttons[clicked]->SetState(FALSE);
			if (!Buttons[clicked]->Repeats())
				Buttons[clicked]->ButtonFunc();
		}
		clicked = -1;
	}
}

void TButtonPane::MouseMove(int button, int x, int y)
{
	if (button == MB_LEFTDOWN && clicked >= 0)
	{
		if (Buttons[clicked]->OnButton(x, y))
		{
			if (Buttons[clicked]->GetState() == FALSE &&
				!Buttons[clicked]->IsToggle())
				Buttons[clicked]->SetState(TRUE);
		}
		else
		{
			if (Buttons[clicked]->GetState() == TRUE ||
				!Buttons[clicked]->IsToggle())
				Buttons[clicked]->SetState(FALSE);
		}
	}
}

BOOL TButtonPane::NewButton(PTButton b)
{
	if (b)
		return (Buttons.Add(b) >= 0);

	CheckGroup(b->RadioGroup());

	return FALSE;
}

void TButtonPane::ClearGroup(int group)
{
	if (group < 0)
		return;

	for (TPointerIterator<TButton> i(&Buttons); i; i++)
		if (i.Item()->RadioGroup() == group)
			i.Item()->SetState(FALSE);
}

void TButtonPane::CheckGroup(int group)
{
	if (group < 0)
		return;

	for (TPointerIterator<TButton> i(&Buttons); i; i++)
		if (i.Item()->RadioGroup() == group)
		{
			i.Item()->SetState(TRUE);
			break;
		}
}

// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                 character.cpp - TCharacter module                     *
// *************************************************************************

#include <windows.h>
#include <math.h>
#include <string.h>

#include "revenant.h"
#include "character.h"
#include "rules.h"
#include "mappane.h"
#include "display.h"
#include "spell.h"
#include "sound.h"
#include "playscreen.h"
#include "multi.h"
#include "animation.h"
#include "statusbar.h"
#include "dialog.h"
#include "effect.h"
#include "textbar.h"
#include "3dimage.h"
#include "inventory.h"
#include "exit.h"
#include "script.h"
#include "effect.h"
#include "charanimator.h"
#include "weapon.h"
#include "player.h"

#define GRIDSNAPSIZE	48

REGISTER_BUILDER(TCharacter)
TObjectClass CharacterClass("CHARACTER", OBJCLASS_CHARACTER, 0);

extern TObjectClass EffectClass;

// Hard coded character class stats
DEFSTAT(Character, Radius,          RAD,  0, 16, 16, 256)

// Hard coded character object stats
DEFOBJSTAT(Character, Aggressive,	AGGR, CHRFLAG_FIRST + CHRFLAG_AGGRESSIVE, 1, 0, 1)
DEFOBJSTAT(Character, Poisoned,		PSND, CHRFLAG_FIRST + CHRFLAG_POISONED, 0, 0, 1)
DEFOBJSTAT(Character, Sleeping,		SLP,  CHRFLAG_FIRST + CHRFLAG_SLEEPING, 0, 0, 1)

DEFOBJSTAT(Character, Health,		HLT,  CHRSTAT_FIRST + CHRSTAT_HEALTH, 25, 0, 10000)
DEFOBJSTAT(Character, Fatigue,		FAT,  CHRSTAT_FIRST + CHRSTAT_FATIGUE, 25, 0, 10000)
DEFOBJSTAT(Character, Mana,			MAN,  CHRSTAT_FIRST + CHRSTAT_MANA, 25, 0, 10000)

extern TDialogPane DialogPane;

// Some character defines
#define IMPACT_THRESHOLD	4	// how much damage has to be done before they enter impact state
#define MAXENEMYRANGE		512 // Maximum range of enemy

// *************************************************************
// *                          Character                        *
// *************************************************************

void TCharacter::ClearChar()
{
	flags |= OF_MOVING | OF_PULSE | OF_ANIMATE | OF_AI; // Is moving object, pulse, animate, and has AI

	waittype = WAIT_NOTHING;
	waitticks = 0;
	forcecommanddone = FALSE;
	forcenomove = FALSE;
	is_invisible = FALSE;

    // When character loaded or created, make exit timestamp current..
	// Prevents ONEXIT flag from expiring when character is saved on top of a
	// destination exit.
	exittimestamp = CurrentScreen->FrameCount();

  // Set root state
  // NONE: DefaultRootState() will NOT be virtual when ClearChar()
  // is called in the constructor!
	if (!root)
		root = doing = desired = new TActionBlock(DefaultRootState() /* SEE ABOVE NOTE */);
	else
		strcpy(root->name, DefaultRootState());

	int newstate = FindState(root->name);
	if (newstate < 0)
		newstate = FindState("walk");
	if (newstate < 0)
		newstate = FindState("combat");
	if (newstate < 0)
		newstate = 0;
	state = newstate;

  // Set character data pointer
	chardata = Rules.GetCharData(objtype, objclass);

  // Set initial health/fatigue/mana values
	SetHealth(MaxHealth());
	SetFatigue(MaxFatigue());
	SetMana(MaxMana());

  // Reset AI data
	nextattack = -1;
	shovedir = -1;				  // Block go around direction choice
	glimpse = noise = -1;		  // Reset glimpse and noise values
}

void TCharacter::Pulse()
{
//	if (!animator)	// Quick hack to fix super slodown... BEN  (if not on screen, ignore me)
//		return; 

	if (forcecommanddone)
	{
		if (doing)
			doing->wait = 0;

		commanddone = TRUE;
		forcecommanddone = FALSE;
	}

	TComplexObject::Pulse();

	// Signal processing - let other characters know what's going on
	PTCharacter target = Fighting();
	if (target)
		target->SignalHostility(this, target);

	// Check to see if exit flag has expired (exit flags are set by exit objects)
	// Exits search through character list to tag character that it is on an exit.  Characters
	// then check the time stamp and clear themselves after two frames.  This system prevents
	// the old reflective exit bug, where an exit takes a character to another exit, which
	// then takes him back to the first... etc. etc. as the character can only activate an
	// exit when he was previously (in the past two frames) not already on one.
	if (exittimestamp < CurrentScreen->FrameCount() - 2)
		SetFlag(OF_ONEXIT, FALSE);

	if (IsDead())
	{
		Halt();	// Don't go anywhere!

		if (script)	// Hey Mr. Script.. , I'm dead now...
			script->Trigger(TRIGGER_DEAD);
		return;			// all processing below is for alive characters only
	}

	// Do the character's AI now
	AI();

	// Recover health, fatigue, and mana
	// This code checks last recovery time stamps (in game 100ths of a second) to see
	// if the health,fatigue, or mana for a character need to be updated.  The time stamps
	// are actually saved with the character data, so even if a character has been unloaded
	// for a while, when he is reloaded, he will have the proper health,mana,and fatigue based
	// on the elapsed game time.
	int gametime = PlayScreen.GameTime();
	int pcnt;
	if (Health() < MaxHealth() && gametime - lasthealthrecov >= Rules.healthrecovrate)
	{
		pcnt = ((gametime - lasthealthrecov) / Rules.healthrecovrate) * Rules.healthrecovval;
		SetHealth(max(MaxHealth(), Health() + (MaxHealth() * pcnt / 100)));
		lasthealthrecov = gametime;
	}
	if (Fatigue() < MaxFatigue() && gametime - lastfatiguerecov >= Rules.fatiguerecovrate)
	{
		pcnt = ((gametime - lastfatiguerecov) / Rules.fatiguerecovrate) * Rules.fatiguerecovval;
		SetFatigue(max(MaxFatigue(), Fatigue() + (MaxFatigue() * pcnt / 100)));
		lastfatiguerecov = gametime;
	}
	if (Mana() < MaxMana() && gametime - lastmanarecov >= Rules.manarecovrate)
	{
		pcnt = ((gametime - lastmanarecov) / Rules.manarecovrate) * Rules.manarecovval;
		SetMana(max(MaxMana(), Mana() + (MaxMana() * pcnt / 100)));
		lastmanarecov = gametime;
	}

	// Handle affects
/*	if (IsPoisoined()poison > 0)
	{
		poisonaccum += poison;
		int dam = poisonaccum / POISON_SPEED;
		if (dam)
		{
			Damage(dam, DAMAGE_POISON);
			poisonaccum -= dam * POISON_SPEED;

			// give a chance for it to wear off
//			if (GetResistance(DAMAGE_POISON) >= random(0, 100) || random(0, 20) == 7)
//				poison--;
		}
	}
*/
}

void TCharacter::UpdateAction(int bits)
{
  // Reset stealth values for every move (when not in root state)
	if ((commanddone && root != doing) || glimpse < 0 || noise < 0)
		ResetStealthValues();

  // Set sleep to awake if doing non sleeping root states
	if (root->Is("walk") || root->Is("combat"))
		SetSleeping(0);

  // ********************************************************************
  // Animation 'commanddone' state is set, now process this state through
  // the ACTION handlers.  If nothing sets the command state, we set it by
  // seeing if the character is doing anything.  This is defined as either
  // being in the root state, having the current animation completed.
	int comstate = ResolveAction(bits);
	if (comstate == 0)
		comstate = (commanddone || !animator || (flags & OF_INVISIBLE)) ? // If done, or not animating..										// Done if finished animating
			COM_COMPLETED : COM_EXECUTING;

  // Reset priority when command complete	
	if (comstate == COM_COMPLETED && doing->priority)
		doing->priority = FALSE;

  // Set firstime flag to FALSE
	if (doing->firsttime)
		doing->firsttime = FALSE;

  // ********************************************************************
  // Now continue the script (before the code below sets the Action Block for the
  // next frame.  The script is currently paused if this code is running.  Ordinary
  // script CMD_WAITS always wait on the next command being finished (WAIT_NOTHING).
  // Special waits can set the WAIT_ flags to wait on other things.
	if (GetScript())
	{
		BOOL continuescript = FALSE;

		if (waittype == WAIT_NOTHING && comstate == COM_COMPLETED) // Ordinary wait action done
			continuescript = TRUE;
		else if (waittype == WAIT_TICKS)						   // Wait for ticks done
		{
			waitticks--;
			if (waitticks <= 0)
				continuescript = TRUE;	
		}
		else if (waittype == WAIT_RESPONSE && DialogPane.HasResponded())  // Wait for a response	
		{
			ScriptJump(DialogPane.GetResponseLabel());
			waittype = WAIT_NOTHING;
			continuescript = TRUE;
			DialogPane.Hide(); // Done with dialog pane, now hide it
		}
		else if (waittype == WAIT_CHAR_DONE && comstate == COM_COMPLETED)
		{
			if (!doing->obj || ((PTCharacter)doing->obj)->IsInRoot())
				continuescript = TRUE;
		}

	  // NEXT LINE: Next line in script
		if (continuescript)
		{
			commanddone = TRUE;				// Force animation state to done
			comstate = COM_COMPLETED;		// Force command state to COMPLETED
			if (desired)					// Break whatever is animating!
				desired->priority = FALSE;
			if (doing)						// Break whatever is animating!
				doing->priority = FALSE;
			waittype = WAIT_NOTHING;		// Don't wait anymore
			ContinueScript();
		}
	}


  // ********************************************************************
  // Now set the action blocks for the next frame.  The rules are:
  //
  // If an action block is compleded, and it's not a ROOT2ROOT block, it
  // just sits there with the desired and doing doing the same thing.
  // If the animation is a looping animation, it resets the frame and does
  // it again.  If the animation is ROOT2ROOT, it just transitions back to
  // the root state.

  // Cause character to fall if move bits flag has fall
	if (bits & MOVE_FALLING)
		comstate = ForceCommand(new TActionBlock("fall"), bits);
	else
		comstate = TryCommand(desired, bits);

  // ********************************************************************
  // Decrement the wait value (if any)

	if (doing && doing->wait > 0)
		doing->wait--;
}

int TCharacter::ResolveAction(int bits)
{
	int comstate = TComplexObject::ResolveAction(bits);
	if (comstate != 0)
		return comstate;

  // Check for movement	
	if (doing->action == ACTION_MOVE)
		comstate = ResolveMove(doing, bits);
	else if (doing->action == ACTION_ATTACK) 
		comstate = ResolveAttack(doing, bits);
	else if (doing->action == ACTION_INVOKE)
		comstate = ResolveInvoke(doing, bits);
	else if (doing->action == ACTION_IMPACT)
		comstate = ResolveImpact(doing, bits);
	else if (doing->action == ACTION_BLOCK)
		comstate = ResolveBlock(doing, bits);
	else if (doing->action == ACTION_COMBATMOVE)
		comstate = ResolveCombatMove(doing, bits);
	else if (doing->action == ACTION_COMBAT)
		comstate = ResolveCombat(doing, bits);
	else if (doing->action == ACTION_COMBATLEAP)
		comstate = ResolveLeap(doing, bits);
	else if (doing->action == ACTION_SAY)
		comstate = ResolveSay(doing, bits);
	else if (doing->action == ACTION_PULL)
		comstate = ResolvePull(doing, bits);
	else if (doing->action == ACTION_PIVOT)
		comstate = ResolvePivot(doing, bits);
	else if (doing->action == ACTION_DEAD)
		comstate = ResolveDead(doing, bits);
	
	return comstate;
}

void TCharacter::Animate(BOOL draw)
{
	TObjectInstance::Animate(draw);

	if (animator && draw && doing && 
		doing->action == ACTION_SAY && 
		doing->data &&
		doing->wait > 12) // Leave a half a second between sentences
	{
		SRect r;
		Display->GetClipRect(r);

		SColor color = { 0, 150, 255 };

		if (this == (PTCharacter)Player)
		{
			color.red = 200;
			color.green = 0;
			color.blue = 0;
		}

		int x, y;
		WorldToScreen(pos, x, y);

		PlayScreen.AddPostCharText((char *)doing->data, x, y - 120, &color, r.right - r.left + 1 - 32);
	}
}

void TCharacter::Notify(int notify, void *ptr)
{
	// **** WARNING!!! MAKE SURE YOU CHECK FOR BROKEN LINKS AND DELETED OBJECTS HERE!!! ****
	// If you want to be notified, you must call SetNotify() in your contsructor

	TComplexObject::Notify(notify, ptr);
}

#define MAXZMOVE 32

BOOL TCharacter::Blocked(S3DPoint &pos, S3DPoint &newpos, DWORD bits, int *height, PTCharacter *bychar)
{
	int h;
	if (!height)
		height = &h;

  // Get walk map values in current area
	int mindelta, maxdelta;
	if (bits & MOVE_NOTMOVING)
	{
		*height = MapPane.GetWalkHeight(newpos);  // If not moving, just get what's under us
		maxdelta = mindelta = 0;
	}
	else
	{
	  // If moving, check Radius() around us to see if changes (deltas) between walk
	  // grids go to far up (maxdelta - walls, barriers), or too far down (mindelta -
	  // holes, etc.)  Also returns height underneath us.
		MapPane.GetWalkHeightRadius(newpos, Radius(), mindelta, maxdelta, *height);
	}

	int aniflags = GetAniFlags();

	PTCharacter dummybychar;
	if (!bychar)
		bychar = &dummybychar;
	*bychar = NULL;

  // Are we blocked? 
    BOOL blocked = !(bits & MOVE_FALLING) && 
		(abs(pos.z - *height) > MAXZMOVE || 
		abs(maxdelta) > MAXZMOVE || abs(mindelta) > MAXZMOVE ||
		*height == 0 || (!(aniflags & AF_FLY) && (*bychar = CharBlocking(this, newpos))));
		 
	return blocked;
}

DWORD TCharacter::Move()
{
	if (flags & OF_IMMOBILE || inventnum >= 0 || IsDead())
		return MOVE_NOTHING;

	DWORD retval = 0;

	int h = MapPane.GetWalkHeight(pos);
	int d = pos.z - h;

	if (d < -16)
		pos.z = h;
	else if (d > 16)
	{
		vel.z = max(vel.z - GRAVITY, -TERMINAL_VELOCITY);
		retval |= MOVE_FALLING;
	}

	if (d < 1)
		vel.z = 0;

	S3DPoint tmpaccum = accum;

	if (forcenomove)
		forcenomove = FALSE;
	else
		tmpaccum += nextmove;

	tmpaccum += vel;

	S3DPoint newpos = pos;
	rollover(tmpaccum.x, newpos.x);
	rollover(tmpaccum.y, newpos.y);
	rollover(tmpaccum.z, newpos.z);

	if (newpos == pos &&
		nextmove.x == 0 && nextmove.y == 0 && nextmove.z == 0 &&
		vel.x == 0 && vel.y == 0 && vel.z == 0)
			retval |= MOVE_NOTMOVING;

	int nh;

  // Check to see if character is blocked
	if (Blocked(pos, newpos, retval, &nh)) // New position is blocked
	{
	  // Check to see if character is totally stuck...
 		if (!Blocked(pos, pos, retval, &nh))
			retval |= MOVE_BLOCKED;	// If he's not totally stuck, report him as blocked
	}
	else
	{
		shovedir = -1;		// Not blocked anymore!  Reset block direction choice

		vel.x = vel.y = vel.z = 0;

		if (newpos.z != nh)
			if (vel.z < 0)
				newpos.z = nh;
			else
				newpos.z += (nh - newpos.z) / 2;

		if (retval & MOVE_NOTMOVING)
		{
			accum = tmpaccum;
			return MOVE_NOTHING;		// can only check this _after_ gravity
		}
	}

	// If blocked, check in front of char at walk granularity intervals for an open
	// path, if we find one, shove the character in that direction, and save the dir
	// in 'shovedir' so we keep shoving in the same direction until the character is 
	// stuck, or he's around the obstacle.
	if (retval & MOVE_BLOCKED) // Try to nudge!
	{
		// check nearby squares in front of char to try to find open path
		if (shovedir < 0)
		{
			for (int i = 0; i < 4; i++)
			{
				int d;
				if (i & 1)
					d = WALKMAPGRANULARITY << (i >> 1);
				else
					d = -(WALKMAPGRANULARITY << (i >> 1));

				S3DPoint v, p;
//				p = pos;
//				ConvertToVector(moveangle, 6, v);
//				p += v;
				p = newpos;
				ConvertToVector(moveangle + 64, d, v);
				p += v;

			  // Check to see if there's open space to right/left
				if (!Blocked(pos, p, retval)) // This way's ok
				{
					if (d < 0)
						shovedir = (moveangle - 64) & 255; // Go left around obstacle
					else
						shovedir = (moveangle + 64) & 255; // Go right around obstacle
					break;
				}
			}
		}

		if (shovedir >= 0)
		{
			S3DPoint v;
			ConvertToVector(shovedir, 4, v);
			newpos = pos;
			newpos += v;
			tmpaccum = accum;
			if (!Blocked(pos, newpos, retval)) // This way's ok
				retval &= ~MOVE_BLOCKED; // Go ahead and move there
		}
	}

	if (!(retval & MOVE_BLOCKED))
	{
		retval |= MOVE_MOVED;

		accum = tmpaccum;
		if (newpos != pos)
			SetPos(newpos);
	}

	return retval;
}

int TCharacter::GetDamageType(int weapontype, int attackflags)
{
	if (weapontype == WT_HAND)
	{
		return DT_HAND;
	}
	else if (weapontype == WT_SHORTBLADE || weapontype == WT_LONGBLADE)
	{
		if (attackflags & CA_THRUST)
			return DT_PUNCTURE;
		else if (attackflags & CA_SLASH)
			return DT_CUT;
		else if (attackflags & CA_CHOP)
			return DT_CHOP;
	}
	else if (weapontype == WT_BLUDGEON)
	{
		if (attackflags & CA_THRUST)
			return DT_NONE;
		else if (attackflags & CA_SLASH)
			return DT_BLUDGEON;
		else if (attackflags & CA_CHOP)
			return DT_BLUDGEON;
	}
	else if (weapontype == WT_AXE)
	{
		if (attackflags & CA_THRUST)
			return DT_NONE;
		else if (attackflags & CA_SLASH)
			return DT_CHOP;
		else if (attackflags & CA_CHOP)
			return DT_CHOP;
	}
	else if (weapontype == WT_BOW)
	{
		return DT_NONE; // Bow can't hurt anybody, only arrows
	}

	return DT_NONE;
}

// Get the total damage amount (based on this function)
int TCharacter::CalculateDamage(int damage, int damagetype, int modifier)
{
	int attackdamage, totaldamage;
	if (damagetype == DT_NONE)
		return 0;
	else
	{
		attackdamage = damage * (100 + modifier) / 100;
		totaldamage = attackdamage * (100 + DamageModifier(damagetype)) / 100;
	}

	return totaldamage;
}

void TCharacter::Damage(int damage, int damagetype, int modifier,
	PTActionBlock impact, PTActionBlock death)
{
  // Calculate total damage
	damage = CalculateDamage(damage, damagetype, modifier);

  // Apply damage to low level object
	TObjectInstance::Damage(damage);

  // Do death...
	if (Health() < 1)
	{
		if(!random(0, 2))
		{
			S3DPoint vel;
			vel.x = random(-8, 8);
			vel.y = random(-8, 8);
			vel.z = random(7, 12); 
			int count = random(6, 16);
			Pulp(vel, count, count * 30);
		}

		if (impact)
			delete impact;
		if (!death)
		{
			if (FindState("dead") < 0) // Doesn't have death, so remove character
			{
				SetFlag(OF_KILL); 
				return;
			}
			death = new TActionBlock("dead", ACTION_DEAD);
		}
		death->obj = doing->obj;
		death->interrupt = TRUE;
		ForceCommand(root);		// Make sure we play "combat to" transitions
		ForceCommand(death);
	}

  // Or do impact...
	else
	{
		if (death)
			delete death;
		if (!impact)
		{
			if (!HasActionAni("impact"))  // Do we have state, or transition state?
				return;
			impact = new TActionBlock("impact", ACTION_IMPACT);
		}
		impact->obj = doing->obj;
		impact->interrupt = TRUE;
		ForceCommand(root);		// Make sure we play "combat to" transitions
		ForceCommand(impact);
	}
}

void TCharacter::RestoreHealth()
{
	SetPoisoned(FALSE);
	SetHealth(MaxHealth());
}

// DLS brightness routine (gives brightness given distance)
extern double GetLightBrightness(int dist, int intensity, int multiplier);

// Returns the total visibility 1-100 for character (based on lights, ambient, and fog, etc.)
int TCharacter::Visibility()
{
	int brightness = 0;

	for (TMapIterator i(*this, CHECK_MAPRECT | CHECK_NOINVENT, OBJSET_LIGHTS); i; i++)
	{
		brightness += i->GetIllumination(this);
	}
	
	if (brightness <= 0)
		brightness = (int)(min(GetLightBrightness(512, 256, 40), 1.0) * 255.0);	
					// Use out of range light value (distance=512) to
					// get ambient light intensity (256 and 40 don't matter)

	if (brightness > 255)
		brightness = 255;

	return brightness * 100 / 255;
}

void TCharacter::AdvanceAngles(int faceang, int moveang, int maxturn)
{
	int dif;

  // Do face angle
	faceang &= 255;

	dif = faceang - GetFace();
	if (dif > 128)
		dif = dif - 256;
	if (dif < -128)
		dif = dif + 256;

	int newfaceang;
	if (dif < 0)
		newfaceang = (GetFace() + max(dif, -maxturn)) & 255;
	else
		newfaceang = (GetFace() + min(dif, maxturn)) & 255;

  // Do move angle
	moveang &= 255;

	dif = moveang - GetMoveAngle();
	if (dif > 128)
		dif = dif - 256;
	if (dif < -128)
		dif = dif + 256;

	int newmoveang;
	if (dif < 0)
		newmoveang = (GetMoveAngle() + max(dif, -maxturn)) & 255;
	else
		newmoveang = (GetMoveAngle() + min(dif, maxturn)) & 255;

	if (newfaceang != GetFace())
		FaceOnly(newfaceang);

	if (newmoveang != GetMoveAngle())
		SetMoveAngle(newmoveang);
}

#define MAXCHANGE	200
#define STOPHEIGHT	50

int TCharacter::UpdateAngle(int angle)
{
/*
	int ba = angle;
	int bd = 1000000;

	for (int a = angle - 16; a < angle + 16; a += 1)
	{
		S3DPoint vect;
		ConvertToVector(a, 250, vect);

		int lh = MapPane.GetWalkHeight(pos), delta = 0, h;
		S3DPoint targ = pos, i = pos;
		targ += vect;

		if (vect.x == 0)
		{
			for (i.y = pos.y + 1; i.y < targ.y; i.y++)
			{
				h = MapPane.GetWalkHeight(i);
				delta += absval(h - lh);
				lh = h;

				if (h > STOPHEIGHT || delta > MAXCHANGE)
					break;
			}
		}
		else if (vect.y == 0)
		{
			for (i.x = pos.x + 1; i.x < targ.x; i.x++)
			{
				h = MapPane.GetWalkHeight(i);
				delta += absval(h - lh);
				lh = h;

				if (h > STOPHEIGHT || delta > MAXCHANGE)
					break;
			}
		}
		else
		{
			int dist = (int)sqrt((double)(sqr(vect.x) + sqr(vect.y)));
			float yr = (float)vect.y / (float)dist;
			float xr = (float)vect.x / (float)dist;
			S3DPoint oldpoint = i;

			for (int j = 1; j < dist; j++)
			{
				i.x = (int)(xr * (float)j);
				i.y = (int)(yr * (float)j);
				i += pos;

				if (oldpoint.x != i.x && oldpoint.y != i.y)
				{
					h = MapPane.GetWalkHeight(i);
					delta += absval(h - lh);
					lh = h;
				}

				oldpoint = i;

				if (h > STOPHEIGHT || delta > MAXCHANGE)
					break;
			}
		}

		int d = (int)sqrt((double)SQRDIST(i, targ));

		if (d < bd)
		{
			bd = d;
			ba = a;
		}
	}

	return ba;
*/
	int ch = MapPane.GetWalkHeight(pos);
	int nudge = 0;
	S3DPoint c;
	c.z = 0;

	// hum...need to make this keep some sort of static nudge
	// value in order to avoid the quivering affect.
	// possibly need to reset that when the target location
	// is changed, as well.
	// also - in the case of a coridor, need to make sure that
	// no matter what way they are facing it always sends them
	// straight down it.

	for (c.y = pos.y - 32; c.y <= (pos.y + 32); c.y += 16)
		for (c.x = pos.x - 32; c.x <= (pos.x + 32); c.x += 16)
		{
			if (c.y == pos.y && c.x == pos.x)
				continue;

			if (absval(MapPane.GetWalkHeight(c) - ch) < 30)
				continue;

			int dist = (sqr(64) - SQRDIST(c, pos)) / 100;
			dist = min(50, max(1, dist));

			int ang = ConvertToFacing(pos, c) - GetFace();

			int weight = (dist * (64 - absval(ang))) / 100;

			if (weight < 1)
				continue;

			if (ang > 0)
				nudge -= weight;
			else
				nudge += weight;
		}

	return angle;
}

PTObjectInstance TCharacter::FindObjAhead()
{
	S3DPoint pos, v;
	GetPos(pos);
	ConvertToVector(GetFace(), 60, v);
	pos += v;

	int list[MAXFOUNDOBJS];
	int n = MapPane.FindObjectsInRange(pos, list, 60);

	PTObjectInstance best = NULL;
	int bestdist;

	for (int i = 0; i < n; i++)
	{
		PTObjectInstance oi = MapPane.GetInstance(list[i]);
		if (!oi)
			continue;

		if (oi->CursorType() != CURSOR_NONE || oi->IsInventoryItem())
		{
			int dist = Distance(oi);

			if (best == NULL || dist <= bestdist)
			{
				best = oi;
				bestdist = dist;
			}
		}
	}

	return best;
}

// ***********************
// * General AI Routines *
// ***********************

int TCharacter::ResolveMove(PTActionBlock ab, int bits)
{
	if (bits & MOVE_BLOCKED)
	{
		SetDesired(NULL);
		return COM_COMPLETED;
	}

	BOOL advanceang = TRUE;

	if (ab->target.x > 0 || ab->target.y > 0 || ab->target.z > 0)
	{
		BOOL exact = FALSE;
		int endfacing = -1;

#if 0
		if (ab->data)
		{
			exact = ((int *)ab->data)[0];
			endfacing = ((int *)ab->data)[1];
		}
#endif

		if (exact)
		{
			int sqrdist = dist(pos.x, pos.y, ab->target.x, ab->target.y);
			
			if (sqrdist < 16)
			{
				ab->terminating = TRUE;

				// start adjusting the angle
				if (endfacing >= 0)
				{
					advanceang = FALSE;
					int savefacing = facing;
					AdvanceAngles(endfacing, endfacing, 128);
					facing = savefacing;
				}

				// make sure he hits the point exactly
				S3DPoint newpos = pos;
				newpos += nextmove;
				if (sqrdist < dist(newpos.x, newpos.y, ab->target.x, ab->target.y))
					forcenomove = TRUE;

				return COM_COMPLETED;
			}
			else
			{
				ab->angle = ConvertToFacing(pos, ab->target);
			}

		}
		else
		{
			if (dist(pos.x, pos.y, ab->target.x, ab->target.y) < 32)
			{
				ab->terminating = TRUE;
				return COM_COMPLETED;
			}
			else
			{
				ab->angle = ConvertToFacing(pos, ab->target);
			}
		}
		if (ab->terminating)
		{
			return COM_COMPLETED;
		}
	}

	if (!GridSnap)
	{
		if (advanceang)
			AdvanceAngles(ab->angle, ab->angle, 128);
	}
	else
	{
		if (commanddone)
			Face(ab->angle);
	}
	
	if (doing && desired && !ab->stop) // Take another step unless we were stopped
	{
	  // Single forward animation
		if (doing->Is(StName(root->name, "f")) && !desired->Is(StName(root->name, "f")))
		{
			SetDesired(doing); // Just keep looping it!
		}
	  // Left step
		else if (doing->IsLeft(root->name) && !desired->IsRight(root->name))
		{
			PTActionBlock newab = new TActionBlock(*doing);
			newab->stop = newab->interrupt = FALSE;
			strcpy(newab->name, StName(root->name, "r"));
			SetDesired(newab);
		}
      // Right step   
		else if (doing->IsRight(root->name) && !desired->IsLeft(root->name))
		{
			PTActionBlock newab = new TActionBlock(*doing);
			newab->stop = newab->interrupt = FALSE;
			strcpy(newab->name, StName(root->name, "l"));
			SetDesired(newab);
		}
	}

	return COM_EXECUTING;
}

int TCharacter::ResolveAttack(PTActionBlock ab, int bits)
{
	PTCharacter targ = (PTCharacter)ab->obj;
	PSCharAttackData attack = ab->attack;

  // Make sure moving angle equals face (it doesn't during a combat move)
	SetMoveAngle(GetFace());

	int dist, angle;
	if (targ)
	{
		dist = Distance(targ);
		angle = FaceAngleTo(targ);
	}
	else
	{
		dist = 0;
		angle = 0;
	}

  // Do this
	if (ab->firsttime)
	{
	  // Signal our opponent that he's getting wailed on
		if (targ)
			targ->SignalAttack(this, ab->obj);
	}

  // If we have target, and frame has reached trigger time for impact, then do the impact.
	if (attack && frame == attack->impacttime)
	{
		int damage = 0;

	  // Check to see if impact is even possible?	
		if (targ &&
			dist >= attack->hitminrange &&
			dist <= attack->hitmaxrange && 
			abs(angle) <= attack->hitangle)
		{

			S3DPoint vect;
			ConvertToVector(facing, 4 * ROLLOVER, vect);
			((PTCharacter)ab->obj)->vel += vect;

		  // Chance to hit is concatenation of all the below
		  // Note: To hit value is based on the following formula
		  // 
		  //	Armor + DefenseModifier + FatigueModifier(always negative) - AttackModifier
		  // 
		  //    This TOHIT value should 'almost' always be less than 25.  If it is greater,
		  //    the random value will be 1-(tohit + 1) to always give the char a chance to hit.  
		  // 
			int targangle = targ->FaceAngleTo(this);
			int tohit = targ->ArmorValue() + targ->DefenseModifier() + 
				targ->FatigueModifier() - AttackModifier();
			int maxroll = max(25, tohit + 1);			
			if (abs(targangle) < 48  &&					// HALVE hit chances if blocking/dodging
				(targ->IsDoing(ACTION_BLOCK) || targ->IsDoing(ACTION_DODGE)))
				tohit += (maxroll - tohit + 1) / 2;
			if (abs(targ->FaceAngleTo(this)) >= 48 ||	// If not facing us or...
				targ->IsDoing(ACTION_ATTACK))			// is currently trying to do an attack
				tohit -= (maxroll - tohit + 1) / 2;		// Then DOUBLE hit chances

		  // Did we do any damage whatsoever?
			damage = 0; 
			if (random(1, maxroll) > tohit)
			{
				damage = targ->CalculateDamage(WeaponDamage(), 
					GetDamageType(WeaponType(), attack->flags), attack->damagemod);
			}
		}

	  // We hit and did damage!
		if (damage > 0)			// ****** CODE FOR HIT *******
		{
		  // Do snap if needed
			if (attack->snapdist > 0)
				targ->SnapDist(this, attack->snapdist);

		  // Create a special DEATH action to use for Damage() function
			PTActionBlock deathab, impactab;
			deathab = impactab = NULL;
			if (targ->Health() - damage < 1)
			{
				char *deathname = "dead";
				if (targ->HasActionAni(attack->deathname))
					deathname = attack->deathname;
				deathab = new TActionBlock(deathname, ACTION_DEAD);
				deathab->obj = targ->doing->obj;
				deathab->priority = TRUE;
				deathab->attack = attack;
				targ->SetFighting(this);
			}

		  // Create a special impact command to use for Damage() function
			else
			{
			  // If we're not fighting anyone, fight the guy who just hit us
				if (!targ->Fighting())
				{
					// not fighting - shall we engage this target?
					if (dist <= targ->chardata->combatrange)
						targ->BeginCombat(this);
				}

			  // Get impact animations
				char *impactname = "impact";
				if (targ->HasActionAni(attack->impactname))
				{
					impactname = attack->impactname;
					targ->SetFighting(this); // If special impact, face char to impact
				}
				impactab = new TActionBlock(impactname, ACTION_IMPACT);
				impactab->obj = targ->doing->obj;
				impactab->interrupt = TRUE;
				impactab->attack = attack;
				impactab->wait = attack->stunwait;
			}

			targ->Damage(WeaponDamage(), 
					GetDamageType(WeaponType(), attack->flags),
					attack->damagemod,
					impactab, deathab);
		}
		else							// ****** CODE FOR MISS ******
		{
			PTActionBlock missab;

		  // Do we play miss animation, or return straightway to combat state? 
			if (!(attack->flags & CA_NOMISS))
			{
				if (HasActionAni(attack->missname))
				{
					missab = new TActionBlock(attack->missname, ACTION_MISS);
					missab->attack = attack;
				}
				else
				{
					missab = new TActionBlock("combat", ACTION_COMBAT);
					PLAY(listrnd(chardata->misssounds));  // Play default sounds
				}
				missab->interrupt = TRUE;
				missab->obj = ab->obj;
				SetDesired(missab);
			}
			
          // Play block sound do sparks
			if (targ && targ->doing->action == ACTION_BLOCK)
			{
				if (attack->flags && CA_SPARKS)
					EffectBurst("sparks");
				PLAY(listrnd(chardata->blocksounds));
			}
		}
	}

	return 0;
}

int TCharacter::ResolveImpact(PTActionBlock ab, int bits)
{
  // Make sure moving angle equals face (it doesn't during a combat move)
	SetMoveAngle(GetFace());

#if 0
	static int frame;
	if (ab->firsttime)
		frame = 0;

	if (frame < 4)
	{
		int x, y;
		S3DPoint fpos = pos;
		fpos.z += 75;
		S3DPoint vect;
		ConvertToVector(facing, 14, vect);
		fpos += vect;
		WorldToScreen(fpos, x, y);
		PlayScreen.AddPostCharAnim(x, y, 0, GameData->Animation("flashred")->GetFrame(frame++), DM_ALPHA);
	}
#endif

  // Do blood for impale	
	if ((ab->Is("impale") && random(0, 5) == 1))
		EffectBurst("blood", ab->Is("impale") ? 40 : 50);
	
  // Do blood for attack
	if (ab->firsttime && (!ab->attack || (ab->attack->flags & CA_BLOOD)))
		EffectBurst("blood", ab->Is("impale") ? 40 : 50);

  // Return from looping or root impact states.
  // This allows some impacts to be used as death states.  For example, the impact state is
  // a looping root state of the guy on the ground, and the impact has a "impact to combat"
  // state where the guy gets up again and goes back to fight pose.  The impact state will
  // use the get up transition, where the death state will just loop forever in the 'on the ground'
  // animation.
  // It also allows some impacts to have looping "stun" states where the attack sets the
  // wait value of the action block to 'stunwait', and the impact loop plays until 'wait'
  // is exauhsted.
	if (commanddone && ab->wait <= 0)
	{
		PTActionBlock newab = new TActionBlock("combat", ACTION_COMBAT);
		newab->interrupt = TRUE;
		SetDesired(newab);
	}
						
	return 0;
}

int TCharacter::ResolveBlock(PTActionBlock ab, int bits)
{
	if (ab->wait <= 0 || (doing && doing->stop))
	{
		ab->wait = 0;
		SetDesired(NULL);
		return COM_COMPLETED;
	}

	return COM_EXECUTING;
}

int TCharacter::ResolveDead(PTActionBlock ab, int bits)
{
  // Make sure moving angle equals face (it doesn't during a combat move)
	SetMoveAngle(GetFace());

	return COM_EXECUTING;
}


void TCharacter::EffectBurst(char *name, int height)
{
	extern TObjectClass EffectClass;

	SObjectDef def;
	memset(&def, 0, sizeof(SObjectDef));

	def.objclass = OBJCLASS_EFFECT;
	def.objtype = EffectClass.FindObjType(name);

	def.pos = pos;
	def.level = MapPane.GetMapLevel();

	int index = MapPane.NewObject(&def);
	PTObjectInstance inst = MapPane.GetInstance(index);
	if (!inst)
		return;

	inst->CreateAnimator();
	PTParticle3DAnimator anim = (PTParticle3DAnimator)inst->GetAnimator();

	int ang = (GetFace() + random(-80, 80)) & 0xff;

	S3DPoint vect;
	ConvertToVector(ang, 100, vect);

	if (anim)
	{
		SParticleParams pr;

		if (stricmp(name, "blood") == 0)
		{
			pr.particles = random(5, 10);
			pr.pos.x = (D3DVALUE)0.0;
			pr.pos.y = (D3DVALUE)0.0;
			pr.pos.z = (D3DVALUE)height;
			pr.pspread.x = (D3DVALUE)3.0;
			pr.pspread.y = (D3DVALUE)3.0;
			pr.pspread.z = (D3DVALUE)3.0;
			pr.dir.x = (D3DVALUE)((float)vect.x / (float)100.0);
			pr.dir.y = (D3DVALUE)((float)vect.y / (float)100.0);
			pr.dir.z = (D3DVALUE)((float)vect.z / (float)100.0);
			pr.spread.x = (D3DVALUE)0.5;
			pr.spread.y = (D3DVALUE)0.5;
			pr.spread.z = (D3DVALUE)0.5;
			pr.gravity = (D3DVALUE)0.3;
			pr.trails = 3;
			pr.minstart = 0;
			pr.maxstart = 8;
			pr.minlife = 10;
			pr.maxlife = 30;
			pr.bounce = FALSE;
			pr.killobj = TRUE; 
			pr.objflags = 0xF;
			pr.seektargets = FALSE;
			pr.numtargets = 0;
		}
		else
		{
			S3DPoint vect0, tpos;
			doing->obj->GetPos(tpos);
			ang = ConvertToFacing(pos, tpos);
			int dist = TObjectInstance::Distance(doing->obj);
			ConvertToVector(ang, dist / 2, vect0);
			vect0.z += 45;

			pr.particles = random(15, 25);
			pr.pos.x = (D3DVALUE)vect0.x;
			pr.pos.y = (D3DVALUE)vect0.y;
			pr.pos.z = (D3DVALUE)vect0.z;
			pr.pspread.x = (D3DVALUE)3.0;
			pr.pspread.y = (D3DVALUE)3.0;
			pr.pspread.z = (D3DVALUE)3.0;
			pr.dir.x = (D3DVALUE)((float)vect.x / (float)100.0);
			pr.dir.y = (D3DVALUE)((float)vect.y / (float)100.0);
			pr.dir.z = (D3DVALUE)((float)vect.z / (float)100.0);
			pr.spread.x = (D3DVALUE)0.5;
			pr.spread.y = (D3DVALUE)0.5;
			pr.spread.z = (D3DVALUE)0.5;
			pr.gravity = (D3DVALUE)0.2;
			pr.trails = 1;
			pr.minstart = 0;
			pr.maxstart = 8;
			pr.minlife = 20;
			pr.maxlife = 40;
			pr.bounce = FALSE;
			pr.killobj = TRUE; 
			pr.objflags = 1 << (ObjId() & 0x3);
			pr.seektargets = FALSE;
			pr.numtargets = 0;
		}

		anim->InitParticles(&pr);
	}
}

int TCharacter::ResolveCombat(PTActionBlock ab, int bits)
{
	// line them up with whoever they are fighting
	if (ab->obj)
	{

	  // If target is dead, change to new target, or end combat
		PTCharacter targ = (PTCharacter)ab->obj;
		if (targ->IsDead())
		{
			targ = FindClosestEnemy();
			if (!targ)
			{
				EndCombat();
				return 0;
			}
			else
			{
				SetFighting(targ);
			}
		}

	  // If walking, set proper walk animation for current monster direction
		S3DPoint target;
		ab->obj->GetPos(target);
		int angle = ConvertToFacing(pos, target);

		if (ab->action == ACTION_COMBATMOVE && !ab->stop) // If angle to target has changed, get new walk anim
		{
			int roundangle = ((angle + 15) & 0xE0); // round to 8 dirs
			int diff = ab->moveangle - roundangle;
			int anim = (diff & 255) / 32;

			char *animname;
			switch (anim)
			{
				case 0: animname = "combatf"; break;
				case 1: animname = "combatfr"; break;
				case 2: animname = "combatr"; break;
				case 3: animname = "combatbr"; break;
				case 4: animname = "combatb"; break;
				case 5: animname = "combatbl"; break;
				case 6: animname = "combatl"; break;
				case 7: animname = "combatfl"; break;
			}
			
			if (!ab->Is(animname))  // Not already going this way
			{
				PTActionBlock newab = new TActionBlock(animname, ACTION_COMBATMOVE);
				newab->angle = angle;
				newab->moveangle = ab->moveangle;
				newab->obj = ab->obj;
				SetDesired(newab);
			}
		}

	  // Change facing angle here, but don't change movement angle
		FaceOnly(angle);
		SetMoveAngle(ab->moveangle);
	}

	return 0;
}

int TCharacter::ResolveCombatMove(PTActionBlock ab, int bits)
{
	if (bits & MOVE_BLOCKED || ab->stop)
	{
		ForceCommand(root);
		return COM_COMPLETED;
	}

	if (!IsDesired(ACTION_COMBATMOVE) && !ab->stop) // Set next step if not stopped
		SetDesired(doing);	

	return ResolveCombat(ab, bits);
}

int TCharacter::ResolveLeap(PTActionBlock ab, int bits)
{
	return ResolveCombat(ab, bits);
}

int TCharacter::ResolvePull(PTActionBlock ab, int bits)
{
	int start;

	if (!ab->data)
		return 0;

	start = ((int *)ab->data)[0];

	if ((start == LEVER_PULLSOUTH) || (start == LEVER_PULLNORTH))
	{
		if (commanddone && ab->obj)
		{
			if (start == LEVER_PULLNORTH)
			{
				if (ab->obj->GetState() == EXIT_OPEN)
					ab->obj->SetState( EXIT_CLOSING);
			}
			else
			{
				if (ab->obj->GetState() == EXIT_CLOSED)
					ab->obj->SetState( EXIT_OPENING);
			}
		}
	}

	if ((start == LEVER_PUSHSOUTH) || (start == LEVER_PUSHNORTH))
	{
		if (ab->firsttime && ab->obj)
		{
			if (start == LEVER_PUSHNORTH)
			{
				if (ab->obj->GetState() == EXIT_OPEN)
					ab->obj->SetState( EXIT_CLOSING);
			}
			else
			{
				if (ab->obj->GetState() == EXIT_CLOSED)
					ab->obj->SetState( EXIT_OPENING);
			}
		}
	}

	return 0;
}

int TCharacter::ResolveSay(PTActionBlock ab, int bits)
{
	if (ab->wait <= 0 || (doing && doing->stop))
	{
		ab->wait = 0;
		SetDesired(NULL);
		return COM_COMPLETED;
	}

	return COM_EXECUTING;
}

int TCharacter::ResolvePivot(PTActionBlock ab, int bits)
{
	if (commanddone)
	{
		int pos = strlen(root->name) + 5;  // i.e. "WALKPIVOTxx"
		// Checks last characters of "xxxxPIVOTxx" to get turn values
		if (!stricmp(ab->name + pos, "fl"))
			Face((facing + 32) & 255);
		else if (!stricmp(ab->name + pos, "fr"))
			Face((facing - 32) & 255);
		else if (!stricmp(ab->name + pos, "l"))
			Face((facing + 64) & 255);
		else if (!stricmp(ab->name + pos, "r"))
			Face((facing - 64) & 255);
		else if (!stricmp(ab->name + pos, "bl"))
			Face((facing + 96) & 255);
		else if (!stricmp(ab->name + pos, "br"))
			Face((facing - 96) & 255);
		else if (!stricmp(ab->name + pos, "al"))
			Face((facing + 128) & 255);
		else if (!stricmp(ab->name + pos, "ar"))
			Face((facing - 128) & 255);
			 
		if (animator)		// Since hips are rotated, interpolation will cause it to rotate even more
			animator->ClearPrevState(); // So clear prev ani so it won't interpolate

		SetDesired(NULL); // Return to root state
	}

	return COM_EXECUTING;
}

int TalismanStat(int tal, char *statname)
{
	extern TObjectClass TalismanClass;

	return TalismanClass.GetStat(tal, statname);
}

int TCharacter::ResolveInvoke(PTActionBlock ab, int bits)
{
	if (ab->firsttime)
	{
		/* stuff to handle failed spellcasting should be here - a fizzle
			results when you suck due to mind stat and invocation ability,
			as compared to the power level of the spell. */

		// now calculate the values for the spell and replace the string with the value block
		PTSpellBlock spell = new TSpellBlock(this, Fighting());

		int *ptr = (int *)ab->data;
		spell->AddPower(*ptr);

		delete ab->data;		// don't need the spell values anymore

		ab->data = spell;		// point to the spell block
	}

	else //if (!ab->transition)		// don't begin execution until they have fully entered the state
	{
		PTSpellBlock spell = (PTSpellBlock)ab->data;

		/*
		BOOL kill = FALSE;
		if (ab->wait >= 3)
			kill = TRUE;

		if (commanddone && !kill)
			ab->wait++;
		
		if (((PTSpellBlock)ab->data)->Pulse(kill) && commanddone)
			return COM_COMPLETED;
		*/
		BOOL kill =	FALSE;
		if(commanddone)
			kill = TRUE;
		int result;
		result = ((PTSpellBlock)ab->data)->Pulse(kill);
		if(kill)
			return COM_COMPLETED;
	}

	return COM_EXECUTING;
}

BOOL TCharacter::IsFighting()
{
	if (IsRoot(ACTION_COMBAT))
		return TRUE;

	return FALSE;
}

BOOL TCharacter::IsFinalState()
{
	if (doing && (doing->Is("collapse") || doing->Is("dead") || doing->Is("impale") || doing->Is("fall")))
		return TRUE;

	return FALSE;
}

BOOL TCharacter::IsEnemy(PTCharacter chr)
{
	if (listin(chardata->enemies, chr->GetName()) ||
		listin(chardata->enemies, chr->GetTypeName()) )
			return chr->Aggressive();

	int numgroups = listnum(chr->chardata->groups);

	for (int c = 0; c < numgroups; c++)
	{
		if (listin(chardata->enemies, listget(chr->chardata->groups, c)))
			return chr->Aggressive() || chr->ObjClass() == OBJCLASS_PLAYER;
	}

	return FALSE;
}

// ***********************
// * General AI Routines *
// ***********************

// Change the two values below to determine when characters start fighting.
// The first number is the range to start a fight.  The second number is the
// buffer after which the fight stops - increase it if there is problems with
// characters bouncing in and out of combat mode when other characters are right
// on the edge of HOSTILITY_RANGE.
#define HOSTILITY_RANGE				(chardata->combatrange)
#define HOSTILITY_EDGE				16
#define HOSTILITY_TOTAL				(chardata->combatrange + HOSTILITY_EDGE)

void TCharacter::AI()
{
	if (flags & OF_DISABLED || Editor)
		return;

	PTCharacter target = Fighting();
	
  // We don't have a target.. try to find one
	if (!target && !Editor && Aggressive())
	{
		target = FindClosestEnemy(); // Finds the closest visible enemy (if it can see it)
		if (target && Distance((PTCharacter)target) < HOSTILITY_RANGE)
			BeginCombat(target);
	}

	if (target && doing)
	{
		if (doing->action == ACTION_COMBAT)
		{
			if (nextattack > 0)
				nextattack--;

			if (nextattack == 0)
			{
				if (random(1,100) <= chardata->blockfreq)
					Block();
				else
					RandomAttack(random(1,100));
				nextattack--;
			}
			else

			if (nextattack <= 0)
			{
				nextattack = 
					random(chardata->minattackfreq * FRAMERATE / 100, 
						   chardata->maxattackfreq * FRAMERATE / 100);
			}
		}
		else if (doing->action == ACTION_COMBATMOVE)
		{
			Stop();
		}
	}
}

BOOL TCharacter::CanHearCharacter(PTCharacter chr)
{
	BOOL hear = TRUE;
	int dist = Distance(chr);
	int noise = chr->LastNoise();
	if (dist > chardata->hearingrange ||	// Within hearing range
		 noise < (100 - Hearing(dist)))		// Last noise made was too quiet
		hear = FALSE;

	return hear;
}

BOOL TCharacter::CanSeeCharacter(PTCharacter chr, int angle)
{
	BOOL see = TRUE;

	if (angle < 1)
		angle = GetFace();
	int dist = Distance(chr);
	int angleto = AngleTo(chr);
	int anglediff = abs(AngleDiff(angle, angleto));

	int glimpse = chr->LastGlimpse();
	if (chardata->flags & CF_INFRAVISION)
		glimpse = 10000; // Always sees
	else if (chardata->flags & CF_LIGHTBLIND)
		glimpse = 100 - glimpse; // Reverse glimpse value so more light is less visible!

	S3DPoint from, to;
	GetPos(from);
	from.z += LIGHTINGCHARHEIGHT; // Nominal character height
	chr->GetPos(to);
	to.z += LIGHTINGCHARHEIGHT; // Nominal character height

	if (dist > chardata->sightrange ||
		anglediff > chardata->sightangle ||
		!MapPane.LineOfSight(from, to) ||
		glimpse < (100 - Sight(dist)))
		see = FALSE;

	return see;
}

PTCharacter TCharacter::FindCharacter(int range, int angle, int anglerange, int flags)
{
	PTCharacter best = NULL;
	int bestdist;
	
	if (range < 0 || (flags & FINDCHAR_HEAR))
		range = max(range, chardata->hearingrange);
	if (range < 0 || (flags & FINDCHAR_SEE))
		range = max(range, chardata->sightrange);

	for (TMapIterator i(Pos(), range, CHECK_NOINVENT | CHECK_MAPRECT, OBJSET_CHARACTER); i; i++)
	{
		PTCharacter chr = (PTCharacter)i.Item();

		if (chr == this)
			continue;

		if ((flags & FINDCHAR_ENEMY) && !IsEnemy(chr))
			continue;

		int dist = Distance(chr);
		int angleto = AngleTo(chr);

	 // Do we hear this guy?
		BOOL hear = TRUE;
		if (flags & FINDCHAR_HEAR)
			hear = CanHearCharacter(chr);

	  // Do we see this guy
		BOOL see = TRUE;
		if (flags & FINDCHAR_SEE)
			see = CanSeeCharacter(chr, angle); // Uses 'angle' if >= 0, otherwise uses facing
	
	  // If we can't hear him or see him, he doesn't exist	
		if (!hear && !see)
			continue;

	  // Is this guy in the direction we're checking?	
		if (angle >= 0)
		{
			int diff = abs(AngleDiff(angle, angleto));
			if (diff > anglerange)
				continue;
			dist = dist * ((anglerange + 1) - diff); // Dist gets bigger when diff between angles small
		}
	
	  // Is this the closest guy		
		if (best == NULL || dist <= bestdist)
		{
			best = chr;
			bestdist = dist;
		}
	}

	return best;
}

PTCharacter TCharacter::FindCharacterAhead(int angle, int anglerange)
{
	return FindCharacter(512, angle, anglerange, 0);
}

PTCharacter TCharacter::FindClosestEnemy(int angle, int anglerange)
{
	return FindCharacter(-1, angle, anglerange, FINDCHAR_ENEMY | FINDCHAR_SEE | FINDCHAR_HEAR);
}

// Returns a 1-100 hearing value which indicates how the average noise will be heard
// by a monster.  If the monster is sleeping, the listening value is 20% of normal. 
// The hearing value is based on the minhearing/maxhearing values in the chardata structure,
// where minhearing is the hearing value at the characters maximum hearing range, and 
// maxhearing is the hearing value right in front of the character.
int TCharacter::Hearing(int dist)
{
	dist = max(0, dist - (Radius() + 32));

	if (dist > chardata->hearingrange)
		return 0;

	int hearing = chardata->hearingmin +
		(chardata->hearingrange - dist) *
		(chardata->hearingmax - chardata->hearingmin) / 
		chardata->hearingrange;

	if (Sleeping())
		hearing = hearing * 20 / 100;

	return hearing;
}

// Returns a 1-100 sight value which indicates how the average char will be seen
// by a monster in the darkness.  The sight value is based on the minsight/maxsight
// values in the chardata structure, where minsight is the sight value at the characters
// maximum sight range, and maxsight is the sight value right in front of the character.
// If the monster is sleeping, the sight value is always 0.
int TCharacter::Sight(int dist)
{
	dist = max(0, dist - (Radius() + 32));

	if (Sleeping() || dist > chardata->sightrange)
		return 0;
	
  // Basically return min + (max - min) * dist/range
	return chardata->sightmin +
		(chardata->sightrange - dist) *
		(chardata->sightmax - chardata->sightmin) / 
		chardata->sightrange;
}

// Resets the noise and glimpse values to control whether monsters see you or not
void TCharacter::ResetStealthValues()
{
  // Figure out stealth!
	int stealthmod;
	if (IsSneakMode())
		stealthmod = Rules.sneakstealth;
	else
		stealthmod = Rules.maxstealth;
	stealthmod = stealthmod * (100 - StealthMod()) / 100;
	if (stealthmod < Rules.minstealth)
		stealthmod = Rules.minstealth;  // Always aleast ten percent

	int r = random(1, 100);

  // Get noise character made!
	noise = r * stealthmod / 100;

  // Get glimpse character made! 
	int visibility = Visibility();
	glimpse = (visibility + (r * visibility / 100)) * stealthmod / 100;
}

void TCharacter::SignalMovement(PTObjectInstance actor)
{
}

void TCharacter::SignalHostility(PTObjectInstance actor, PTObjectInstance target)
{
	if (target != this)
		return;
}

void TCharacter::SignalAttack(PTObjectInstance actor, PTObjectInstance target)
{
	if (target != this)
		return;

	if (actor == doing->obj && 
		random(1, 100) <= BlockPcnt())
		  Block();
}

void TCharacter::SetOnExit()
{
	SetFlag(OF_ONEXIT, TRUE);
	exittimestamp = CurrentScreen->FrameCount();
}

// ***********************************************************************************
// * Access functions - called by script or player to make the character do whatever *
// ***********************************************************************************

BOOL TCharacter::Go(int angle)
{
	PTActionBlock ab = NULL;

	if (!IsFighting())
	{
		if (doing == root)			// If root (standing)..
		{
			Face(angle);			// Face new direction immediately instead of turning
			root->angle = angle;
		}

		if (IsDesired(ACTION_MOVE))
		{
			ab = desired;
			ab->stop = FALSE;		// Make sure desired stop flag is false too
		}
		else
		{
			char *name = "walk";
			if (root)
				name = root->name;

			if (HasActionAni(StName(name, "f")))
				ab = new TActionBlock(StName(name, "f"), ACTION_MOVE);
			else if (FindTransitionState(name, StName(name, "l")) >= 0)
				ab = new TActionBlock(StName(name, "l"), ACTION_MOVE);
			else
				ab = new TActionBlock(StName(name, "r"), ACTION_MOVE);
		}
		
		if (IsDoing(ACTION_MOVE))
		{
			doing->stop = FALSE;	// Keep going if we we're recently stopped
			if (doing->angle != angle)
				doing->angle = angle;
		}

		ab->angle = angle;
	}
	else	// Do fighting walking
	{
	  // Do we start fighting a new character?
		PTCharacter newtarg = FindClosestEnemy(angle, 32);
		if (newtarg && newtarg != (PTCharacter)doing->obj)
			SetFighting(newtarg);

		if (!doing || !doing->obj) // If we're not facing an enemy, set facing to move angle
			Face(angle);

		if (doing->action != ACTION_COMBAT && doing->action != ACTION_COMBATMOVE)
			return FALSE;

		int roundangle = ((GetFace() + 15) & 0xE0); // round to 8 dirs
		int diff = (angle - roundangle) & 255;
		int anim = diff / 32;

		switch (anim)
		{
			case 0: ab = new TActionBlock("combatf", ACTION_COMBATMOVE); break;
			case 1: ab = new TActionBlock("combatfr", ACTION_COMBATMOVE); break;
			case 2: ab = new TActionBlock("combatr", ACTION_COMBATMOVE); break;
			case 3: ab = new TActionBlock("combatbr", ACTION_COMBATMOVE); break;
			case 4: ab = new TActionBlock("combatb", ACTION_COMBATMOVE); break;
			case 5: ab = new TActionBlock("combatbl", ACTION_COMBATMOVE); break;
			case 6: ab = new TActionBlock("combatl", ACTION_COMBATMOVE); break;
			case 7: ab = new TActionBlock("combatfl", ACTION_COMBATMOVE); break;
		}

		if (ab && doing) // Copy combat target
			ab->obj = doing->obj;

		if (doing->obj)
			ab->angle = AngleTo(doing->obj);
		else
			ab->angle = angle;
		ab->moveangle = angle;
		SetMoveAngle(angle);
	
		if (doing->action == ACTION_COMBATMOVE) // Interrupt current step if dir changes
			doing->interrupt = TRUE;
	}

	if (!HasActionAni(ab->name)) // Can't do this
	{
		if (ab != doing && ab != desired && ab != root)
			delete ab;
		return FALSE;
	}

	SetDesired(ab);
	return TRUE;
}

BOOL TCharacter::Go(S3DPoint vect)
{
	S3DPoint zero;
	memset(&zero, 0, sizeof(S3DPoint));
	int angle = ConvertToFacing(zero, vect);
	return Go(angle);
}

BOOL TCharacter::Goto(int x, int y, BOOL exact, int endfacing)
{
	if (IsFighting())
		return FALSE;
	
	PTActionBlock ab;
	char *name = root->name;

	if (FindTransitionState(name, StName(name, "f")) >= 0)
		ab = new TActionBlock(StName(name, "f"), ACTION_MOVE);
	else if (FindTransitionState(name, StName(name, "l")) >= 0)
		ab = new TActionBlock(StName(name, "l"), ACTION_MOVE);
	else
		ab = new TActionBlock(StName(name, "r"), ACTION_MOVE);

	ab->target.x = x;
	ab->target.y = y;
	ab->target.z = pos.z;
	ab->angle = ConvertToFacing(pos, ab->target);
	ab->terminating = FALSE;
#if 0
	ab->data = malloc(sizeof(int) * 2);
	((int *)ab->data)[0] = exact;
	((int *)ab->data)[1] = endfacing;
#endif

	if (!HasActionAni(ab->name)) // Can't do this
	{
		if (ab != doing && ab != desired && ab != root)
			delete ab;
		return FALSE;
	}

	SetDesired(ab);

	return TRUE;
}

BOOL TCharacter::Stop(char *name)
{
	if (!IsMoving() &&
		(!name || !doing->Is(name)))								   // Is a use specified command
		return FALSE;

	if (doing)
		doing->stop = TRUE;

	SetDesired(NULL);

	return TRUE;
}

BOOL TCharacter::Disable()
{
	SetFlags(OF_DISABLED);
	if (doing != root)
		ForceCommand(root);
	return TRUE;
}

// Causes character to jump (in normal mode, use Leap in Combat mode)
BOOL TCharacter::Jump()
{
	return FALSE;
}

// Sets walk mode
BOOL TCharacter::SetWalkMode()
{
	if (IsWalkMode())
		return TRUE;

	PTActionBlock ab = new TActionBlock("walk");

	if (doing && doing->action == ACTION_MOVE)		// If moving, change next step to new root
		desired->SwapRoot(root->name, ab->name);
	else if (doing && doing->action == ACTION_ANIMATE)  // If standing, set desired to new root
		SetDesired(ab);

  // Whatever we're doing now, we'll go back to this state when we're done
 	SetRoot(ab);

	return TRUE;
}

// Sets sneak mode
BOOL TCharacter::SetSneakMode()
{
	if (IsSneakMode())
		return TRUE;

	PTActionBlock ab = new TActionBlock("sneak");

	if (doing && doing->action == ACTION_MOVE)		// If moving, change next step to new root
		desired->SwapRoot(root->name, ab->name);
	else if (doing && doing->action == ACTION_ANIMATE)  // If standing, set desired to new root
		SetDesired(ab);

  // Whatever we're doing now, we'll go back to this state when we're done
 	SetRoot(ab);

	return TRUE;
}

// Sets run mode
BOOL TCharacter::SetRunMode()
{
	if (IsRunMode())
		return TRUE;

	PTActionBlock ab = new TActionBlock("run");

	if (doing && doing->action == ACTION_MOVE)		// If moving, change next step to new root
		desired->SwapRoot(root->name, ab->name);
	else if (doing && doing->action == ACTION_ANIMATE)  // If standing, set desired to new root
		SetDesired(ab);

  // Whatever we're doing now, we'll go back to this state when we're done
 	SetRoot(ab);

	return TRUE;
}

// Attempt to play a pivot animation towards the given delta angle
BOOL TCharacter::Pivot(int angle)
{
	if (angle > 0)
		angle = (angle + 15) & 0xE0;
	else
		angle = -((-angle + 15) & 0xE0);

	if (angle == 0)
		return TRUE;

	char buf[30];

	strcpy(buf, root->name);
	strcat(buf, "pivot");
	if (angle == 32)
		strcat(buf, "fl");
	else if (angle == -32)
		strcat(buf, "fr");
	else if (angle == 64)
		strcat(buf, "l");
	else if (angle == -64)
		strcat(buf, "r");
	else if (angle == 96)
		strcat(buf, "bl");
	else if (angle == -96)
		strcat(buf, "br");
	else if (angle == 128)
		strcat(buf, "al");
	else if (angle == -128)
		strcat(buf, "ar");

	if (FindTransitionState(root->name, buf) < 0)
	{
		Face(facing + angle);
		return TRUE;
	}

	PTActionBlock ab = new TActionBlock(buf, ACTION_PIVOT);
	ab->angle = (facing + angle) & 0xFF;
	SetDesired(ab);

	return TRUE;
}

// This obviously does nothing right now
BOOL TCharacter::FollowChar(PTObjectInstance inst)
{
	return FALSE;
}

BOOL TCharacter::Pickup(PTObjectInstance inst)
{
	if (!inst || !inst->IsInventoryItem())
		return FALSE;

	inst->RemoveFromMap();
	if (!Inventory.GetContainer()->AddToInventory(inst))
		TextBar.Print("Can't carry any more.");

/*	
	if (!inst || !inst->IsInventoryItem())
		return;

	desired = new TActionBlock("pickup");
	desired->obj = inst;*/

	return TRUE;
}

BOOL TCharacter::Pull(PTObjectInstance inst)
{
	PTActionBlock ab = new TActionBlock("Pull Front");
	int	state = inst->GetState();
	int	direction = (((PTLever)inst)->targetpos.z / 64);

	ab->obj = inst;
	ab->priority = TRUE;	// Won't do it otherwise

	ab->data = malloc(sizeof(int));

	if ((direction == 3) && (state == EXIT_OPEN))
		state = LEVER_PUSHNORTH;
	else if ((direction == 3) && (state == EXIT_CLOSED))
		state = LEVER_PULLSOUTH;
	else if ((direction == 1) && (state == EXIT_OPEN))
		state = LEVER_PULLNORTH;
	else if ((direction == 1) && (state == EXIT_CLOSED))
		state = LEVER_PUSHSOUTH;

	((int *)ab->data)[0] = state;

	SetDesired(ab);

	return TRUE;
}

// Attempts to use something in the direction character is facing
BOOL TCharacter::TryUse()
{
	S3DPoint pos, v;
	GetPos(pos);
	ConvertToVector(GetFace(), 60, v);
	pos += v;

	int list[MAXFOUNDOBJS];
	int n = MapPane.FindObjectsInRange(pos, list, 60);

	PTObjectInstance best = NULL;
	int bestdist;

	for (int i = 0; i < n; i++)
	{
		PTObjectInstance oi = MapPane.GetInstance(list[i]);
		if (!oi)
			continue;

		if (oi->ObjClass() == OBJCLASS_CONTAINER ||
			oi->ObjClass() == OBJCLASS_EXIT)
		{
			int dist = Distance(oi);

			if (best == NULL || dist <= bestdist)
			{
				best = oi;
				bestdist = dist;
			}
		}
	}

	if (!best)
	{
		TextBar.Print("Nothing to use");
		return FALSE;
	}
	
	TextBar.Print("Use %s", best->GetName());
	best->Use(this);

	return TRUE;
}

// Attempts to get something in the direction character is facing
BOOL TCharacter::TryGet()
{
	S3DPoint pos, v;
	GetPos(pos);
	ConvertToVector(GetFace(), 60, v);
	pos += v;

	int list[MAXFOUNDOBJS];
	int n = MapPane.FindObjectsInRange(pos, list, 60);

	PTObjectInstance best = NULL;
	int bestdist;

	for (int i = 0; i < n; i++)
	{
		PTObjectInstance oi = MapPane.GetInstance(list[i]);
		if (!oi)
			continue;

		if (oi->CursorType() != CURSOR_NONE || oi->IsInventoryItem())
		{
			int dist = Distance(oi);

			if (best == NULL || dist <= bestdist)
			{
				best = oi;
				bestdist = dist;
			}
		}
	}

	if (!best)
	{
		TextBar.Print("Nothing to get");
		return FALSE;
	}

	TextBar.Print("Get %s", best->GetName());
	Pickup(best);

	return TRUE;
}

BOOL TCharacter::Say(char *string, int wait, char *anim)
{
	char buf[128];
	DialogLine(string, buf, 128);  // Translate dialog line (convert [tags])

	PTActionBlock ab;
	if (anim)
		ab = new TActionBlock(anim, ACTION_SAY);
	else
		ab = new TActionBlock("say", ACTION_SAY);

	ab->data = (void *)strdup(buf);
	if (wait < 0)
		ab->wait = 15 + max(15, strlen(buf) * 5 / 4);  // Ratio of ticks to chars
	else
		ab->wait = wait;
	SetDesired(ab);

	return TRUE;
}

// Checks attack to see if it is valid or not
BOOL TCharacter::IsValidAttack(int attacknum, int tdist, int id, int pcnt, int flagmask, int flags)
{
	if ((DWORD)attacknum >= (DWORD)chardata->attacks.NumItems())
		return FALSE;

	PSCharAttackData ad = &(chardata->attacks[attacknum]);
	PTCharacter targ = Fighting();

  // Matches flags
	if ((ad->flags & flagmask) != flags)
		return FALSE;

  // Button id matches attack button id (for controller/keyboard buttons)
	if (id >= 0 && ad->button != id)
		return FALSE;

  // Percentage value is less than percent parameter (for random attack finding)
	if (ad->attackpcnt < pcnt)
		return FALSE;
		
  // In range
	if (ad->maxdist > 0 && (tdist < ad->mindist || tdist > ad->maxdist))
		return FALSE;;

   // Not still doing another attack
	if (doing->action == ACTION_ATTACK && frame < doing->attack->waittime)
		return FALSE;

  // Has animation
	if (!HasActionAni(ad->attackname))
		return FALSE;

  // Not too tired
	if (Fatigue() < ad->fatigue)
		return FALSE;

  // Make sure character has appropriate impact animation
	if (targ && ad->impactname[0] != NULL && !targ->HasActionAni(ad->impactname))
		return FALSE;
	
  // If a response, make sure target character is in correct state to respond to
	if (targ && ad->responsename[0] != 0 && targ->doing->Is(ad->responsename))
		return FALSE;

  // If a death attack, make sure the guy will actually die...
	if (ad->flags & CA_DEATH)
	{
		if (!targ)
			return FALSE;
		int damage = CalculateDamage(WeaponDamage(), 
			GetDamageType(WeaponType(), ad->flags), ad->damagemod);
		if (damage >= targ->Health())
			return TRUE;
	}
	
  // Check player skills	
	if (objclass == OBJCLASS_PLAYER)
	{
		PTPlayer player = (PTPlayer)this;
		
//	  // Is using correct weapon for this attack
//		if (!(ad->weaponmask & (1 << WeaponType())))
//			return FALSE;

	  // Player must have high enough attack skill
		if (player->Skill(SK_ATTACK) < ad->attackskill)
			return FALSE;

	  // Player must have high enough weapon skill for the given weapon being used
		if (player->WeaponSkill(WeaponType()) < ad->weaponskill)
			return FALSE;
	}

	return TRUE;
}

// Finds a valid attack given an attack id (i.e. controller button)
int TCharacter::FindButtonAttack(int id)
{
	if (!IsFighting())
		return NULL;

	int flags;

	int tdist;
	if (Fighting())
		tdist = Distance(Fighting());
	else
		tdist = 10000;

  // Loop through array three times (1-combo attack, 2-special attack, 3-normal attack)
  // This allows combos, specials, and normals to use the same attack buttons on the joypad/
  // keyboard.  Specials and combo's will only happen when they are available and all
  // parameters qualify, otherwise this routine will cascade down to the normal attacks.
	for (int mode = 0; mode < 3; mode++)
	{

	// Look for combos first, then specials, then just normals
	  if (mode == 0)
		flags = CA_RESPONSE;
	  else if (mode == 1)
		flags = CA_SPECIAL;
	  else
		flags = 0;

    // Loop through attack list to find a valid attack
	  for (int attack = 0; attack < chardata->attacks.NumItems(); attack++)
	  {
		if (IsValidAttack(attack, tdist, id, 0, CA_RESPONSE | CA_SPECIAL, flags))
			return attack;
	  }
	}

	return -1;
}

// Finds a valid attack given a randomly generated percentage (0-100) number
int TCharacter::FindPcntAttack(int pcnt)
{
	if (!IsFighting() && Fighting())
		return NULL;

	int tdist = Distance(Fighting());

  // Loop through attack list to find a valid attack
  // Loops through twice.. should be able to find one that works by then...
    for (int attack = 0; attack < chardata->attacks.NumItems() * 2; attack++)
    {
		int randattack = random(0, chardata->attacks.NumItems() - 1);
		if (IsValidAttack(randattack, tdist, -1, pcnt, 0, 0))
			return randattack;
	}

	return -1;
}

// Executes a particular attack (using index into SCharData's attack array)
BOOL TCharacter::DoAttack(int num)
{
	if (!IsFighting() || (DWORD)num >= (DWORD)chardata->attacks.NumItems())
		return FALSE;

  // Wait for previous attack?
	if (doing->action == ACTION_ATTACK && 
		frame < doing->attack->waittime)
		return FALSE;
	
  // Get attack info from char data
	PSCharAttackData ad = &(chardata->attacks[num]);

  // Setup action block
	PTActionBlock ab = new TActionBlock(ad->attackname, ACTION_ATTACK);
	ab->obj = doing->obj;
	ab->attack = ad;

	SetDesired(ab);

  // Make sure moving angle equals face (it doesn't during a combat move)
	SetMoveAngle(GetFace());

	return TRUE;
}

// Find attack based on the button the player pressed
BOOL TCharacter::Attack(int buttonid)
{
	int num = FindButtonAttack(buttonid);
	if (num >= 0)
		return DoAttack(num);
	else
		return FALSE;
}

// Find a random attack (for a monster)
BOOL TCharacter::RandomAttack(int pcnt)
{
	int num = FindPcntAttack(pcnt);
	if (num >= 0)
		return DoAttack(num);
	else 
		return FALSE;
}

BOOL TCharacter::Leap(int angle)
{
	if (!IsFighting())
		return FALSE;

	int roundangle = ((GetFace() + 15) & 0xE0); // round to 8 dirs
	int diff = (angle - roundangle) & 255;
	int anim = diff / 32;

	PTActionBlock ab = NULL;

	switch (anim)
	{
		case 0: ab = new TActionBlock("combatleapf", ACTION_COMBATLEAP); break;
		case 1: ab = new TActionBlock("combatleapfr", ACTION_COMBATLEAP); break;
		case 2: ab = new TActionBlock("combatleapr", ACTION_COMBATLEAP); break;
		case 3: ab = new TActionBlock("combatleapbr", ACTION_COMBATLEAP); break;
		case 4: ab = new TActionBlock("combatleapb", ACTION_COMBATLEAP); break;
		case 5: ab = new TActionBlock("combatleapbl", ACTION_COMBATLEAP); break;
		case 6: ab = new TActionBlock("combatleapl", ACTION_COMBATLEAP); break;
		case 7: ab = new TActionBlock("combatleapfl", ACTION_COMBATLEAP); break;
	}

	if (ab && doing)	// Copy current target
		ab->obj = doing->obj;

	SetDesired(ab);

	return TRUE;
}

BOOL TCharacter::Block()
{
	if (!IsFighting() || !IsDoing(ACTION_COMBAT))
		return FALSE;

	PTCharacter targ = (PTCharacter)doing->obj;

	char *blockanim = "block";
	BOOL synchronize = FALSE;

	if (targ &&													// Char is attacking
		targ->IsDoing(ACTION_ATTACK) &&							 
		targ->GetFrame() < targ->GetDoing()->attack->blocktime)	// And we're in time to block
	{
		blockanim = targ->GetDoing()->attack->blockname;		// Get desired block name
		if (!HasActionAni(blockanim))
			blockanim = "block";								// Use default block
		else
		{
			if (targ->GetDoing()->attack->flags & CA_SNAPBLOCK)	// If special block, and needs snap, do snap
				SnapDist(targ, targ->doing->attack->snapdist);
		}
	}

	if (!HasActionAni(blockanim)) // Do we have this particular block?
		return FALSE;

  // Ok, now start the block (note that AF_SYNCHRONIZE will cause frames to sync with attack
	PTActionBlock ab = new TActionBlock(blockanim, ACTION_BLOCK);
	ab->obj = doing->obj;
	ab->wait = random(chardata->blockmin, chardata->blockmax);
	SetDesired(ab);

  // Make sure moving angle equals face (it doesn't during a combat move)
	SetMoveAngle(GetFace());

	return TRUE;
}

BOOL TCharacter::Dodge()
{
	if (!IsFighting() || !IsDoing(ACTION_COMBAT))
		return FALSE;

	PTActionBlock ab = new TActionBlock("dodge", ACTION_DODGE);
	ab->obj = doing->obj;
	SetDesired(ab);

	return TRUE;
}

BOOL TCharacter::Invoke(int *spell, int len)
{
	char *n = "invoke";

	if (IsFighting())
		n = "invokec";

	if (!HasActionAni(n))
		return FALSE;

	PTActionBlock ab = new TActionBlock(n, ACTION_INVOKE);
	ab->obj = Fighting();
	int *tmp = new int[len+1];
	memcpy(tmp, spell, len);
	tmp[len] = 0xff;			// terminator
	ab->data = tmp;
	ab->priority = TRUE;		// don't interrupt spellcasting
	SetDesired(ab);

  // Make sure moving angle equals face (it doesn't during a combat move)
	SetMoveAngle(GetFace());

	return TRUE;
}

BOOL TCharacter::Pulp(S3DPoint vel, int piece_count, int blood_count)
{
	// create the action block
	PTActionBlock ab = new TActionBlock("pulped");
	ab->priority = TRUE;
	ab->action = ACTION_PULP;
	SetDesired(ab);

	SObjectDef def;
	memset(&def, 0, sizeof(SObjectDef));
	def.objclass = OBJCLASS_EFFECT;
	def.level = MapPane.GetMapLevel();
	def.pos = Pos();
	def.facing = GetFace();
    def.objtype = EffectClass.FindObjType("PULP");

	PTPulpEffect pulpstuff = (PTPulpEffect)MapPane.GetInstance(MapPane.NewObject(&def));
	if (!pulpstuff)
		return FALSE;

	// init all the params
	pulpstuff->Set(vel, this, piece_count, blood_count);

	return TRUE;
}

BOOL TCharacter::Burn()
{
	SObjectDef def;
	memset(&def, 0, sizeof(SObjectDef));
	def.objclass = OBJCLASS_EFFECT;
	def.level = MapPane.GetMapLevel();
	def.pos = Pos();
	def.facing = GetFace();
    def.objtype = EffectClass.FindObjType("BURNBABYBURN");

	PTBurnBabyBurnEffect burnbabyburnstuff = (PTBurnBabyBurnEffect)MapPane.GetInstance(MapPane.NewObject(&def));
	if (!burnbabyburnstuff)
		return FALSE;

	// init all the params
	burnbabyburnstuff->Set(this);

	return TRUE;
}

BOOL TCharacter::BeginCombat(PTCharacter target)
{
	if (target && target->IsDead())
		target = NULL;

	if (root->action == ACTION_COMBAT)
		return SetFighting(target);

	if (FindState("combat") < 0)
		return FALSE;

	PTActionBlock ab = new TActionBlock("combat", ACTION_COMBAT);
	ab->obj = target;
	ab->priority = TRUE;	  // Don't interrupt me
	if (doing->Is("walk"))
		doing->priority = FALSE; // Allow him to override an EndCombat() action
	SetDesired(ab);

	if (GetScript())
		GetScript()->Trigger(TRIGGER_COMBAT); // Trigger the combat script

	nextattack = -1;

	return TRUE;
}

BOOL TCharacter::EndCombat()
{
	if (root->action != ACTION_COMBAT)
		return TRUE;

	if (FindState("walk") < 0)		// Avoid trying to set walk state in the future
		return FALSE;

	PTActionBlock ab = new TActionBlock("walk");
	ab->priority = TRUE;		 // Don't interrupt me
	if (doing->Is("combat"))
		doing->priority = FALSE; // Allow him to override a BeginCombat() action
	SetDesired(ab);

  // Make sure moving angle equals face (it doesn't during a combat move)
	SetMoveAngle(GetFace());

	if ((PTPlayer)this == Player)
		TextBar.ClearHealthDisplay();

	return TRUE;
}

BOOL TCharacter::SetFighting(PTCharacter newtarget)
{
	if (root->action != ACTION_COMBAT)
		return BeginCombat(newtarget);
	if (doing->obj == newtarget)
		return TRUE;
	doing->obj = newtarget;
	desired->obj = newtarget;
	root->obj = newtarget;
	if (newtarget)
	{
		int newangle = AngleTo(newtarget);
		doing->angle = newangle;
		desired->angle = newangle;
		root->angle = newangle;

		if ((PTPlayer)this == Player)
			TextBar.SetHealthDisplay(newtarget->GetName(), newtarget->Health());
	}

	return TRUE;
}

void TCharacter::Wait(int waitlen)
{
	waittype = WAIT_TICKS;
	waitticks = waitlen;
}

BOOL TCharacter::PlayAnim(char *string)
{
	if (!HasActionAni(string))
		return FALSE;

	PTActionBlock ab = new TActionBlock(string, ACTION_ANIMATE);
	SetDesired(ab);

	return TRUE;
}

BOOL TCharacter::ExecutingQueued()
{
	if (desired && (desired->Is("walkl") || desired->Is("walkr")) &&
		(desired->target.x || desired->target.y))
		return TRUE;

	return FALSE;
}

int TCharacter::CursorType(PTObjectInstance inst)
{
	if (inst)
		return CURSOR_NONE;

	if (IsDead())
	{
		if (RealNumInventoryItems() > 0)
			return CURSOR_HAND;			// loot the corpse
		else
			return CURSOR_NONE;			// He's dead, Jim
	}

	if (Aggressive())
		return CURSOR_NONE;
//		return CURSOR_SWORDS;			// kick its ass

	return CURSOR_MOUTH;				// chat for a bit
}

BOOL TCharacter::Use(PTObjectInstance user, int with)
{
	if (with >= 0)
	{
		PTObjectInstance inst = MapPane.GetInstance(with);
		if (!inst)
			return FALSE;
		if (GetScript())
			GetScript()->Trigger(TRIGGER_GET, inst->GetName());
		if (user && user->GetScript())
			GetScript()->Trigger(TRIGGER_GIVE, inst->GetName());
		return TRUE;
	}

	if (IsDead())
	{
		// loot the corpse
		TInventoryIterator i(this);
		PTObjectInstance oi = i.Item();

		if (oi)
		{
			if ((DWORD)FindFreeInventorySlot() >= MAXINVITEMS)
				TextBar.Print("Can't carry any more.");
			else
			{
				oi->RemoveFromInventory();
				AddToInventory(oi);

				char buf[80];
				sprintf(buf, "%s taken from corpse of %s.", oi->GetName(), GetName());
				TextBar.Print(buf);
			}

			return TRUE;
		}

		return FALSE;
	}

	if (!Aggressive() && user == (PTObjectInstance)Player)
	{
	  // Face eachother
		S3DPoint upos;
		user->GetPos(upos);
		int angle = ConvertToFacing(pos, upos);
		Face(angle);
		angle = ConvertToFacing(upos, pos);
		user->Face(angle);

	  // Start DIALOG section
		if (GetScript())
			GetScript()->Trigger(TRIGGER_DIALOG);

		return TRUE;
	}

	return FALSE;
}

PTCharacter TCharacter::CharBlocking(PTObjectInstance inst, RS3DPoint pos, int radius)
{
	int list[MAXFOUNDOBJS];
	int n = MapPane.FindObjectsInRange(pos, list, 100, 0, 
		OBJCLASS_CHARACTER, MAXFOUNDOBJS, OBJSET_CHARACTER);

	for (int i = 0; i <= n; i++)
	{
		PTObjectInstance oi;

		if (i >= n)
			oi = (PTObjectInstance)Player;
		else
			oi = MapPane.GetInstance(list[i]);

		if (oi && oi != inst)
		{
			S3DPoint opos;
			oi->GetPos(opos);
			int dist = ::Distance(opos, pos);
			dist -= radius;
			dist -= ((PTCharacter)oi)->Radius();

			if (dist < 1)
				return (PTCharacter)oi;
		}
	}

	return NULL;
}

// ------------- Streaming functions ------------------

// Loads object data from the sector
void TCharacter::Load(RTInputStream is, int version, int objversion)
{
	TComplexObject::Load(is, version, objversion);

  // Get saved last pulse values (so we can figure what has happened to char)
	if (objversion < 1)
		return;

  // Last time any health/fatigue/mana was recovered
	is >> lasthealthrecov;
	is >> lastfatiguerecov;
	is >> lastmanarecov;
}

// Saves object data to the sector
void TCharacter::Save(RTOutputStream os)
{
	if(!strcmp(GetState(), "pulped") || !strcmp(GetState(), "to pulped"))
		return;
	TComplexObject::Save(os);

  // Last time any health/fatigue/mana was recovered
	os << lasthealthrecov;
	os << lastfatiguerecov;
	os << lastmanarecov;
}

// make a character visible
void TCharacter::MakeVisible()
{
	is_invisible = FALSE;

	PTCharAnimator animator = (PTCharAnimator)GetAnimator();

	for(int i = 0; i < animator->Get3DImagery()->NumMaterials(); ++i)
	{
		S3DMat mat;
		animator->Get3DImagery()->GetMaterial(i, &mat);

		D3DMATERIAL &m = mat.matdesc;

		m.ambient.a = 1.0f;
		m.diffuse.a = 1.0f;
		m.specular.a = 1.0f;

		animator->Get3DImagery()->SetMaterial(i, &mat);
	}
}

// make a character invisible
void TCharacter::MakeInvisible()
{
	is_invisible = TRUE;

	PTCharAnimator animator = (PTCharAnimator)GetAnimator();

	for(int i = 0; i < animator->Get3DImagery()->NumMaterials(); ++i)
	{
		S3DMat mat;
		animator->Get3DImagery()->GetMaterial(i, &mat);
		D3DMATERIAL &m = mat.matdesc;

		m.ambient.a = .5f;
		m.diffuse.a = .5f;
		m.specular.a = .5f;

		animator->Get3DImagery()->SetMaterial(i, &mat);
	}
}
// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                 chunkcache.cpp - Chunk Cache Object                   *
// *************************************************************************

#include "revenant.h"
#include "bitmap.h"
#include "decompdata.h"
#include "chunkcache.h"

int TChunkCache::ChunkDecompress(void *source, void *dest, DWORD clear);
int TChunkCache::ChunkDecompressZ(void *source, void *dest, DWORD clear);

TChunkCache::TChunkCache()
{
	numchunks = 0;
	chunks = chunks16 = NULL;
	id = used = id16 = used16 = NULL;
	chunkbuffer = chunkbuffer16 = NULL;
}

void TChunkCache::AllocCache(int megabytes)
{
	numchunks = (megabytes * 1024 * 1024) / (CHUNKWIDTH * CHUNKHEIGHT * 3);

	chunks = (void **)malloc(numchunks * sizeof(void *));
	id = (int *)malloc(numchunks * sizeof(int));
	used = (int *)malloc(numchunks * sizeof(int));

	chunks16 = (void **)malloc(numchunks * sizeof(void *));
	id16 = (int *)malloc(numchunks * sizeof(int));
	used16 = (int *)malloc(numchunks * sizeof(int));

	for (int loop = 0; loop < numchunks; loop++)
	{
		chunks[loop] = NULL;
		id[loop]	 = 0;
		used[loop]	 = 0;
	
		chunks16[loop] = NULL;
		id16[loop]	   = 0;
		used16[loop]   = 0;
	}	

	currentcycle   = 0;
	currentcycle16 = 0;
	chunkbuffer    = (char *)malloc(CHUNKWIDTH * CHUNKHEIGHT * numchunks);
//	if (!VirtualLock(chunkbuffer, CHUNKWIDTH * CHUNKHEIGHT * numchunks))
//	{
//		Error("Error");
//	}
	chunkbuffer16  = (char *)malloc(CHUNKWIDTH * CHUNKHEIGHT * numchunks * 2);
//	if (!VirtualLock(chunkbuffer16, CHUNKWIDTH * CHUNKHEIGHT * numchunks * 2))
//	{
//		Error("Error");
//	}
}

DWORD TChunkCache::MemUsed()
{
	return numchunks * CHUNKWIDTH * CHUNKHEIGHT * 3;
}

void *TChunkCache::AddChunk(void *chunk, DWORD type)
{
	if (chunk == NULL || chunks == NULL)
		return NULL;

	BEGIN_CRITICAL(); // Don't allow two threads at once

	int oldest    = 0x7fffffff;
	int oldestptr = 0;

	currentcycle++;

	int *value = (int *)chunk;
	int number = *value;

	int *idptr = id;
	int *usedptr = used;
	for (int loop = 0; loop < numchunks; loop++, idptr++, usedptr++)
	{
		if (*idptr == number)
		{
			used[loop] = currentcycle;
			END_CRITICAL();
			return chunks[loop];
		}
			
		if (*usedptr < oldest)
		{
			oldest     = used[loop];
			oldestptr  = loop;
		}
	}

	used[oldestptr]   = currentcycle;										  
	chunks[oldestptr] = (void *)((char *)chunkbuffer + (oldestptr * CHUNKWIDTH * CHUNKHEIGHT));

	END_CRITICAL(); // 

	number = ChunkDecompress(chunk, chunks[oldestptr], type);
	id[oldestptr] = number;

	return chunks[oldestptr];
}

void *TChunkCache::AddChunkZ(void *chunk, DWORD type)
{
	if (chunk == NULL || chunks == NULL)
		return NULL;

	BEGIN_CRITICAL(); // Don't allow two threads at once

	int oldest    = 0x7fffffff;
	int oldestptr = 0;

	currentcycle16++;

	int *value = (int *)chunk;
	int number = *value;

	for (int loop = 0; loop < numchunks; loop++)
	{
		if (id16[loop] == number)
		{
			used16[loop] = currentcycle16;
			END_CRITICAL(); 
			return chunks16[loop];
		}
			
		if (used16[loop] < oldest)
		{
			oldest     = used16[loop];
			oldestptr  = loop;
		}
	}

	used16[oldestptr]   = currentcycle16;
	chunks16[oldestptr] = (void *)((char *)chunkbuffer16 + (oldestptr * CHUNKWIDTH * CHUNKHEIGHT * 2));

	END_CRITICAL(); // 

	number = ChunkDecompressZ(chunk, chunks16[oldestptr], type);
	id16[oldestptr] = number;

	return chunks16[oldestptr];
}

void *TChunkCache::AddChunk16(void *chunk, DWORD type)
{
	if (chunk == NULL || chunks == NULL)
		return NULL;

	BEGIN_CRITICAL(); // Don't allow two threads at once

	int oldest    = 0x7fffffff;
	int oldestptr = 0;

	currentcycle16++;

	int *value = (int *)chunk;
	int number = *value;

	for (int loop = 0; loop < numchunks; loop++)
	{
		if (id16[loop] == number)
		{
			used16[loop] = currentcycle16;
			END_CRITICAL(); 
			return chunks16[loop];
		}
			
		if (used16[loop] < oldest)
		{
			oldest     = used16[loop];
			oldestptr  = loop;
		}
	}

	used16[oldestptr]   = currentcycle16;
	chunks16[oldestptr] = (void *)((char *)chunkbuffer16 + (oldestptr * CHUNKWIDTH * CHUNKHEIGHT * 2));

	END_CRITICAL(); // 

	number = ChunkDecompress16(chunk, chunks16[oldestptr], type);
	id16[oldestptr] = number;

	return chunks16[oldestptr];
}

BOOL TChunkCache::RemoveChunk(int number)
{
	if (chunks == NULL)
		return FALSE;

	BEGIN_CRITICAL(); // Don't allow two threads at once

	for (int loop = 0; loop < numchunks; loop++)
	{
		int cycle = currentcycle - 10;

		if (id[loop] == number)
		{
			used[loop] = cycle;
			id[loop]   = 0;

			break;
		}
	}

	END_CRITICAL(); // 

	if (loop == numchunks)
		return FALSE;

	return TRUE;
}

BOOL TChunkCache::RemoveChunk16(int number)
{
	if (chunks == NULL)
		return FALSE;

	BEGIN_CRITICAL(); // Don't allow two threads at once

	for (int loop = 0; loop < numchunks; loop++)
	{
		int cycle = currentcycle16 - 10;

		if (id16[loop] == number)
		{
			used16[loop] = cycle;
			id16[loop]   = 0;

			break;
		}
	}

	END_CRITICAL(); // 

	if (loop == numchunks)
		return FALSE;

	return TRUE;
}

int TChunkCache::ChunkDecompress(void *source, void *dest, DWORD clear)
{
	if (chunks == NULL)
		return -1;
	
	int *buffer = (int *)source;
	int number  = *buffer;
	buffer++;
	
	DWORD tmpedx;
	DWORD tmpesi;

	__asm
	{
		mov  ecx, CHUNKWIDTH * CHUNKHEIGHT
		shr  ecx, 2

		mov  edi, [dest]

		mov  eax, [clear]
		cmp  eax, 1
		jne  clearzloop

	clearloop:
		mov  DWORD PTR [edi], DWORD PTR 0
		add  edi, 4
		dec  ecx
		jne  clearloop
		jmp  normy

	clearzloop:
		mov  DWORD PTR [edi], DWORD PTR 0xffffffff
		add  edi, 4
		dec  ecx
		jne  clearzloop

	normy:
		mov  esi, [buffer]			; Point ESI to source
		mov	 edi, [dest]			; Point EDI to destination

		cld							; Forward direction

		mov	 dx, [esi]				; Get DLE 1/2
		add	 esi, 2					; Advance past header
		
		mov  ecx, CHUNKHEIGHT

	DecompLoop:
		mov	 ax, [esi]				; Get one byte of data
		inc	 esi

		cmp	 al, dl					; Is RLE ?
		je	 unrle	

		cmp	 al, dh					; Is LZ ?
		je	 unlz	

		mov	 [edi], al				; Store raw	data

		inc	 edi
		jmp  DecompLoop

	EOL:
		dec  ecx
		jne  DecompLoop

 		jmp	 Exit

	unrle:
		mov	 al, ah				; Get count
		inc	 esi

		or   al, al
		je   EOL

		cmp  al, 80h
		jb   NormalRLE
		
		and  eax, 7fh
		add  edi, eax

		jmp	 DecompLoop				; Loop for more data

	NormalRLE:
		and  eax, 7fh
		mov  [tmpedx], edx			

		mov	 edx, eax				; Use local counter
		mov	 al, [esi]				; Get byte to repeat cx	times

		inc	 esi    				; Advance
		mov	 ah, al					; Extend to	ax

		mov	 ebx, eax				; Store in bx
		shl	 eax, 16				; Put it into high 16 bits

		mov	 al, bl					; Include it in low 16 bits
		mov	 ah, bh					; Include it in low 16 bits

		shr	 edx, 1					; Make ready for word
		setc bl						; Store carry-flag in bl

		shr	 edx, 1					; Make ready for dwords
		setc bh						; Store carry-flag in bh

		or   edx, edx
		je 	 CheckSingle
	
	RLEDecompLoop:
		mov  [edi], eax
		add  edi, 4

		dec  edx
		jne  RLEDecompLoop

	CheckSingle:
		or   bh, bh
		jz   skip1

		mov	 [edi], ax				; Store extra-word
		add	 edi, 2					; Advance

	skip1:
		or	 bl, bl					; Extra byte ?
		jz	 skip2	

		mov	 [edi], al				; Store extra byte
		inc	 edi					; Advance

	skip2:
		mov  edx, [tmpedx]
		jmp	 DecompLoop				; Loop for more data

	unlz:
		xor  ebx, ebx
		mov  [tmpedx], edx

		mov	 dl, ah					; Get count
		mov	 bx, [esi + 1]			; Get distance to look back

		and  edx, 000000ffh
		add	 esi, 3					; Advance

		mov  [tmpesi], esi 
		sub	 esi, ebx				; Go back to start of data

		sub  esi, 4

		cmp	 ebx, 4					; Less than	4 bytes back ?
		jae	 Ok386

	LZDecompLoop:
		mov  al, [esi]
		inc  esi

		mov  [edi], al
		inc  edi

		dec  edx
		jne  LZDecompLoop

		jmp	 GoOn

	Ok386:
		shr	 edx, 1					; Make ready for words
		setc bl						; Save carry flag

		shr	 edx, 1					; Make ready for dwords
		setc bh						; Save carry flag

		or   edx, edx
		je   Skip3

	LZDeLoop2:
		mov  eax, [esi]
		add  esi, 4

		mov  [edi], eax
		add  edi, 4
	
		dec  edx
		jne  LZDeLoop2

		or   bh, bh
		jz	 Skip3					; Skip if no extra word

		mov  ax, [esi]
		add  esi, 2

		mov  [edi], ax
		add  edi, 2
	
	Skip3:
		or	 bl, bl					; Extra-byte ?
		jz	 GoOn	

		mov  al, [esi]
		inc  esi

		mov  [edi], al
		inc  edi

	GoOn:
		mov  edx, [tmpedx]
		mov  esi, [tmpesi]

		jmp	 DecompLoop

	Exit:
	}

	return number;
}

int TChunkCache::ChunkDecompressZ(void *source, void *dest, DWORD clear)
{
	if (chunks == NULL)
		return -1;

	int *buffer = (int *)source;
	int number  = *buffer;
	buffer++;
	
	DWORD tmpecx;
	DWORD tmpedx;
	DWORD tmpesi;
	BYTE  highbyte = 0;

	__asm
	{
		mov  ecx, CHUNKWIDTH * CHUNKHEIGHT
		shr  ecx, 1

		mov  edi, [dest]

	clearzloop:
		mov  DWORD PTR [edi], DWORD PTR 0x7f7f7f7f
		add  edi, 4
		dec  ecx
		jne  clearzloop

		mov  esi, [buffer]			; Point ESI to source
		mov	 edi, [dest]			; Point EDI to destination

		cld							; Forward direction

		mov	 dx, [esi]				; Get DLE 1/2
		add	 esi, 2					; Advance past header
		
		mov  [tmpecx], CHUNKHEIGHT

	DecompLoop:
	   	mov	 ax, [esi]				; Get one byte of data
		inc	 esi

		cmp	 al, dl					; Is RLE ?
		je	 unrle	

		cmp	 al, dh					; Is LZ ?
		je	 unlz	

		mov  ah, [highbyte]
		mov	 [edi], ax				; Store raw	data

		add  edi, 2
		jmp  DecompLoop

	EOL:
		dec  [tmpecx]
		jne  DecompLoop

 		jmp	 Exit

	unrle:
		mov	 al, ah				; Get count
		inc  esi

		or   al, al
		je   EOL
				 
		cmp  al, 80h
		jb   NormalRLE
		
		and  eax, 7fh
		
		shl  eax, 1
		add  edi, eax

		jmp	 DecompLoop				; Loop for more data

	NormalRLE:
		and  eax, 7fh
		mov  [tmpedx], eax			

		mov	 al, [esi]				; Get byte to repeat cx	times
		inc	 esi    				; Advance

		mov  ah, [highbyte]
		mov	 ebx, eax				; Store in bx
		
		shl	 eax,  16				; Put it into high 16 bits
		mov	 al, bl					; Include it in low 16 bits
		
		mov  ah, bh
		shr	 [tmpedx], 1			; Make ready for word

		setc bl						; Store carry-flag in bl
		
		cmp	 [tmpedx], 0
		je 	 CheckSingle
	
	RLEDecompLoop:
		mov  [edi], eax
		add  edi, 4

		dec  [tmpedx]
		jne  RLEDecompLoop

	CheckSingle:
		or	 bl, bl					; Extra byte ?
		je	 skip2	

		mov	 [edi], ax				; Store extra byte
		add	 edi, 2					; Advance

	skip2:
		jmp	 DecompLoop				; Loop for more data

	unlz:
		or   ah, ah
		jne  normallz

		mov  ah, [esi + 1]
		add  esi, 2

		mov  [highbyte], ah
		jmp  DecompLoop

	normallz:
		mov	 al, ah					; Get count

		mov	 bx, [esi + 1]			; Get distance to look back
		and  ebx, 0000ffffh

		and  eax, 000000ffh
		mov  [tmpedx], eax
	
		add	 esi, 3					; Advance
		mov  [tmpesi], esi 

		sub	 esi, ebx				; Go back to start of data
		sub  esi, 4

		mov  ah, [highbyte]

	LZDecompLoop:
		mov  al, [esi]
		inc  esi

		mov  [edi], ax
		add  edi, 2

		dec  [tmpedx]
		jne  LZDecompLoop

		mov  esi, [tmpesi]
		jmp	 DecompLoop

	Exit:
	}

	return number;
}

int TChunkCache::ChunkDecompress16(void *source, void *dest, DWORD clear)
{
	if (chunks == NULL)
		return -1;

	int *buffer = (int *)source;
	int number  = *buffer;
	buffer++;

	memcpy(dest, buffer, CHUNKWIDTH * CHUNKHEIGHT * 2);

	return number;
}

TChunkCache::~TChunkCache()
{
//	VirtualUnlock(chunkbuffer, CHUNKWIDTH * CHUNKHEIGHT * numchunks);
//	VirtualUnlock(chunkbuffer16, CHUNKWIDTH * CHUNKHEIGHT * numchunks * 2);

	if (chunks)
		free(chunks);
	if (id)
		free(id);
	if (used)
		free(used);
	if (chunks16)
		free(chunks16);
	if (id16)
		free(id16);
	if (used16)
		free(used16);
	if (chunkbuffer)
		free(chunkbuffer);
	if (chunkbuffer16)
		free(chunkbuffer16);
}

// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                colortable.cpp - Color table objects                   *
// *************************************************************************

#include <math.h>
#include "display.h"

#include "revenant.h"
#include "dls.h"

// Lighting
static double maxbrightness   = 50.0;			// Maximum brightness
static double attrange		  = 0;				// (real intensity always cut to 63)
static double attmin		  = 256 - attrange; // Minimum attenuation position
static double exponent		  = -1.1;			// power of exponential curve
static double multiplierscale = 20.0;			// Scale of multipliers

// Color Table
static double MonoPercent = 0;
static int AmbientLight;
static SColor AmbientColor = { 255, 255, 255 };
static double AmbientMultiplier = 1.0;
static SColor LightColors[NUMBASELIGHTS] =
	{ {255, 255, 255}, {10, 10, 255}, {255, 250, 20}, {80, 0, 200} };
static int LightMultipliers[NUMBASELIGHTS] = { 28, 28, 28, 28 };
static int LightUseCount[NUMBASELIGHTS] = { 0, 0, 0, 0 };

BYTE  DistTable[256][256];
BYTE  AngleTable[256][256];
short DistX[256];					// Quick rotation lookups for facing system
short DistY[256];
BYTE  CosCos[64*256];
BYTE  IntCos[256*256];
BYTE  SinSin[64*256];
BYTE  LightDropOffTable[32768];

// Note, this buffer is pretty large, but not all of it is actually used
// However, the bottom 5 bits of the table lookups are used, so its garanteed that
// the table has data in at least 32 byte chunks, which incidently fit perfectly into
// a single cache entry.  Isn't that nice!
WORD LightTableBuffer[256 * 256 + 32]; // One 64k buffer plus 32 extra bytes for cache alignment
WORD *LightTable;

BYTE  ColorTable[32 * 256];
BYTE  ColorTable16[32 * 256];
BYTE  ColorTableUpperHi[32 * 256];
BYTE  ColorTableUpperLo[32 * 256];
BYTE  ColorTableLower[32 * 256];
DWORD Conv16to32Upper[128];
DWORD Conv16to32Lower[256];
BYTE  IntensityTableUpper[256];
BYTE  IntensityTableLower[256];
double BrightnessTable[256];
DWORD MMXLightTable[256];

// rounding function to avoid normal truncation on typecasting
int Round(double d)
{
	int i = (int)d;
	if ((d - (double)i) >= 0.5)
		i++;

	return i;
}

void SetAmbientLight(int ambient)
{
	if (ambient != -1)
		AmbientLight = ambient;

  // Reset light table colors (must change tables when AmbientLight value changes)
	for (int i = 0; i < NUMBASELIGHTS; i++)
		if (i == 0 || LightUseCount[i] > 0)
			SetLightColor(i, LightColors[i]);
}

int GetAmbientLight()
{
	return AmbientLight;
}

void SetAmbientColor(RSColor color)
{
	AmbientColor.red = color.red;
	AmbientColor.green = color.green;
	AmbientColor.blue = color.blue;

	for (int i = 0; i < NUMBASELIGHTS; i++)
		if (i == 0 || LightUseCount[i] > 0)
			SetLightColor(i, LightColors[i]);
}

void GetAmbientColor(RSColor color)
{
	color.red = AmbientColor.red;
	color.green = AmbientColor.green;
	color.blue = AmbientColor.blue;
}

double GetLightBrightness(int dist, int intensity, int multiplier)
{
	intensity = min(254, max(intensity, 1));
	dist = max(0, dist) * 254 / intensity;
	if (dist > 254)
		return 0.0;
	else
		return BrightnessTable[dist] * (double)multiplier / (multiplierscale / 2);
}

void SetMonoPercent(int pcnt)
{
	return;		// it's not working right now so don't bother

	int loop;

	if (pcnt < 0)
		pcnt = 0;
	else if (pcnt > 100)
		pcnt = 100;
		
   // Color tables for 16 to 32 bit conversion
	MonoPercent = (double)pcnt / 100.0;
	
	if (Display->BitsPerPixel() == 15)
	{
		for(loop = 0; loop < 256; loop++)
		{
			BYTE red   = ((loop & 124) >> 2) << 3;
			BYTE green = ((loop & 3) << 3) << 3;
			BYTE blue = 0;
			BYTE rm = (BYTE)(double)((double)red * (1.0 - MonoPercent) + 
				((double)red + (double)green + (double)blue) * MonoPercent / 3.0);
			BYTE gm = (BYTE)(double)((double)green * (1.0 - MonoPercent) + 
				((double)red + (double)green + (double)blue) * MonoPercent / 3.0);
			BYTE bm = (BYTE)(double)((double)blue * (1.0 - MonoPercent) + 
				((double)red + (double)green + (double)blue) * MonoPercent / 3.0);
						
			Conv16to32Upper[loop] = (DWORD)(((DWORD)rm << 0) |
				 ((DWORD)gm << 8) | ((DWORD)bm << 16));
		}

		for(loop = 0; loop < 256; loop++)
		{
			BYTE red = 0;
			BYTE green = ((loop & 224) >> 5) << 3;
			BYTE blue  = (loop & 31) << 3;
			BYTE rm = (BYTE)(double)((double)red * (1.0 - MonoPercent) + 
				((double)red + (double)green + (double)blue) * MonoPercent / 3.0);
			BYTE gm = (BYTE)(double)((double)green * (1.0 - MonoPercent) + 
				((double)red + (double)green + (double)blue) * MonoPercent / 3.0);
			BYTE bm = (BYTE)(double)((double)blue * (1.0 - MonoPercent) + 
				((double)red + (double)green + (double)blue) * MonoPercent / 3.0);

			Conv16to32Lower[loop] = (DWORD)(((DWORD)rm << 0) |
				 ((DWORD)gm << 8) | ((DWORD)bm << 16));
		}
	}
	else
	{
		for(loop = 0; loop < 128; loop++)
		{
			BYTE red   = ((loop & 0xF8) >> 3) << 3;
			BYTE green = ((loop & 0x07) << 3) << 2;
			BYTE blue = 0;
			BYTE rm = (BYTE)(double)((double)red * (1.0 - MonoPercent) + 
				((double)red + (double)green + (double)blue) * MonoPercent / 3.0);
			BYTE gm = (BYTE)(double)((double)green * (1.0 - MonoPercent) + 
				((double)red + (double)green + (double)blue) * MonoPercent / 3.0);
			BYTE bm = (BYTE)(double)((double)blue * (1.0 - MonoPercent) + 
				((double)red + (double)green + (double)blue) * MonoPercent / 3.0);

			Conv16to32Upper[loop] = (DWORD)(((DWORD)rm << 0) |
				((DWORD)gm << 8) | ((DWORD)bm << 16));
		}

		for(loop = 0; loop < 256; loop++)
		{
			BYTE red = 0;
			BYTE green = ((loop & 0xE0) >> 5) << 2;
			BYTE blue  = (loop & 0x01F) << 3;
			BYTE rm = (BYTE)(double)((double)red * (1.0 - MonoPercent) + 
				((double)red + (double)green + (double)blue) * MonoPercent / 3.0);
			BYTE gm = (BYTE)(double)((double)green * (1.0 - MonoPercent) + 
				((double)red + (double)green + (double)blue) * MonoPercent / 3.0);
			BYTE bm = (BYTE)(double)((double)blue * (1.0 - MonoPercent) + 
				((double)red + (double)green + (double)blue) * MonoPercent / 3.0);

			Conv16to32Lower[loop] = (DWORD)(((DWORD)rm << 0) |
				((DWORD)gm << 8) | ((DWORD)bm << 16));
		}
	}
}

int GetMonoPercent()
{
	return (int)(MonoPercent * 100.0);
}

// Move this number down to increase light accuracy, up to increase onscreen light quantity
#define TOLERANCE		3

int NewLightIndex(RSColor color, int mult)
{
  // Match color with lighting colors	
	int bestid = 0;
	int bestdiff = 255 + 255 + 255 + 255;
	for (int i = 0; i < 4; i++)
	{
		if (i == 0 || LightUseCount[i] > 0)
		{
			int diff = abs(color.red - LightColors[i].red) + 
				abs(color.green - LightColors[i].green) +
				abs(color.blue - LightColors[i].blue) +
				(mult > 0 ? abs(mult - LightMultipliers[i]) : 0);
			if (diff < bestdiff)
			{
				bestid = i;
				bestdiff = diff;
			}
		}
	}

	int id;
	for (id = 1; id < NUMBASELIGHTS; id++)
		if (LightUseCount[id] < 1)
			break;

	if (bestdiff < TOLERANCE || id >= NUMBASELIGHTS)
	{
		LightUseCount[bestid]++;
		return bestid;
	}

	SetLightColor(id, color, mult > 0 ? mult : 28);
	LightUseCount[id] = 1;

	return id;
}

void FreeLightIndex(int id)
{
	LightUseCount[id]--;
}

void ClearLights()
{
	for (int i = 1; i < NUMBASELIGHTS; i++)
		LightUseCount[i] = 0;
}

void SetLightColor(int id, RSColor color, int mult)
{
	if ((DWORD)id >= NUMBASELIGHTS)
		return;

	if (mult >= 0)
		LightMultipliers[id] = mult;
	double multiplier = (double)LightMultipliers[id] / multiplierscale;

	double ared = (double)AmbientColor.red / 255.0;
	double agreen = (double)AmbientColor.green / 255.0;
	double ablue = (double)AmbientColor.blue / 255.0;
	double am = 1.0 / max(ared, max(agreen, ablue));
	ared = ared * am;
	agreen = agreen * am;
	ablue = ablue * am;

	double lred = (double)color.red / 255.0;
	double lgreen = (double)color.green / 255.0;
	double lblue = (double)color.blue / 255.0;
	double lm = 1.0 / max(lred, max(lgreen, lblue));
	lred = lred * lm;
	lgreen = lgreen * lm;
	lblue = lblue * lm;

	LightColors[id] = color;

	BYTE red, green, blue;

	for(int loop = 0; loop < 64; loop++)
	{
	    double aintensity = (double)AmbientLight / 255.0;
	    double intensity = (1.0 - aintensity) * ((double)loop / 63.0);

	    if (intensity > 1.0) 
			intensity = 1.0;

		int mmxclr = 80;

		red = (BYTE)min((double)mmxclr * ared * aintensity * AmbientMultiplier, 255.0);
		red = (BYTE)min((double)mmxclr * lred * intensity * multiplier + (double)red, 255.0);
        green = (BYTE)min((double)mmxclr * agreen * aintensity * AmbientMultiplier, 255.0);
	    green = (BYTE)min((double)mmxclr * lgreen * intensity * multiplier + (double)green, 255.0);
		blue = (BYTE)min((double)mmxclr * ablue * aintensity * AmbientMultiplier, 255.0);
		blue = (BYTE)min((double)mmxclr * lblue * intensity * multiplier + (double)blue, 255.0);

		MMXLightTable[(loop * 4) + id] = ((DWORD)blue << 16) | ((DWORD)green << 8) | ((DWORD)red);

	    for(int loop2 = 0; loop2 < 32; loop2++)
	    {
			int clr = loop2 << 3;

			WORD color = 0;

			red = (BYTE)min((double)clr * ared * aintensity * AmbientMultiplier, 31.0);
			red = (BYTE)min((double)clr * lred * intensity * multiplier + (double)red, 31.0);

			if (Display->BitsPerPixel() == 16)
	        {
				green = (BYTE)min((double)(clr << 1) * agreen * aintensity *
					AmbientMultiplier, 63.0);
				green = (BYTE)min((double)(clr << 1) * lgreen * intensity * 
								  multiplier + (double)green, 63.0);

				color |= (WORD)(red << 11);
			}

			else
			{
	            green = (BYTE)min((double)clr * agreen * aintensity * 
					AmbientMultiplier, 31.0);
	            green = (BYTE)min((double)clr * lgreen * intensity * 
								  multiplier + (double)green, 31.0);

				color |= (WORD)(red << 10);
			}

			blue = (BYTE)min((double)clr * ablue * aintensity * AmbientMultiplier, 31.0);
			blue = (BYTE)min((double)clr * lblue * intensity * multiplier + (double)blue, 31.0);

	        color |= (WORD)(green << 5);
			color |= (WORD)blue;

			LightTable[(loop * 4 * 256) + (id * 256) + loop2] = color;
		}
	}
}

void GetLightColor(int id, RSColor color, int &mult)
{
	if ((DWORD)id >= NUMBASELIGHTS)
		return;
	color = LightColors[id];
	mult = LightMultipliers[id];
}

void MakeColorTables()
{

  // Round up light table pointer to nearest 32 (so 32 color values fit in one cache entry)
	LightTable = (WORD *)(((DWORD)LightTableBuffer + 31) & 0xFFFFFFE0);

  // Make Falloff Table 
	double minpower = pow(256.0, exponent);
	double maxpower = pow(1.0, exponent) - minpower;
	for (int dist = 0; dist < 256; dist++)
	{
		double p = pow((double)(dist + 1.0), exponent) - minpower;
		double brightness = min(p / maxpower * maxbrightness, 1.0);

		if (dist > attmin)
			brightness = brightness * max((attrange - ((double)dist - attmin)) / 
						 attrange, 0);

		BrightnessTable[dist] = brightness;
	}

  // Make alpha channel conversion table here..	

	int red, green, blue;

	for (int loop = 0; loop < 32; loop++)
	{
	    for(int loop2 = 0; loop2 < 256; loop2++)
	    {

			if (Display->BitsPerPixel() == 16)
			{
		        red   = (loop2 & 0xf8) >> 3;
				red   = red * loop / 31;
				green = (loop2 & 0x07) << 3;
				green = green * loop / 31;
				ColorTableUpperHi[loop * 256 + loop2] = (BYTE)((red << 3) 
													  | (green >> 3));
				IntensityTableUpper[loop2] = red + green; // Green is twice red
			}
			
			else
			{
		        red   = (loop2 & 0x7C) >> 2;
				red   = red * loop / 31;
				green = (loop2 & 0x03) << 3;
				green = green * loop / 31;
				ColorTableUpperHi[loop * 256 + loop2] = (BYTE)((red << 2) 
													  | (green >> 3));
				IntensityTableUpper[loop2] = red + (green * 2); // Green is twice red

			}

			ColorTableUpperLo[loop * 256 + loop2] = (BYTE)((green & 7) << 5);
		 }
	}

	for (loop = 0; loop < 32; loop++)
	{
		for(int loop2 = 0; loop2 < 256; loop2++)
	    {
			green = (loop2 & 0xE0) >> 5;
			green = green * loop / 31;
			blue  = (loop2 & 0x1F);
			blue  = blue * loop / 31;

			ColorTableLower[loop * 256 + loop2] = (BYTE)((green << 5) | blue);

			IntensityTableLower[loop2] = (green * 2) + 0; //(blue / 3);
				// Blue is 1/3rd red
		}
	}
	
	BYTE *index = IntCos;   

	for (short y = 0; y < 256; y++)
	{
		for(short x = 0; x < 256; x++)
	    {
			signed char looppos = (signed char)y;
	        double a1           = (double)x / 256.0 * M_2PI;
			double brightness   = (double)sin(a1) * (double)looppos/127.0 * 31.0;

			*(index++)   = (BYTE)brightness;

			dist     = Round(sqrt((double)x * (double)x + (double)y * (double)y));
			BYTE ang;
			if (x == 0)
				ang = 64;				// otherwise it cuts off a bit short
			else
 				ang = (BYTE)Round((atan2l(y, x) / M_2PI) * 256.0);

			if (dist >= 255)
				DistTable[x][y] = (BYTE)255;
			else
				DistTable[x][y] = dist;
			
			AngleTable[x][y]    = ang;
		}
	}

	// make this as explicit as possible to avoid any precision errors
	for (loop = 0; loop < 64; loop++)
	{
		if (loop == 0)
		{
			DistX[0] = 0;
			DistY[0] = 256;
		}
		else
		{
			double angle = (loop * M_2PI) / 256.0;
			DistX[loop] = (short) Round(256.0 * sin(angle));
			if (loop == 32)
				DistY[32] = DistX[32];
			else
				DistY[loop] = (short) Round(256.0 * cos(angle));
		}
		
	}
	// and just copy to the other three quadrants with appropriate sign changes
	for (loop = 64; loop < 128; loop++)
	{
		DistX[loop] = DistY[loop - 64];
		DistY[loop] = -(DistX[loop - 64]);
	}
	for (loop = 128; loop < (128+64); loop++)
	{
		DistX[loop] = -(DistX[loop - 128]);
		DistY[loop] = -(DistY[loop - 128]);
	}
	for (loop = (128+64); loop < 256; loop++)
	{
		DistX[loop] = -(DistX[loop - 128]);
		DistY[loop] = -(DistY[loop - 128]);
	}

	signed char *coscosidx = (signed char *)CosCos;   
	index = SinSin;   
	
	for (loop = 0; loop < 64; loop++)
	{
	    for (int loop2 = 0; loop2 < 256; loop2++)
		{
			signed char loop2pos = (signed char)loop2;

			double b2    = (double)loop / 128.0 * M_2PI;
			double delta = (double)loop2pos / 256.0 * M_2PI;
			double a2    = (double)loop2 / 256.0 * M_2PI;
	
		    double brightness = sin(b2) * cos(delta) * 127.0;
			*(coscosidx++)    = (signed char)brightness;

	        brightness = cos(b2) * cos(a2) * 31.0;
			*(index++) = (BYTE)brightness;
		}
	}


	for(dist = 0; dist < 256; dist++)
	{
		int brightness = (int)(BrightnessTable[dist] * 63.0);
	
		LightDropOffTable[dist] = (BYTE)min((int)brightness, 0x63) << 2;
	}
	
	for(loop = 0; loop < 32; loop++)
	{
	    for(int loop2 = 0; loop2 < 256; loop2++)
	    {
			red = (BYTE)((float)(loop2) * ((float)(loop) / 31.0));
			ColorTable[loop * 256 + loop2] = (BYTE)red;
		}
	}

  // Set Initial Light Colors
	SColor color;
	color.red = color.green = color.blue = 255;
	SetAmbientColor(color);						// also inits all lights

  // Set 16 to 32 bit conversion table
	SetMonoPercent(0);
}

// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                  command.cpp - Command interpreter                    *
// *************************************************************************

#include <stdlib.h>
#include <stdarg.h>
#include <string.h>

#include "revenant.h"
#include "command.h"
#include "parse.h"
#include "editor.h"
#include "object.h"
#include "character.h"
#include "editor.h"
#include "script.h"
#include "mappane.h"
#include "spell.h"
#include "dialog.h"
#include "exit.h"
#include "playscreen.h"

/* externs */
extern TConsolePane Console;
extern char buf[];

/* Prototypes for command functions */
// editor and general object manipulation
COMMAND(CmdSelect);
COMMAND(CmdDeselect);
COMMAND(CmdAdd);
COMMAND(CmdAddInv);
COMMAND(CmdGive);
COMMAND(CmdUndo);
COMMAND(CmdMove);
COMMAND(CmdPos);
COMMAND(CmdDelete);
COMMAND(CmdDelInv);
COMMAND(CmdTake);
COMMAND(CmdStat);
COMMAND(CmdScript);
COMMAND(CmdCenterOn);
COMMAND(CmdScrollTo);
COMMAND(CmdMapPos);
COMMAND(CmdShow);
COMMAND(CmdAmbient);
COMMAND(CmdAmbColor);
COMMAND(CmdDirLight);
COMMAND(CmdMono);
COMMAND(CmdBaseLight);
COMMAND(CmdReplace);
COMMAND(CmdLight);
COMMAND(CmdZOffset);
COMMAND(CmdRegistration);
COMMAND(CmdAnimRegistration);
COMMAND(CmdAnimZ);
COMMAND(CmdName);
COMMAND(CmdFlip);
COMMAND(CmdHelp);
COMMAND(CmdLock);
COMMAND(CmdUnlock);
COMMAND(CmdImmobile);
COMMAND(CmdUnimmobile);
COMMAND(CmdLoad);
COMMAND(CmdSave);
COMMAND(CmdSaveTileBM);
COMMAND(CmdDXStats);
COMMAND(CmdMemory);
COMMAND(CmdGenerate);
COMMAND(CmdCalcWalkmap);
COMMAND(CmdWalkmap);
COMMAND(CmdState);
COMMAND(CmdTry);
COMMAND(CmdForce);
COMMAND(CmdReveal);
COMMAND(CmdLevel);
COMMAND(CmdTemplate);
COMMAND(CmdTileWalkmap);
COMMAND(CmdSmoothScroll);
COMMAND(CmdDLight);
COMMAND(CmdAddRC);
COMMAND(CmdDeleteRC);
COMMAND(CmdExit);
COMMAND(CmdResetScreenRect);
COMMAND(CmdBounds);
COMMAND(CmdToggle);
COMMAND(CmdGet);
COMMAND(CmdSectorCommand);
COMMAND(CmdSwap);
COMMAND(CmdToFront);
COMMAND(CmdToBack);
COMMAND(CmdGroup);
COMMAND(CmdPlay);
COMMAND(CmdTrigger);
COMMAND(CmdNewGame);
COMMAND(CmdCurPlayer);
COMMAND(CmdGetState);

// object-specific commands
COMMAND(CmdText);
COMMAND(CmdFollow);
COMMAND(CmdRestore);


// in-game control commands (for scripts)
COMMAND(CmdSay);
COMMAND(CmdGo);
COMMAND(CmdGoto);
COMMAND(CmdFace);
COMMAND(CmdPivot);
COMMAND(CmdUse);
COMMAND(CmdActivate);
COMMAND(CmdCombat);
COMMAND(CmdAttack);
COMMAND(CmdInvoke);
COMMAND(CmdStop);
COMMAND(CmdBlock);
COMMAND(CmdControl);
COMMAND(CmdPulp);
COMMAND(CmdBurn);
COMMAND(CmdSetVisibility);

// character dialog commands
COMMAND(CmdChoice);

// script conditionals, loops, gamestate control
COMMAND(CmdBegin);
COMMAND(CmdEnd);
COMMAND(CmdIf);
COMMAND(CmdElse);
COMMAND(CmdWhile);
COMMAND(CmdSet);
COMMAND(CmdWait);
COMMAND(CmdJump);

// Master command list, evaluated top-to-bottom
// --------------------------------------------
//
// "name", function, class1 (0 all, -1 none), class2, requiresparams, editoronly, "usage"

SCommand Commands[] =
{ { "select", CmdSelect, -1, -1, TRUE, TRUE, "usage: select [#.]<object name>\n"
								   "       select <#/next/prev>\n" },
  { "deselect", CmdDeselect, -1, -1, FALSE, TRUE, "usage: deselect [<selection number>]\n" },
  { "add", CmdAdd, -1, -1, TRUE, FALSE, 
			"usage: add [<amt>] <typename>\n"
			"       add light [<intensity>]\n"
			"       add <class> stat <statname> [<default> <min> <max>]\n" },
  { "addinv", CmdAddInv, 0, 0, TRUE, FALSE, "usage: <object>.addinv [<amt>] <obj>\n" },
  { "give", CmdGive, 0, 0, TRUE, FALSE, "usage: <object>.give <to> [<amt>] <obj>\n" },
  { "undo", CmdUndo, -1, -1, FALSE, TRUE, "usage: undo\n" },
  { "move", CmdMove, 0, 0, TRUE, FALSE, "usage: <object>.move <dx> <dy> [<dz>]\n" },
  { "pos", CmdPos, 0, 0, TRUE, FALSE, "usage: <object>.pos <dx> <dy> [<dz> [<level>]]\n" },
  { "delete", CmdDelete, 0, 0, FALSE, FALSE, "usage: <object>.delete\n" },
  { "delinv", CmdDelInv, 0, 0, FALSE, FALSE, "usage: <object>.delinv [<amt>] <obj>\n" },
  { "take", CmdTake, 0, 0, TRUE, FALSE, "usage: <object>.take <from> [<amt>] <obj>\n" },
  { "stat", CmdStat, 0, 0, FALSE, FALSE, "usage: <object>.stat [<amt>]<name> <value>]\n" },
  { "script", CmdScript, 0, 0, FALSE, TRUE, "usage: <object>.script\n" },
  { "centeron",	CmdCenterOn, 0, 0, FALSE, FALSE, "usage: <object>.centeron OR\n\t centeron <object> OR\n\t centeron <x> <y> <z> [<level>]\n" },
  { "scrollto",	CmdScrollTo, 0, 0, FALSE, FALSE, "usage: <object>.scrollto OR\n\t scrollto <object> OR\n\t scrollto <x> <y> <z> [<level>]\n" },
  { "mappos",	CmdMapPos, -1, -1, TRUE, TRUE, "usage: mappos list [or] <name> [or] <x> <y> <z>\n" },
  { "show", CmdShow, -1, -1, TRUE, FALSE, "usage: show <class> [<type>]\n" },
  { "ambient", CmdAmbient, -1, -1, TRUE, FALSE, "usage: ambient <intensity>\n" },
  { "ambcolor", CmdAmbColor, -1, -1, TRUE, FALSE, "usage: ambcolor <red> <green> <blue>\n" },
  { "mono", CmdMono, -1, -1, TRUE, FALSE, "usage: mono <percent>\n" },
  { "dirlight", CmdDirLight, -1, -1, TRUE, FALSE, "usage: dirlight <intensity> [<hnormal> <vnormal>]\n" },
  { "replace", CmdReplace, 0, 0, TRUE, FALSE, "usage: <object>.replace [<class>] [<newobjtype>]\n" },
  { "light", CmdLight, 0, 0, TRUE, FALSE, "usage: <object>.light <on/off>    <object>.light <intensity>\n"
				"       <object>.light directional <on/off>\n"
				"       <object>.light color <red> <green> <blue>\n"
				"       <object>.light position <x> <y> <z>\n" },
  { "zoffset", CmdZOffset, 0, 0, FALSE, TRUE, "usage: <object>.zoffset <zoffset>\n" },
  { "registration", CmdRegistration, 0, 0, FALSE, TRUE, "usage: <object>.registration <deltax> <deltay>\n" },
  { "animregistration", CmdAnimRegistration, 0, 0, FALSE, TRUE, "usage: <object>.animregistration <deltax> <deltay>\n" },
  { "animz", CmdAnimZ, 0, 0, FALSE, TRUE, "usage: <object>.animz <zval>\n" },
  { "name", CmdName, 0, 0, TRUE, FALSE, "usage: <object>.name [type/clear] <name>\n" },
  { "flip", CmdFlip, 0, 0, FALSE, FALSE, "usage: <object>.flip\n" },
  { "help", CmdHelp, -1, -1, FALSE, TRUE, "usage: help [<command>]\n" },
  { "lock", CmdLock, 0, 0, FALSE, TRUE, "usage: lock\n" },
  { "unlock", CmdUnlock, 0, 0, FALSE, TRUE, "usage: unlock\n" },
  { "immobile", CmdImmobile, 0, 0, FALSE, TRUE, "usage: immobile\n" },
  { "unimmobile", CmdUnimmobile, 0, 0, FALSE, TRUE, "usage: unimmobile\n" },
  { "load", CmdLoad, -1, -1, FALSE, TRUE, "usage: load\n" },
  { "save", CmdSave, -1, -1, FALSE, TRUE, "usage: save [game | map | headers | classes | exits]\n" },
  { "savetilebm", CmdSaveTileBM, -1, -1, FALSE, TRUE, "usage: savetilebm\n" },
  { "dxstats", CmdDXStats, -1, -1, FALSE, FALSE, "usage: dxstats\n" },
  { "memory", CmdMemory, -1, -1, FALSE, FALSE, "usage: memory\n" },
  { "generate", CmdGenerate, -1, -1, FALSE, TRUE, "usage: generate [<sizex> <sizey>] [from <startx> <starty>]\n" },
  { "calcwalkmap", CmdCalcWalkmap, -1, -1, FALSE, TRUE, "usage: calcwalkmap\n" },
  { "walkmap", CmdWalkmap, 0, 0, TRUE, TRUE, "usage: walkmap <delta z>\n" },
  { "tilewalkmap", CmdTileWalkmap, OBJCLASS_TILE, -1, FALSE, TRUE, "usage: tilewalkmap\n" },
  { "state", CmdState, 0, -1, TRUE, FALSE, "usage: state <state number>\n" },
  { "try", CmdTry, 0, -1, TRUE, FALSE, "usage: try <state name>\n" },
  { "force", CmdForce, 0, -1, TRUE, FALSE, "usage: force <state name>\n" },
  { "reveal", CmdReveal, 0, -1, FALSE, FALSE, "usage: reveal\n" },
  { "level", CmdLevel, -1, -1, TRUE, FALSE, "usage: level <level number>\n" },
  { "template", CmdTemplate, 0, -1, FALSE, TRUE, "usage: <object.>template\n" },
  { "smoothscroll", CmdSmoothScroll, -1, -1, TRUE, FALSE, "usage: smoothscroll <on/off>\n" },
  { "dlight", CmdDLight, -1, -1, TRUE, FALSE, "usage: dlight <intensity>\n" },
  { "addrc", CmdAddRC, -1, -1, FALSE, TRUE, "usage: addrc\n" },
  { "deleterc", CmdDeleteRC, -1, -1, FALSE, TRUE, "usage: deleterc\n" },
  { "exit", CmdExit, OBJCLASS_EXIT, -1, TRUE, TRUE, "usage: <object>.exit <name> [posonly]\n" },
  { "resetscreenrect", CmdResetScreenRect, 0, 0, FALSE, TRUE, "usage: <object>.resetscreenrect [<state>]\n" },
  { "bounds", CmdBounds, 0, 0, TRUE, TRUE, "usage: <object>.bounds <regx> <regy> <width> <length>\n" },
  { "toggle", CmdToggle, 0, 0, TRUE, FALSE, "usage: <object>.toggle <flagname>\n" },
  { "get", CmdGet, 0, 0, FALSE, FALSE, "usage: <character>.get <object>\n" },
  { "sectorcommand", CmdSectorCommand, -1, -1, TRUE, TRUE, "usage: sectorcommand <level> <command>\n" },
  { "swap", CmdSwap, 0, 0, TRUE, TRUE, "usage: swap <obj to swap with>\n" },
  { "tofront", CmdToFront, 0, 0, FALSE, TRUE, "usage: tofront\n" },
  { "toback", CmdToBack, 0, 0, FALSE, TRUE, "usage: toback\n" },
  { "group", CmdGroup, 0, 0, FALSE, TRUE, "usage: group <groupnum>\n"},
  { "play", CmdPlay, 0, 0, TRUE, FALSE, "usage: play <sound>\n" },
  { "trigger", CmdTrigger, 0, 0, TRUE, FALSE, "usage: trigger <trigname>\n" },
  { "newgame", CmdNewGame, -1, -1, FALSE, FALSE, "usage: newgame\n" },
  { "curplayer", CmdCurPlayer, OBJCLASS_PLAYER, -1, FALSE, FALSE, "usage: <player>.curplayer\n" },

  { "text", CmdText, OBJCLASS_SCROLL, -1, FALSE, TRUE, "usage: <scroll>.text\n" },
  { "follow", CmdFollow, OBJCLASS_EXIT, -1, FALSE, TRUE, "usage: <exit>.follow\n" },
  { "restore", CmdRestore, OBJCLASS_CHARACTER, OBJCLASS_PLAYER, FALSE, FALSE, "usage: <character>.restore\n" },
  
  { "say", CmdSay, OBJCLASS_CHARACTER, OBJCLASS_PLAYER, TRUE, FALSE, "usage: <character>.say [<nowait>] [choice|\"string\"]\n" },
  { "go", CmdGo, OBJCLASS_CHARACTER, OBJCLASS_PLAYER, TRUE, FALSE, "usage: <character>.go <angle>\n" },
  { "goto", CmdGoto, OBJCLASS_CHARACTER, OBJCLASS_PLAYER, TRUE, FALSE, "usage: <character>.goto <x> <y>\n" },
  { "face", CmdFace, 0, 0, TRUE, FALSE, "usage: <object>.face <angle>\n" },
  { "pivot", CmdPivot, OBJCLASS_CHARACTER, OBJCLASS_PLAYER, TRUE, FALSE, "usage: <object>.pivot <angle>\n" },
  { "use", CmdUse, 0, 0, FALSE, FALSE, "usage: <object>.use [<with object>]\n" },
  { "activate", CmdActivate, OBJCLASS_EXIT, 0, FALSE, FALSE, "usage: <object>.activate\n" },
  { "combat", CmdCombat, OBJCLASS_CHARACTER, OBJCLASS_PLAYER, TRUE, FALSE, "usage: <object>.combat [off|on|<target>]\n" },
  { "attack", CmdAttack, OBJCLASS_CHARACTER, OBJCLASS_PLAYER, TRUE, FALSE, "usage: <object>.attack <target>\n" },
  { "invoke", CmdInvoke, OBJCLASS_CHARACTER, OBJCLASS_PLAYER, TRUE, FALSE, "usage: <object>.invoke <spellname>\n" },
  { "stop", CmdStop, OBJCLASS_CHARACTER, OBJCLASS_PLAYER, FALSE, FALSE, "usage: <object>.stop\n" },
  { "block", CmdBlock, OBJCLASS_CHARACTER, OBJCLASS_PLAYER, FALSE, FALSE, "usage: <object>.block\n" },
  { "control", CmdControl, -1, -1, FALSE, FALSE, "usage: control <on|off>\n" },

  { "choice", CmdChoice, -1, -1, TRUE, FALSE, "usage: choice <label> <text string>\n" },

  { "begin", CmdBegin, -1, -1, FALSE, FALSE, "usage: begin\n         <block>\n       end\n" },
  { "end", CmdEnd, -1, -1, FALSE, FALSE, "usage: begin\n         <block>\n       end\n" },
  { "if", CmdIf, -1, -1, TRUE, FALSE, "usage: if <condition>\n          <command block>\n"
								  "         else <alternate command block>\n" },
  { "else", CmdElse, -1, -1, FALSE, FALSE, "usage: if <condition>\n          <command block>\n"
								  "         else <alternate command block>\n" },
  { "while", CmdWhile, -1, -1, TRUE, FALSE, "usage: while <condition>\n         <command block>\n" },
  { "set", CmdSet, -1, -1, TRUE, FALSE, "usage: set <state name> <new value>\n" },
  { "wait", CmdWait, OBJCLASS_CHARACTER, OBJCLASS_PLAYER, FALSE, FALSE, "usage: <character>.wait [<wait type>]\n" },
  { "jump", CmdJump, -1, -1, TRUE, FALSE, "usage: jump <label>\n" },
  { "pulp", CmdPulp, OBJCLASS_CHARACTER, OBJCLASS_PLAYER, TRUE, FALSE, "usage: <character>.pulp <x> <y> <z>\n" },
  { "burn", CmdBurn, OBJCLASS_CHARACTER, OBJCLASS_PLAYER, TRUE, FALSE, "usage: <character>.burn\n" },
  { "getstate", CmdGetState, OBJCLASS_CHARACTER, OBJCLASS_PLAYER, FALSE, FALSE, "usage: <character>.getstate\n" },
  { "visible", CmdSetVisibility, OBJCLASS_CHARACTER, OBJCLASS_PLAYER, TRUE, FALSE, "usage: <character>.visible <state #>\n" },

  { NULL, NULL }			// list terminator
};


inline BOOL CheckOneContext(PTObjectInstance context, int classid)
{
	if (classid >= 0)
	{
		if (context == NULL)
			return FALSE;
	}
	else
	{
		if (context != NULL)
			return FALSE;
	}

	if (classid > 0 && context && context->ObjClass() != classid)
		return FALSE;

	return TRUE;
}

inline BOOL CheckContext(PTObjectInstance context, int classid, int classid2)
{
	if (classid < 0 && classid2 < 0)
		return TRUE;

	return (CheckOneContext(context, classid) || (classid2 >= 0 && CheckOneContext(context, classid2)));
}

int CommandInterpreter(PTObjectInstance context, TToken &t, int abrevlen)
{
 	BOOL skip = FALSE;
	BOOL nowait = FALSE;

	PTObjectInstance orgcontext = context; // Save original context

	t.SkipBlanks();
	if (t.Type() == TKN_EOF)
		return 0;				// don't bother if there's nothing there

	strcpy(buf, t.Text());

	int groupnum = -1; // Set to valid group number if we're doing groups

	SetDialogContext(context); // Who's script is running?

	// check for <context>.<command> syntax
	if (t.Type() == TKN_IDENT)
	{
		if (t.Is("nowait"))
		{
			nowait = TRUE;
			t.WhiteGet();
		}

		t.Get();
		if (t.Is(".")) // Houston we have a context...
		{
			if (!strnicmp(buf, "group", 5))
			{
				groupnum = atoi(buf + 5);
				t.Get();
				if (t.Type() == TKN_IDENT)
					strcpy(buf, t.Text());
				else
				{
					Output("Specify command following group context\n");
					return CMD_BADPARAMS;
				}
			}
			else
			{				
				PTObjectInstance inst = MapPane.FindClosestObject(buf);
				if (inst)
				{
					context = inst;
					t.Get();
					if (t.Type() == TKN_IDENT)
						strcpy(buf, t.Text());
					else
					{
						Output("Specify command following object context\n");
						return CMD_BADPARAMS;
					}
				}
				else
				{
					sprintf(buf, "%s: Context not found\n", buf);
					Output(buf);
					return 0;
				}
			}
		}
	}

	int retval = CMD_BADCOMMAND;

	for (int cmd = 0; Commands[cmd].name; cmd++)
	{
		if ((abrevlen && abbrevcmp(buf, Commands[cmd].name) >= abrevlen) ||
			!stricmp(buf, Commands[cmd].name))
		{
			// check editor-only commands
			if (Commands[cmd].editoronly && !Editor)
			{
				Output("Command can only be used in the editor\n");
				skip = TRUE;
			}

			// validate object context (we do it later if doing a command for a group though)
			if (groupnum < 0 && !CheckContext(context, Commands[cmd].classcontext, Commands[cmd].classcontext2))
			{
				skip = TRUE;

				if (context == NULL)
					Output("Object context required for command\n");
				else
					Output("Command not availible for context's class\n");
			}

			// Save start of command for group stuff later		
			DWORD startpos = t.GetPos(); // Go through map, and do command for all objs which fit group#

			// check params
			if (t.Type() != TKN_RETURN)
				t.WhiteGet();
			if (Commands[cmd].requiresparams && (t.Type() == TKN_RETURN || t.Type() == TKN_EOF))
			{
				Output(Commands[cmd].usage);
				skip = TRUE;
			}

			// execute the command
			if (skip)
				t.SkipLine();			// Skip the command if 'skip' is true
			else
			{

			  // Group command
				if (groupnum >= 0)		// If context is group, do command for all objects in group
				{
					for (TMapIterator i; i; i++)
					{
						if (i.Item()->GetGroup() == groupnum)
						{
							t.SetPos(startpos);
							t.WhiteGet();

							context = i.Item();

						  // Make sure this object is correct class for command	
							if (CheckContext(context, Commands[cmd].classcontext, Commands[cmd].classcontext2))
							{
								retval = (*(Commands[cmd].cmdfunc))(context, t); // Do it
								if (retval & CMD_ERROR)
									break;
							}
						}
					}
				}
				else					// Do command for current context
					retval = (*(Commands[cmd].cmdfunc))(context, t);
			}

			break;
		}
	}

  // Command wasn't on list, try current context
	if (retval == CMD_BADCOMMAND && context)
	{
		retval = context->ParseCommand(t);
	}

	if (retval & CMD_BADPARAMS)
		Output("Bad parameters.\n");
	if (retval & CMD_OUTOFMEM)
		Output("Couldn't complete command due to low memory.\n");
	if (retval & (CMD_USAGE | CMD_BADPARAMS))
		Output(Commands[cmd].usage);
	if (retval & CMD_BADCOMMAND)
		Output("Unrecognized command.");
	else if (t.Type() != TKN_RETURN && t.Type() != TKN_EOF)
	{
		if (!(retval & CMD_ERROR))
			Output("(extra parameters ignored)\n");
		while (t.Type() != TKN_RETURN && t.Type() != TKN_EOF)
			t.Get();
	}

	if (nowait && retval == CMD_WAIT)
		retval = 0;

  // If we're  character, and our script just caused another character to do something, 
  // wait for that character to finish what he's doing
	if (orgcontext && context && // Both not null
		orgcontext != context && // Doing something to somebody other than ourselves
		retval == CMD_WAIT &&    // Script caused a wait (and we are both chars below)
		(context->ObjClass() == OBJCLASS_CHARACTER || context->ObjClass() == OBJCLASS_PLAYER) &&
		(orgcontext->ObjClass() == OBJCLASS_CHARACTER || orgcontext->ObjClass() == OBJCLASS_PLAYER))
	{
		((PTCharacter)orgcontext)->WaitChar(context);
	}

	return retval;
}

// Defined in editor.cpp
static char buf[1024]; // Temporary buf for output

void Output(char *fmt,...)
{
	va_list marker;
	va_start(marker, fmt);
	vsprintf(buf, fmt, marker);

	if (Editor && !Console.IsHidden())
		Console.Output(buf);
}

COMMAND(CmdHelp)
{
	if (t.Type() == TKN_IDENT)
	{
		for (int cmd = 0; Commands[cmd].name; cmd++)
			if (t.Is(Commands[cmd].name, MINCMDABREV))
			{
				Output(Commands[cmd].usage);
				break;
			}

		if (Commands[cmd].name == NULL)
			Output("Command not found.\n");

		t.WhiteGet();
		return 0;
	}

	Output("The following commands are currently availible:\n");

	int cnt = 0;
	char buf[256] = "";

	for (int cmd = 0; Commands[cmd].name; cmd++)
	{
		sprintf(buf, "%s %-10s", buf, Commands[cmd].name);
		if (++cnt >= 5)
		{
			strcat(buf, "\n");
			Output(buf);
			buf[0] = 0;
			cnt = 0;
		}
	}

	if (cnt)
	{
		strcat(buf, "\n");
		Output(buf);
	}

	return 0;
}

// *******************
// * Alias Functions *
// *******************

/*_STRUCTDEF(SAliasTag)
struct SAliasTag
{
	char name[MAXCONTEXTNAME];  // Name of this alias
	char alias[MAXCONTEXTNAME]; // What we are aliasing
};

typedef TVirtualArray<SAliasTag, 16, 16> TAliasArray;
static TAliasArray AliasArray;

int NumAliases()
{
	return AliasArray.NumItems();
}

void ClearAliases()
{
	AliasArray.Clear();
}

char *GetAliasName(int aliasnum)
{
	return AliasArray[aliasnum].name;
}

char *GetAlias(int aliasnum)
{
	return AliasArray[aliasnum].alias;
}

int GetAliasNum(char *aliasname)
{
	for (int c = 0; c < NumAliases(); c++)
	{
		if (!stricmp(AliasArray[c].name, aliasname))
			return c;
	}
	return -1;
}

char *GetAlias(char *aliasname)
{
	int aliasnum = GetAliasNum(aliasname);
	if (aliasnum < 0)
		return NULL;

	return GetAlias(aliasnum);
}

int AddAlias(char *aliasname, char *alias)
{
	SAliasTag a;
	memset(a, 0, sizeof(SAliasTag));
	strcpy(a.name, aliasname);
	strcpy(a.alias, alias);
	int aliasnum = GetAliasNum(aliasname);
	if (aliasnum < 0)
		aliasnum = NumAliases();
	return AliasArray.Set(a, aliasnum);
}
*/
// *******************
// * Object Commands *
// *******************

COMMAND(CmdUse)
{
	PTObjectInstance inst = NULL;
	PTObjectInstance with = NULL;

	if (t.Type() == TKN_IDENT || t.Type() == TKN_TEXT)
	{
		inst = MapPane.FindClosestObject(t.Text(), context);
		t.WhiteGet();
	}

	if (t.Type() == TKN_IDENT || t.Type() == TKN_TEXT)
	{
		with = MapPane.FindClosestObject(t.Text(), context);
		t.WhiteGet();
	}

	if (context && inst)
	{
		if (with)
			inst->Use(context, with->GetMapIndex());
		else
			inst->Use(context, -1);
	}
	else
		context->Use(context, -1);

	return 0;
}

COMMAND(CmdActivate)
{
	((PTExit)context)->Activate();

	return 0;
}

COMMAND(CmdSay)
{
	char sayanim[20];
	sayanim[0] = NULL;

	BOOL nowait = FALSE;
	if (t.Is("nowait"))
	{
		nowait = TRUE;
		t.WhiteGet();
	}

	int wait = -1;
	if (t.Type() == TKN_NUMBER)
	{
		wait = t.Index();
		t.WhiteGet();
	}

	buf[0] = '\"';

	if (t.Is("choice"))
	{
		if (DialogPane.GetResponseText())
			strcpy(buf + 1, DialogPane.GetResponseText());
		else
			buf[1] = NULL;
		t.WhiteGet();
	}
	else if (t.Type() == TKN_IDENT)
	{
		strcpy(sayanim, t.Text());
		t.WhiteGet();

		if (!Parse(t, "%s", buf+1))
			return CMD_BADPARAMS;
		strcat(buf, "\"");
	}
	else
	{
		if (!Parse(t, "%s", buf+1))
			return CMD_BADPARAMS;
		strcat(buf, "\"");
	}

	if (sayanim[0] != NULL)
		((PTCharacter)context)->Say(buf, wait, sayanim);
	else
		((PTCharacter)context)->Say(buf, wait, NULL);

	if (nowait)
		return 0;

	return CMD_WAIT;
}

COMMAND(CmdGo)
{
	int angle;
	if (!Parse(t, "%d", &angle))
		return CMD_BADPARAMS;

	((PTCharacter)context)->Go(angle);

	return 0;
}

COMMAND(CmdGoto)
{
	int x, y;
	if (!Parse(t, "%d %d", &x, &y))
		return CMD_BADPARAMS;

	((PTCharacter)context)->Goto(x, y);

	return CMD_WAIT;
}

COMMAND(CmdFace)
{
	int angle;
	if (!Parse(t, "%d", &angle))
		return CMD_BADPARAMS;

	if (context)
		context->Face(angle);

	return CMD_WAIT;
}

COMMAND(CmdPivot)
{
	int angle;
	if (!Parse(t, "%d", &angle))
		return CMD_BADPARAMS;

	if (context)
		((PTCharacter)context)->Pivot(angle);

	return CMD_WAIT;
}

COMMAND(CmdCombat)
{
	int index = -1;

	if (t.Type() == TKN_IDENT)
	{
		if (t.Is("off"))
			((PTCharacter)context)->EndCombat();
		else
		{
			PTObjectInstance inst = NULL;
			if (!t.Is("on"))
			{
				inst = MapPane.FindClosestObject(t.Text(), context);
				if (!inst)
					return CMD_BADPARAMS;
			}
			((PTCharacter)context)->BeginCombat((PTCharacter)inst);
		}
		t.WhiteGet();
	}

	return 0;
}

COMMAND(CmdAttack)
{
	int index = -1;

	if (t.Type() == TKN_IDENT)
	{
		PTObjectInstance inst = MapPane.FindClosestObject(t.Text(), context);
		t.WhiteGet();
	}

	return 0;
}

COMMAND(CmdBlock)
{
	((PTCharacter)context)->Block();
	return CMD_WAIT;
}

COMMAND(CmdControl)
{
	if (t.Type() != TKN_IDENT)
		return CMD_BADPARAMS;

	if ((PTPlayer)context == Player)
	{
		if (t.Is("on"))
			PlayScreen.SetDemoMode(FALSE);
		else if (t.Is("off"))
			PlayScreen.SetDemoMode(TRUE);
		else
			return CMD_BADPARAMS;
	}
	else
	{
		if (t.Is("on"))
			PlayScreen.SetControlOn(TRUE);
		else if (t.Is("off"))
			PlayScreen.SetControlOn(FALSE);
		else
			return CMD_BADPARAMS;
	}

	t.WhiteGet();

	return 0;
}

COMMAND(CmdInvoke)
{
	extern int spellvals[];
	extern char *spellnames[];

	if (t.Type() != TKN_IDENT)
		return CMD_BADPARAMS;

/*
	for (int i = 0; i < NUM_SPELLS; i++)
		if (t.Is(spellnames[i]))
			break;

	t.WhiteGet();

	if (i >= NUM_SPELLS)
		return CMD_BADPARAMS;

	((PTCharacter)context)->Invoke(&(spellvals[i]));
*/
	return CMD_WAIT;
}

COMMAND(CmdStop)
{
	((PTCharacter)context)->Stop();
	return CMD_WAIT;
}

// ******************************
// * Script Language Components *
// ******************************

char *Operators[] = { "=", "<>", ">", "<", ">=", "<=", "and", "or", "not", "+", "-", "*", "/", NULL };

int ApplyOperation(int &lval, int op, int rval)
{
	int newval = 0;

	switch (op)
	{
		case 0: newval = (lval == rval); break;
		case 1: newval = (lval != rval); break;
		case 2: newval = (lval > rval); break;
		case 3: newval = (lval < rval); break;
		case 4: newval = (lval >= rval); break;
		case 5: newval = (lval <= rval); break;
		case 6: newval = (lval && rval); break;
		case 7: newval = (lval || rval); break;
		case 8: newval = !rval; break;				// boolean not is a special case
		case 9: newval = (lval + rval); break;
		case 10: newval = (lval - rval); break;
		case 11: newval = (lval * rval); break;
		case 12: if (rval == 0) newval = 0; else newval = (lval / rval); break;
	}

	// adjust for boolean or arithmatic operations
	if (op <= 5)
		lval = rval;
	else
		lval = newval;

	return newval;
}

int FindElement(char *elem, char *list[])
{
	for (int i = 0; list[i] && i < 64; i++)
		if (stricmp(elem, list[i]) == 0)
			return i;

	return -1;
}

// Finds a (semi-)unique value for a given string for expression parsing
int StringVal(char *string)
{
	int val = 0;

	for (int i = 0; string[i]; i++)
		val |= (int)(string[i] - 'A') << i;

	return val;
}

BOOL ParseExpression(TToken &t, int *value)
{
	int totalval = STATE_INVALID;
	int lval = STATE_INVALID;
	int optype = -1;
	char buf[60];

	while (t.Type() != TKN_RETURN && t.Type() != TKN_EOF)
	{
		if (t.Type() == TKN_SYMBOL)
		{
			if (optype != -1)
				return FALSE;

			strcpy(buf, t.Text());		// First char of operator
			t.Get();
			if (t.Type() == TKN_SYMBOL)
				strcat(buf, t.Text());	// Add second char to operator

			int ot = FindElement(buf, Operators);
			if (ot >= 0 && (lval != STATE_INVALID || ot == 8))	// boolean "not" is 7
				optype = ot;
			else
				return FALSE;

			t.WhiteGet();
		}
		else if (t.Type() == TKN_IDENT || t.Type() == TKN_NUMBER || t.Type() == TKN_TEXT)
		{
			int rval;
			BOOL isop = FALSE;

			if (t.Type() == TKN_IDENT)
			{
				int ot = FindElement(t.Text(), Operators);
				if (ot >= 0) // and, or, not...
				{
					if (lval != STATE_INVALID || ot == 8)
						optype = ot;
					else
						return FALSE;

					isop = TRUE;

					t.WhiteGet();
				}
				else		 // Game id
				{
					strcpy(buf, t.Text());
					t.Get();
					if (t.Is("."))
					{
						t.Get();
						if (t.Type() != TKN_IDENT)
							return FALSE;

						PTObjectInstance inst = MapPane.FindClosestObject(buf);;
						if (inst)
						{
							if (t.Is("state"))
								rval = inst->GetState();
							else
								rval = inst->GetStat(t.Text());
						}
						t.WhiteGet();
					}
					else
						rval = ScriptManager.GameState(buf);
					if (t.Type() == TKN_WHITESPACE)
						t.Get();
				}
			}
			else if (t.Type() == TKN_TEXT)
			{
				rval = StringVal(t.Text());
				t.WhiteGet();
			}
			else
			{
				rval = t.Index();
				t.WhiteGet();
			}

			if (!isop)
			{
				if (rval == STATE_INVALID)
					return FALSE;

				if (lval == STATE_INVALID)
				{
					if (optype == 7)		// boolean not
						totalval = ApplyOperation(lval, optype, rval);
					else
						totalval = lval = rval;
				}
				else
				{
					if (optype == -1)
						return FALSE;
					else
					{
						totalval = ApplyOperation(lval, optype, rval);
						optype = -1;
					}
				}
			}
		}
	}

	if (totalval == STATE_INVALID)
		return FALSE;

	*value = totalval;
	return TRUE;
}

COMMAND(CmdBegin)
{
	return CMD_BEGIN;
}

COMMAND(CmdEnd)
{
	return CMD_END;
}

COMMAND(CmdIf)
{
	int cond;
	if (!ParseExpression(t, &cond))
		return CMD_BADPARAMS;

	return (cond ? CMD_CONDTRUE : CMD_CONDFALSE);
}

COMMAND(CmdElse)
{
	// The hideously complex algorithm contained in this function
	// is enough to drive a programmer insane, so don't bother
	// trying to comprehend its greatness.  Just accept the fact
	// that it works.

	return CMD_ELSE;
}

COMMAND(CmdWhile)
{
	int cond;
	if (!ParseExpression(t, &cond))
		return CMD_BADPARAMS;

	return cond ? CMD_LOOP : CMD_SKIPBLOCK;
}

COMMAND(CmdSet)
{
	char buf[40];

	if (t.Type() != TKN_IDENT)
		return CMD_BADPARAMS;

	strcpy(buf, t.Text());
	t.WhiteGet();

	if (t.Type() == TKN_RETURN || t.Type() == TKN_EOF)
	{
		Output("%s = %d\n", buf, 	ScriptManager.GameState(buf));
		return 0;
	}
		
	if (t.Is("="))
		t.WhiteGet();

	int value;
	if (t.Is("on") || t.Is("true"))
	{
		value = 1;
		t.WhiteGet();
	}
	else if (t.Is("off") || t.Is("false"))
	{
		value = 0;
		t.WhiteGet();
	}
	else if (t.Type() == TKN_NUMBER)
		value = t.Index();
	else
		return CMD_BADPARAMS;

	ScriptManager.SetGameState(buf, value);

	return 0;
}

COMMAND(CmdWait)
{
	if (t.Type() == TKN_NUMBER)
	{
		int wait = t.Index();

		((PTCharacter)context)->Wait(wait);

		t.WhiteGet();
	}
	else if (t.Is("response"))
	{
		DialogPane.SetCharacter((PTCharacter)context);	// Waiting for dialog.. show dialog pane
		DialogPane.Show();

		((PTCharacter)context)->WaitResponse();

		t.WhiteGet();
	}
	else if (t.Is("char"))
	{
		t.WhiteGet();
		if (t.Type() != TKN_IDENT && t.Type() != TKN_TEXT)
			return CMD_BADPARAMS;

		PTObjectInstance inst = MapPane.FindClosestObject(t.Text(), context);
		if (!inst)
			Output("Couldn't find wait char\n");

		((PTCharacter)context)->WaitChar(inst);

		t.WhiteGet();
	}

	return CMD_WAIT;
}

COMMAND(CmdJump)
{
	if (t.Type() != TKN_IDENT && t.Type() != TKN_KEYWORD)
		return CMD_BADPARAMS;

	if (context)
		context->ScriptJump(t.Text());

	return CMD_JUMP;
}

// pulp a character
COMMAND(CmdPulp)
{
	S3DPoint vel;
	if(!Parse(t, "%d %d %d", &vel.x, &vel.y, &vel.z))
		return CMD_BADPARAMS;

	int x = random(6, 16);

	((PTCharacter)context)->Pulp(vel, x, x * 30);
	
	return 0;
}

// burn a character
COMMAND(CmdBurn)
{
	((PTCharacter)context)->Burn();
	
	return 0;
}

// return state info
COMMAND(CmdGetState)
{
	char buf[1024];
	sprintf(buf, "state = \"%s\"", ((PTCharacter)context)->GetState());
	if(((PTCharacter)context)->IsInRoot())
		strcat(buf, " <root>");
	Output(buf);

	return 0;
}

COMMAND(CmdSetVisibility)
{
	int state;
	if(!Parse(t, "%d", &state))
		return CMD_BADPARAMS;

	if(!state)
		((PTCharacter)context)->MakeInvisible();
	else
		((PTCharacter)context)->MakeVisible();

	return 0;
}
// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                complexobj.cpp - TComplexObject module                 *
// *************************************************************************

#include <stdlib.h>

#include "revenant.h"
#include "textbar.h"
#include "complexobj.h"

//#define SHOWSTATES

#ifdef SHOWSTATES
char desname1[RESNAMELEN], desname2[RESNAMELEN], desname3[RESNAMELEN], desname4[RESNAMELEN];
#endif

// ******************** Action Block ************************

TActionBlock::TActionBlock(char *n, ACTION a)
{
	ClearBlock();
	strcpy(name, n);
	action = a;
}

TActionBlock::TActionBlock(char *n, char *str, ACTION a)
{
	ClearBlock();
	sprintf(name, "%s%s", n, str);
	action = a;
}

TActionBlock::TActionBlock(TActionBlock &ab, char *str, ACTION a)
{
	memcpy(this, &ab, sizeof(TActionBlock));
	if (str)
		strcpy(name, str);
	if (a != ACTION_NONE)
		action = a;
}

void TActionBlock::ClearBlock()
{
	name[0] = NULL;
	action = ACTION_ANIMATE;
	wait = 0;
	angle = 0;
	moveangle = 0;
	target.x = target.y = target.z = 0;
	obj = NULL;
	data = NULL;
	flags = 0;
	firsttime = TRUE;
}

BOOL TActionBlock::Is(char *s)
{
	char *p1 = name;
	char *p2 = s;

	while (*p1 && *p2 && 
	         (
			    *p2 == '?' ||					  // 1 char
	            *p2 == '*' ||					  // 0 or more chars
	            *p2 == '[' ||					  // Beginning of char list
	            *p2 == ']' ||					  // Ending of char list
		        (*p2 == '#' && isdigit(*p1)) ||   // Any digit
		        tolower(*p2) == tolower(*p1)      // Regular match
	         )
	      )
	{
		if (*p2 == '[') // Multichar match
		{
			p2++;
			while (*p2 && *p2 != ']')
			{
				if (*p1 == *p2)
				{
					p1++;
					break;
				}
			}
			if (*p2)
				p2++;
		}
		else			// Ordinary match
		{
			p1++;
			if (*p2 != '*')
				p2++;
		}
	}
	
	if (*p2 == '*')
		p2++;

	if (*p1 || *p2)
		return FALSE;

	return TRUE;
}

BOOL TActionBlock::IsRight(char *state)
{
	int len = strlen(state);
	if (!strnicmp(name, state, len) && name[len] == 'r' && name[len + 1] == NULL)
		return TRUE;

	return FALSE;
}

BOOL TActionBlock::IsLeft(char *state)
{
	int len = strlen(state);
	if (!strnicmp(name, state, len) && name[len] == 'l' && name[len + 1] == NULL)
		return TRUE;

	return FALSE;
}

BOOL TActionBlock::IsStep(char *state)
{
	int len = strlen(state);
	if (!strnicmp(name, state, len) && 
	  (name[len] == 'r' || name[len] == 'l') && name[len + 1] == NULL)
		return TRUE;

	return FALSE;
}

// TRUE if state is one of the master state (i.e. "attack1" is one of "attack")
BOOL TActionBlock::IsOneOf(char *state)
{
	int len = strlen(state);
	if (!strnicmp(name, state, len) && 
	  (name[len] >= '0' && name[len] <= '9') && name[len + 1] == NULL)
		return TRUE;

	return FALSE;
}

// Returns the number at the end of a state
int TActionBlock::StateNum()
{
	int len = strlen(name);
	if (len <= 1)
		return 0;
	else
		return atol(name + len - 1);
}

static char stnamebuf[RESNAMELEN];

// Helper function to make it easy to make state names
char *StName(char *name, int num)
{
	sprintf(stnamebuf, "%s%d", name, num);
	return stnamebuf;
}

// Helper function to make it easy to make state names
char *StName(char *name, char *str)
{
	sprintf(stnamebuf, "%s%s", name, str);
	return stnamebuf;
}

BOOL TActionBlock::IsPartOf(char *prefix, char *state)
{
	if (state)
		sprintf(stnamebuf, "%s%s*", prefix, state);
	else
		sprintf(stnamebuf, "%s*", prefix, state);
	return Is(stnamebuf);
}

// Swaps the root part of the name with a new root
void TActionBlock::SwapRoot(char *root, char *newroot)
{
	int l = strlen(root);
	if (strnicmp(name, root, l) != 0)
		return;

	char buf[RESNAMELEN];
	strncpyz(buf, newroot, RESNAMELEN);
	strncatz(buf, name + l, RESNAMELEN);
	strcpy(name, buf);
}

// ******************** Complex Object ************************

// NOTE: DefaultRootState() will not be virtual (will only call COMPLEXOBJ version)
// when ClearComplexObj() is called from constructor!

void TComplexObject::ClearComplexObj()
{
	flags |= OF_PULSE | OF_COMPLEX;	// Causes the PULSE function to be called for this object
	SetNotify(N_DELETING);			// Check for deleted objs in action blocks
	root = doing = desired = new TActionBlock(DefaultRootState() /* SEE ABOVE NOTE */);
	state = FindState(root->name);
}

void TComplexObject::Pulse()
{
	if (UpdatingBoundingRect)
		return;

	int bits = Move();		// object movement

	UpdateAction(bits);		// update current state
}

void TComplexObject::UpdateAction(int bits)
{
	int comstate = ResolveAction(bits);

	if (comstate == 0)
		comstate = commanddone ? COM_COMPLETED : COM_EXECUTING;

	if (doing)
	{
		// check firsttime (first frame) and priority (on completion)
		if (doing->firsttime)
			doing->firsttime = FALSE;

		if (comstate == COM_COMPLETED && doing->priority)
			doing->priority = FALSE;
	}

	if (desired)
	{
		if (desired == root)
			comstate = COM_COMPLETED;
		else
			comstate = TryCommand(desired, bits);
	}

	if (comstate == COM_COMPLETED || comstate == COM_IMPOSSIBLE)
	{
		SetDesired(NULL);
		TryCommand(root);
	}
}

int TComplexObject::ResolveAction(int bits)
{
	if (!doing)
		return COM_IMPOSSIBLE;

	return 0;
}

void TComplexObject::SetRoot(PTActionBlock ab)
{
	if (ab != root)
	{
		if (root && root != doing && root != desired && root != ab)
			delete root;
		root = ab;
	}

	root->nowaitdone = TRUE;	// We can always interrupt a root state
	root->interrupt = FALSE;	// We don't ever interrupt another state
}

void TComplexObject::SetDoing(PTActionBlock ab)
{
	if (ab != doing)
	{
		if (doing && doing != root && doing != desired && doing != ab)
			delete doing;
		doing = ab;
	}
	root->interrupt = FALSE;	// Now that we're doing, don't interrupt
}

void TComplexObject::SetDesired(PTActionBlock ab)
{
	if (ab == NULL)				// NULL indicates we want to go back to root
		ab = root;

	if (desired && desired != doing &&	// If we have a priority action, and we aren't already
		desired->priority)				// playing it, don't replace it.
			return;

	if (ab != desired)					// Set the desired command
	{
		if (desired && desired != doing && desired != root)
			delete desired;
		desired = ab;

#ifdef SHOWSTATES
		strcpy(desname4, desname3);
		strcpy(desname3, desname2);
		strcpy(desname2, desname1);
		strcpy(desname1, ab->name);
#endif
	}

	if (ab->interrupt && doing != ab && !doing->priority) // Interrupt flag means DO IT RIGHT NOW
	{
		ForceCommand(ab);
		ab->interrupt = FALSE;
	}
}

// Have object attempt to move into a new state
int TComplexObject::TryCommand(PTActionBlock ab, int bits)
{
  // Use root if desired is NULL
	if (ab == NULL)
		ab = root;

  // Wait till we're done animating (unless we're in root)
	if (!doing->priority &&								// Can't do until priority is cleared
		(commanddone || !doing ||						// Okay, command done, or not doing anything
		(doing && ab != doing && doing->nowaitdone) ||  // Or doing action is nowait action
		(desired && ab != desired && desired->interrupt))) // Or desired action is interrupt
		return ForceCommand(ab, bits); // Do new state when old one is done (or interrupted)
	else
		return COM_EXECUTING;	// Otherwise tell program we're still waiting
}

// Force the object into the given state
int TComplexObject::ForceCommand(PTActionBlock ab, int bits)
{
	if (doing && doing->priority)
		return COM_EXECUTING;

	if (ab == NULL)
		ab = root;

#ifdef SHOWSTATES
	if (this == (PTComplexObject)Player)
		TextBar.Print("[%s,%s,%s] %s %s %s %s", root->name, desired->name, doing->name,
			desname1, desname2, desname3, desname4);
#endif

	ab->interrupt = FALSE;	// Now that we've interrupted... set this to false.

	int newstate = -1;

	if (doing == NULL)
		newstate = FindState(ab->name);
	else
	{
	  // ROOT2ROOT means don't do a transition back to the root state because the 
	  // transition TO animation (i.e. "walk to say") has the transition BACK animation
	  // in it already (has "say to walk" in it).  If current animation is root2root, and user
	  // actually wants to go back to the root, don't bother looking for a transition ani,
	  // just set directly back to root..
		if ((GetAniFlags() & AF_ROOT2ROOT) && desired && desired == root)
		{
			ab = root; // Return back too root right now
			newstate = FindState(ab->name);
		}
		else
		{
	  // Try to find a transition from the current action to the new action.  If we can't
	  // find one, we will just force it (see below).
			newstate = FindTransitionState(doing->name, ab->name);
		}

	  // Can't find a transition, well then we go ahead and force it... 
		if (newstate < 0 &&	!ab->dontforce)
		{	
		  // One of these things is bound to work!!
		  newstate = FindState(ab->name);	// Use end state name
		  if (newstate < 0)
			newstate = FindTransitionState(root->name, ab->name);  // Try transition from root
		  if (newstate < 0)
			newstate = FindTransitionState(ab->name, root->name);  // Try transition to root
		}

		// flag transition if the two states aren't the same
		ab->transition = (stricmp(doing->name, ab->name) != 0);
	}

	if (newstate < 0)
		return COM_IMPOSSIBLE;

	SetState(newstate);
	SetDoing(ab);

  // If the sychronize flag is set, synchronize frames with 'obj'.
  // Use for block/impact animations which must match the frame number of an associated
  // opponents attack animation.  Useful for any other synchronized animations as well.
	if (ab->obj && GetAniFlags() & AF_SYNCHRONIZE)
		SetFrame(ab->obj->GetFrame() + 1);

  // Make this block the root block if current or next animation is a root animation
	DWORD nextaniflags = imagery ? imagery->GetAniFlags(FindState(ab->name)) : 0;
	if (GetAniFlags() & AF_ROOT || nextaniflags & AF_ROOT)
		SetRoot(ab);

  // If this is a looping animation, set desired to the same action again, otherwise
  // set it to go back to the root state
	if ((GetAniFlags() & AF_LOOPING) || (GetAniFlags() & AF_ROOT) ||
		(nextaniflags & AF_LOOPING) || (nextaniflags & AF_ROOT))
		SetDesired(ab);
	else
		SetDesired(NULL);

	return COM_EXECUTING;
}

// Loads object data from the sector
void TComplexObject::Load(RTInputStream is, int version, int objversion)
{
	TObjectInstance::Load(is, version, objversion);

  // Load root state
	PTActionBlock ab;
	if (version < 7)
	{
		ab = new TActionBlock(DefaultRootState());
	}
	else
	{
		BYTE action;
		BYTE len;
		char name[RESNAMELEN];
		is >> action;
		is >> len;
		char *p = name;
		while (len)
		{
			is >> (*p);
			p++;
			len--;
		}
		*p = NULL;
		ab = new TActionBlock(name, (ACTION)action);
	}

	SetRoot(ab);
	SetDoing(ab);
	SetDesired(ab);
	state = FindState(ab->name);
}

// Saves object data to the sector
void TComplexObject::Save(RTOutputStream os)
{
	TObjectInstance::Save(os);

  // Save root state
	os << (BYTE)root->action;
	BYTE len = (BYTE)strlen(root->name);
	os << len;
	char *p = root->name;
	while (len)
	{
		os << (*p);
		p++;
		len--;
	}
}

void TComplexObject::Notify(int notify, void *ptr)
{
	// **** WARNING!!! MAKE SURE YOU CHECK FOR BROKEN LINKS AND DELETED OBJECTS HERE!!! ****
	// If you want to be notified, you must call SetNotify() in your contsructor

	if (sector == (PTSector)ptr)
		return;

	TObjectInstance::Notify(notify, ptr);

	if (root && root->obj && NOTIFY_DELETED(ptr, root->obj))
		root->obj = NULL;
	if (doing && doing->obj && NOTIFY_DELETED(ptr, doing->obj))
		doing->obj = NULL;
	if (desired && desired->obj && NOTIFY_DELETED(ptr, desired->obj))
		desired->obj = NULL;
}
// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                  container.cpp - TContainer module                    *
// *************************************************************************

#include "revenant.h"
#include "container.h"
#include "mappane.h"
#include "inventory.h"
#include "textbar.h"
#include "tool.h"
#include "player.h"
#include "key.h"
#include "sound.h"

REGISTER_BUILDER(TContainer)
TObjectClass ContainerClass("CONTAINER", OBJCLASS_CONTAINER, 0);

// Hard coded class stats
DEFSTAT(Container, Openable,	OPEN, 0, 0, 0, 1)
DEFSTAT(Container, Value,		VAL,  1, 0, 0, 1000000)

// Hard coded object stats
DEFOBJSTAT(Container, Locked,			LOCK, 0, 0, 0, 0)
DEFOBJSTAT(Container, KeyId,			KEY,  1, 0, 0, 0)
DEFOBJSTAT(Container, PickDifficulty,	PICK, 2, 0, 0, 0)

extern PTObjectInstance TakenObject;
extern PTObjectInstance DroppedObject;

// Container states
#define CLOSED		0
#define OPEN		1

BOOL TContainer::Use(PTObjectInstance user, int with)
{
	TObjectInstance::Use(user, with);

	PTObjectInstance inst = MapPane.GetInstance(with);

	if (state == CLOSED && CheckKeyUse(user, inst))
		return TRUE;

	if (Locked())
	{
		TextBar.Print("It seems to be locked.");
		return FALSE;
	}

	char buf[80];

	if (Openable() && state == CLOSED)
	{
		if (inst)
		{
			sprintf(buf, "The %s is closed.", GetName());
			TextBar.Print(buf);
			return FALSE;
		}

		SetState(OPEN);
		
		sprintf(buf, "%s opened.", GetName());
		TextBar.Print(buf);
		return TRUE;
	}

	if (GetTopOwner() == Inventory.GetTopContainer())
	{
		// it's in inventory
		if (!inst)
			Inventory.SetContainer(this);
		else if (NumObjects() < (MAXINVITEMS - 1))
		{
			if ((DWORD)FindFreeInventorySlot() < MAXINVITEMS)
			{
				inst->RemoveFromInventory();
				AddToInventory(inst);
			}
		}
	}
	else
	{
		// it's on the ground
		if (!inst)
		{
			// get from
			TInventoryIterator i(this);
			PTObjectInstance oi = i.Item();

			if (oi)
			{
				if (Inventory.GetContainer() && (DWORD)Inventory.GetContainer()->FindFreeInventorySlot() < MAXINVITEMS)
				{
					oi->RemoveFromInventory();
					Inventory.GetContainer()->AddToInventory(oi);

					sprintf(buf, "%s taken from %s.", oi->GetName(), GetName());
					TextBar.Print(buf);

					TakenObject = oi;
				}
				else
					TextBar.Print("Can't carry any more.");
			}
			else
			{
				if (!Openable())
					return FALSE;

				SetState(CLOSED);
				sprintf(buf, "%s closed.", GetName());
				TextBar.Print(buf);
			}
		}
		else
		{
			// add to
			inst->RemoveFromInventory();
			AddToInventory(inst);

			sprintf(buf, "%s put in %s.", inst->GetName(), GetName());
			TextBar.Print(buf);

			DroppedObject = inst;
		}

	}

	return TRUE;
}

int TContainer::CursorType(PTObjectInstance inst)
{
	if (Openable() || NumObjects() > 0)
		return CURSOR_HAND;

	return CURSOR_NONE;
}

int TContainer::NumObjects()
{
	return RealNumInventoryItems();
}

void TContainer::Load(RTInputStream is, int version, int objversion)
{
	TObjectInstance::Load(is, version, objversion);

	if (version >= 2 && version < 5) // We're using object stats now
	{
		int contflags, pickdifficulty;
		is >> contflags >> pickdifficulty;
		SetStat("Locked", contflags != 0);
		SetStat("PickDifficulty", pickdifficulty);
	}

}

void TContainer::Save(RTOutputStream os)
{
	TObjectInstance::Save(os);
}

BOOL TContainer::CheckKeyUse(PTObjectInstance user, PTObjectInstance inst)
{
	if (!inst || !Locked())
		return FALSE;

	// check for the key unlock
	if (inst->ObjClass() == OBJCLASS_KEY)
	{
		if (((PTKey)inst)->KeyId() == KeyId())
		{	
			PLAY("unlock succeed");
			TextBar.Print("Unlocked.");
			SetLocked(FALSE);
			return TRUE;
		}
		else
		{
			PLAY("unlock failed");
			TextBar.Print("This is the wrong key.");
			return TRUE;
		}
	}

	// check for a lockpick attempt
	if (inst->ObjClass() == OBJCLASS_TOOL)
	{
		int abil = ((PTTool)inst)->Pick();
		if (abil > 0)
		{
			if (user->ObjClass() == OBJCLASS_PLAYER)
				abil += ((PTPlayer)user)->Agil() + ((PTPlayer)user)->Skill(SK_LOCKPICK);

			if (abil < PickDifficulty())
			{
				PLAY("unlock fail");
				TextBar.Print("The lock is too difficult to pick.");
			}
			else if (random(0, abil) < PickDifficulty())
			{
				PLAY("unlock fail");
				TextBar.Print("You fail to pick the lock.");
			}
			else
			{
				PLAY("unlock succeed");
				TextBar.Print("The lock quietly yields to your skills.");
				SetLocked(FALSE);
			}

			return TRUE;
		}
	}

	return FALSE;
}


// *************
// * TVialRack *
// *************

_CLASSDEF(TVialRack)
class TVialRack : public TContainer
{
  public:
	TVialRack(PTObjectImagery newim) : TContainer(newim) {}
	TVialRack(PSObjectDef def, PTObjectImagery newim) : TContainer(def, newim) {}

	virtual BOOL Use(PTObjectInstance user, int with = -1);
	virtual int CursorType(PTObjectInstance inst = NULL);
	virtual void Save(RTOutputStream os);
};

DEFINE_BUILDER("VIAL RACK", TVialRack)
REGISTER_BUILDER(TVialRack)

BOOL TVialRack::Use(PTObjectInstance user, int with)
{
	PTObjectInstance inst = MapPane.GetInstance(with);

	if (!inst)
	{
		if (state > 0)
		{
			if ((DWORD)Inventory.GetContainer()->FindFreeInventorySlot() >= MAXINVITEMS)
				TextBar.Print("Can't carry any more.");
			else
			{
				// generate a new vial
				SObjectDef def;
				memset(&def, 0, sizeof(SObjectDef));
				def.objclass = OBJCLASS_CONTAINER;
				def.objtype = ContainerClass.FindObjType("Empty Vial");
				GetPos(def.pos);
				int index = MapPane.NewObject(&def);

				TakenObject = MapPane.GetInstance(index);
				Inventory.GetContainer()->AddToInventory(TakenObject);

				TextBar.Print("Poison Vial taken from Vial Rack.");
				SetState(state - 1);

				return TRUE;
			}
		}
	}
	else
	{
		if (strcmp(inst->GetName(), "Poison Empty Vial") == 0 && state < 4)
		{
			// Originally I just deleted the vial here, but this caused problems
			// in shop scripts.  Now I just stash it into the rack, which clears itself
			// out when it saves to disk.

			//MapPane.RemoveObject(with);
			//delete inst;

			inst->RemoveFromInventory();
			AddToInventory(inst);

			TextBar.Print("Poison Vial put in Vial Rack.");
			SetState(state + 1);

			DroppedObject = inst;

			return TRUE;
		}
	}

	return FALSE;
}

int TVialRack::CursorType(PTObjectInstance inst)
{
	if (state > 0 && (!inst || (state < 4 && strcmp(inst->GetName(), "Poison Vial") == 0)))
		return CURSOR_HAND;

	return CURSOR_NONE;
}

void TVialRack::Save(RTOutputStream os)
{
	inventory.DeleteAll();

	TContainer::Save(os);
}

// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                   ctrlmap.h - Game Control Mapper                     *
// *************************************************************************

#include "revenant.h"
#include "ctrlmap.h"
#include "directinput.h"

_STRUCTDEF(SKeyName)
struct SKeyName
{
	int key;
	char *name;
};

static SKeyName keynames[] =
{
    {VK_LBUTTON, "LBUTTON"},
    {VK_RBUTTON, "RBUTTON"},
    {VK_CANCEL, "CANCEL"},
    {VK_MBUTTON, "MBUTTON"},
    {VK_BACK, "BS"},
    {VK_TAB, "TAB"},
    {VK_CLEAR, "CLEAR"},
    {VK_RETURN, "RETURN"},
    {VK_SHIFT, "SHIFT"},
    {VK_CONTROL, "CTRL"},
    {VK_MENU, "MENU"},
    {VK_PAUSE, "PAUSE"},
    {VK_CAPITAL, "CAPS"},
    {VK_ESCAPE, "ESCAPE"},
    {VK_SPACE, "SPACE"},
    {VK_PRIOR, "PGUP"},
    {VK_NEXT, "PGDN"},
    {VK_END, "END"},
    {VK_HOME, "HOME"},
    {VK_LEFT, "LEFT"},
    {VK_UP, "UP"},
    {VK_RIGHT, "RIGHT"},
    {VK_DOWN, "DOWN"},
    {VK_SELECT, "SELECT"},
    {VK_EXECUTE, "EXECUTE"},
    {VK_SNAPSHOT, "SNAPSHOT"},
    {VK_INSERT, "INS"},
    {VK_DELETE, "DEL"},
    {VK_HELP, "HELP"},
    {VK_LWIN, "LWIN"},
    {VK_RWIN, "RWIN"},
    {VK_APPS, "APPS"},
    {VK_NUMPAD0, "NUM0"},
    {VK_NUMPAD1, "NUM1"},
    {VK_NUMPAD2, "NUM2"},
    {VK_NUMPAD3, "NUM3"},
    {VK_NUMPAD4, "NUM4"},
    {VK_NUMPAD5, "NUM5"},
    {VK_NUMPAD6, "NUM6"},
    {VK_NUMPAD7, "NUM7"},
    {VK_NUMPAD8, "NUM8"},
    {VK_NUMPAD9, "NUM9"},
    {VK_MULTIPLY, "NUMMULT"},
    {VK_ADD, "NUMADD"},
    {VK_SEPARATOR, "SEPARATOR"},
    {VK_SUBTRACT, "NUMSUB"},
    {VK_DECIMAL, "NUMDEC"},
    {VK_DIVIDE, "NUMDIV"},
    {VK_F1, "F1"},
    {VK_F2, "F2"},
    {VK_F3, "F3"},
    {VK_F4, "F4"},
    {VK_F5, "F5"},
    {VK_F6, "F6"},
    {VK_F7, "F7"},
    {VK_F8, "F8"},
    {VK_F9, "F9"},
    {VK_F10, "F10"},
    {VK_F11, "F11"},
    {VK_F12, "F12"},
    {VK_F13, "F13"},
    {VK_F14, "F14"},
    {VK_F15, "F15"},
    {VK_F16, "F16"},
    {VK_F17, "F17"},
    {VK_F18, "F18"},
    {VK_F19, "F19"},
    {VK_F20, "F20"},
    {VK_F21, "F21"},
    {VK_F22, "F22"},
    {VK_F23, "F23"},
    {VK_F24, "F24"},
    {VK_NUMLOCK, "NUMLOCK"},
    {VK_SCROLL, "SCROLL"},
    {VK_ATTN, "ATTN"},
    {VK_CRSEL, "CRSEL"},
    {VK_EXSEL, "EXSEL"},
    {VK_EREOF, "EREOF"},
    {VK_PLAY, "PLAY"},
    {VK_ZOOM, "ZOOM"},
    {VK_NONAME, "NONAME"},
    {VK_JOYUPLEFT, "JOYUPLF"},
    {VK_JOYUP, "JOYUP"},
    {VK_JOYUPRIGHT, "JOYUPRT"},
    {VK_JOYLEFT, "JOYLF"},
    {VK_JOYRIGHT, "JOYRT"},
    {VK_JOYDOWNLEFT, "JOYDNLF"},
    {VK_JOYDOWN, "JOYDN"},
    {VK_JOYDOWNRIGHT, "JOYDNRT"},
    {VK_JOYBUTTON1, "JOY1"},
    {VK_JOYBUTTON2, "JOY2"},
    {VK_JOYBUTTON3, "JOY3"},
    {VK_JOYBUTTON4, "JOY4"},
    {VK_JOYBUTTON5, "JOY5"},
    {VK_JOYBUTTON6, "JOY6"},
    {VK_JOYBUTTON7, "JOY7"},
    {VK_JOYBUTTON8, "JOY8"},
    {VK_JOYBUTTON9, "JOY9"},
    {VK_JOYBUTTON10, "JOY10"},
    {VK_JOYBUTTON11, "JOY11"},
    {VK_JOYBUTTON12, "JOY12"},
    {VK_JOYBUTTON13, "JOY13"},
    {VK_JOYBUTTON14, "JOY14"},
    {VK_JOYBUTTON15, "JOY15"},
    {VK_JOYBUTTON16, "JOY16"},
    {VK_JOYBUTTON17, "JOY17"},
    {VK_JOYBUTTON18, "JOY18"},
    {VK_JOYBUTTON19, "JOY19"},
    {VK_JOYBUTTON20, "JOY20"},
    {VK_JOYBUTTON21, "JOY21"},
    {VK_JOYBUTTON22, "JOY22"},
    {VK_JOYBUTTON23, "JOY23"},
    {VK_JOYBUTTON24, "JOY24"}
};
#define NUMKEYNAMES sizearray(keynames)

// Initialize the control mapper from a static list of controls
BOOL TControlMap::Initialize(int numcontrols, PSControlEntry controlarray)
{
	if (initialized)
		return TRUE;

	controls.Clear();
	for (int c = 0; c < numcontrols; c++)
	{
		controls.Add(controlarray[c]); // Note virtual array stores copy of structure only
	}

	cmdflagstate = cmdflagchanged = 0;

	initialized = TRUE;

	return TRUE;
}

// closes the control mapper
void TControlMap::Close()
{
	if (!initialized)
		return;

	controls.Clear();

	initialized = FALSE;
}

// Returns the control entry for the given index
void TControlMap::GetControlEntry(int index, PSControlEntry ce)
{
	if (!initialized)
		return;

	if ((DWORD)index >= (DWORD)controls.NumItems())
		return;

	memcpy(ce, &(controls[index]), sizeof(SControlEntry));
}

// Returns the control entry for the given index
void TControlMap::SetControlEntry(int index, PSControlEntry ce)
{
	if (!initialized)
		return;

	if ((DWORD)index >= (DWORD)controls.NumItems())
		return;

	memcpy(&(controls[index]), ce, sizeof(SControlEntry));
}

// Returns the game command given the 'keycode'
int TControlMap::GetCommand(int keycode, BOOL down, DWORD modeflags)
{
	if (!initialized)
		return 0;

	for (int c = 0; c < controls.NumItems(); c++)
	{
		if (!controls.Used(c))
			continue;

		PSControlEntry ce = &(controls[c]);

	  // Do key codes one by one
		for (int code = 0; code < CODESPERCOMMAND; code++)
		{
			PSControlKey ck = &ce->codes[code];

			if (ck->keys[0] <= 0) // This code not used
				continue;

          // Start at last key, and go backwards
			int key = KEYSPERCODE - 1;
			int kdown = 1 << (KEYSPERCODE - 1);
			int kmask = 0xFFFFFFFF >> (32 - (KEYSPERCODE - 1));

		  // Find last key
			while (key > 0 && ck->keys[key] <= 0)
			{
				key--;
				kdown = kdown >> 1;
				kmask = kmask >> 1;
			}
				
		  // If we are last key, and other keys are down, return a command
			if ((ck->keys[key] == keycode) &&		// Key matches last key of command
				((ce->down && !down) |				// Currently down and key is up OR...
				((ck->flags & kmask) == kmask)))	// Prefix keys for command (if any) are down
			{
				if (down)
					ck->flags |= kdown;
				else
					ck->flags &= ~kdown;

				if (ce->mode & modeflags &&			// Command is part of this mode	
					ce->down != down)				// Not a key repeat (already down)
				{
					cmdflagchanged |= ce->cmdflag;

					ce->down = down;				// Indicate that command is down or not
					if (down)
					{
						cmdflagstate |= ce->cmdflag;
						return ce->downcmd;
					}
					else
					{
						cmdflagstate &= ~(ce->cmdflag);
						return ce->upcmd;
					}
				}
			}
					
		  // Set or clear down flags for prefix keys
			key--;
			kdown = kdown >> 1;
			while (key >= 0)
			{
				if (ck->keys[key] == keycode)
				{
					if (down)
						ck->flags |= kdown;
					else
						ck->flags &= ~kdown;
				}
				key--;
				kdown = kdown >> 1;
			}

		} // End of code loop
	
	} // End of command entry loop

	return 0;
}

BOOL TControlMap::CommandOn(int command, DWORD modeflags)
{
	if (!initialized)
		return FALSE;

	for (int c = 0; c < controls.NumItems(); c++)
	{
		if (!controls.Used(c))
			continue;

		PSControlEntry ce = &(controls[c]);

		if ((ce->downcmd == command) &&			// Command matches
		     ce->down &&						// Key or keys are currently down
			(ce->mode & modeflags))				// We're in this mode
				return TRUE;
		else if (ce->upcmd == command)			// Matches up command and we weren't down
			return TRUE;
	}

	return FALSE;
}

// Clears command settings
void TControlMap::Clear()
{
	if (!initialized)
		return;

	for (int c = 0; c < controls.NumItems(); c++)
	{
		if (!controls.Used(c))
			continue;

		PSControlEntry ce = &(controls[c]);

		ce->down = FALSE;

	  // Do key codes one by one
		for (int code = 0; code < CODESPERCOMMAND; code++)
		{
			PSControlKey ck = &ce->codes[code];

			for (int key = 0;  key < KEYSPERCODE; key++)
				ck->keys[key] = 0;

			ck->flags = 0;
		}
	}
}

// Gets a keycode id given the ascii string name
int TControlMap::GetKeyCode(char *name)
{
	if (name[1] == NULL && (name[0] >= 'A' && name[0] <= 'Z'))
		return name[0];
	if (name[1] == NULL && (name[0] >= 'a' && name[0] <= 'z'))
		return name[0] - 'a' + 'A';
	for (int c = 0; c < NUMKEYNAMES; c++)
	{
		if (!stricmp(name, keynames[c].name))
			return keynames[c].key;
	}

	return 0;
}

// Gets a string name given the keycode id
char *TControlMap::GetKeyName(int keycode)
{
	static char buf[2];
	if (keycode >= 'A' && keycode <= 'Z')
	{
		buf[0] = (char)keycode;
		buf[1] = NULL;
		return buf;
	}

	for (int c = 0; c < NUMKEYNAMES; c++)
	{
		if (keynames[c].key == keycode)
			return keynames[c].name;
	}

	return NULL;
}

// Takes an array of keycodes and returns a keystring with the format "CTRL-SHIFT-A"
char *TControlMap::MakeKeyString(int numkeys, int *keys, char *buf, int buflen)
{
	buf[0] = NULL;

	if (numkeys < 1 || keys[0] <= 0)
		return buf;

	for (int c = 0; c < numkeys; c++)
	{
		if (keys[c] <= 0)
			break;

		char *keyname = GetKeyName(keys[c]);
		if (!keyname)
			break;

		if (c > 0)
			strncatz(buf, "-", buflen);

		strncatz(buf, keyname, buflen);
	}

	return buf;
}

// Takes a string of the format "CTRL-A"
int TControlMap::ParseKeyString(char *str, int numkeys, int *keys)
{
	char buf[64];
	strncpyz(buf, str, 64);

	char *t = buf;
	char *p = strchr(buf, '-');
	if (p)
		*p = NULL;

	int key = 0;
	int num = 0;
	while (t && *t && key < numkeys)
	{
		keys[key] = GetKeyCode(t);

		if (p)
		{
			t = p + 1;
			p = strchr(t, '-');
			if (p)
				*p = NULL;
		}
		else
			t = NULL;

		key++;
		num++;
	}

	while (key < numkeys)
	{
		keys[key] = 0;
		key++;
	}

	return num;
}

// Takes a command entry structure, and creates a string of the format "CTRL-A,SHIFT-F1"
char *TControlMap::MakeCommandString(PSControlEntry ce, char *buf, int buflen)
{
	buf[0] = NULL;

	for (int code = 0; code < CODESPERCOMMAND; code++)
	{
		PSControlKey ck = &ce->codes[code];
		if (ck->keys[0] > 0)
		{
			if (code > 0)
				strncatz(buf, ",", buflen);
			char keybuf[64];
			MakeKeyString(KEYSPERCODE, ck->keys, keybuf, 64);
			strncatz(buf, keybuf, buflen);
		}
	}

	return buf;
}

// Takes a command string and parses it into keys for command structure
int TControlMap::ParseCommandString(char *str, PSControlEntry ce)
{
	char buf[80];
	strncpyz(buf, str, 80);

	char *t = buf;
	char *p = strchr(buf, ',');
	if (p)
		*p = NULL;

	int code = 0;
	int num = 0;
	while (t && *t && code < CODESPERCOMMAND)
	{
		ParseKeyString(t, KEYSPERCODE, ce->codes[code].keys);
		ce->codes[code].flags = 0;

		if (p)
		{
			t = p + 1;
			p = strchr(t, ',');
			if (p)
				*p = NULL;
		}
		else
			t = NULL;

		code++;
		num++;
	}

	while (code < CODESPERCOMMAND)
	{
		for (int key = 0; key < KEYSPERCODE; key++)
			ce->codes[code].keys[key] = 0;
		ce->codes[code].flags = 0;
		code++;
	}

	ce->down = FALSE;

	return num;
}

// Loads settings from the INI file
void TControlMap::Load(char *section)
{
	INISetSection("Controls");

	for (int c = 0; c < controls.NumItems(); c++)
	{
		if (!controls.Used(c))
			continue;
		
		PSControlEntry ce = &(controls[c]);

		char defbuf[64];
		MakeCommandString(ce, defbuf, 64);

		char buf[64];
		INIGetStr(ce->id, defbuf, buf, 64);

		ParseCommandString(buf, ce);
	}
}

// Saves settings to the INI file
void TControlMap::Save(char *section)
{
	INISetSection("Controls");

	for (int c = 0; c < controls.NumItems(); c++)
	{
		if (!controls.Used(c))
			continue;
		
		PSControlEntry ce = &(controls[c]);

		char buf[64];
		MakeCommandString(ce, buf, 64);

		INISetStr(ce->id, buf);
	}
}// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                  cursor.cpp - Mouse cursor handling                   * 
// *************************************************************************

#include <windows.h>

#include "revenant.h"
#include "bitmap.h"
#include "display.h"
#include "bmsurface.h"
#include "cursor.h"
#include "object.h"
#include "multi.h"
#include "playscreen.h"
#include "mainwnd.h"

// Globals for storing current mouse imagery
PTBitmap MouseCursor = NULL;
PTBitmap MouseShadow = NULL;
int shadowoffsetx = 0, shadowoffsety = 0;
PTBitmap MouseCursorAdd = NULL;		// Little picture that goes in the corner
BOOL priority;						// Priority of mouse image

PTBitmap DragBitmap = NULL;
int grabx, graby;

PTObjectInstance DragObj = NULL;

BOOL cleardragbitmap = FALSE;

int oldcursorx = WIDTH/2, oldcursory = HEIGHT/2;	// Save cursor pos between activations

// List of cursor types
char *CursorTypes[NUMCURSORTYPES] = { "hand", "eye", "mouth", "door", "stairs", "hourglass", "swords" };


void SetMouseBitmap(PTBitmap cursor)
{
	MouseCursor = cursor;

	if (cursor == GameData->Bitmap("cursor"))
		SetMouseShadow(GameData->Bitmap("cursorshadow"));
	else
	{
		//MouseShadow = NULL;
		MouseCursorAdd = NULL;		// no corner bitmaps if not in regular cursor
		priority = TRUE;
	}
}

void SetMouseShadow(PTBitmap shadow, int offsetx, int offsety)
{
	MouseShadow = shadow;
	shadowoffsetx = offsetx;
	shadowoffsety = offsety;
}

void SetMouseCornerBitmap(PTBitmap corner, BOOL toppriority)
{
	if (corner || toppriority)
	{
		MouseCursorAdd = corner;
		priority = toppriority;
	}
}

void SetMouseCornerBitmap(int type, BOOL toppriority)
{
	if (type != CURSOR_NONE || toppriority)
		SetMouseCornerBitmap(type != CURSOR_NONE ? GameData->Bitmap(CursorTypes[type]) : NULL);
}

void SetDragBitmap(PTBitmap drag, int x, int y)
{
	DragBitmap = drag;
	grabx = x;
	graby = y;
}

void ClearDragBitmap()
{
	cleardragbitmap = TRUE;
}

void SetDragObj(PTObjectInstance inst)
{
	DragObj = inst;
}

PTObjectInstance GetDragObj()
{
	return DragObj;
}

void DrawMouseShadow(int x, int y, int width, int height)
{
	Display->SetClipRect(x, y, width, height);
	Display->Put(cursorx + shadowoffsetx, cursory + shadowoffsety, MouseShadow, DM_TRANSPARENT | DM_USEREG | DM_ALIAS);
}

void DrawMouseCursor()
{
	// draw the bitmap first so that the cursor appears over the top of it
	if (DragBitmap)
		Display->Put(cursorx - grabx, cursory - graby, DragBitmap, DM_TRANSPARENT | DM_USEREG);

	if (MouseCursor && !MouseCursorAdd)
		Display->Put(cursorx, cursory, MouseCursor, DM_TRANSPARENT | DM_USEREG | DM_ALIAS);

	if (MouseCursorAdd)
		Display->Put(cursorx, cursory, MouseCursorAdd, DM_TRANSPARENT | DM_USEREG | DM_ALIAS);

	if (cleardragbitmap)
	{
		SetDragBitmap(NULL);
		cleardragbitmap = FALSE;
	}

	MouseCursorAdd = NULL;
	priority = FALSE;
}

void DrawMouseShadow()
{
	if (MouseShadow)
	{
		Display->SetOrigin(0, 0);

		if (MouseShadow != GameData->Bitmap("cursorshadow"))
			DrawMouseShadow(MAPPANEX, MAPPANEY, MAPPANEWIDTH, MAPPANEHEIGHT);
		else
		{
			if (PlayScreen.InCompleteExclusion())
				DrawMouseShadow(0, 0, WIDTH, HEIGHT);
			else
			{
				if (cursorx <= MAPPANEX)
					DrawMouseShadow(0, 0, MAPPANEX, HEIGHT);
				else if ((cursorx + MouseShadow->width) >= (MAPPANEX + MAPPANEWIDTH))
					DrawMouseShadow(MAPPANEX + MAPPANEWIDTH, 0, WIDTH - (MAPPANEX + MAPPANEWIDTH), HEIGHT);

				if (cursory <= MAPPANEY)
					DrawMouseShadow(0, 0, WIDTH, MAPPANEY);
				else if ((cursory + MouseShadow->height) >= (MAPPANEY + MAPPANEHEIGHT))
					DrawMouseShadow(0, MAPPANEY + MAPPANEHEIGHT, WIDTH, HEIGHT - (MAPPANEY + MAPPANEHEIGHT));
			}
		}

		Display->ResetClipRect();
	}
}

void CursorOverObject(PTObjectInstance inst, BOOL toppriority)
{
	if (toppriority || !priority)
	{
		int type = CURSOR_NONE;

		if (inst)
			type = inst->CursorType(DragObj);

		SetMouseCornerBitmap(type, toppriority);
	}
}

void RestrictCursor()
{
	// center the cursor
	RECT r;
	GetClientRect(MainWindow.Hwnd(), &r);
	ClientToScreen(MainWindow.Hwnd(), (LPPOINT)&r);
	SetCursorPos(r.left + oldcursorx, r.top + oldcursory);

	// clip if not windowed
	if (!Windowed || Borderless)
	{
		r.right = r.left + WIDTH;
		r.bottom = r.top + HEIGHT;
		ClipCursor(&r);
	}
}

void ReleaseCursor()
{
	// save the old position for restore after reactivation
	oldcursorx = cursorx;
	oldcursory = cursory;

	// clear out the clip rect (cursor can move anywhere)
	ClipCursor(NULL);
}

/*==========================================================================
 *
 *  Copyright (C) 1995, 1996 Microsoft Corporation. All Rights Reserved.
 *
 *  File: d3dmath.cpp
 *
 ***************************************************************************/

#include <d3d.h>
#include "d3dmath.h"

typedef D3DVALUE MATRIX[4][4];

static D3DMATRIX IDENTITY = {
	D3DVAL(1.0), D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0),
	D3DVAL(0.0), D3DVAL(1.0), D3DVAL(0.0), D3DVAL(0.0),
	D3DVAL(0.0), D3DVAL(0.0), D3DVAL(1.0), D3DVAL(0.0),
	D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0), D3DVAL(1.0)
};

/*
 * Normalises the vector v
 */
LPD3DVECTOR 
D3DVECTORNormalise(LPD3DVECTOR v)
{
    float vx, vy, vz, inv_mod;
    vx = v->x;
    vy = v->y;
    vz = v->z;
    if ((vx == 0) && (vy == 0) && (vz == 0))
        return v;
    inv_mod = (float)(1.0 / sqrt(vx * vx + vy * vy + vz * vz));
    v->x = vx * inv_mod;
    v->y = vy * inv_mod;
    v->z = vz * inv_mod;
    return v;
}


/*
 * Calculates cross product of a and b.
 */
LPD3DVECTOR 
D3DVECTORCrossProduct(LPD3DVECTOR lpd, LPD3DVECTOR lpa, LPD3DVECTOR lpb)
{

    lpd->x = lpa->y * lpb->z - lpa->z * lpb->y;
    lpd->y = lpa->z * lpb->x - lpa->x * lpb->z;
    lpd->z = lpa->x * lpb->y - lpa->y * lpb->x;
    return lpd;
}

/*
 * Clears matrix to the identity matrix.
 */
LPD3DMATRIX D3DMATRIXClear(LPD3DMATRIX lpMat)
{
	memcpy(lpMat, &IDENTITY, sizeof(D3DMATRIX));
	return lpMat;
}

/*
 * lpDst = lpSrc1 * lpSrc2
 * lpDst can be equal to lpSrc1 or lpSrc2
 */
LPD3DMATRIX MultiplyD3DMATRIX(LPD3DMATRIX lpDst, LPD3DMATRIX lpSrc1, 
                              LPD3DMATRIX lpSrc2)
{
    MATRIX &M1 = *(MATRIX *)lpSrc1;
	MATRIX &M2 = *(MATRIX *)lpSrc2;
	MATRIX D;
    int i, r, c;

    for (r = 0; r < 4; r++) {
        for (c = 0; c < 4; c++) {
            D[r][c] = (float)0.0;
            for (i = 0; i < 4; i++)
                D[r][c] += M1[r][i] * M2[i][c];
        }
    }

	memcpy(lpDst, D, sizeof(D3DMATRIX));

    return lpDst;
}

void D3DMATRIXTransform(LPD3DMATRIX lpm, LPD3DVECTOR lpV, LPD3DVECTOR lpD)
{
	D3DVECTOR v;
	v.x = lpV->x;
	v.y = lpV->y;
	v.z = lpV->z;

	lpD->x = lpm->_11 * v.x  + lpm->_21 * v.y + lpm->_31 * v.z + lpm->_41;
	lpD->y = lpm->_12 * v.x  + lpm->_22 * v.y + lpm->_32 * v.z + lpm->_42;
	lpD->z = lpm->_13 * v.x  + lpm->_23 * v.y + lpm->_33 * v.z + lpm->_43;
}

/*
 * -1 d = a
 */
LPD3DMATRIX D3DMATRIXInvert(LPD3DMATRIX d, LPD3DMATRIX a)
{
    d->_11 = a->_11;
    d->_12 = a->_21;
    d->_13 = a->_31;
    d->_14 = a->_14;

    d->_21 = a->_12;
    d->_22 = a->_22;
    d->_23 = a->_32;
    d->_24 = a->_24;

    d->_31 = a->_13;
    d->_32 = a->_23;
    d->_33 = a->_33;
    d->_34 = a->_34;

    d->_41 = a->_14;
    d->_42 = a->_24;
    d->_43 = a->_34;
    d->_44 = a->_44;

    return d;
}


/*
 * Set the rotation part of a matrix such that the vector lpD is the new
 * z-axis and lpU is the new y-axis.
 */
LPD3DMATRIX D3DMATRIXSetRotation(LPD3DMATRIX lpM, LPD3DVECTOR lpD, LPD3DVECTOR lpU)
{
    float t;
    D3DVECTOR d, u, r;

    /*
     * Normalise the direction vector.
     */
    d.x = lpD->x;
    d.y = lpD->y;
    d.z = lpD->z;
    D3DVECTORNormalise(&d);

    u.x = lpU->x;
    u.y = lpU->y;
    u.z = lpU->z;
    /*
     * Project u into the plane defined by d and normalise.
     */
    t = u.x * d.x + u.y * d.y + u.z * d.z;
    u.x -= d.x * t;
    u.y -= d.y * t;
    u.z -= d.z * t;
    D3DVECTORNormalise(&u);

    /*
     * Calculate the vector pointing along the matrix x axis (in a right
     * handed coordinate system) using cross product.
     */
    D3DVECTORCrossProduct(&r, &u, &d);

    lpM->_11 = r.x;
    lpM->_12 = r.y, lpM->_13 = r.z;
    lpM->_21 = u.x;
    lpM->_22 = u.y, lpM->_23 = u.z;
    lpM->_31 = d.x;
    lpM->_32 = d.y;
    lpM->_33 = d.z;

    return lpM;
}

/*
 * Set translates a matrix such that the vector lpV is the new
 * x, y, and z orign.
 */
LPD3DMATRIX D3DMATRIXTranslate(LPD3DMATRIX lpDst, LPD3DVECTOR lpV)
{
	MATRIX m;
	memcpy(&m, &IDENTITY, sizeof(D3DMATRIX));
	m[3][0] = lpV->x;
	m[3][1] = lpV->y;
	m[3][2] = lpV->z;
	MultiplyD3DMATRIX(lpDst, lpDst, (LPD3DMATRIX)&m);
	return lpDst;
}

/*
 * Set the translation part of a matrix such that the vector lpV is the new
 * x, y, and z orign.
 */
LPD3DMATRIX D3DMATRIXMove(LPD3DMATRIX lpDst, LPD3DVECTOR lpV)
{
	MATRIX m;
	memcpy(&m, &IDENTITY, sizeof(D3DMATRIX));
	m[3][0] = -lpV->x;
	m[3][1] = -lpV->y;
	m[3][2] = -lpV->z;
	MultiplyD3DMATRIX(lpDst, lpDst, (LPD3DMATRIX)&m);
	return lpDst;
}

/*
 * Set the scale part of a matrix such that the vector lpV is the new
 * x, y, and z orign.
 */
LPD3DMATRIX D3DMATRIXScale(LPD3DMATRIX lpDst, LPD3DVECTOR lpV)
{
	MATRIX m;
	memcpy(&m, &IDENTITY, sizeof(D3DMATRIX));
	m[0][0] = lpV->x;
	m[1][1] = lpV->y;
	m[2][2] = lpV->z;
	MultiplyD3DMATRIX(lpDst, lpDst, (LPD3DMATRIX)&m);
	return lpDst;
}

/*
 * Set the X rotation components of a matrix given the angle in radians.
 */
LPD3DMATRIX D3DMATRIXRotateX(LPD3DMATRIX lpDst, D3DVALUE a)
{
	float c = (float)cos((double)a);
	float s = (float)sin((double)a);
	MATRIX m;
	memcpy(&m, &IDENTITY, sizeof(D3DMATRIX));
	m[1][1] = c;
	m[1][2] = s;
	m[2][1] = -s;
	m[2][2] = c;
	MultiplyD3DMATRIX(lpDst, lpDst, (LPD3DMATRIX)&m);
	return lpDst;
}

/*
 * Set the Y rotation components of a matrix given the angle in radians.
 */
LPD3DMATRIX D3DMATRIXRotateY(LPD3DMATRIX lpDst, D3DVALUE a)
{
	float c = (float)cos((double)a);
	float s = (float)sin((double)a);
	MATRIX m;
	memcpy(&m, &IDENTITY, sizeof(D3DMATRIX));
	m[0][0] = c;
	m[0][2] = -s;
	m[2][0] = s;
	m[2][2] = c;
	MultiplyD3DMATRIX(lpDst, lpDst, (LPD3DMATRIX)&m);
	return lpDst;
}

/*
 * Set the Z rotation components of a matrix given the angle in radians.
 */
LPD3DMATRIX D3DMATRIXRotateZ(LPD3DMATRIX lpDst, D3DVALUE a)
{
	float c = (float)cos((double)a);
	float s = (float)sin((double)a);
	MATRIX m;
	memcpy(&m, &IDENTITY, sizeof(D3DMATRIX));
	m[0][0] = c;
	m[0][1] = s;
	m[1][0] = -s;
	m[1][1] = c;
	MultiplyD3DMATRIX(lpDst, lpDst, (LPD3DMATRIX)&m);
	return lpDst;
}

/*
 * Calculates a point along a B-Spline curve defined by four points. p
 * n output, contain the point. t                                Position
 * along the curve between p2 and p3.  This position is a float between 0
 * and 1. p1, p2, p3, p4    Points defining spline curve. p, at parameter
 * t along the spline curve
 */
void 
spline(LPD3DVECTOR p, float t, LPD3DVECTOR p1, LPD3DVECTOR p2,
       LPD3DVECTOR p3, LPD3DVECTOR p4)
{
    double t2, t3;
    float m1, m2, m3, m4;

    t2 = (double)(t * t);
    t3 = t2 * (double)t;

    m1 = (float)((-1.0 * t3) + (2.0 * t2) + (-1.0 * (double)t));
    m2 = (float)((3.0 * t3) + (-5.0 * t2) + (0.0 * (double)t) + 2.0);
    m3 = (float)((-3.0 * t3) + (4.0 * t2) + (1.0 * (double)t));
    m4 = (float)((1.0 * t3) + (-1.0 * t2) + (0.0 * (double)t));

    m1 /= (float)2.0;
    m2 /= (float)2.0;
    m3 /= (float)2.0;
    m4 /= (float)2.0;

    p->x = p1->x * m1 + p2->x * m2 + p3->x * m3 + p4->x * m4;
    p->y = p1->y * m1 + p2->y * m2 + p3->y * m3 + p4->y * m4;
    p->z = p1->z * m1 + p2->z * m2 + p3->z * m3 + p4->z * m4;
}

// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                ddsurface.cpp - EXILE Surface Object                   *
// *************************************************************************

#include <windows.h>
#include <ddraw.h>

#include "revenant.h"
#include "directdraw.h"
#include "bitmap.h"
#include "display.h"
#include "ddsurface.h"
#include "graphics.h"

// Direct Draw Global variables

extern LPDIRECTDRAW DirectDraw;       // DirectDraw pointer
extern BOOL			BlitHardware;
extern DWORD		ZBufferBitDepth;

TDDSurface::TDDSurface()
{
	surface = NULL;
}

void TDDSurface::Initialize(int vidwidth, int vidheight, int createflags, int vidstride)
{
	if (surface != NULL)
		return;

  // Don't allow any real zbuffer surfaces if in voodoo mode
	if (NoBlitZBuffer)
		createflags &= ~VSURF_ZBUFFER;

	vidwidth &= 0xfffe;

	if ((createflags & VSURF_VIDEOMEM) &&
		(GetFreeVideoMem() - (vidwidth * vidheight * 2) < TEXTURERESERVE))
	{
		if (createflags & VSURF_VIDEOONLY)
			Error("Not enough video memory for textures");
		createflags &= ~VSURF_VIDEOMEM;
		createflags |= VSURF_SYSTEMMEM;
	}

	HRESULT             DirectDrawReturn;
	DDSURFACEDESC       ddsd;
	LPDIRECTDRAWSURFACE Surface;

	ddsd.dwSize         = sizeof(ddsd);
	ddsd.dwFlags        = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH /* | DDSD_PIXELFORMAT*/;
	if (createflags & VSURF_VIDEOMEM)
		ddsd.ddsCaps.dwCaps = DDSCAPS_VIDEOMEMORY;	
	else if (createflags & VSURF_SYSTEMMEM)
		ddsd.ddsCaps.dwCaps = DDSCAPS_SYSTEMMEMORY;	
	else
		Error("Invalid TDDSurface initialize flag");

	if (createflags & VSURF_ZBUFFER)
	{
		ddsd.ddsCaps.dwCaps |= DDSCAPS_ZBUFFER;
        ddsd.dwFlags |= DDSD_ZBUFFERBITDEPTH;
		ddsd.dwZBufferBitDepth = ZBufferBitDepth;
	}
	else
	{
		ddsd.ddsCaps.dwCaps |= DDSCAPS_OFFSCREENPLAIN;
	}

	ddsd.dwHeight       = vidheight;
	ddsd.dwWidth        = vidwidth;
	if (vidstride != 0)
		ddsd.dwWidth = vidstride;

/*	ddsd.ddpfPixelFormat.dwFlags = DDPF_RGB;
	ddsd.ddpfPixelFormat.dwRGBBitCount = 16;
	ddsd.ddpfPixelFormat.dwRBitMask = 0x7C00;
	ddsd.ddpfPixelFormat.dwGBitMask = 0x03E0;
	ddsd.ddpfPixelFormat.dwBBitMask = 0x001F;
	ddsd.ddpfPixelFormat.dwRGBAlphaBitMask = 0;
*/
	DirectDrawReturn = DirectDraw->CreateSurface(&ddsd, &Surface, NULL);

	if (DirectDrawReturn != DD_OK)
	{
		if ((createflags & VSURF_VIDEOMEM) && (createflags & VSURF_VIDEOONLY))
			Error("Unable to allocate video memory for surface");

		ddsd.dwSize         = sizeof(ddsd);
		ddsd.dwFlags        = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH;
		ddsd.ddsCaps.dwCaps = DDSCAPS_SYSTEMMEMORY;	
		ddsd.dwHeight       = vidheight;
		ddsd.dwWidth        = vidwidth;
		if (vidstride != 0)
			ddsd.dwWidth = vidstride;

		if (createflags & VSURF_ZBUFFER)
		{
			ddsd.ddsCaps.dwCaps |= DDSCAPS_ZBUFFER;
			ddsd.dwFlags |= DDSD_ZBUFFERBITDEPTH;
			ddsd.dwZBufferBitDepth = ZBufferBitDepth;
		}
		else
		{
			ddsd.ddsCaps.dwCaps |= DDSCAPS_OFFSCREENPLAIN;
		}

		DirectDrawReturn = DirectDraw->CreateSurface(&ddsd, &Surface, NULL);

		if (DirectDrawReturn != DD_OK)
			Surface = NULL;
	}

	if (Surface == NULL)
		FatalError("Couldn't allocate video surface");

	Initialize(Surface);

	if (vidstride) // Adjust width/stride if stride was specified
	{
		width = vidwidth;
		stride = vidstride;
	}

	ownssurface = TRUE;
}

void TDDSurface::Initialize(PTBitmap bitmap, int intensity, BOOL usevideomem)
{
	if (surface != NULL)
		return;

	Initialize(bitmap->width, bitmap->height, usevideomem);

	flags = bitmap->flags;

	SDrawParam  dp;
	
	MakeDP(dp, 0, 0, 0, 0, bitmap->width, bitmap->height, 
		bitmap->drawmode | DM_NORESTORE);

	dp.intensity = intensity;

	ParamDraw(&dp, bitmap);
}

void TDDSurface::Initialize(LPDIRECTDRAWSURFACE ddsurface)
{
	DDSURFACEDESC ddsd;
    memset(&ddsd, 0, sizeof(DDSURFACEDESC));
    ddsd.dwSize = sizeof(DDSURFACEDESC);
	ddsurface->GetSurfaceDesc(&ddsd);

	width        = ddsd.dwWidth;
	height       = ddsd.dwHeight;
	bitsperpixel = ddsd.ddpfPixelFormat.dwRGBBitCount;
	stride	     = ddsd.lPitch / (bitsperpixel / 8);
	originx		 = 0;
	originy		 = 0;
	clipmode     = CLIP_EDGES;
	clipx        = 0;
	clipy        = 0;
	clipwidth    = ddsd.dwWidth;
	clipheight   = ddsd.dwHeight;
	keycolor     = 0;
	if (bitsperpixel == 8)
		flags = BM_8BIT;
	else if (bitsperpixel == 15)
		flags = BM_15BIT;
	else if (bitsperpixel == 16)
		flags = BM_16BIT;
	else if (bitsperpixel == 24)
		flags = BM_24BIT;
	else if (bitsperpixel == 32)
		flags = BM_32BIT;
	lost         = FALSE;
	surface      = ddsurface;
	ownssurface  = FALSE;
	if (ddsd.ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
		vsflags = VSURF_SYSTEMMEM;
	else if (ddsd.ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)
		vsflags = VSURF_VIDEOMEM;
}

void TDDSurface::Close()
{
	if (ownssurface && surface != NULL) 
	{
		surface->Release();
		surface = NULL;		
	}
}

TDDSurface::~TDDSurface()
{
	Close();
}

// Restore Surface
BOOL TDDSurface::Restore()
{
    // Attempt to restore surface
    if (surface)
    {
        if (surface->IsLost() == DDERR_SURFACELOST)
		{
			if (surface->Restore() != DD_OK)
				return FALSE;
		}
    }

    return TRUE;
}

void *TDDSurface::Lock()
{
	if (!surface)
		return NULL;

	if (locked || !surface)
		return locked;

	// NOTE: !!! MAKE SURE FUNCTION DOES NOT EXIT UNTIL LeaveCriticalSection IS CALLED !!!
	BEGIN_CRITICAL();

    DDSURFACEDESC ddsd;
    HRESULT DirectDrawReturn;

    ZeroMemory(&ddsd, sizeof(ddsd));
    ddsd.dwSize = sizeof(ddsd);

    // Loop until an error occurs or the lock succeeds
    while (1)
    {
		DirectDrawReturn = surface->Lock(0, &ddsd, 0, 0);

        if (DirectDrawReturn == DD_OK)
        {
            switch(bitsperpixel)
			{
				case 8:
					stride = ddsd.lPitch;
					break;
				case 15:
				case 16:
					stride = (ddsd.lPitch) >> 1;
					break;
				case 24:
					stride = (ddsd.lPitch) / 3;
					break;
				case 32:
					stride = (ddsd.lPitch) >> 2;
					break;
				default:
					stride = 0;
					break;
			}

			locked = ddsd.lpSurface;
			break;
        }

        else if (DirectDrawReturn == DDERR_SURFACELOST)
        {
            if (!surface->Restore())
			{
				ddsd.lpSurface = NULL;
				break;
			}
        }

        else if (DirectDrawReturn != DDERR_WASSTILLDRAWING)
		{
			TRY_DD(DirectDrawReturn)
		}

		Sleep(1);	// Release time slice and try again next slice
    }

	if (UnlockImmediately)
		Unlock();

	END_CRITICAL();

	return ddsd.lpSurface;
}

BOOL TDDSurface::Unlock()
{
	if (!locked)
		return TRUE;

    HRESULT DirectDrawReturn;

	// NOTE: !!! MAKE SURE FUNCTION DOES NOT EXIT UNTIL LeaveCriticalSection IS CALLED !!!
	BEGIN_CRITICAL();

    if (!surface) return FALSE;
	// Loop until an error occurs or the unlock succeeds
    while (1)
    {        
        DirectDrawReturn = surface->Unlock(0);

        if (DirectDrawReturn == DD_OK || DirectDrawReturn == DDERR_NOTLOCKED)
		{
			locked = NULL;
			break;
		}

        else if (DirectDrawReturn == DDERR_SURFACELOST)
        {
            if (!(surface->Restore()))
				FatalError("Couldn't restore surface");
        }

        else if (DirectDrawReturn != DDERR_WASSTILLDRAWING) 
		{
			TRY_DD(DirectDrawReturn)
		}
		
		Sleep(1); // Release time slice and try again next slice
    }

	END_CRITICAL();

	return TRUE;
}

BOOL TDDSurface::BlitHandler(PSDrawParam dp, PTSurface srcsurface, int flags, LPDDBLTFX fx)
{
	HRESULT error;

	LPDIRECTDRAWSURFACE ddsrcsurf = NULL;
	if (srcsurface)
		ddsrcsurf = srcsurface->GetDDSurface();

  // Can't blit to the zbuffer..
	if (NoBlitZBuffer && 
	  (this == Display->GetRealZBuffer() || srcsurface == Display->GetRealZBuffer()) )
		dp->drawmode |= DM_NOHARDWARE;

	if (!(dp->drawmode & DM_NOHARDWARE) && BlitHardware && (!srcsurface || ddsrcsurf) && !dp->func)
	{
		SDrawParam  tmpdp = *dp;
		SDrawBlock  tmpdb;

		if (!ParamBlitSetup(tmpdp, srcsurface, flags, fx))
			return FALSE;

		tmpdb.dstbitmapflags = flags;
		tmpdb.dbufwidth  = width;
		tmpdb.dbufheight = height;
		tmpdb.dstride = stride;

		if (srcsurface)
		{
			tmpdb.srcbitmapflags = srcsurface->flags;
			tmpdb.keycolor   = srcsurface->KeyColor();
			tmpdb.sbufwidth  = srcsurface->Width();
			tmpdb.sbufheight = srcsurface->Height();
			tmpdb.sstride = srcsurface->Stride();

		  // Clip source
			if (!(tmpdp.drawmode & DM_WRAPCLIPSRC) &&
			   (tmpdp.sx >= tmpdb.sbufwidth || tmpdp.sy >= tmpdb.sbufheight ||
				tmpdp.sx + tmpdp.swidth < 0 || tmpdp.sy + tmpdp.sheight < 0))
					return FALSE;
		}
		else
		{	
			tmpdb.srcbitmapflags = 0;
			tmpdb.keycolor = 0;
			tmpdb.sbufwidth = tmpdb.sbufheight = tmpdb.sstride = 0;
		}

	  // Get draw call back (for restoring)
		DRAWCALLBACK callback = tmpdp.callback;

		DDCOLORKEY DirectDrawColorKey;
	
		SDrawParam dparray[4];
    
		int ArrayIndex = 0;    
		dparray[0]     = tmpdp;

	    if (tmpdp.drawmode & DM_NOCLIP)
			ArrayIndex = 1;
		else
			Clip(&tmpdb, &tmpdp, dparray, ArrayIndex);

	    for (int loop = 0; loop < ArrayIndex; loop++)
	    {
			SDrawParam dpm = dparray[loop];

			if (dpm.dwidth <= 0 || dpm.dheight <= 0)
				return FALSE;
			
			if (srcsurface && (dpm.swidth <= 0 || dpm.sheight <= 0))
				return FALSE;

			RECT drc = {
				 dpm.dx + dpm.originx,
				 dpm.dy + dpm.originy,
				 dpm.dx + dpm.originx + dpm.dwidth,
				 dpm.dy + dpm.originy + dpm.dheight };

			RECT src = {dpm.sx, dpm.sy, dpm.sx + dpm.swidth,
						dpm.sy + dpm.sheight};

			DDBLTFX ddbltfx;
			memset(&ddbltfx, 0, sizeof(DDBLTFX));
			ddbltfx.dwSize = sizeof(DDBLTFX);
			if (!fx)
				fx = &ddbltfx;

			if ((dpm.drawmode & DM_TRANSPARENT) && ddsrcsurf)
			{
				DirectDrawColorKey.dwColorSpaceLowValue  = (tmpdb.keycolor & 0xffff);
				DirectDrawColorKey.dwColorSpaceHighValue = (tmpdb.keycolor & 0xffff);
				TRY_DD(ddsrcsurf->SetColorKey(DDCKEY_SRCBLT, &DirectDrawColorKey));
				flags = DDBLT_KEYSRC | DDBLT_ASYNC;
			}
			else
			{
				if (flags != DDBLT_WAIT)
					flags |= DDBLT_ASYNC;
			}

			LPDIRECTDRAWSURFACE2 dstdd2, srcdd2;
			TRY_DD(surface->QueryInterface(IID_IDirectDrawSurface2, (LPVOID*)&dstdd2));

			if (ddsrcsurf)
			{
				TRY_DD(ddsrcsurf->QueryInterface(IID_IDirectDrawSurface2, (LPVOID*)&srcdd2));
			}
			else
				srcdd2 = NULL;

			BEGIN_CRITICAL(); // Never do two blits at once

			do
			{

			// Check if somebody else locked the surface, and if so, temporarily unlock it
//				BOOL dstlocked = IsLocked();
//				BOOL srclocked = FALSE;
//				if (srcsurface)
//					srclocked = srcsurface->IsLocked();
//				if (dstlocked)
//					Unlock();
//				if (srclocked)
//					srcsurface->Unlock();

				if (dstdd2->IsLost() == DDERR_SURFACELOST)
				{
					dstdd2->Restore(); // Attempt to restore, don't check for errors
				}

				if (srcdd2 && srcdd2->IsLost() == DDERR_SURFACELOST)
				{
					srcdd2->Restore(); // Attempt to restore, don't check for errors
				}

				error = dstdd2->Blt(&drc, srcdd2, &src, flags, fx);
			
			 // Now relock the surface 
//				if (dstlocked)
//					Lock();
//				if (srclocked)
//					srcsurface->Lock();

				if (error == DDERR_WASSTILLDRAWING || error == DDERR_SURFACEBUSY)
				{
					END_CRITICAL();
					Sleep(1); // Release time slice and try again next slice
					BEGIN_CRITICAL();
				}

			} while (error == DDERR_WASSTILLDRAWING || error == DDERR_SURFACEBUSY);


			END_CRITICAL();

			if (error == DDERR_SURFACELOST)
				return FALSE; // Just bomb out if surface was lost

			if (error == DDERR_NOBLTHW)
			{
				BlitHardware = FALSE;
				break;
			}
			else if (error != DD_OK)
			{
//				char buf[80];
//				sprintf(buf, "UNSUPPORED: %d %d %d %d - %d %d %d %d - %d", 
//					src.left, src.top, src.right, src.bottom, 
//					drc.left, drc.top, drc.right, drc.bottom,
//					flags);
//				_RPT0(_CRT_ASSERT, buf); 
				TRY_DD(error)
			}

			if (callback)
				callback(&tmpdb, &dpm);
		}
	}

	if ((dp->drawmode & DM_NOHARDWARE) ||	// If user chose no hardware
		!BlitHardware ||					// or if there ain't no hardware
		!(!srcsurface || ddsrcsurf) ||		// or one or both surfaces aren't DD surfaces
//		error != DD_OK ||					// or there was an error using hardware blit
		dp->func)							// or user chose to use his own blit function
	{
		return TSurface::BlitHandler(dp, srcsurface, flags, fx);
	}

	return TRUE;
}

BOOL TDDSurface::Box(int dx, int dy, int dwidth, int dheight, 
		DWORD color, WORD zpos, WORD normal, DWORD drawmode)
{
	if (drawmode == DM_USEDEFAULT)
		drawmode = DM_ZBUFFER | DM_NORMALS;

  // Can we do a hardware clear?
	if (!BlitHardware ||
		(!((DDHWCaps.dwCaps & DDCAPS_BLTCOLORFILL) && 
		  (!(drawmode & DM_ZBUFFER) || DDHWCaps.dwCaps & DDCAPS_BLTDEPTHFILL))))
		return TSurface::Box(dx, dy, dwidth, dheight, color, zpos, normal, drawmode);

  // Hardware clear (doesn't seem to work for some reason)
	DWORD dm = drawmode & ~(DM_ZBUFFER | DM_NORMALS);

	DDBLTFX fx;
	memset(&fx, 0, sizeof(DDBLTFX));
	fx.dwSize = sizeof(DDBLTFX);
	
	if (!(drawmode & DM_NODRAW))
	{
		fx.dwFillColor = color;
		Blit(dx, dy, dwidth, dheight, dm, DDBLT_ASYNC | DDBLT_COLORFILL, &fx);
	}

	if ((drawmode & DM_ZBUFFER) && GetZBuffer())
	{
		fx.dwFillDepth = zpos & 0xFFFF;
		Blit(dx, dy, dwidth, dheight, 
			dm | DM_NODRAW | DM_ZBUFFER | DM_NORESTORE, DDBLT_ASYNC | DDBLT_DEPTHFILL, &fx);
	}

	if ((drawmode & DM_NORMALS) && GetNormalBuffer())
	{
		fx.dwFillColor = normal;
		Blit(dx, dy, dwidth, dheight, 
			dm | DM_NODRAW | DM_NORMALS | DM_NORESTORE, DDBLT_ASYNC | DDBLT_COLORFILL | DDBLT_DDFX, &fx);
	}

	return TRUE;
}
// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                    death.cpp - TDeathPane module                      *
// *************************************************************************

#include "revenant.h"
#include "death.h"
#include "display.h"
#include "multi.h"
#include "playscreen.h"
#include "savegame.h"

static BOOL saveisfullscreen;

TDeathPane DeathPane;

void DeathBtnRestart()
{
	SaveGame.ReadGame();
	DeathPane.Close();
}

void DeathBtnLoad()
{
	SaveGame.ReadGame();
	DeathPane.Close();
}

void DeathBtnExit()
{
	SaveGame.ReadGame();
	DeathPane.Close();
}

BOOL TDeathPane::Initialize()
{
	TButtonPane::Initialize();

	deathdata = TMulti::LoadMulti("death.dat");

	if (deathdata)
	{
		saveisfullscreen = PlayScreen.IsFullScreen();
		PlayScreen.SetFullScreen(FALSE);

		NewButton("restart", 76, 144, 148, 80, VK_TAB, DeathBtnRestart, deathdata->Bitmap("restartdown"), deathdata->Bitmap("restartup"));
		NewButton("load", 240, 146, 112, 72, VK_RETURN, DeathBtnLoad, deathdata->Bitmap("loaddown"), deathdata->Bitmap("loadup"));
		NewButton("exit", 384, 152, 96, 64, VK_ESCAPE, DeathBtnExit, deathdata->Bitmap("exitdown"), deathdata->Bitmap("exitup"));

		PlayScreen.AddPane(this);
		PlayScreen.SetExclusivePane(this, TRUE);
		return TRUE;
	}

	return FALSE;
}

void TDeathPane::Close()
{
	TButtonPane::Close();

	if (deathdata)
		delete deathdata;

	PlayScreen.ReleaseExclusivePane(this);
	PlayScreen.RemovePane(this);
	PlayScreen.Redraw();

	PlayScreen.SetFullScreen(saveisfullscreen);
}

void TDeathPane::DrawBackground()
{
	if (IsDirty())
	{
		Display->Put(0, 0, deathdata->Bitmap("background"), DM_BACKGROUND);
		PlayScreen.DrawOverhangs();
		SetClipRect();		// drawing overhangs screws them up
		SetDirty(FALSE);
	}

	TButtonPane::DrawBackground();
}

// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                   dialog.cpp - TDialogPane module                     *
// *************************************************************************

#include "revenant.h"
#include "dialog.h"
#include "display.h"
#include "multi.h"
#include "playscreen.h"
#include "character.h"
#include "command.h"
#include "bitmap.h"
#include "mappane.h"
#include "script.h"
#include "player.h"

TDialogPane DialogPane;

static PTObjectInstance DlgContext;
static BOOL savecontrolon;
static BOOL saveisfullscreen;

void SetDialogContext(PTObjectInstance context)
{
	DlgContext = context;
}

// Dialog line translator... Note: Dialog TAGS are listed in DLGTAG.TXT

char *DialogLine(char *line, char *outbuf, int buflen)
{
	char buf[128];
	char tag[20];
	char data[128];
	char *p, *b, *d;

	b = buf;
	for (p = line; *p != NULL; )
	{
		if (*p == '[')
		{
			p++;
			if (*p == '[' || *p == ']')
			{
				*b++ = *p++;
				continue;
			}
			char *t = tag;
			while (*p && *p != ']')
				*t++ = *p++;
			if (*p == ']')
				p++;
			*t++ = NULL;

			data[0] = NULL;
			if (!stricmp(tag, "me"))				// "me" is locke
				strcpy(data, Player->GetName());
			else if (!stricmp(tag, "chr") && DlgContext != NULL) // "chr" is the character talking
				strcpy(data, DlgContext->GetName());
			
			d = data;
			while (*d)
				*b++ = *d++;
		}
		else
			*b++ = *p++;
	}

	*b = NULL;

	return strncpyz(outbuf, buf, buflen);
}

BOOL TDialogPane::Initialize()
{
	if (IsOpen())
		return TRUE;

	if (!TPane::Initialize())
		return FALSE;

	dialogdata = TMulti::LoadMulti("dialog.dat");
	choice = -1;
	freshresponse = FALSE;

	for (int i = 0; i < MAXCHOICES; i++)
		choices[i] = label[i] = NULL;

	return TRUE;
}

void TDialogPane::Close()
{
	if (!IsOpen())
		return;

	TPane::Close();

	if (dialogdata)
		delete dialogdata;
}

void TDialogPane::Show()
{
	if (!IsHidden() || !IsOpen() || PlayScreen.IsDemoMode())
		return;

	TPane::Show();

	if (dialogdata)
	{
		saveisfullscreen = PlayScreen.IsFullScreen();
		PlayScreen.SetFullScreen(FALSE);
		PlayScreen.HideLowerPanes();
		savecontrolon = PlayScreen.IsControlOn();
		PlayScreen.SetControlOn(FALSE);		// don't want them wandering off or anything

//		OldScrollLock = ScrollLock;
//		ScrollLock = FALSE;
	}
	SetDirty(TRUE);
}

void TDialogPane::Hide()
{
	if (IsHidden() || !IsOpen())
		return;

	TPane::Hide();

	PlayScreen.ShowLowerPanes();
	PlayScreen.Redraw();
	PlayScreen.SetControlOn(savecontrolon);
	PlayScreen.SetFullScreen(saveisfullscreen);

	character = NULL;

//	ScrollLock = OldScrollLock;
}

#define CHOICEHEIGHT	21

void TDialogPane::DrawBackground()
{
	if (IsDirty())
	{
		Display->Put(0, 0, dialogdata->Bitmap("background"), DM_BACKGROUND);

		for (int i = 0; i < numchoices; i++)
		{
			SColor color = { 255, 0, 50 };
			Display->WriteText(choices[i], 32, (i * CHOICEHEIGHT) + 4, 1, GameData->Font("choicefont"),
								((grabslot == i || choice == i) && highlighted) ? &color : NULL);
		}

		SetDirty(FALSE);
	}
}

void TDialogPane::Animate(BOOL draw)
{
}

void TDialogPane::KeyPress(int key, BOOL down)
{
	if (down)
	{
		switch (key)
		{
			case '1':
				SetChoice(0);
				break;
			case '2':
				SetChoice(1);
				break;
			case '3':
				SetChoice(2);
				break;
			case '4':
				SetChoice(3);
				break;
			case ' ':
				Skip();
				break;
			case VK_ESCAPE:
				Skip();

				if (character)
					character->ScriptJump("Finish");

				Close();
		}
	}
}

void TDialogPane::MouseClick(int button, int x, int y)
{
	if (button == MB_LEFTDOWN)
	{
		if (numchoices > 0)
		{
			highlighted = TRUE;
			grabslot = OnSlot(x, y);
			SetDirty(TRUE);
		}
		else
			Skip();
	}
	else if (button == MB_LEFTUP && grabslot >= 0)
	{
		if (OnSlot(x, y) == grabslot)
			SetChoice(grabslot);

		grabslot = -1;
	}
}

void TDialogPane::MouseMove(int button, int x, int y)
{
	if (button == MB_LEFTDOWN)
	{
		int onslot = OnSlot(x, y);

		if ((onslot == grabslot && !highlighted) ||
			(onslot != grabslot && highlighted))
		{
			highlighted = !highlighted;
			SetDirty(TRUE);
		}
	}
}

int TDialogPane::OnSlot(int x, int y)
{
	if (!InPane(x, y))
		return -1;

	y -= 6;
	if (y < 0)
		return -1;

	y /= CHOICEHEIGHT;
	return y;
}

void TDialogPane::AddChoice(char *lab, char *txt)
{
	if (!IsOpen())
		return;

	if (choice >= 0)
		ResetResponses();

	if (numchoices >= MAXCHOICES)
		return;

	if (!txt)
		choices[numchoices] = NULL;
	else
		choices[numchoices] = _strdup(txt);

	label[numchoices] = lab ? _strdup(lab) : NULL;

	numchoices++;

	SetDirty(TRUE);
}

void TDialogPane::ResetResponses()
{
	if (!IsOpen())
		return;

	for (int i = 0; i < numchoices; i++)
	{
		if (choices[i])
			free(choices[i]);

		if (label[i])
			free(label[i]);
	}

	if (numchoices > 0)
		SetDirty(TRUE);		// only redraw if there wasn't anything there before

	numchoices = 0;
	choice = -1;
	freshresponse = FALSE;
	grabslot = -1;
}

void TDialogPane::Skip()
{
	if (!IsOpen())
		return;

	if (character && character->IsTalking())
		character->ForceCommandDone();
}


COMMAND(CmdChoice)
{
	if (t.Type() != TKN_IDENT)
		return CMD_BADPARAMS;

	char buf[80];
	strcpy(buf, t.Text());

	t.WhiteGet();
	if (t.Type() != TKN_TEXT)
		return CMD_BADPARAMS;

	DialogPane.AddChoice(buf, t.Text());

	t.Get();
	return 0;
}
// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *             directdraw.cpp - direct draw oject module                 *  
// *************************************************************************

#define INITGUID
#include <ddraw.h>
#include <d3drmwin.h>
#include <stdio.h>

#include "revenant.h"
#include "directdraw.h"
#include "monitor.h"
#include "display.h"
#include "mainwnd.h"
#include "3dscene.h"

#define DRIVERNAMELEN 80
#define DRIVERDESCLEN 80

// Direct Draw Global variables
LPDIRECTDRAW	     DirectDraw;		// DirectDraw pointer
LPDIRECTDRAW2        DirectDraw2;		// DirectDraw 2 pointer
char				 DirectDrawDesc[DRIVERNAMELEN];	// DirectDraw device desc
char				 DirectDrawName[DRIVERDESCLEN];	// DirectDraw device name
char				 DriversAvailable[DRIVERNAMELEN]; // Lists names of available drivers

DDCAPS				 DDHWCaps;			// Direct Draw Hardware Caps
DDCAPS				 DDHELCaps;			// Direct Draw Hel Caps

// Direct 3d 2 Global variables
LPDIRECT3D			  Direct3D;			// Direct3D object
LPDIRECT3D2           Direct3D2;		// Direct3D object
LPDIRECT3DDEVICE      Device;			// Direct3D device
LPDIRECT3DDEVICE2     Device2;			// Direct3D device 2
LPDIRECT3DVIEWPORT	  Viewport;			// Direct3D Viewport
LPDIRECT3DVIEWPORT2	  Viewport2;		// Direct3D Viewport
D3DDEVICEDESC		  D3DHWCaps;		// Direct3D Hardware Caps
D3DDEVICEDESC		  D3DHELCaps;		// Direct3D Hardware Emulation Layer Caps

// Direct X Variables
DWORD         GDIMem;					// Memory in available from GDI's surface
D3DDeviceInfo DeviceInfo;				// 3D device info
LPGUID        DeviceGuid;				// Guid to 3D device
DDCAPS        HWCaps;					// Hardware Caps
DDCAPS        HELCaps;					// Hardware Emulation Layer Caps
DWORD         ZBufferBitDepth;			// ZBuffer bit depth
BOOL          BlitHardware;				// Is blit hardware available?
BOOL          Hardware3D = FALSE;		// Do we have hardware?
BOOL          UsingHardware = FALSE;	// Are we using hardware?

// External surfaces
extern LPDIRECTDRAWSURFACE back;

// The driver setup function in exlmain.cpp.  Sets system flags based on driver
// we are using.
void DriverSetupCallback();

// Get available enum
BOOL FAR PASCAL DDEnumGetAvailable(GUID FAR* GUID, LPSTR DriverDesc, LPSTR DriverName, 
	LPVOID Context);

BOOL InitDirectDraw()
{
    DDSURFACEDESC DirectDrawSurfaceDesc;

	DriversAvailable[0] = NULL;
    TRY_DD(DirectDrawEnumerate(DDEnumGetAvailable, NULL))

    // Enumerate DirectDraw drivers to see what is installed, preferring one with
    // Hardware 3D capabilities

	DirectDraw = NULL;
    TRY_DD(DirectDrawEnumerate(DDEnumCallback, NULL))

    // If DirectDraw is NULL, there is no 3D hardware present
    if (!DirectDraw)
		TRY_DD(DirectDrawCreate(NULL, &DirectDraw, NULL))

	// Call the setup callback in the main module to set system flags before continueing
	DriverSetupCallback();

	// Get other interfaces
    TRY_DD(DirectDraw->QueryInterface(IID_IDirectDraw2, (LPVOID *)&DirectDraw2))

	DDHWCaps.dwSize = sizeof(DDCAPS);
	DDHELCaps.dwSize = sizeof(DDCAPS);
	TRY_DD(DirectDraw2->GetCaps(&DDHWCaps, &DDHELCaps))

    // Get the current display mode as we can use that memory when full
    // screen exclusive
    memset(&DirectDrawSurfaceDesc, 0, sizeof(DirectDrawSurfaceDesc));
    DirectDrawSurfaceDesc.dwSize = sizeof(DirectDrawSurfaceDesc);

    TRY_DD(DirectDraw->GetDisplayMode(&DirectDrawSurfaceDesc));
    GDIMem = DirectDrawSurfaceDesc.lPitch * DirectDrawSurfaceDesc.dwHeight *
             (DirectDrawSurfaceDesc.ddpfPixelFormat.dwRGBBitCount / 8);

    // Zero out caps structures
    memset(&HWCaps, 0, sizeof(DDCAPS));
    HWCaps.dwSize = sizeof(DDCAPS);

    memset(&HELCaps, 0, sizeof(DDCAPS));
    HELCaps.dwSize = sizeof(DDCAPS);

    // Get hardware capabilities
    TRY_DD(DirectDraw->GetCaps(&HWCaps, &HELCaps))

	if (HWCaps.dwCaps & DDCAPS_BLT)
		BlitHardware = TRUE;

	if (Ignore3D)
		return TRUE;

	// Global to determine whether we have hardware 3D capabilities or not
    Hardware3D = (HWCaps.dwCaps & DDCAPS_3D) && !UseSoftware3D;

    // Create Direct3D object
	if (!Ignore3D)
	{
		TRY_DD(DirectDraw->QueryInterface(IID_IDirect3D, (LPVOID *)&Direct3D))
		if (UseDirect3D2)
		{	
			Direct3D2 = NULL;
			if (DirectDraw->QueryInterface(IID_IDirect3D2, (LPVOID *)&Direct3D2) != DD_OK)
				UseDirect3D2 = FALSE; // Direct3D II isn't available! 
			if (!Direct3D2)
				UseDirect3D2 = FALSE; // Direct3D II isn't available! 
		}

		// Enumerate Direct3D devices, preferring hardware rendering over software    
		if (!InitD3DDevice())
		{
			FatalError("Error locating suitable Direct3D driver!");
			return FALSE;
		}
	}

    // Enumerate all the display modes, this is done after locating the 3D device so
    // that any mode that is not compatible with the 3D device does not get added to
    // the list of valid modes.
    TRY_DD(DirectDraw->EnumDisplayModes(0, NULL, NULL, DDEnumDisplayModesCallback))

    return TRUE;
}

BOOL InitD3DDevice()
{
	if (Ignore3D)
		return TRUE;		

    memset(&DeviceInfo, 0, sizeof(DeviceInfo));

    // Record the color model that we wish to search for in the structure passed
    // to the enumeration call back

	if (Hardware3D && !UseSoftware3D) // Hardware
		DeviceInfo.cm = D3DCOLOR_RGB;
	else
	{
		if (SoftRampMode)
			DeviceInfo.cm = D3DCOLOR_MONO;
		else if (SoftRGBMode)
			DeviceInfo.cm = D3DCOLOR_RGB;
		else
			DeviceInfo.cm = D3DCOLOR_MONO;
	}

    // Enumerate the drivers
    TRY_D3D(Direct3D->EnumDevices(D3DEnumDeviceCallBack, &DeviceInfo));

	// Test to see whether we have hardware or software
	if (DeviceInfo.HWGuid && (DeviceInfo.HWDeviceDesc.dwDeviceZBufferBitDepth 
		& DDBD_16))
    {
       // We have a hardware driver!

		ZBufferBitDepth = 16;
        
        // Use Hardware device
        DeviceGuid = DeviceInfo.HWGuid;
		
		UsingHardware = TRUE;
	}
    
	else
	{
        // We have a software driver!

        // And force the bit depth to 16
        ZBufferBitDepth = 16;

        // Default to the software device
        DeviceGuid = DeviceInfo.SWGuid;
	
		UsingHardware = FALSE;
    }

    return TRUE;
}

BOOL SetExclusiveMode()
{
    TRY_DD(DirectDraw->SetCooperativeLevel(MainWindow.Hwnd(), DDSCL_EXCLUSIVE | DDSCL_FULLSCREEN ))

    return TRUE;
}

BOOL SetNormalMode()
{
    TRY_DD(DirectDraw->SetCooperativeLevel(NULL, DDSCL_NORMAL ))

    return TRUE;
}

// Terminates and releases DirectX components.
BOOL CloseDirectDraw()
{
	if (!Ignore3D)
	{
		// Destroy Direct3D viewport
		if (Viewport2 && UseDirect3D2)
			Viewport2->Release();
		else if (Viewport)
			Viewport->Release();
		Viewport2 = NULL;
		Viewport = NULL;

		// Destroy rendering device
		if (Device2 && UseDirect3D2)
			Device2->Release();
		else if (Device)
			Device->Release();
		Device2 = NULL;
		Device = NULL;

		// Destroy Direct3D object
		if (Direct3D2 && UseDirect3D2)
			Direct3D2->Release();
		else if (Direct3D)
			Direct3D->Release();
		Direct3D2 = NULL;
		Direct3D = NULL;
	}

    // Destroy DirectDraw object
    if (DirectDraw)
    {
        DirectDraw->RestoreDisplayMode();
		DirectDraw->Release();
        DirectDraw = NULL;
    }

    return TRUE;
}

BOOL EnterVideoMode(int width, int height, int bitdepth)
{
    // Switch video mode
    TRY_DD(DirectDraw->SetDisplayMode(width, height, bitdepth))

	return TRUE;
}

BOOL Setup3D(int width, int height)
{
	if (Ignore3D)
		return TRUE;

	// Destroy Direct3D viewport
	if (Viewport2 && UseDirect3D2)
		Viewport2->Release();
	else if (Viewport)
		Viewport->Release();
	Viewport2 = NULL;
	Viewport = NULL;

    // Destroy Direct3D device
    if (Device2 && UseDirect3D2)
        Device2->Release();
	else if (Device)
		Device->Release();
	Device2 = NULL;
	Device = NULL;

    // Create Direct3D device
	if (UseDirect3D2)
	{
	    TRY_D3D(Direct3D2->CreateDevice(*DeviceGuid, back, &Device2))
		TRY_D3D(Device2->QueryInterface(IID_IDirect3DDevice, (LPVOID *)&Device))
	}
	else
	{
		Device2 = NULL;
	    TRY_DD(back->QueryInterface(*DeviceGuid, (LPVOID *)&Device))
	}

	memset(&D3DHWCaps, 0, sizeof(D3DDEVICEDESC));

	memset(&D3DHELCaps, 0, sizeof(D3DDEVICEDESC));

	if (UseDirect3D2)
	{
		D3DHWCaps.dwSize = sizeof(D3DDEVICEDESC);
		D3DHELCaps.dwSize = sizeof(D3DDEVICEDESC);
		TRY_D3D(Device2->GetCaps(&D3DHWCaps, &D3DHELCaps));
	}
	else
	{
		D3DHWCaps.dwSize = sizeof(D3DDEVICEDESC);
		D3DHELCaps.dwSize = sizeof(D3DDEVICEDESC);

		TRY_D3D(Device->GetCaps(&D3DHWCaps, &D3DHELCaps));
	}

    return TRUE;        
}

// Closes 3D scene
void Close3D()
{       
	Scene3D.Close();

	// Destroy Direct3D viewport
	if (Viewport2 && UseDirect3D2)
		Viewport2->Release();
	else if (Viewport)
		Viewport->Release();
	Viewport2 = NULL;
	Viewport = NULL;

    // Destroy Direct3D device
    if (Device2 && UseDirect3D2)
        Device2->Release();
	else if (Device)
		Device->Release();
	Device2 = NULL;
	Device = NULL;
}

DWORD GetVideoMem(DWORD type, BOOL getavail)
{
    if (!DirectDraw)
		return 0;

    // Get hardware capabilities
	DDSCAPS DDSCaps;
	memset(&DDSCaps, 0, sizeof(DDSCaps));

	DWORD total, avail;
	if (DirectDraw2->GetAvailableVidMem(&DDSCaps, &total, &avail) != DD_OK)
	{
		total = avail = 0;
	}

	if (total <= 0 && ((type == DDSCAPS_VIDEOMEMORY) || (type == DDSCAPS_TEXTURE)))
	{
		total = avail = 4096 * 1024;  // Fix for cards with shitty DirectX support
	}

	if (getavail)
		return avail;
	else
		return total;
}

DWORD GetTotalVideoMem()
{
	return GetVideoMem(DDSCAPS_VIDEOMEMORY, FALSE);
}

DWORD GetFreeVideoMem()
{
	return GetVideoMem(DDSCAPS_VIDEOMEMORY, TRUE);
}

DWORD GetTotalLocalVideoMem()
{
	return GetVideoMem(DDSCAPS_LOCALVIDMEM, FALSE);
}

DWORD GetFreeLocalVideoMem()
{
	return GetVideoMem(DDSCAPS_LOCALVIDMEM, TRUE);
}

DWORD GetTotalNonLocalVideoMem()
{
	return GetVideoMem(DDSCAPS_NONLOCALVIDMEM, FALSE);
}

DWORD GetFreeNonLocalVideoMem()
{
	return GetVideoMem(DDSCAPS_NONLOCALVIDMEM, TRUE);
}

DWORD GetTotalTextureMem()
{
	return GetVideoMem(DDSCAPS_TEXTURE, FALSE);
}

DWORD GetFreeTextureMem()
{
	return GetVideoMem(DDSCAPS_TEXTURE, TRUE);
}

int GetColorMode()
{
	if (DeviceInfo.cm == D3DCOLOR_MONO)
		return MONO;
	
	else if (DeviceInfo.cm == D3DCOLOR_RGB)
		return COLOR;
	
	else 
		return 0;
}

BOOL IsUsingHardware()
{
	return UsingHardware;
}

// Global Direct Draw Driver Callback Routine
BOOL FAR PASCAL DDEnumGetAvailable(GUID FAR* GUID, LPSTR DriverDesc, LPSTR DriverName, 
	LPVOID Context)
{
	if (DriversAvailable[0] != NULL)
		strncatz(DriversAvailable, ",", DRIVERNAMELEN);
	strncatz(DriversAvailable, DriverName, DRIVERNAMELEN);
	return DDENUMRET_OK;	// Keep going through list
}

// Global Direct Draw Driver Callback Routine
BOOL FAR PASCAL DDEnumCallback(GUID FAR* GUID, LPSTR DriverDesc, LPSTR DriverName, 
	LPVOID Context)
{
    // Try to create a DirectDraw object
    LPDIRECTDRAW Driver;
	TRY_DD(DirectDrawCreate(GUID, &Driver, NULL))

	BOOL found = FALSE;
	if (DXDriverMatchStr[0] != NULL)
	{
		char buf[80];
		strncpyz(buf, DriverName, 80);
		strncatz(buf, " ", 80);
		strncatz(buf, DriverDesc, 80);
		strlwr(buf);

		found = strstr(buf, DXDriverMatchStr) != NULL;
	}
	else if (MonitorNum != 0)
	{
		found = stricmp(MonitorInfo.szDevice, DriverName) == 0;
	}
	else
	{
		// If no default monitor, search for the best 3D so that it doesn't
		// do something stupid like using software emulation when there's
		// actually a 3DFX card in the system
		DDCAPS HWCaps, HELCaps;

		// Get the DirectDraw capabilities
		memset(&HWCaps, 0, sizeof(DDCAPS));
		HWCaps.dwSize = sizeof(DDCAPS);
    
		memset(&HELCaps, 0, sizeof(DDCAPS));
		HELCaps.dwSize = sizeof(DDCAPS);
    
		TRY_DD(Driver->GetCaps(&HWCaps, &HELCaps))

		found = (HWCaps.dwCaps & DDCAPS_3D) != 0;
	}

	// If first device, or device matches criteria above, set device..
	if (!DirectDraw || found) 
	{
	   if (DirectDraw)				// Override's first device found
			DirectDraw->Release();
		DirectDraw = Driver;
		strncpyz(DirectDrawName, DriverName, DRIVERNAMELEN);
		strncpyz(DirectDrawDesc, DriverDesc, DRIVERDESCLEN);
	}
	else  // This one didn't match, and we already have the default, so delete it
	{
		Driver->Release();
		Driver = NULL;
	}

	if (found)			// Found a match, don't do any more enums
		return FALSE;
	else
		return DDENUMRET_OK;	// Keep going through list
}


// Global Direct Draw Mode Callback routine
HRESULT CALLBACK DDEnumDisplayModesCallback(LPDDSURFACEDESC DirectDrawSurfaceDesc, 
	LPVOID Context)
{       
    // Ensure mode supports 3d device
    if (DeviceInfo.HWGuid)
    {           
        // Make sure there is enough video ram to support this mode
        // if hardware is in use
        DWORD BitDepthMultiplier;
        
        switch(DirectDrawSurfaceDesc->ddpfPixelFormat.dwRGBBitCount)
        {
            case 8: 
				BitDepthMultiplier = 1; 
				break;

            case 16: 
				BitDepthMultiplier = 2; 
				break;

            case 24: 
				BitDepthMultiplier = 3; 
				break;

            case 32: 
				BitDepthMultiplier = 4; 
				break;
        }

        DWORD VidRamNeeded = ((DirectDrawSurfaceDesc->dwWidth * 
			DirectDrawSurfaceDesc->dwHeight) * BitDepthMultiplier) * 3;

        if (VidRamNeeded > (HWCaps.dwVidMemFree + GDIMem))
            return DDENUMRET_OK;

        // Make sure the Direct3D device can render at a given bit depth
        switch (DirectDrawSurfaceDesc->ddpfPixelFormat.dwRGBBitCount)
        {
            case 8 : 
            {
                if (!(DeviceInfo.HWDeviceDesc.dwDeviceRenderBitDepth & DDBD_8)) 
					return DDENUMRET_OK;
            }
            break;

            case 16 :
            {
                if (!(DeviceInfo.HWDeviceDesc.dwDeviceRenderBitDepth & DDBD_16)) 
					return DDENUMRET_OK;
            }
            break;

            case 24 : 
            {
                if (!(DeviceInfo.HWDeviceDesc.dwDeviceRenderBitDepth & DDBD_24)) 
					return DDENUMRET_OK;
            }
            break;

            case 32 :
            {
                if (!(DeviceInfo.HWDeviceDesc.dwDeviceRenderBitDepth & DDBD_32)) 
					return DDENUMRET_OK;
            }
            break;
        }

        // If we have hardware, start up in 640x480x16 if possible
        if ((DirectDrawSurfaceDesc->dwWidth == 640) && 
			(DirectDrawSurfaceDesc->dwHeight == 480) && 
			(DirectDrawSurfaceDesc->ddpfPixelFormat.dwRGBBitCount == 16))
			return DDENUMRET_CANCEL;
    }

    return DDENUMRET_OK;
}

// Global Direct3D driver callback routine
HRESULT WINAPI D3DEnumDeviceCallBack(LPGUID Guid, LPSTR DeviceDescription,
	LPSTR DeviceName, LPD3DDEVICEDESC HWDesc, LPD3DDEVICEDESC HELDesc, LPVOID Context)
{
    static BOOL FoundHardwareDevice = FALSE;   

    // No need to enumerate if we already found the device that supports hardware
    if (FoundHardwareDevice) return D3DENUMRET_OK;

    D3DDeviceInfo *Info = (D3DDeviceInfo *)Context;
    
	// Is this a hardware device?
    if ((HWDesc->dcmColorModel & Info->cm) && !UseSoftware3D)
    {
        // Make sure the driver has ZBuffering capabilities
        if (HWDesc->dwDeviceZBufferBitDepth & DDBD_16)
        {                                       
            // Record the HAL description for later use
            memcpy(&Info->HWDeviceDesc, HWDesc, sizeof(D3DDEVICEDESC));

            // Record the guid for later use
            Info->HWGuid = Guid;
            
            // No need to keep looking for any more devices
            FoundHardwareDevice = TRUE;
        }
        
        return D3DENUMRET_OK;
    }

    // Is this a software device?
    if (HELDesc->dcmColorModel & Info->cm) 
	{
        // Record the HEL description for later use
        memcpy(&Info->SWDeviceDesc, HELDesc, sizeof(D3DDEVICEDESC));
            
        // Record the guid for later use
        Info->SWGuid = Guid;
    }

    return D3DENUMRET_OK;
}


struct DDERRORSTRING
{
	HRESULT Error;
	char *lpszErrorStr;
};

static DDERRORSTRING dderrors[] =
{
  // DirectDraw errors...  
    {DDERR_ALREADYINITIALIZED, "DDERR_ALREADYINITIALIZED"},
    {DDERR_CANNOTATTACHSURFACE, "DDERR_CANNOTATTACHSURFACE"},
    {DDERR_CANNOTDETACHSURFACE, "DDERR_CANNOTDETACHSURFACE"},
    {DDERR_CURRENTLYNOTAVAIL, "DDERR_CURRENTLYNOTAVAIL"},
    {DDERR_EXCEPTION, "DDERR_EXCEPTION"},
    {DDERR_GENERIC, "DDERR_GENERIC"},
    {DDERR_HEIGHTALIGN, "DDERR_HEIGHTALIGN"},
    {DDERR_INCOMPATIBLEPRIMARY, "DDERR_INCOMPATIBLEPRIMARY"},
    {DDERR_INVALIDCAPS, "DDERR_INVALIDCAPS"},
    {DDERR_INVALIDCLIPLIST, "DDERR_INVALIDCLIPLIST"},
    {DDERR_INVALIDMODE, "DDERR_INVALIDMODE"},
    {DDERR_INVALIDOBJECT, "DDERR_INVALIDOBJECT"},
    {DDERR_INVALIDPARAMS, "DDERR_INVALIDPARAMS"},
    {DDERR_INVALIDPIXELFORMAT, "DDERR_INVALIDPIXELFORMAT"},
    {DDERR_INVALIDRECT, "DDERR_INVALIDRECT"},
    {DDERR_LOCKEDSURFACES, "DDERR_LOCKEDSURFACES"},
    {DDERR_NO3D, "DDERR_NO3D"},
    {DDERR_NOALPHAHW, "DDERR_NOALPHAHW"},
    {DDERR_NOCLIPLIST, "DDERR_NOCLIPLIST"},
    {DDERR_NOCOLORCONVHW, "DDERR_NOCOLORCONVHW"},
    {DDERR_NOCOOPERATIVELEVELSET, "DDERR_NOCOOPERATIVELEVELSET"},
    {DDERR_NOCOLORKEY, "DDERR_NOCOLORKEY"},
    {DDERR_NOCOLORKEYHW, "DDERR_NOCOLORKEYHW"},
    {DDERR_NODIRECTDRAWSUPPORT, "DDERR_NODIRECTDRAWSUPPORT"},
    {DDERR_NOEXCLUSIVEMODE, "DDERR_NOEXCLUSIVEMODE"},
    {DDERR_NOFLIPHW, "DDERR_NOFLIPHW"},
    {DDERR_NOGDI, "DDERR_NOGDI"},
    {DDERR_NOMIRRORHW, "DDERR_NOMIRRORHW"},
    {DDERR_NOTFOUND, "DDERR_NOTFOUND"},
    {DDERR_NOOVERLAYHW, "DDERR_NOOVERLAYHW"},
    {DDERR_NORASTEROPHW, "DDERR_NORASTEROPHW"},
    {DDERR_NOROTATIONHW, "DDERR_NOROTATIONHW"},
    {DDERR_NOSTRETCHHW, "DDERR_NOSTRETCHHW"},
    {DDERR_NOT4BITCOLOR, "DDERR_NOT4BITCOLOR"},
    {DDERR_NOT4BITCOLORINDEX, "DDERR_NOT4BITCOLORINDEX"},
    {DDERR_NOT8BITCOLOR, "DDERR_NOT8BITCOLOR"},
    {DDERR_NOTEXTUREHW, "DDERR_NOTEXTUREHW"},
    {DDERR_NOVSYNCHW, "DDERR_NOVSYNCHW"},
    {DDERR_NOZBUFFERHW, "DDERR_NOZBUFFERHW"},
    {DDERR_NOZOVERLAYHW, "DDERR_NOZOVERLAYHW"},
    {DDERR_OUTOFCAPS, "DDERR_OUTOFCAPS"},
    {DDERR_OUTOFMEMORY, "DDERR_OUTOFMEMORY"},
    {DDERR_OUTOFVIDEOMEMORY, "DDERR_OUTOFVIDEOMEMORY"},
    {DDERR_OVERLAYCANTCLIP, "DDERR_OVERLAYCANTCLIP"},
    {DDERR_OVERLAYCOLORKEYONLYONEACTIVE, "DDERR_OVERLAYCOLORKEYONLYONEACTIVE"},
    {DDERR_PALETTEBUSY, "DDERR_PALETTEBUSY"},
    {DDERR_COLORKEYNOTSET, "DDERR_COLORKEYNOTSET"},
    {DDERR_SURFACEALREADYATTACHED, "DDERR_SURFACEALREADYATTACHED"},
    {DDERR_SURFACEALREADYDEPENDENT, "DDERR_SURFACEALREADYDEPENDENT"},
    {DDERR_SURFACEBUSY, "DDERR_SURFACEBUSY"},
    {DDERR_CANTLOCKSURFACE, "DDERR_CANTLOCKSURFACE"},
    {DDERR_SURFACEISOBSCURED, "DDERR_SURFACEISOBSCURED"},
    {DDERR_SURFACELOST, "DDERR_SURFACELOST"},
    {DDERR_SURFACENOTATTACHED, "DDERR_SURFACENOTATTACHED"},
    {DDERR_TOOBIGHEIGHT, "DDERR_TOOBIGHEIGHT"},
    {DDERR_TOOBIGSIZE, "DDERR_TOOBIGSIZE"},
    {DDERR_TOOBIGWIDTH, "DDERR_TOOBIGWIDTH"},
    {DDERR_UNSUPPORTED, "DDERR_UNSUPPORTED"},
    {DDERR_UNSUPPORTEDFORMAT, "DDERR_UNSUPPORTEDFORMAT"},
    {DDERR_UNSUPPORTEDMASK, "DDERR_UNSUPPORTEDMASK"},
    {DDERR_VERTICALBLANKINPROGRESS, "DDERR_VERTICALBLANKINPROGRESS"},
    {DDERR_WASSTILLDRAWING, "DDERR_WASSTILLDRAWING"},
    {DDERR_XALIGN, "DDERR_XALIGN"},
    {DDERR_INVALIDDIRECTDRAWGUID, "DDERR_INVALIDDIRECTDRAWGUID"},
    {DDERR_DIRECTDRAWALREADYCREATED, "DDERR_DIRECTDRAWALREADYCREATED"},
    {DDERR_NODIRECTDRAWHW, "DDERR_NODIRECTDRAWHW"},
    {DDERR_PRIMARYSURFACEALREADYEXISTS, "DDERR_PRIMARYSURFACEALREADYEXISTS"},
    {DDERR_NOEMULATION, "DDERR_NOEMULATION"},
    {DDERR_REGIONTOOSMALL, "DDERR_REGIONTOOSMALL"},
    {DDERR_CLIPPERISUSINGHWND, "DDERR_CLIPPERISUSINGHWND"},
    {DDERR_NOCLIPPERATTACHED, "DDERR_NOCLIPPERATTACHED"},
    {DDERR_NOHWND, "DDERR_NOHWND"},
    {DDERR_HWNDSUBCLASSED, "DDERR_HWNDSUBCLASSED"},
    {DDERR_HWNDALREADYSET, "DDERR_HWNDALREADYSET"},
    {DDERR_NOPALETTEATTACHED, "DDERR_NOPALETTEATTACHED"},
    {DDERR_NOPALETTEHW, "DDERR_NOPALETTEHW"},
    {DDERR_BLTFASTCANTCLIP, "DDERR_BLTFASTCANTCLIP"},
    {DDERR_NOBLTHW, "DDERR_NOBLTHW"},
    {DDERR_NODDROPSHW, "DDERR_NODDROPSHW"},
    {DDERR_OVERLAYNOTVISIBLE, "DDERR_OVERLAYNOTVISIBLE"},
    {DDERR_NOOVERLAYDEST, "DDERR_NOOVERLAYDEST"},
    {DDERR_INVALIDPOSITION, "DDERR_INVALIDPOSITION"},
    {DDERR_NOTAOVERLAYSURFACE, "DDERR_NOTAOVERLAYSURFACE"},
    {DDERR_EXCLUSIVEMODEALREADYSET, "DDERR_EXCLUSIVEMODEALREADYSET"},
    {DDERR_NOTFLIPPABLE, "DDERR_NOTFLIPPABLE"},
    {DDERR_CANTDUPLICATE, "DDERR_CANTDUPLICATE"},
    {DDERR_NOTLOCKED, "DDERR_NOTLOCKED"},
    {DDERR_CANTCREATEDC, "DDERR_CANTCREATEDC"},
    {DDERR_NODC, "DDERR_NODC"},
    {DDERR_WRONGMODE, "DDERR_WRONGMODE"},
    {DDERR_IMPLICITLYCREATED, "DDERR_IMPLICITLYCREATED"},
    {DDERR_NOTPALETTIZED, "DDERR_NOTPALETTIZED"},
    {DDERR_UNSUPPORTEDMODE, "DDERR_UNSUPPORTEDMODE"},
    {DDERR_NOMIPMAPHW, "DDERR_NOMIPMAPHW"},
    {DDERR_INVALIDSURFACETYPE, "DDERR_INVALIDSURFACETYPE"},
    {DDERR_NOOPTIMIZEHW, "DDERR_NOOPTIMIZEHW"},
    {DDERR_NOTLOADED, "DDERR_NOTLOADED"},
    {DDERR_DCALREADYCREATED, "DDERR_DCALREADYCREATED"},
    {DDERR_NONONLOCALVIDMEM, "DDERR_NONONLOCALVIDMEM"},
    {DDERR_CANTPAGELOCK, "DDERR_CANTPAGELOCK"},
    {DDERR_CANTPAGEUNLOCK, "DDERR_CANTPAGEUNLOCK"},
    {DDERR_NOTPAGELOCKED, "DDERR_NOTPAGELOCKED"},
    {DDERR_MOREDATA, "DDERR_MOREDATA"},
    {DDERR_VIDEONOTACTIVE, "DDERR_VIDEONOTACTIVE"},
    {DDERR_DEVICEDOESNTOWNSURFACE, "DDERR_DEVICEDOESNTOWNSURFACE"},
	{DDERR_NOTINITIALIZED, "DDERR_NOTINITIALIZED"},

  // Direct 3D errors...  
	{D3DERR_BADMAJORVERSION,"D3DERR_BADMAJORVERSION"},
    {D3DERR_BADMINORVERSION,"D3DERR_BADMINORVERSION"},
    {D3DERR_INVALID_DEVICE,"D3DERR_INVALID_DEVICE"},
    {D3DERR_INITFAILED,"D3DERR_INITFAILED"},
    {D3DERR_DEVICEAGGREGATED,"D3DERR_DEVICEAGGREGATED"},
    {D3DERR_EXECUTE_CREATE_FAILED,"D3DERR_EXECUTE_CREATE_FAILED"},
    {D3DERR_EXECUTE_DESTROY_FAILED,"D3DERR_EXECUTE_DESTROY_FAILED"},
    {D3DERR_EXECUTE_LOCK_FAILED,"D3DERR_EXECUTE_LOCK_FAILED"},
    {D3DERR_EXECUTE_UNLOCK_FAILED,"D3DERR_EXECUTE_UNLOCK_FAILED"},
    {D3DERR_EXECUTE_LOCKED,"D3DERR_EXECUTE_LOCKED"},
    {D3DERR_EXECUTE_NOT_LOCKED,"D3DERR_EXECUTE_NOT_LOCKED"},
    {D3DERR_EXECUTE_FAILED,"D3DERR_EXECUTE_FAILED"},
    {D3DERR_EXECUTE_CLIPPED_FAILED,"D3DERR_EXECUTE_CLIPPED_FAILED"},
    {D3DERR_TEXTURE_NO_SUPPORT,"D3DERR_TEXTURE_NO_SUPPORT"},
    {D3DERR_TEXTURE_CREATE_FAILED,"D3DERR_TEXTURE_CREATE_FAILED"},
    {D3DERR_TEXTURE_DESTROY_FAILED,"D3DERR_TEXTURE_DESTROY_FAILED"},
    {D3DERR_TEXTURE_LOCK_FAILED,"D3DERR_TEXTURE_LOCK_FAILED"},
    {D3DERR_TEXTURE_UNLOCK_FAILED,"D3DERR_TEXTURE_UNLOCK_FAILED"},
    {D3DERR_TEXTURE_LOAD_FAILED,"D3DERR_TEXTURE_LOAD_FAILED"},
    {D3DERR_TEXTURE_SWAP_FAILED,"D3DERR_TEXTURE_SWAP_FAILED"},
    {D3DERR_TEXTURE_LOCKED,"D3DERR_TEXTURE_LOCKED"},
    {D3DERR_TEXTURE_NOT_LOCKED,"D3DERR_TEXTURE_NOT_LOCKED"},
    {D3DERR_TEXTURE_GETSURF_FAILED,"D3DERR_TEXTURE_GETSURF_FAILED"},
    {D3DERR_MATRIX_CREATE_FAILED,"D3DERR_MATRIX_CREATE_FAILED"},
    {D3DERR_MATRIX_DESTROY_FAILED,"D3DERR_MATRIX_DESTROY_FAILED"},
    {D3DERR_MATRIX_SETDATA_FAILED,"D3DERR_MATRIX_SETDATA_FAILED"},
    {D3DERR_MATRIX_GETDATA_FAILED,"D3DERR_MATRIX_GETDATA_FAILED"},
    {D3DERR_SETVIEWPORTDATA_FAILED,"D3DERR_SETVIEWPORTDATA_FAILED"},
    {D3DERR_INVALIDCURRENTVIEWPORT,"D3DERR_INVALIDCURRENTVIEWPORT"},
    {D3DERR_INVALIDPRIMITIVETYPE,"D3DERR_INVALIDPRIMITIVETYPE"},
    {D3DERR_INVALIDVERTEXTYPE,"D3DERR_INVALIDVERTEXTYPE"},
    {D3DERR_TEXTURE_BADSIZE,"D3DERR_TEXTURE_BADSIZE"},
    {D3DERR_INVALIDRAMPTEXTURE,"D3DERR_INVALIDRAMPTEXTURE"},
    {D3DERR_MATERIAL_CREATE_FAILED,"D3DERR_MATERIAL_CREATE_FAILED"},
    {D3DERR_MATERIAL_DESTROY_FAILED,"D3DERR_MATERIAL_DESTROY_FAILED"},
    {D3DERR_MATERIAL_SETDATA_FAILED,"D3DERR_MATERIAL_SETDATA_FAILED"},
    {D3DERR_MATERIAL_GETDATA_FAILED,"D3DERR_MATERIAL_GETDATA_FAILED"},
    {D3DERR_INVALIDPALETTE,"D3DERR_INVALIDPALETTE"},
    {D3DERR_ZBUFF_NEEDS_SYSTEMMEMORY,"D3DERR_ZBUFF_NEEDS_SYSTEMMEMORY"},
    {D3DERR_ZBUFF_NEEDS_VIDEOMEMORY,"D3DERR_ZBUFF_NEEDS_VIDEOMEMORY"},
    {D3DERR_SURFACENOTINVIDMEM,"D3DERR_SURFACENOTINVIDMEM"},
    {D3DERR_LIGHT_SET_FAILED,"D3DERR_LIGHT_SET_FAILED"},
    {D3DERR_LIGHTHASVIEWPORT,"D3DERR_LIGHTHASVIEWPORT"},
    {D3DERR_LIGHTNOTINTHISVIEWPORT,"D3DERR_LIGHTNOTINTHISVIEWPORT"},
    {D3DERR_SCENE_IN_SCENE,"D3DERR_SCENE_IN_SCENE"},
    {D3DERR_SCENE_NOT_IN_SCENE,"D3DERR_SCENE_NOT_IN_SCENE"},
    {D3DERR_SCENE_BEGIN_FAILED,"D3DERR_SCENE_BEGIN_FAILED"},
    {D3DERR_SCENE_END_FAILED,"D3DERR_SCENE_END_FAILED"},
    {D3DERR_INBEGIN,"D3DERR_INBEGIN"},
    {D3DERR_NOTINBEGIN,"D3DERR_NOTINBEGIN"},
    {D3DERR_NOVIEWPORTS,"D3DERR_NOVIEWPORTS"},
    {D3DERR_VIEWPORTDATANOTSET,"D3DERR_VIEWPORTDATANOTSET"},
    {D3DERR_VIEWPORTHASNODEVICE,"D3DERR_VIEWPORTHASNODEVICE"},
    {D3DERR_NOCURRENTVIEWPORT,"D3DERR_NOCURRENTVIEWPORT"}
};
#define NUMDDERRORS sizearray(dderrors)

 // Global DirectDraw Error function
void TraceErrorDD(HRESULT Err, char *file, int line)
{       
    char *dderr;
    char err[1024];

	if (Err == DDERR_SURFACELOST)
		return;

	for (int c = 0; c < NUMDDERRORS; c++)
	{
		if (Err == dderrors[c].Error)
		{
			dderr = dderrors[c].lpszErrorStr; 
			break;
		}
	}
	if (c >= NUMDDERRORS)
		sprintf(dderr, "Unknown Error"); 

    sprintf(err, "DirectX Error %s\nin file %s at line %d", dderr, file, line);
    FatalError(err);
}
// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *           directinput.cpp - DirectInput functions module              *  
// *************************************************************************

#define INITGUID
#include <dinput.h>
#include <stdio.h>

#include "revenant.h"
#include "mainwnd.h"
#include "directinput.h"

LPDIRECTINPUT DirectInput = NULL;

// *******************************
// * DirectInput Error Functions *
// *******************************

#define TRY_DI(exp) { { HRESULT rval = exp; if (rval != DI_OK) { TraceErrorDI(rval, __FILE__, __LINE__); return FALSE; } } }
  //Global Direct Draw error handler 

struct DIERRORSTRING
{
	HRESULT Error;
	char *lpszErrorStr;
};

static DIERRORSTRING dierrors[] =
{
  // DirectInput errors...  
    {DI_NOTATTACHED, "DI_NOTATTACHED"},
    {DI_BUFFEROVERFLOW, "DI_BUFFEROVERFLOW"},
    {DI_PROPNOEFFECT, "DI_PROPNOEFFECT"},
    {DI_NOEFFECT, "DI_NOEFFECT"},
    {DI_POLLEDDEVICE, "DI_POLLEDDEVICE"},
    {DI_DOWNLOADSKIPPED, "DI_DOWNLOADSKIPPED"},
    {DI_EFFECTRESTARTED, "DI_EFFECTRESTARTED"},
    {DI_TRUNCATED, "DI_TRUNCATED"},
    {DI_TRUNCATEDANDRESTARTED, "DI_TRUNCATEDANDRESTARTED"},
    {DIERR_OLDDIRECTINPUTVERSION, "DIERR_OLDDIRECTINPUTVERSION"},
    {DIERR_BETADIRECTINPUTVERSION, "DIERR_BETADIRECTINPUTVERSION"},
    {DIERR_BADDRIVERVER, "DIERR_BADDRIVERVER"},
    {DIERR_DEVICENOTREG, "DIERR_DEVICENOTREG"},
    {DIERR_NOTFOUND, "DIERR_NOTFOUND"},
    {DIERR_OBJECTNOTFOUND, "DIERR_OBJECTNOTFOUND"},
    {DIERR_INVALIDPARAM, "DIERR_INVALIDPARAM"},
    {DIERR_NOINTERFACE, "DIERR_NOINTERFACE"},
    {DIERR_GENERIC, "DIERR_GENERIC"},
    {DIERR_OUTOFMEMORY, "DIERR_OUTOFMEMORY"},
    {DIERR_UNSUPPORTED, "DIERR_UNSUPPORTED"},
    {DIERR_NOTINITIALIZED, "DIERR_NOTINITIALIZED"},
    {DIERR_ALREADYINITIALIZED, "DIERR_ALREADYINITIALIZED"},
    {DIERR_NOAGGREGATION, "DIERR_NOAGGREGATION"},
    {DIERR_OTHERAPPHASPRIO, "DIERR_OTHERAPPHASPRIO"},
    {DIERR_INPUTLOST, "DIERR_INPUTLOST"},
    {DIERR_ACQUIRED, "DIERR_ACQUIRED"},
    {DIERR_NOTACQUIRED, "DIERR_NOTACQUIRED"},
    {DIERR_READONLY, "DIERR_READONLY"},
    {DIERR_HANDLEEXISTS, "DIERR_HANDLEEXISTS"},
    {DIERR_INSUFFICIENTPRIVS, "DIERR_INSUFFICIENTPRIVS"},
    {DIERR_DEVICEFULL, "DIERR_DEVICEFULL"},
    {DIERR_MOREDATA, "DIERR_MOREDATA"},
    {DIERR_NOTDOWNLOADED, "DIERR_NOTDOWNLOADED"},
    {DIERR_HASEFFECTS, "DIERR_HASEFFECTS"},
    {DIERR_NOTEXCLUSIVEACQUIRED, "DIERR_NOTEXCLUSIVEACQUIRED"},
    {DIERR_INCOMPLETEEFFECT, "DIERR_INCOMPLETEEFFECT"},
    {DIERR_NOTBUFFERED, "DIERR_NOTBUFFERED"},
    {DIERR_EFFECTPLAYING, "DIERR_EFFECTPLAYING"},
};
#define NUMDIERRORS sizearray(dierrors)

 // Global DirectInput Error function
void TraceErrorDI(HRESULT Err, char *file, int line)
{       
    char *dierr;
    char err[1024];

	for (int c = 0; c < NUMDIERRORS; c++)
	{
		if (Err == dierrors[c].Error)
		{
			dierr = dierrors[c].lpszErrorStr; 
			break;
		}
	}
	if (c >= NUMDIERRORS)
		sprintf(dierr, "Unknown Error"); 

    sprintf(err, "DirectX Error %s\nin file %s at line %d", dierr, file, line);
    FatalError(err);
}

// *************************
// * DirectInput Functions *
// *************************

BOOL InitializeDirectInput()
{
	if (DirectInput != NULL)
		return TRUE;

   // create the DirectInput 5.0 interface object
	DWORD err = DirectInputCreate(hInstance, DIRECTINPUT_VERSION, &DirectInput, NULL);
	if (err != DI_OK)
	{
		_RPT0(_CRT_WARN, "DIRECTINPUT: Unable to initialize DirectInput");
		DirectInput = NULL;
		return FALSE;
	}

   return TRUE;
}

void CloseDirectInput()
{
	if (!DirectInput)
		return;

	CloseJoysticks();
	DirectInput->Release();

	DirectInput = NULL;
}

// **********************
// * Joystick Functions *
// **********************

_STRUCTDEF(SJoystick)
struct SJoystick
{
	LPDIRECTINPUTDEVICE2 joydev;
	DWORD laststate;
};

static int numjoysticks = 0;
static SJoystick joysticks[MAXJOYSTICKS];

// Called to set word length properties on joystick device
HRESULT SetWordProperty(LPDIRECTINPUTDEVICE2 pdev, REFGUID guidProperty,
                   DWORD dwObject, DWORD dwHow, DWORD dwValue)
{
   DIPROPDWORD dipdw;

   dipdw.diph.dwSize       = sizeof(dipdw);
   dipdw.diph.dwHeaderSize = sizeof(dipdw.diph);
   dipdw.diph.dwObj        = dwObject;
   dipdw.diph.dwHow        = dwHow;
   dipdw.dwData            = dwValue;

   return pdev->SetProperty(guidProperty, &dipdw.diph);

}

// Called by joystick init enum function to create joystick devices
BOOL FAR PASCAL EnumJoystickFunc(LPCDIDEVICEINSTANCE pdinst, LPVOID)
{
   // create the DirectInput joystick device
	LPDIRECTINPUTDEVICE joydev;
	LPDIRECTINPUTDEVICE2 joydev2;
	TRY_DI(DirectInput->CreateDevice(pdinst->guidInstance, &joydev, NULL));
    TRY_DI(joydev->QueryInterface(IID_IDirectInputDevice2, (LPVOID *)&joydev2));
	TRY_DI(joydev2->SetDataFormat(&c_dfDIJoystick));
    TRY_DI(joydev2->SetCooperativeLevel(MainWindow.Hwnd(), 
		DISCL_BACKGROUND | DISCL_NONEXCLUSIVE));

	// set X-axis range to (-1000 ... +1000)
	// This lets us test against 0 to see which way the stick is pointed.

	DIPROPRANGE diprg;
    diprg.diph.dwSize       = sizeof(diprg);
    diprg.diph.dwHeaderSize = sizeof(diprg.diph);
    diprg.diph.dwObj        = DIJOFS_X;
    diprg.diph.dwHow        = DIPH_BYOFFSET;
    diprg.lMin              = -1000;
    diprg.lMax              = +1000;

	TRY_DI(joydev2->SetProperty(DIPROP_RANGE, &diprg.diph));

	//
	// And again for Y-axis range
	//
	diprg.diph.dwObj        = DIJOFS_Y;

	TRY_DI(joydev2->SetProperty(DIPROP_RANGE, &diprg.diph));

	// set X axis dead zone to 50% (to avoid accidental turning)
	// Units are ten thousandths, so 50% = 5000/10000.

	TRY_DI(SetWordProperty(joydev2, DIPROP_DEADZONE, DIJOFS_X, DIPH_BYOFFSET, 5000));

	// set Y axis dead zone to 50% (to avoid accidental thrust)
	// Units are ten thousandths, so 50% = 5000/10000.
	TRY_DI(SetWordProperty(joydev2, DIPROP_DEADZONE, DIJOFS_Y, DIPH_BYOFFSET, 5000));

	// Start getting input!
	TRY_DI(joydev2->Acquire());

	joysticks[numjoysticks].joydev = joydev2;
	joysticks[numjoysticks].laststate = 0;
	numjoysticks++;
 
	if (numjoysticks < MAXJOYSTICKS)
		return DIENUM_CONTINUE;
	else
		return FALSE;
}

// Initializes joystick devices
BOOL InitializeJoysticks()
{
	if (!DirectInput)
		return FALSE;

	TRY_DI(DirectInput->EnumDevices(DIDEVTYPE_JOYSTICK,
		EnumJoystickFunc, NULL, DIEDFL_ATTACHEDONLY));

	return numjoysticks > 0;
}

void CloseJoysticks()
{
	if (numjoysticks <= 0)
		return;

	for (int c = 0; c < numjoysticks; c++)
	{
		joysticks[c].joydev->Unacquire();
		joysticks[c].joydev->Release();
		joysticks[c].joydev = NULL;
		joysticks[c].laststate = 0;
	}

	numjoysticks = 0;
}

int NumJoysticks()
{
	return numjoysticks;
}

void GetJoystickState(int joynum, DWORD *state, DWORD *changed)
{
   HRESULT hRes;
   DIJOYSTATE js;

 	if (numjoysticks <= 0)
	{
		*state = *changed = 0;
		return;
	}

  // poll the joystick to read the current state
   hRes = joysticks[joynum].joydev->Poll();

   // get data from the joystick
   hRes = joysticks[joynum].joydev->GetDeviceState(sizeof(DIJOYSTATE), &js);

   if(hRes != DI_OK)
   {
      // did the read fail because we lost input for some reason?
      // if so, then attempt to reacquire.  If the second acquire
      // fails, then the error from GetDeviceData will be
      // DIERR_NOTACQUIRED, so we won't get stuck an infinite loop.
      if(hRes == DIERR_INPUTLOST)
         joysticks[joynum].joydev->Acquire();

	  // get data from the joystick
	  hRes = joysticks[joynum].joydev->GetDeviceState(sizeof(DIJOYSTATE), &js);
	  if (hRes != DI_OK)
	  {
		*state = joysticks[joynum].laststate;
		*changed = 0;
		return;
	  }
   }

   DWORD buttons = 0;

   if (js.lX < 0 && js.lY < 0)
	  buttons |= JOYSTICK_UPLEFT;
   else if (js.lX == 0 && js.lY < 0)
	  buttons |= JOYSTICK_UP;
   else if (js.lX > 0 && js.lY < 0)
	  buttons |= JOYSTICK_UPRIGHT;
   else if (js.lX < 0 && js.lY == 0)
	  buttons |= JOYSTICK_LEFT;
   else if (js.lX > 0 && js.lY == 0)
	  buttons |= JOYSTICK_RIGHT;
   else if (js.lX < 0 && js.lY > 0)
	  buttons |= JOYSTICK_DOWNLEFT;
   else if (js.lX == 0 && js.lY > 0)
	  buttons |= JOYSTICK_DOWN;
   else if (js.lX > 0 && js.lY > 0)
      buttons |= JOYSTICK_DOWNRIGHT;

   for (int c = 0; c < 24; c++)
   {
		if (js.rgbButtons[c] & 0x80)
			buttons |= (JOYSTICK_BUTTON1 << c);
   }

   *state = buttons;
   *changed = joysticks[joynum].laststate ^ buttons;
   joysticks[joynum].laststate = buttons;
}

// Generates VK compatible codes given the values in state, and changed.  The code returned
// from the previous call must be passed in 'code' in order to get the next code, or code
// must be -1 when the funciton is first called.  The function returns 'FALSE' when there
// are no more codes.
BOOL GetJoystickKeyCode(DWORD state, DWORD changed, int &code, BOOL &down)
{
	if (code < VK_JOYFIRST || code > VK_JOYLAST)
		code = VK_JOYFIRST - 1;

	code++;

	while (code <= VK_JOYLAST)
	{
		if (changed & (1 << (code - VK_JOYFIRST)))
		{
			down = (state & (1 << (code - VK_JOYFIRST))) != 0;
			return TRUE;
		}

		code++;
	}

	code = -1;
	down = FALSE;

	return FALSE;
}
// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                    dls.cpp - Scene system module                      *
// *************************************************************************

#define RADIUS 254
#define DIAMETER (RADIUS << 1)

#include <math.h>

#include "revenant.h"

#include "bitmap.h"
#include "dls.h"
#include "display.h"
#include "graphics.h"
#include "surface.h"

#define rdtsc __asm _emit 0x0f __asm _emit 0x31

BYTE IntTable[256];

extern SColor LightColors[NUMBASELIGHTS];
extern int LightUseCount[NUMBASELIGHTS];

extern BYTE  DistTable[256][256];
extern BYTE  AngleTable[256][256];
extern BYTE  CosCos[64*256];
extern BYTE  IntCos[256*256];
extern BYTE  SinSin[64*256];
extern BYTE  LightDropOffTable[32768];
extern WORD *LightTable;
extern BYTE  ColorTable[32 * 256];
extern BYTE  ColorTable16[32 * 256];
extern BYTE  ColorTableUpperHi[32 * 256];
extern BYTE  ColorTableUpperLo[32 * 256];
extern BYTE  ColorTableLower[32 * 256];
extern DWORD Conv16to32Upper[256];
extern DWORD Conv16to32Lower[256];
extern DWORD MMXLightTable[256];

// Aqua color light
extern double lred;
extern double lgreen;
extern double lblue;

/*
Normal buffer stuff is commented out to save some memory.
If you want to put it back in, you need to find every
occurance of 'nb' in this file and 'NormalBuffer' in
other files (like colortable.cpp) and uncomment it.
*/

// *****************************************************************************
// *                   L I G H T I N G   F U N C T I O N S                     *
// *****************************************************************************

//void DrawLight(RS3DPoint pos, RSColor color, int intensity, PTSurface surface)
//{
//  See OLDDLS.CPP for source for this function
//}

_STRUCTDEF(SLightData)
struct SLightData
{
	int z;
	SColor color;
	int intensity;
	PTSurface surface;
	int id;
};

void DrawStaticLightBlock(int ptrpos, WORD *zbufptr, DWORD *ubptr, 
	DWORD z, int intensity, int nextline, BYTE xpos, BYTE xend, BYTE ypos, BYTE yend) 
{
	if (ypos == yend || xpos == xend)
		return;

	int xdir, xdir2;
	if (xpos > xend)
		xdir = -1;
	else
		xdir = 1;
	xdir2 = xdir + xdir;

	char ydir;
	if (ypos > yend)
		ydir = -1;
	else
		ydir = 1;

	DWORD curxend = 0;
	BYTE iseven = !(abs(xend - xpos) & 1);

	DWORD ubpos = ptrpos + ((DWORD)ubptr / 4);
	DWORD zoffset = (DWORD)zbufptr - ((DWORD)ubptr / 2);

	DWORD saveesp = 0;

	DWORD begtime, endtime;

	__asm
	{
		rdtsc
		mov begtime, eax
		rdtsc
		mov endtime, eax

		mov  saveesp, esp

		mov	 esi, ubpos
		mov  esp, zoffset
		xor  eax, eax
		xor	 ebx, ebx
		xor	 ecx, ecx
		xor  edx, edx

		mov  ch, ypos 			
		mov  cl, xend

	yloop1:
		mov  curxend, ecx
		mov	 cl, xpos
		mov  edi, ecx
		xor  ecx, ecx
		
		mov  al, iseven
		or   al, al
		jne	 twoforone

		mov  al, DistTable[edi]					; Get XY dist
		cmp  al, 0FFh
		je singlenext1
		
		mov  bl, [esp + esi * 2]				; Get Z
		mov  bh, [esp + esi * 2 + 1]
		sub	 ebx, z
		jns	 singlepos
		neg	 ebx
	singlepos:
 		cmp	 ebx, intensity						; Make sure Z is in light range
		ja	 singlenext1
		
		mov  bh, al
		mov	 al, DistTable[ebx]					; d-z plane distance
		add  al, IntTable[eax]

		jc	 singlenext1						; skip if dist too great

		mov  bl, BYTE PTR [esi * 4 + 3]
		and  bl, 0FCh
		add  bl, LightDropOffTable[eax]			; get brightness based on dist
		jnc  singlenochange
		or   bl, 0FCh
	singlenochange:
		mov  BYTE PTR [esi * 4 + 3], bl

	singlenext1:
		inc  esi
		add	 edi, xdir

		cmp  edi, curxend
		je	 nexty1

		; **** Do 2for1 block (count em.. 2for1)

	twoforone:
		mov  bh, DistTable[edi]					; Get XY dist
		mov  bl, DistTable[edi + 1]				; Get XY dist 2
		cmp  ebx, 0FFFFh						; Both out of range
		je next1
		
		mov  al, [esp + esi * 2 + 0]			; Get Z
		mov  ah, [esp + esi * 2 + 1]
		mov  dl, [esp + esi * 2 + 2]			; Get Z 2
		mov  dh, [esp + esi * 2 + 3]
		sub	 eax, z
		jns	 twoforonepos1
		neg  eax
	twoforonepos1:
		sub	 edx, z
		jns	 twoforonepos2
		neg  edx
	twoforonepos2:
 		cmp	 eax, intensity						; Make sure Z is in light range
		ja	 do2only
		cmp  edx, intensity
		ja   do1only

		mov  dh, bh								; XY dist 2
		mov  bh, al								; XY dist 1
		mov	 al, DistTable[ebx]					; d-z plane distance
		mov  cl, DistTable[edx]					; d-z plane distance 2
		add	 al, IntTable[eax]
		jc	 nodraw1
		add  cl, IntTable[ecx]
		jc	 nodraw2							; skip if dist too great

		mov  bl, BYTE PTR [esi * 4 + 3]
		mov	 bh, BYTE PTR [esi * 4 + 7]
		and  ebx, 0FCFCh
		add	 bl, LightDropOffTable[eax]			; get brightness based on dist
		jnc  nochange1
		or   bl, 0FCh
	nochange1:
		add  bh, LightDropOffTable[ecx]			
		mov  BYTE PTR [esi * 4 + 3], bl
		jnc  nochange2
		or   bh, 0FCh
	nochange2:
		mov  BYTE PTR [esi * 4 + 7], bh
		jmp  next1

		; **** Do only blocks

	do2only:
		cmp  edx, intensity
		ja   next1
		mov  dh, bh								; XY dist 2
		mov  cl, DistTable[edx]					; d-z plane distance 2
		add  cl, IntTable[ecx]
		jc	 next1								; skip if dist too great

		mov	 dl, BYTE PTR [esi * 4 + 7]
		and	 dl, 0FCh
		add  dl, LightDropOffTable[ecx]			
		jnc  do2onlynochange
		or   dl, 0FCh
	do2onlynochange:
		mov  BYTE PTR [esi * 4 + 7], dl
		jmp  next1

	do1only:
		mov  bh, al								; XY dist 1
		mov	 al, DistTable[ebx]					; d-z plane distance
		add	 al, IntTable[eax]
		jc	 next1

		mov	 bl, BYTE PTR [esi * 4 + 3]
		and  bl, 0FCh
		add  bl, LightDropOffTable[eax]			; get brightness based on dist
		jnc  do1onlynochange
		or   bl, 0FCh
	do1onlynochange:
		mov  BYTE PTR [esi * 4 + 3], bl
		jmp  next1

		; **** Do no draw blocks

	nodraw1:
		add  cl, IntTable[ecx]					; d-z plane distance 2
		jc	 next1								; skip if dist too great
		mov	 dl, BYTE PTR [esi * 4 + 7]
		and  dl, 0FCh
		add  dl, LightDropOffTable[ecx]			
		jnc  nodraw1nochange
		or   dl, 0FCh
	nodraw1nochange:
		mov  BYTE PTR [esi * 4 + 7], dl
		jmp  next1

	nodraw2:
		mov  bl, BYTE PTR [esi * 4 + 3]
		and  bl, 0FCh
		add  bl, LightDropOffTable[eax]			; get brightness based on dist
		jnc  nodraw2nochange
		or   bl, 0FCh
	nodraw2nochange:
		mov  BYTE PTR [esi * 4 + 3], bl
		jmp  next1

	next1:
		add  esi,2
		add	 edi, xdir2

		cmp  edi, curxend
		jne	 twoforone

	nexty1:
		add  esi, nextline

		mov  ecx, edi
		add	 ch, ydir
		mov  curxend, ecx
		cmp	 ch, BYTE PTR yend
		jne	 yloop1

		mov  esp, saveesp

		rdtsc
		mov endtime, eax
	}

	int diff = (int)(endtime - begtime);
	int pixels = (abs(xend - xpos) + 1) * (abs(yend - ypos) + 1);
	int cyclesperpixel = diff / pixels;
	diff = 0;
}

BOOL DrawStaticLightNoNormalsFunc(PSDrawBlock db, PSDrawParam dp)
{
	RSLightData ld = *(PSLightData)dp->data;
	RSColor color = ld.color;
	int intensity = ld.intensity;
	PTSurface surface = ld.surface;
	int id = ld.id;

	if (dp->dwidth <= 0 || dp->dheight <= 0)
		return FALSE;

  // Calculate center of light in this coordinate system
	int x = dp->dx + dp->originx - dp->sx;  // Subtract source pos to get light center
	int y = dp->dy + dp->originy - dp->sy;	
	int z = ld.z;
	
	DWORD *ubptr = (DWORD *)db->dest;
	WORD *zbufptr = (WORD *)db->dzbuffer;

	SRect r;
	r.left   = dp->dx + dp->originx;
	r.top    = dp->dy + dp->originy;
	r.right  = r.left + dp->dwidth - 1;
	r.bottom = r.top + dp->dheight - 1;
		
	int ptrpos, width, height, nextline;
	int ypos, yend, xpos, xend;
	
	// Upper left quadrant
	int xstart = x - intensity;
	int ystart = y - intensity;
	width  = intensity;
	height = intensity;
	
	if ((xstart + width > r.left) && (ystart + height > r.top) &&
		(xstart <= r.right) && (ystart <= r.bottom))
	{
		xpos = width;
		ypos = height;
				  
		if (xstart < r.left)
		{
			width += (xstart - r.left);
			xpos  -= (r.left - xstart);
			xstart = r.left;
		}

		if (xstart + width > r.right + 1)
			width = r.right + 1 - xstart;

		if (ystart < r.top)
		{
			height += (ystart - r.top);
			ypos   -= (r.top - ystart);
			ystart  = r.top;
		}
	
		if (ystart + height > r.bottom + 1)
			height = r.bottom + 1 - ystart;
		
		xend = xpos - width;
		yend = ypos - height;
				
		ptrpos   = (ystart * db->dstride + xstart);
		nextline = (db->dstride - width);

		DrawStaticLightBlock(ptrpos, zbufptr, ubptr, z, intensity, nextline, xpos, xend, ypos, yend);
	}

	// Upper right quadrant
	xstart = x;
	ystart = y - intensity;
	width  = intensity;
	height = intensity;
	
	if ((xstart + width > r.left) && (ystart + height > r.top) &&
		(xstart <= r.right) && (ystart <= r.bottom))
	{
		xpos = 0;
		ypos = height;
				  
		if (xstart < r.left)
		{		   
			width += (xstart - r.left);
			xpos  += (r.left - xstart);
			xstart = r.left;
		}
		
		if (xstart + width > r.right + 1)
			width = r.right + 1 - xstart;

		if (ystart < r.top)
		{
			height += (ystart - r.top);
			ypos   -= (r.top - ystart);
			ystart  = r.top;
		}
		
		if (ystart + height > r.bottom + 1)
			height = r.bottom + 1 - ystart;
			
		xend = xpos + width;
		yend = ypos - height;
					
		ptrpos   = (ystart * db->dstride + xstart);
		nextline = (db->dstride - width);
		  
		DrawStaticLightBlock(ptrpos, zbufptr, ubptr, z, intensity, nextline, xpos, xend, ypos, yend);
	}
	
	// Lower left quadrant
	xstart = x - intensity;
	ystart = y;
	width  = intensity;
	height = intensity;
	
	if ((xstart + width > r.left) && (ystart + height > r.top) &&
		(xstart <= r.right) && (ystart <= r.bottom))
	{
		xpos = width;
		ypos = 0;
					
		if (xstart < r.left)
		{
			width += (xstart - r.left);
			xpos  -= (r.left - xstart);
			xstart = r.left;
		}

		if (xstart + width > r.right + 1)
			width = r.right + 1 - xstart;

 		if (ystart < r.top)
		{
			height += (ystart - r.top);
			ypos   += (r.top - ystart);
			ystart  = r.top;
		}

		if (ystart + height > r.bottom + 1)
			height = r.bottom + 1 - ystart;
				
		xend = xpos - width;
		yend = ypos + height;
							
		ptrpos   = (ystart * db->dstride + xstart);
		nextline = (db->dstride - width);
					  
		DrawStaticLightBlock(ptrpos, zbufptr, ubptr, z, intensity, nextline, xpos, xend, ypos, yend);
	}

  // Lower right quadrant
	xstart = x;
	ystart = y;
	width  = intensity;
	height = intensity;

	if ((xstart + width > r.left) && (ystart + height > r.top) &&
		(xstart <= r.right) && (ystart <= r.bottom))
	{
		xpos = 0;
		ypos = 0;

		if (xstart < r.left)
		{
			width += (xstart - r.left);
			xpos  += (r.left - xstart);
			xstart = r.left;
		}

		if (xstart + width > r.right + 1)
			width = r.right + 1 - xstart;
		
		if (ystart < r.top)
		{
			height += (ystart - r.top);
			ypos   += (r.top - ystart);
			ystart  = r.top;
		}
		
		if (ystart + height > r.bottom + 1)
			height = r.bottom + 1 - ystart;

		xend = xpos + width;
		yend = ypos + height;
		
		ptrpos   = (ystart * db->dstride + xstart);
		nextline = (db->dstride - width);

		DrawStaticLightBlock(ptrpos, zbufptr, ubptr, z, intensity, nextline, xpos, xend, ypos, yend);
	}

	return TRUE;
}

void DrawStaticLightNoNormals(RS3DPoint pos, RSColor color, int intensity, PTSurface surface, int id)
{
	if (surface->BitsPerPixel() != 32 || id >= NUMBASELIGHTS)
		return;

	if (intensity > 254)
		intensity = 254;

	if (intensity < 0)
		intensity = 0;

	BYTE coloridx = id & 3;
	int intratio = (254 << 16) / intensity + 256;
	int intaccum = 0;
	for (int c = 0; c < 256; c++)
	{
	  // Set the color id for the lighting table
	  LightDropOffTable[c] = LightDropOffTable[c] & 0xFC | coloridx;

 	  // Set the intensity ramp for the intensity table
	  intaccum += intratio;
	  IntTable[c] = (BYTE)(min((intaccum >> 16) - c, 255));
	}

	SLightData ld;
	ld.z = pos.z;
	ld.color = color;
	ld.intensity = intensity;
	ld.surface = surface;
	ld.id = id;

	int x = pos.x - intensity;
	int y = pos.y - intensity;
	int w = intensity * 2;
	int h = intensity * 2;

	SDrawParam dp;
	MakeDP(dp, x, y, -intensity, -intensity, w, h, DM_ZBUFFER);
	dp.func = DrawStaticLightNoNormalsFunc;
	dp.data = (void *)&ld;

    surface->ParamDraw(&dp);
}

BOOL DrawAmbientLightFunc(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->dwidth < 1 || dp->dheight < 1) 
		return FALSE;

	SETUP_DRAW

	int width  = dp->dwidth;
	int height = dp->dheight;

	int ypos = dp->dheight;
	
	DWORD dstptr  = (DWORD)db->dest + dstoff;
	  
	__asm
	{
		mov  esi, dstptr

		xor  eax, eax
		xor  edx, edx

	ayloop1:
		mov  ebx, width

	axloop1:
		mov  BYTE PTR [esi + 3], dh
		add  esi, 4

		dec	 ebx
		jne	 axloop1

		add  esi, dstadd

		dec	 ypos
		jne	 ayloop1
	}

	return TRUE;
}

void DrawAmbientLight(PTSurface surface, RSRect r)
{
	SDrawParam dp;
	MakeDPNoSrc(dp, r.x(), r.y(), r.w(), r.h(), DM_DEFAULT);
	dp.func = DrawAmbientLightFunc;

    surface->ParamDraw(&dp);
}

BOOL Transfer32to16MMXFunc(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 1 || dp->dheight < 1) 
		return FALSE;

	SETUP_DRAW

	DWORD srcptr = (DWORD)db->source;
	srcptr += srcoff;
	DWORD dstptr = (DWORD)db->dest;
	dstptr += dstoff;

	int height = dp->dheight;

	// Note: we're doing two pixels at a time below.. Make sure that the paired pixels
	// are DWORD aligned by finding out whether the beginning and ending of the line
	// is even or odd, then draw the first pixel, all the pairs, then the last pixel.

	DWORD dowidth = (dp->dwidth << 1);
	DWORD dofirst = 0;
	DWORD dolast = 0;
	if (dowidth < 8)
	{
		dofirst = dowidth;
		dolast = 0;
		dowidth = 0;
	}
	else
	{
	  if ((dstptr & 7) != 0)  // Is first pixel DWORD aligned
	  {
		dofirst = dstptr & 7;
		dowidth -= dofirst;
	  }
	  if ((dowidth & 7) != 0)
	  {
		dolast = dowidth & 7;
		dowidth -= dolast;
	  }
	}

	DWORD loopdone = 0;

	// Optimization notes:
	//
	// The tables below are big (64k or 128k each), but this shouldn't hash the cache
	// since the lower 8 bits holds only a 5 bit color value whose lookup fits neatly into
	// one cache entry, and the upper 8 bits change only on the brightness value (upper 6 bits).
	// The Blue and Red table should only use about 2k in cache entries (64 brightness values
	// times 32 color values times 1 byte per value), and the Green table should only be about
	// 4k (2k times 2 bytes per value) for a total cache use of only 8k, which fits inside
	// the on chip cache no problem.
	//
	// In essence, there are large numbers of empty 32 byte chunks in the lookup tables
	// that are never loaded into the cache.

	BYTE BLUEMASK = 0x1F;
	BYTE REDMASK = (Display->BitsPerPixel() == 15) ? 0x7C : 0xF8;
	DWORD GREENMASK = (Display->BitsPerPixel() == 15) ? 0x03E0 : 0x07E0;

	unsigned __int64 ZERO = 0;
	unsigned __int64 MULFACT = 0x0008200000082000;
	unsigned __int64 REDBLUE = 0x00F800F800F800F8;
	unsigned __int64 GREEN =   0x0000F8000000F800;
	unsigned __int64 MASKBLUE16 =0x7FE07FE07FE07FE0;
	unsigned __int64 TEST = 0;

	DWORD begtime, endtime;

	__asm
	{
		rdtsc
		mov begtime, eax
		rdtsc
		mov endtime, eax

		mov  edi, dstptr
		mov  esi, srcptr

	    xor  eax, eax
		xor  ebx, ebx
		xor	 ecx, ecx

	DoFirst:
		mov  ecx, dofirst
		or   ecx, ecx
		je	 DoPairs
		add  ecx, edi
		mov  loopdone, ecx
		mov  edx, LightTable
		xor  ebx, ebx

	DoFirstLoop:
		mov  bh, BYTE PTR [esi + 3]
				
		mov  bl, BYTE PTR [esi + 2]
		mov  al, [edx + ebx * 2]				; get blue
		and  al, BLUEMASK
		mov  bl, BYTE PTR [esi]
		mov  ah, [edx + ebx * 2 + 1]			; get red
		and  ah, REDMASK
		mov  bl, BYTE PTR [esi + 1]  
		mov  cl, [edx + ebx * 2]				; l/u green & blue
		mov  ch, [edx + ebx * 2 + 1]			; l/u green & blue
		and  ecx, GREENMASK
		or   eax, ecx
		mov  bh, BYTE PTR [esi + 3]
				
		add	 esi, 4
		mov  [edi], ax
		add  edi, 2
		cmp  edi, loopdone
		jne  DoFirstLoop

	DoPairs:
		mov  ecx, dowidth
		or   ecx, ecx
		je	 DoLast
		add  ecx, edi
		mov  loopdone, ecx
		xor  ecx, ecx

//		rdtsc
//		mov begtime, eax

		xor	 eax, eax
		xor  ebx, ebx
		xor  ecx, ecx
		xor  edx, edx

	DoMainLoop:
		mov			al, [esi + 3]			; Get light value 1
		mov			bl, [esi + 7]			; Get light value 2
		mov			cl, [esi + 11]			; Get light value 3
		mov			dl, [esi + 15]			; Get light value 4
		movq		mm0, [esi]				; Get RGB value 1-2
		movq		mm4, [esi + 8]			; Get RGB value 3-4
		add			esi, 16
		movd		mm2, MMXLightTable[eax * 4]	; Get RGB multiplier 1
		movd		mm3, MMXLightTable[ebx * 4]	; Get RGB multiplier 2
		movd		mm6, MMXLightTable[ecx * 4]	; Get RGB multiplier 1
		movd		mm7, MMXLightTable[edx * 4]	; Get RGB multiplier 2
		movq		mm1, mm0				; Copy 1-2
		movq        mm5, mm4				; Copy 3-4
		punpcklbw	mm0, ZERO				; Unpack RGB 1
		punpckhbw	mm1, ZERO				; Unpack RGB 2
		punpcklbw	mm2, ZERO				; Unpack light value 1
		punpcklbw	mm3, ZERO				; Unpack light value 2
		punpcklbw	mm4, ZERO				; Unpack RGB 3
		punpckhbw	mm5, ZERO				; Unpack RGB 4
		punpcklbw	mm6, ZERO				; Unpack light value 3
		punpcklbw	mm7, ZERO				; Unpack light value 4
		pmullw		mm0, mm2				; Multiply pixel 1
		pmullw		mm1, mm3				; Multiply pixel 2
		pmullw		mm4, mm6				; Multiply pixel 3
		pmullw		mm5, mm7				; Multiply pixel 4
		packuswb	mm0, mm1				; Pack RGB words back to bytes 1-2
		packuswb    mm4, mm5				; Pack 3-4
		movq		mm1, mm0				; Save the original data 1-2
		movq		mm5, mm4				; Save 3-4
		pand		mm0, REDBLUE			; Mask out all but hte 5 MSBits of red and blue
		pand		mm4, REDBLUE			; Mask 3-4
		pmaddwd		mm0, MULFACT			; Multiply each word by 2**13, 2**3, 2**13, 2**3
		pmaddwd     mm4, MULFACT            ; Multiply 3-4
		pand		mm1, GREEN				; Mask out all but the 4 MSBits of green
		pand		mm5, GREEN				; Mask 3-4
		por			mm0, mm1				; Combine the red, green, and blue bits
		por			mm4, mm5				; Combine 3-4
		psrld		mm0, 6					; Shift to final position
		psrld		mm4, 6					; Shift 3-4 
		packssdw	mm0, mm4				; Pack back to dword all four pixels
		movq		mm1, mm0				; CONVERT 15->16 BIT Copy final words
		pand		mm1, MASKBLUE16			; CONVERT 15->16 BIT Mask blue 16 bit
		paddusw		mm0, mm1				; CONVERT 15->16 BIT Double Red/Green to 16 bit

		movq		[edi], mm0
		add  edi, 8

		cmp  edi, loopdone
		jne  DoMainLoop

//		rdtsc
//		mov endtime, eax

	DoLast:
		mov  ecx, dolast
		or   ecx, ecx
		je  YDone
		add  ecx, edi
		mov  loopdone, ecx
		mov  edx, LightTable
		xor  ebx, ebx

	DoLastLoop:
		mov  bh, BYTE PTR [esi + 3]
				
		mov  bl, BYTE PTR [esi + 2]
		mov  al, [edx + ebx * 2]				; get blue
		and  al, BLUEMASK
		mov  bl, BYTE PTR [esi]
		mov  ah, [edx + ebx * 2 + 1]			; get red
		and  ah, REDMASK
		mov  bl, BYTE PTR [esi + 1]  
		mov  cl, [edx + ebx * 2]				; l/u green & blue
		mov  ch, [edx + ebx * 2 + 1]			; l/u green & blue
		and  ecx, GREENMASK
		or   eax, ecx

		add	 esi, 4
		mov  [edi], ax
		add  edi, 2
		cmp  edi, loopdone
		jne  DoLastLoop

	YDone:
		add  esi, srcadd
		add  edi, dstadd

		dec  height
		jne  DoFirst

		rdtsc
		mov endtime, eax

		emms
	}

	int diff = (int)(endtime - begtime);
	int pixels = dp->swidth * dp->sheight;
	int cyclesperpixel = diff / pixels;

	return TRUE;
}

BOOL Transfer32to16Func(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 1 || dp->dheight < 1) 
		return FALSE;

	SETUP_DRAW

	DWORD srcptr = (DWORD)db->source;
	srcptr += srcoff;
	DWORD dstptr = (DWORD)db->dest;
	dstptr += dstoff;

	int height = dp->dheight;

	// Note: we're doing two pixels at a time below.. Make sure that the paired pixels
	// are DWORD aligned by finding out whether the beginning and ending of the line
	// is even or odd, then draw the first pixel, all the pairs, then the last pixel.

	BYTE dofirst = 0;
	if ((dstptr & 3) != 0 || dp->dwidth == 1)  // Is first pixel DWORD aligned
		dofirst = 1;
	BYTE dolast = 0;									// Is last pixel DWORD aligned
	if (((dstptr + (dp->dwidth << 1)) & 3) != 0 && dp->dwidth > 1)
		dolast = 1;
	DWORD dopairs = (dp->dwidth - dofirst - dolast) << 1;	// Get number of paired bytes
	DWORD pairsdone = 0;

	DWORD saveesp = 0;

	BYTE BLUEMASK = 0x1F;
	BYTE REDMASK = (Display->BitsPerPixel() == 15) ? 0x7C : 0xF8;
	DWORD GREENMASK = (Display->BitsPerPixel() == 15) ? 0x03E0 : 0x07E0;

	// Optimization notes:
	//
	// The tables below are big (64k or 128k each), but this shouldn't hash the cache
	// since the lower 8 bits holds only a 5 bit color value whose lookup fits neatly into
	// one cache entry, and the upper 8 bits change only on the brightness value (upper 6 bits).
	// The Blue and Red table should only use about 2k in cache entries (64 brightness values
	// times 32 color values times 1 byte per value), and the Green table should only be about
	// 4k (2k times 2 bytes per value) for a total cache use of only 8k, which fits inside
	// the on chip cache no problem.
	//
	// In essence, there are large numbers of empty 32 byte chunks in the lookup tables
	// that are never loaded into the cache.


	DWORD begtime, endtime;

	__asm
	{
		rdtsc
		mov begtime, eax
		rdtsc
		mov endtime, eax

		mov  saveesp, esp

		mov  edi, dstptr
		mov  esi, srcptr
		mov	 esp, LightTable

	    xor  eax, eax
		xor  ebx, ebx
		xor	 ecx, ecx
		xor  edx, edx

	DoFirstPixel:
		mov  al, dofirst
		or   al, al
		je	 DoPairs

		mov  bh, BYTE PTR [esi + 3]
				
		mov  bl, BYTE PTR [esi + 2]
		mov  al, [esp + ebx * 2]				; get blue
		and  al, BLUEMASK
		mov  bl, BYTE PTR [esi]
		mov  ah, [esp + ebx * 2 + 1]			; get red
		and  ah, REDMASK
		mov  bl, BYTE PTR [esi + 1]  
		mov  cl, [esp + ebx * 2]				; l/u green & blue
		mov  ch, [esp + ebx * 2 + 1]			; l/u green & blue
		and  ecx, GREENMASK
		or   eax, ecx

		add	 esi, 4

		mov  [edi], ax
		add  edi, 2

	DoPairs:
		mov  ecx, dopairs
		or   ecx, ecx
		je	 DoLastPixel
		add  ecx, edi
		mov  pairsdone, ecx
//		xor	 eax, eax

	DoPairsLoop:
		mov  bh, BYTE PTR [esi + 3]
		mov	 dh, BYTE PTR [esi + 7]
				
		mov  bl, BYTE PTR [esi + 2]
		mov	 dl, BYTE PTR [esi + 6]
		mov  al, [esp + ebx * 2]				; get blue
		mov  cl, [esp + edx * 2]
		and  al, BLUEMASK
		and  cl, BLUEMASK
		mov  bl, BYTE PTR [esi]
		mov  dl, BYTE PTR [esi + 4]                        
		mov  ah, [esp + ebx * 2 + 1]			; get red
		mov  ch, [esp + edx * 2 + 1]
		and  ah, REDMASK
		and  ch, REDMASK
		mov  bl, BYTE PTR [esi + 1]  
		mov  dl, [esp + ebx * 2]				; l/u green & blue
		and  dl, BYTE PTR [GREENMASK]
		or   al, dl
		mov  dl, BYTE PTR [esp + ebx * 2 + 1]
		and  dl, BYTE PTR [GREENMASK + 1]
		or   ah, dl
		mov  dl, BYTE PTR [esi + 5]                      
		mov  bl, [esp + edx * 2]			; l/u green & blue
		mov  bh, [esp + edx * 2 + 1]
		and  ebx, GREENMASK
		or   ecx, ebx

		add	 esi, 8

		shl  ecx, 16
		or   ecx, eax

		mov  [edi], ecx
		add  edi, 4

		cmp  edi, pairsdone
		jne  DoPairsLoop

	DoLastPixel:
		mov  al, dolast
		or   al, al
		je  YDone

		mov  bh, BYTE PTR [esi + 3]
				
		mov  bl, BYTE PTR [esi + 2]
		mov  al, [esp + ebx * 2]				; get blue
		and  al, BLUEMASK
		mov  bl, BYTE PTR [esi]
		mov  ah, [esp + ebx * 2 + 1]			; get red
		and  ah, REDMASK
		mov  bl, BYTE PTR [esi + 1]  
		mov  cl, [esp + ebx * 2]				; l/u green & blue
		mov  ch, [esp + ebx * 2 + 1]			; l/u green & blue
		and  ecx, GREENMASK
		or   eax, ecx

		add	 esi, 4

		mov  [edi], ax
		add  edi, 2

	YDone:
		add  esi, srcadd
		add  edi, dstadd

		dec  height
		jne  DoFirstPixel

		mov  esp, saveesp

		rdtsc
		mov endtime, eax
	}

	int diff = (int)(endtime - begtime);
	int pixels = dp->swidth * dp->sheight;
	int cyclesperpixel = diff / pixels;

	return TRUE;
}

void TransferAndLight32to16(PTSurface dest, PTSurface source, RSRect r)
{
	SDrawParam dp;
	MakeDP(dp, r.x(), r.y(), r.x(), r.y(), r.w(), r.h(), DM_WRAPCLIP | DM_WRAPCLIPSRC);

	if (!IsMMX)
		dp.func = Transfer32to16Func;
	else
		dp.func = Transfer32to16MMXFunc;

    dest->ParamBlit(&dp, source);
}

#if 0

// Transfer/Light for 15 bit source buffer
	DoMainLoop:
		mov			al, [esi + 3]			; Get light value 1
		mov			bl, [esi + 7]			; Get light value 2
		mov			cl, [esi + 11]			; Get light value 3
		mov			dl, [esi + 15]			; Get light value 4

		movq		mm0, [esp]				; Get RGB value 1-4 (Convert from 16 to 32
		movq		mm1, mm0
		punpcklwd	mm0, ZERO
		punpckhwd	mm1, ZERO
		pslld		mm0, 6
		pslld		mm1, 6
		movq		mm2, mm0
		movq		mm3, mm1
		pmaddwd		mm0, SPLITFACT
		pmaddwd     mm1, SPLITFACT
		pand		mm2, GREEN
		pand		mm3, GREEN
		por			mm0, mm2
		por			mm1, mm3

		add			esi, 4
		add			esp, 8

		movd		mm2, MMXLightTable[eax * 4]	; Get RGB multiplier 1
		movd		mm3, MMXLightTable[ebx * 4]	; Get RGB multiplier 2
		movd		mm6, MMXLightTable[ecx * 4]	; Get RGB multiplier 1
		movd		mm7, MMXLightTable[edx * 4]	; Get RGB multiplier 2
		movq		mm1, mm0				; Copy 1-2
		movq        mm5, mm4				; Copy 3-4
		punpcklbw	mm0, ZERO				; Unpack RGB 1
		punpckhbw	mm1, ZERO				; Unpack RGB 2
		punpcklbw	mm2, ZERO				; Unpack light value 1
		punpcklbw	mm3, ZERO				; Unpack light value 2
		punpcklbw	mm4, ZERO				; Unpack RGB 3
		punpckhbw	mm5, ZERO				; Unpack RGB 4
		punpcklbw	mm6, ZERO				; Unpack light value 3
		punpcklbw	mm7, ZERO				; Unpack light value 4
		pmullw		mm0, mm2				; Multiply pixel 1
		pmullw		mm1, mm3				; Multiply pixel 2
		pmullw		mm4, mm6				; Multiply pixel 3
		pmullw		mm5, mm7				; Multiply pixel 4
		packuswb	mm0, mm1				; Pack RGB words back to bytes 1-2
		packuswb    mm4, mm5				; Pack 3-4

		movq		mm1, mm0				; Save the original data 1-2
		movq		mm5, mm4				; Save 3-4
		pand		mm0, REDBLUE			; Mask out all but hte 5 MSBits of red and blue
		pand		mm4, REDBLUE			; Mask 3-4
		pmaddwd		mm0, MULFACT			; Multiply each word by 2**13, 2**3, 2**13, 2**3
		pmaddwd     mm4, MULFACT            ; Multiply 3-4
		pand		mm1, GREEN				; Mask out all but the 4 MSBits of green
		pand		mm5, GREEN				; Mask 3-4
		por			mm0, mm1				; Combine the red, green, and blue bits
		por			mm4, mm5				; Combine 3-4
		psrld		mm0, 6					; Shift to final position
		psrld		mm4, 6					; Shift 3-4 
		packssdw	mm0, mm4				; Pack back to dword all four pixels
		movq		mm1, mm0				; CONVERT 15->16 BIT Copy final words
		pand		mm1, MASKBLUE16			; CONVERT 15->16 BIT Mask blue 16 bit
		paddusw		mm0, mm1				; CONVERT 15->16 BIT Double Red/Green to 16 bit


/*		This WONT WORK!!


		movq	mm0, [esi]							; Get z buffer values
		psubw	mm0, LIGHTPOS						; Get dist from light
		movq	mm1, mm0							; Copy results
		pcmpgtw ZERO, mm1							; Get not mask to reverse neg values
		pxor    mm0, ONE							; Get absolute values (though neg is 1 off)
		packuswb mm0, ZERO							; Pack and saturate down to bytes
		punpcklbw mm0, ZERO							; Return to words with 255 maximum value
		pxor    mm0, REVERSE						; Reverse directon of low bytes
		paddusw	mm0, ADDVAL							; Add val (to flatten exp curve)
		movd    mm1, [esp]							; Get dist values from table
		punpcklbw mm1, ZERO							; Unpack
		paddus	mm1, ADDVAL							; Add val (to flaten exp curve)
		movq	mm2, mm0
		pmullw	mm0, mm0							; Square distance (should exactly wrap to 10000)
		pmulhw	mm2, mm2
		movq	mm3, mm0
		pmullw  mm1, mm1							; Square distance
		pmulhw  mm3, mm3							; Square distance
		paddusw mm0, mm1
		paddusw mm2, mm3
		pcmpgtw mm2, ZERO							; Saturate low word by checking hi word for stuff
		por     mm0, mm2							; Then or'ing low word with full mask if bits found in high
		psub    mm0, SUBVAL							; Sub val (to flaten exp curve)
		psrlw   mm0, 8								; Divide (to get lighting brightness)
		pand    mm0, LIGHTCODEMASK					; Put lighting code in bottom byte
		por		mm0, LIGHTCODE						
		packuswb mm0, ZERO
		movd    [edi], mm0							; Save out final result

		pcmpgtw mm3, ZERO
		por		mm1, 
		movq	mm3, mm0
		paddus  mm0, mm1
		psrlw	mm0, 10								; Divide result by 1024 (to flatten exp curve)

*/


void DrawStaticLightBlockMMX(int ptrpos, WORD *zbufptr, DWORD *ubptr, 
	DWORD z, int intensity, int nextline, BYTE xpos, BYTE xend, BYTE ypos, BYTE yend) 
{
	if (ypos == yend || xpos == xend)
		return;

	int xdir, xdir2;
	if (xpos > xend)
		xdir = -1;
	else
		xdir = 1;
	xdir2 = xdir + xdir;

	char ydir;
	if (ypos > yend)
		ydir = -1;
	else
		ydir = 1;

	DWORD curxend = 0;
	BYTE iseven = !(abs(xend - xpos) & 1);

	DWORD ubpos = ptrpos + ((DWORD)ubptr / 4);
	DWORD zoffset = (DWORD)zbufptr - ((DWORD)ubptr / 2);

	DWORD saveesp = 0;

	DWORD begtime, endtime;

	__asm
	{
		rdtsc
		mov begtime, eax
		rdtsc
		mov endtime, eax

		mov  saveesp, esp

		mov	 esi, ubpos
		mov  esp, zoffset
		xor  eax, eax
		xor	 ebx, ebx
		xor	 ecx, ecx
		xor  edx, edx

		mov  ch, ypos 			
		mov  cl, xend

	yloop1:
		mov  curxend, ecx
		mov	 cl, xpos
		mov  edi, ecx
		xor  ecx, ecx
		
		mov  al, iseven
		or   al, al
		jne	 twoforone

		mov  al, DistTable[edi]					; Get XY dist
		cmp  al, 0FFh
		je singlenext1
		
		mov  bl, [esp + esi * 2]				; Get Z
		mov  bh, [esp + esi * 2 + 1]
		sub	 ebx, z
		jns	 singlepos
		neg	 ebx
	singlepos:
 		cmp	 ebx, intensity						; Make sure Z is in light range
		ja	 singlenext1
		
		mov  bh, al
		mov	 al, DistTable[ebx]					; d-z plane distance
		add  al, IntTable[eax]

		jc	 singlenext1						; skip if dist too great

		mov  bl, BYTE PTR [esi * 4 + 3]
		and  bl, 0FCh
		add  bl, LightDropOffTable[eax]			; get brightness based on dist
		jnc  singlenochange
		or   bl, 0FCh
	singlenochange:
		mov  BYTE PTR [esi * 4 + 3], bl

	singlenext1:
		inc  esi
		add	 edi, xdir

		cmp  edi, curxend
		je	 nexty1

		; **** Do 2for1 block (count em.. 2for1)

	twoforone:
		movd mm3, DistTable[edi]				; Get XY dist
		movq mm0, [esp + esi * 2]				; Get Z buffer values
		psubus mm0, LIGHTPOSZ
		movq mm1, ZERO
		pcmpgtw mm1, mm0						; Negate negative distances
		pxor mm0, mm1
		packusbw mm0, ZERO						; Saturate bytes
		punpcklbw mm0, mm3						; Combine with distable bytes
		movq mm1, mm0
		punpcklwd mm0, ZERO						; Make 2 DWORDs
		punpcklwd mm1, ZERO						; Make 2 DWORDs

pixel1:
		movd eax, mm0
		cmp eax, MAXDIST
		jle pixel2
		mov bl, DistTable[eax]
		adc bl, IntTable[ebx]
		cmovcc bl, LightDropOffTable[ebx]
		cmovcc cl, [esi]
		cmovcs cl, 0



	twoforonepos2:
 		cmp	 eax, intensity						; Make sure Z is in light range
		ja	 do2only
		cmp  edx, intensity
		ja   do1only

		mov  dh, bh								; XY dist 2
		mov  bh, al								; XY dist 1
		mov	 al, DistTable[ebx]					; d-z plane distance
		mov  cl, DistTable[edx]					; d-z plane distance 2
		add	 al, IntTable[eax]
		jc	 nodraw1
		add  cl, IntTable[ecx]
		jc	 nodraw2							; skip if dist too great

		mov  bl, BYTE PTR [esi * 4 + 3]
		mov	 bh, BYTE PTR [esi * 4 + 7]
		and  ebx, 0FCFCh
		add	 bl, LightDropOffTable[eax]			; get brightness based on dist
		jnc  nochange1
		or   bl, 0FCh
	nochange1:
		add  bh, LightDropOffTable[ecx]			
		mov  BYTE PTR [esi * 4 + 3], bl
		jnc  nochange2
		or   bh, 0FCh
	nochange2:
		mov  BYTE PTR [esi * 4 + 7], bh
		jmp  next1

		; **** Do only blocks

	do2only:
		cmp  edx, intensity
		ja   next1
		mov  dh, bh								; XY dist 2
		mov  cl, DistTable[edx]					; d-z plane distance 2
		add  cl, IntTable[ecx]
		jc	 next1								; skip if dist too great

		mov	 dl, BYTE PTR [esi * 4 + 7]
		and	 dl, 0FCh
		add  dl, LightDropOffTable[ecx]			
		jnc  do2onlynochange
		or   dl, 0FCh
	do2onlynochange:
		mov  BYTE PTR [esi * 4 + 7], dl
		jmp  next1

	do1only:
		mov  bh, al								; XY dist 1
		mov	 al, DistTable[ebx]					; d-z plane distance
		add	 al, IntTable[eax]
		jc	 next1

		mov	 bl, BYTE PTR [esi * 4 + 3]
		and  bl, 0FCh
		add  bl, LightDropOffTable[eax]			; get brightness based on dist
		jnc  do1onlynochange
		or   bl, 0FCh
	do1onlynochange:
		mov  BYTE PTR [esi * 4 + 3], bl
		jmp  next1

		; **** Do no draw blocks

	nodraw1:
		add  cl, IntTable[ecx]					; d-z plane distance 2
		jc	 next1								; skip if dist too great
		mov	 dl, BYTE PTR [esi * 4 + 7]
		and  dl, 0FCh
		add  dl, LightDropOffTable[ecx]			
		jnc  nodraw1nochange
		or   dl, 0FCh
	nodraw1nochange:
		mov  BYTE PTR [esi * 4 + 7], dl
		jmp  next1

	nodraw2:
		mov  bl, BYTE PTR [esi * 4 + 3]
		and  bl, 0FCh
		add  bl, LightDropOffTable[eax]			; get brightness based on dist
		jnc  nodraw2nochange
		or   bl, 0FCh
	nodraw2nochange:
		mov  BYTE PTR [esi * 4 + 3], bl
		jmp  next1

	next1:
		add  esi,2
		add	 edi, xdir2

		cmp  edi, curxend
		jne	 twoforone

	nexty1:
		add  esi, nextline

		mov  ecx, edi
		add	 ch, ydir
		mov  curxend, ecx
		cmp	 ch, BYTE PTR yend
		jne	 yloop1

		mov  esp, saveesp

		rdtsc
		mov endtime, eax
	}

	int diff = (int)(endtime - begtime);
	int pixels = (abs(xend - xpos) + 1) * (abs(yend - ypos) + 1);
	int cyclesperpixel = diff / pixels;
	diff = 0;
}

#endif
// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                 editor.cpp - EXILE editor routines                    *
// *************************************************************************

#include <windows.h>
#include <stdio.h>
#include <io.h>
#include <process.h>

#include "revenant.h"
#include "3dscene.h"
#include "directdraw.h"
#include "mappane.h"
#include "object.h"
#include "tile.h"
#include "editor.h"
#include "display.h"
#include "font.h"
#include "dls.h"
#include "chunkcache.h"
#include "playscreen.h"
#include "inventory.h"
#include "multictrl.h"
#include "command.h"
#include "cursor.h"
#include "script.h"
#include "multi.h"
#include "savegame.h"
#include "player.h"
#include "template.h"
#include "scroll.h"
#include "exit.h"
#include "textbar.h"
#include "statusbar.h"
#include "spell.h"
#include "file.h"
#include "3dimage.h"
#include "sound.h"

extern TObjectClass TileClass;
extern TObjectClass HelperClass;
extern PTBitmap PointerCursor;
//extern CBox ImageryBox;

PTMulti EditorData;
TConsolePane Console;
TScriptPane ScriptEditor;
TScrollEditorPane ScrollEditor;
TEditStatusPane StatusBar;
TEditToolsPane ToolBar;
TEditClassPane ClassPane;
PTTerrainTemplate TerrainTemplates = NULL;

HANDLE TConsolePane::cmdevents[2];    	 	// Events used by the command processor thread
int TConsolePane::cmdchar;					// Character passed to the command processor thread
char *TConsolePane::cmdline; 				// Pointer to the beginning of the command line

extern LPDIRECT3DDEVICE Device;			// Direct3D device
extern BOOL				BlitHardware;

/* enumeration of object flags */
char *objflags[] = OBJFLAGNAMES;

/* enumeration of light flags */
char *lightflags[] = { "DIR", "SUN", "MOON", NULL };

/* enumeration of container flags */
char *contflags[] = { "LOCKED", NULL };

/* general buffer for formated strings */
char buf[1024];

// Reads in handy-dandy location list
BOOL ReadMapLocationList();

// Define the strings needed for writing out CGS files
char *MakeRCInclude = {"#include \"forsaken.hgs\"\r\n\r\n"};
char *MakeRCImagery = {"IMAGERY "};
char *MakeRCBegin   = {"BEGIN\r\n"};
char *MakeRCBitmap  = {"    BITMAP "};
char *MakeRCFlags   = {"imflags ANIIM_UNLIT bmflags BM_8BIT | BM_ZBUFFER | BM_NORMALS | BM_REGPOINT | BM_COMPRESSED | BM_CHUNKED\r\n"};
char *MakeRCEnd     = {"END\r\n\r\n"};

char *RCClassDirs[] =
{
    {"Misc"},       // Item
    {"Equip"},      // Weapon
    {"Equip"},      // Armor
    {"Magic"},      // Talisman
    {"Misc"},       // Food
    {"Misc"},       // Container
    {"Misc"},       // Light Source
    {"Equip"},      // Tool
    {"Misc"},       // Money
    {""},           // Tile
    {"Misc"},       // Exit
    {"Chars"},      // Player
    {"Chars"},      // Character
    {"Misc"},       // Trap
    {"Misc"},       // Shadow
    {"Misc"},       // Helper
    {"Magic"},      // Fireball
    {"Magic"},      // Ice
    {"Magic"},      // Freeze
    {"Magic"},      // Lightning
    {"Magic"},      // Hole
    {"Equip"},      // Ammo
    {"Misc"},       // Scroll
    {"Equip"},      // Ranged Weapon
    {"Misc"}        // Effect
};

char *RCTileDirs[] =   // Directories where the different tile sets
{
    {"Misc"},
    {"Cave"},
    {"Dungeon"},
    {"Forest"},
    {"Keep"},
    {"KeepInt"},
    {"Labyrnth"},
    {"Ruin"},
    {"Swamp"},
    {"Wastelnd"},
    {"Town"},
    {"TownInt"}
};

char *RCPrefixes[] =   // Prefixes for the different tile sets
{
    {""},
    {"Cav"},
    {"Dun"},
    {"For"},
    {"Kep"},
    {"KIn"},
    {"Lab"},
    {"Run"},
    {"Swm"},
    {"Wst"},
    {"Twn"},
    {"TIn"}
};

BOOL IsSectorCommand = FALSE;

#define NUMRCDIRS sizearray(RCTileDirs)

char *sprintbit(int bits, char *enumbits[], char *buf)
{
	for (int i = 0; enumbits[i]; i++)
		if (bits & (1 << i))
			sprintf(buf, "%s %s", buf, enumbits[i]);

	return buf;
}

// Start and shut down editor
void StartEditor(BOOL starting)
{
	memset(buf, 0, 1024);

	EditorData = TMulti::LoadMulti("editor.dat");

	// Pause script processing
	TScript::PauseAllScripts();

	// Turn off full screen mode
	PlayScreen.SetFullScreen(FALSE);

	// Hide interfering panes
	Inventory.Hide();
	QuickSpells.Hide();
	HealthBar.Hide();
	StaminaBar.Hide();
	TextBar.Hide();
	MultiCtrl.Hide();

	// Console - text output
	Console.Initialize();
	PlayScreen.AddPane(&Console);

	// Status bar - handling selected objects
	StatusBar.Initialize();
	PlayScreen.AddPane(&StatusBar);

	// General toolbar - generic object and sector commands
	ToolBar.Initialize();
	PlayScreen.AddPane(&ToolBar);

	// Class pane, allows selecting of all objects in a palette
	ClassPane.Initialize();
	PlayScreen.AddPane(&ClassPane);

	// Script editor
	ScriptEditor.Initialize();
	PlayScreen.AddPane(&ScriptEditor);
	ScriptEditor.Hide();

	// General-purpose text editor
	ScrollEditor.Initialize();
	PlayScreen.AddPane(&ScrollEditor);
	ScrollEditor.Hide();

	ReadMapLocationList();

	Editor = TRUE;

	Console.Output("REVENANT ver 0.5\n");
	Console.Output("(c) 1998 Cinematix Studios, Inc.\n");
	Console.Output(PROMPT);

	NoScrollZBuffer = FALSE;
	MapPane.RedrawAll();

  // Set editor map position	
	if (starting) // If system is starting in editor, start at last saved editor position
	{
		INISetSection("Editor");
		int level = INIGetInt("Level", 0);
		S3DPoint pos;
		INIParse("Pos", "0 0 0", "%i %i %i", &pos.x, &pos.y, &pos.z);
		MapPane.SetMapLevel(level);
		MapPane.SetMapPos(pos);
	}
}

void ShutDownEditor()
{
	// Save INI stuff
	INISetSection("Editor");
	int level = MapPane.GetMapLevel();
	INISetInt("Level", level);
	S3DPoint pos;
	MapPane.GetMapPos(pos);
	INIPrint("Pos", "%d %d %d", pos.x, pos.y, pos.z);

	Console.Close();
	PlayScreen.RemovePane(&Console);

	ScriptEditor.Close();
	PlayScreen.RemovePane(&ScriptEditor);

	ScrollEditor.Close();
	PlayScreen.RemovePane(&ScrollEditor);

	StatusBar.Close();
	PlayScreen.RemovePane(&StatusBar);

	ToolBar.Close();
	PlayScreen.RemovePane(&ToolBar);

	ClassPane.Close();
	PlayScreen.RemovePane(&ClassPane);

	delete EditorData;

	Editor = FALSE;

	// Show game panes
	Inventory.Show();
	QuickSpells.Show();
	HealthBar.Show();
	StaminaBar.Show();
	TextBar.Show();
	MultiCtrl.Show();

	NoScrollZBuffer = TRUE;
	MapPane.RedrawAll();

	// Pause script processing
	TScript::ResumeAllScripts();

	// Recenter on lock (if he's in the game)
	if (Player)
		MapPane.CenterOnObj(Player, FALSE);
}

// Full-screen editing mode toggle
void StartFullScreen()
{
	Console.Hide();
	ToolBar.Hide();
	StatusBar.Hide();
	ClassPane.Hide();

	MapPane.Resize(0, 0, Display->Width(), Display->Height());

	Display->ClearBackgroundAreas();
}

void ShutDownFullScreen()
{
	Console.Show();
	ToolBar.Show();
	StatusBar.Show();
	ClassPane.Show();

	MapPane.Resize(FRAMEMAPPANEX, FRAMEMAPPANEY, FRAMEMAPPANEWIDTH, FRAMEMAPPANEHEIGHT);

	Display->ClearBackgroundAreas();
	PlayScreen.CreateBackgroundAreas();
}

#define TERRAIN_NOTHING		0
#define TERRAIN_GRASS		1
#define TERRAIN_DIRT		2
#define TERRAIN_MOUNTAIN	3
#define TERRAIN_LAKE		4
#define TERRAIN_RIVER		5
#define TERRAIN_OCEAN		6
#define TERRAIN_STREET		7

#define NUMTERRAINTYPES		8
#define TERRAINTYPESHIFT	4

#define OVERLAY_NOTHING		0
#define OVERLAY_PATH		1
#define OVERLAY_ROAD		2
#define OVERLAY_FORESTSTART	16
#define OVERLAY_FORESTEND	32

BYTE GetTerrainType(BYTE *map, int x, int y)
{
	if (x < 0 || x >= (MAXPLATESX-1) || y < 0 || y >= (MAXPLATESY-1))
		return (TERRAIN_OCEAN << TERRAINTYPESHIFT);

	return *(map + (y * MAXPLATESX) + x);
}

#define TERRAIN(dx, dy)		GetTerrainType(map, x + dx, y + dy)

int BaseTerrain(BYTE *map, int x, int y)
{
	int lowest = 1000000;

	for (int y0 = 0; y0 < 2; y0++)
		for (int x0 = 0; x0 < 2; x0++)
			if ((TERRAIN(x0, y0) & 0x0F) < lowest)
				lowest = TERRAIN(x0, y0) & 0x0F;

	return lowest;
}

int GetTileCode(BYTE *map, int x, int y)
{
	int base = BaseTerrain(map, x, y);

	long code = ((TERRAIN(0, 0) - base) << 24) | ((TERRAIN(1, 0) - base) << 16) |
				((TERRAIN(0, 1) - base)  << 8) | ((TERRAIN(1, 1) - base));

	return code;
}

#define WORLD_ZSTART		64			// the minimum z coord for generated objects

int zstart[NUMTERRAINTYPES] = { WORLD_ZSTART, 16 + WORLD_ZSTART, 16 + WORLD_ZSTART, 16 + WORLD_ZSTART,
								WORLD_ZSTART, WORLD_ZSTART - 8, 18 + WORLD_ZSTART, 16 + WORLD_ZSTART };

#define ELEVATIONCHANGE		46

int TerrainHeight(BYTE *map, int x, int y)
{
	int lowest = 1000000;
	int add;

	for (int y0 = 0; y0 < 2; y0++)
		for (int x0 = 0; x0 < 2; x0++)
			if ((TERRAIN(x0, y0) & 0x0F) < lowest)
			{
				lowest = TERRAIN(x0, y0) & 0x0F;
				add = zstart[TERRAIN(x0, y0) >> TERRAINTYPESHIFT];
			}
			else if ((TERRAIN(x0, y0) & 0x0F) == lowest)
			{
				add = min(add, zstart[TERRAIN(x0, y0) >> TERRAINTYPESHIFT]);
			}

	return (lowest * ELEVATIONCHANGE) + add;
}

struct { char ch; int code; } TerrainCodes[] = {
 { 'x', 0x00 }, { 'g', 0x10 }, { 'd', 0x20 }, { 'k', 0x11 },
 { 'i', 0x14 }, { 'm', 0x30 }, { 'r', 0x50 }, { 'o', 0x60 },
 { 0, 0 } // terminator
};

int TerrainToCode(char ch)
{
	if (ch >= 'A' && ch <= 'Z')
		ch += 'a' - 'A';

	for (int i = 0; TerrainCodes[i].ch != 0; i++)
		if (ch == TerrainCodes[i].ch)
			return TerrainCodes[i].code;

	return -1;
}

int FindSuperTile(BYTE *map, int x, int y, BYTE *filled, int *flux)
{
	if (flux)
		*flux = 0;

	for (int i = 0; i < TileClass.NumTypes(); i++)
	{
		if (TileClass.GetObjType(i) == NULL || !TileClass.GetStat(i, "supertile"))
			continue;

		int width = TileClass.GetStat(i, "width");
		int height = TileClass.GetStat(i, "height");
        char *name = TileClass.GetObjType(i)->name + 3;   // Added 3 for the "FOR" (forest) prefix

		if ((size_t)(width * height) != strlen(name))
		{
			Output("width*height != name length for supertile\n");
			continue;
		}

		int base = 1000;
		for (int y0 = 0; y0 < height; y0++)
			for (int x0 = 0; x0 < width; x0++)
				if (BaseTerrain(map, x+x0, y+y0) < base)
					base = BaseTerrain(map, x+x0, y+y0);

		BOOL qualifies = TRUE;
		for (int h = 0; h < height && qualifies; h++)
			for (int w = 0; w < width && qualifies; w++)
			{
				int code = TerrainToCode(*name++);
				if (code < 0)
				{
					Output("bad code character in supertile\n");
					continue;
				}

				if (code != (TERRAIN((w+1)/2, (h+1)/2) - base))
 					qualifies = FALSE;
			}

		if (qualifies)
		{
			for (int h = 0; h < height/2; h++)
				for (int w = 0; w < width/2; w++)
					*(filled+((x+w)*MAXPLATESY)+(y+h)) = 1;

			return i;
		}
	}

	return -1;
}

int overlay(BYTE *overmap, int x, int y)
{
	if (x < 0 || x >= MAXPLATESX || y < 0 || y >= MAXPLATESY)
		return OVERLAY_NOTHING;

	return *(overmap+(y*MAXPLATESX)+x);
}

#define OVERLAY(dx, dy) (overlay(overmap, x+(dx), y+(dy)))

int GetOverlayTile(BYTE *overmap, int x, int y, int code)
{
	if (OVERLAY(0, 0) == OVERLAY_PATH)
	{
		char pathname[80] = "path";

		if (code == 0x10101010)
		{
			if (OVERLAY(0, -1) == OVERLAY_PATH)
				strcat(pathname, "N");
			if (OVERLAY(1, 0) == OVERLAY_PATH)
				strcat(pathname, "E");
			if (OVERLAY(0, 1) == OVERLAY_PATH)
				strcat(pathname, "S");
			if (OVERLAY(-1, 0) == OVERLAY_PATH)
				strcat(pathname, "W");
		}
		else if (code == 0x20102010 && OVERLAY(1, 0) == OVERLAY_PATH)
			strcat(pathname, "BE");
		else if (code == 0x20201010 && OVERLAY(0, 1) == OVERLAY_PATH)
			strcat(pathname, "BS");
		else if (code == 0x10201020 && OVERLAY(-1, 0) == OVERLAY_PATH)
			strcat(pathname, "BW");
		else if (code == 0x10102020 && OVERLAY(0, -1) == OVERLAY_PATH)
			strcat(pathname, "BN");

		return TileClass.FindObjType(pathname);
	}

	return -1;
}

PTObjectInstance GenerateObj(PTSector sect, BYTE *map, BYTE *overmap, int type, int x, int y, int px, int py, int flux = 0)
{
	PTObjectInstance inst;
	SObjectDef def;

	memset(&def, 0, sizeof(SObjectDef));
	def.objclass = OBJCLASS_TILE;

	int tx = (x * PLATESPERSECTX) + px;
	int ty = (y * PLATESPERSECTY) + py;
	int tmp = GetOverlayTile(overmap, tx, ty, TileClass.GetStat(type, "Code"));
	if (tmp >= 0)
		type = tmp;

	def.objtype = type;
	def.flags = OF_GENERATED;
	def.pos.x = (x * SECTORWIDTH) + (px * PLATEWIDTH) + (PLATEWIDTH >> 1);
	def.pos.y = (y * SECTORHEIGHT) + (py * PLATEHEIGHT) + (PLATEHEIGHT >> 1);
	def.pos.z = TerrainHeight(map, (x * PLATESPERSECTX) + px, (y * PLATESPERSECTY) + py) - (flux * ELEVATIONCHANGE);
	def.level = sect->SectorLevel();

	inst = TObjectClass::GetClass(def.objclass)->NewObject(&def);
	if (!inst)
		return NULL;

	sect->AddObject(inst);

	int code = TileClass.GetStat(def.objtype, "Extra");

	if (code != 0xFFFFFFFF)
	{
		int nexttype = TileClass.FindRandStatVal(TileClass.FindStat("Code"), code);
		def.pos.z += (flux * ELEVATIONCHANGE);
		GenerateObj(sect, map, overmap, nexttype, x, y, px, py);
	}

	int over = overlay(overmap, tx, ty);
//	if (over >= OVERLAY_FORESTSTART && over < OVERLAY_FORESTEND)
		TerrainTemplates->ApplyTemplate(inst, sect, random(0, 10));//over - OVERLAY_FORESTSTART + 1);

	return inst;
}

#define QUAD(c, q)	(((c) >> ((q) * 8)) & 0xFF)

void GenerateMap(int startx, int starty, int sizex, int sizey)
{
	TObjectImagery::PauseLoader(); // NOTE: if resume isn't called, program will lock

	PTSector sect;
	BYTE filled[MAXPLATESX][MAXPLATESY];
	int x, y, px, py;
	FILE *fp;

	memset(filled, 0, MAXPLATESX*MAXPLATESY);

	if ((fp = popen("map.bmp", "r")) == NULL)
	{
		TObjectImagery::ResumeLoader();
		return;
	}

	BYTE *map = new BYTE[MAXPLATESX*MAXPLATESY];
	fread(map, 14, 1, fp);
	x = *((int *)(map + 10));
	fseek(fp, x, SEEK_SET);
	// fuckin' upsidedown bitmaps...
	for (y = MAXPLATESY-1; y >= 0; y--)
		fread(map+(y*MAXPLATESX), MAXPLATESX, 1, fp);
	fclose(fp);

	if ((fp = popen("overmap.bmp", "r")) == NULL)
	{
		TObjectImagery::ResumeLoader();
		return;
	}

	BYTE *overmap = new BYTE[MAXPLATESX*MAXPLATESY];
	fread(overmap, 14, 1, fp);
	x = *((int *)(overmap + 10));
	fseek(fp, x, SEEK_SET);
	for (y = MAXPLATESY-1; y >= 0; y--)
		fread(overmap+(y*MAXPLATESX), MAXPLATESX, 1, fp);
	fclose(fp);

	MapPane.FreeAllSectors();

	for (int sy = starty; sy < (starty + sizey); sy++)
		for (int sx = startx; sx < (startx + sizex); sx++)
		{
			sect = new TSector(0, sx, sy);
			sect->Load();

			for (TObjectIterator i(sect->ObjectArray()); i; i++)
				if (i.Item() && i.Item()->GetFlags() & OF_GENERATED)
					sect->ObjectArray()->Remove(i);

			for (py = 0; py < PLATESPERSECTY; py++)
				for (px = 0; px < PLATESPERSECTX; px++)
				{
					x = (sx * PLATESPERSECTX) + px;
					y = (sy * PLATESPERSECTY) + py;

					if (filled[x][y] != 0)
						continue;

					int type, flux = 0;
					if ((type = FindSuperTile(map, x, y, &(filled[0][0]), &flux)) < 0)
					{
						DWORD code = GetTileCode(map, x, y);

						// leave out the 'center' of the mountains
						if ((code & 0xF0F0F0F0) == 0x30303030)
							continue;

						// use solid street tile for anything containing street
						for (int i = 0; i < 4; i++)
							if (QUAD(code, i) == 0x70)
								code = 0x70707070;


						if ((type = TileClass.FindRandStatVal(TileClass.FindStat("Code"), code, NULL)) < 0 &&
							(type = TileClass.FindRandStatVal(TileClass.FindStat("Code"), code, &flux)) < 0)
							continue;

						PTObjectInstance inst = GenerateObj(sect, map, overmap, type, sx, sy, px, py, flux);

						if (!inst)
							continue;

						DWORD oldcode = TileClass.GetStat(inst->ObjType(), "Code");

						// build a mask based on the wildcards in the code
						DWORD newcode = 0;
						if (!QUAD(oldcode, 3))
							newcode |= code & 0xFF000000;
						if (!QUAD(oldcode, 2))
							newcode |= code & 0xFF0000;
						if (!QUAD(oldcode, 1))
							newcode |= code & 0xFF00;
						if (!QUAD(oldcode, 0))
							newcode |= code & 0xFF;

						if (newcode != 0)
						{
							if (!QUAD(newcode, 0))
								if (QUAD(newcode, 1))
									newcode |= QUAD(newcode, 1);
								else if (QUAD(newcode, 2))
									newcode |= QUAD(newcode, 2);
								else
									newcode |= QUAD(newcode, 3);

							if (!QUAD(newcode, 1))
								if (QUAD(newcode, 0))
									newcode |= QUAD(newcode, 0) << 8;
								else if (QUAD(newcode, 3))
									newcode |= QUAD(newcode, 3) << 8;
								else
									newcode |= QUAD(newcode, 2) << 8;

							if (!QUAD(newcode, 2))
								if (QUAD(newcode, 0))
									newcode |= QUAD(newcode, 0) << 16;
								else if (QUAD(newcode, 3))
									newcode |= QUAD(newcode, 3) << 16;
								else
									newcode |= QUAD(newcode, 1) << 16;

							if (!QUAD(newcode, 3))
								if (QUAD(newcode, 1))
									newcode |= QUAD(newcode, 1) << 24;
								else if (QUAD(newcode, 2))
									newcode |= QUAD(newcode, 2) << 24;
								else
									newcode |= QUAD(newcode, 0) << 24;

							flux = 1000;
							for (int i = 0; i < 4; i++)
								if ((QUAD(newcode, i) & 0x0F) < (DWORD)flux)
									flux = QUAD(newcode, i) & 0x0F;

							for (i = 0; i < 4; i++)
								newcode -= flux << (i * 8);

							if ((type = TileClass.FindRandStatVal(TileClass.FindStat("Code"), newcode)) < 0)
								continue;

							flux *= -1;
						}
						else
							continue;
					}

					GenerateObj(sect, map, overmap, type, sx, sy, px, py, flux);
				}

			delete sect;
		}

	delete map;
	delete overmap;

	TObjectImagery::ResumeLoader();

	MapPane.ReloadSectors();
}

// *************
// * TTextPane *
// *************

#define TEXTPANE_LINESPACE 2

BOOL TTextPane::Initialize()
{
	textlen   = 0;
	curstartx = 0;
	curstarty = 0;
	windowx = windowy = 0;
	cursorx = cursory = 0;
	curwidth = winwidth = 60;
	curheight = winheight = GetHeight() / (SystemFont->height + TEXTPANE_LINESPACE);
	wrapwidth = -1;

	SetDirty(TRUE);
	offset = curoffset = 0;
	text = new char[TEXTBUFSIZE];
	text[0] = CURSOR;					// set cursor to start
	text[1] = 0;						// null terminate the buffer
	memset(text, 0, TEXTBUFSIZE);

	return TRUE;
}

void TTextPane::Close()
{
	delete text;
}

void TTextPane::DrawBackground()
{
	if (IsDirty())
	{
		Display->Box(0, 0, GetWidth(), GetHeight(), 0, 0xffff, 0, DM_BACKGROUND);
		Display->WriteText(text+offset, 0, 0, winheight, SystemFont, NULL, DM_USEDEFAULT, 
			wrapwidth, 0, JUSTIFY_LEFT, -1, TEXTPANE_LINESPACE);
		SetDirty(FALSE);
	}
}

// a couple of utility functions for the text processing
inline isvalid(int key)
{
	if (((key >= ' ' && key <= '~') || key == '\n') && key != '`' && !CtrlDown && !AltDown)
		return TRUE;

	return FALSE;
}

int endofline(char *text)
{
	int x, count;

	for (x = 0, count = 0; text[x] && text[x] != '\n'; x++)
		if (text[x] != CURSOR)
			count++;

	return count;
}

BOOL TTextPane::InsertText(char *newtext)
{
	textlen = strlen(text);
	int newlen = strlen(newtext);

	if (newlen == 0)
		return TRUE;

	if ((textlen + newlen + 1) >= TEXTBUFSIZE)
		return FALSE;

	// bump old text forwards (+1 for cursor character)
	memmove(text + curoffset + 1 + newlen, text + curoffset + 1, textlen - curoffset);

	// copy in new text
	memmove(text + curoffset, newtext, newlen);

	// set cursor to the end of new text
	curoffset += newlen;
	text[curoffset] = CURSOR;

	// compute new x and y values
	char *ptr = newtext;
	while ((ptr = strchr(ptr, '\n')))
	{
		cursorx = 0;
		cursory++;
		newtext = ++ptr;
	}

	cursorx += strlen(newtext);

	textlen += newlen;

	UpdateWindow();
	Update();

	return TRUE;
}

BOOL TTextPane::RemoveText(int numchars, BOOL forward)
{
	textlen = strlen(text);

	if (!forward && numchars > (cursorx - curstartx))
		numchars = cursorx - curstartx;

	if (numchars < 0)
		return FALSE;

	if ((textlen - numchars) < 1)			// always at least one char (the cursor)
		numchars = textlen - 1;

	if (forward)
		memmove(text + curoffset + 1, text + curoffset + 1 + numchars, textlen - curoffset - numchars + 1);
	else
	{
		memmove(text + curoffset - numchars, text + curoffset, textlen - curoffset + 1);
		curoffset -= numchars;
		cursorx -= numchars;
	}


	return TRUE;
}

char *TTextPane::GetText(int start, int len, char *buf)
{
	textlen = strlen(text);

	if (start >= textlen)
		return NULL;

	strncpy(buf, text + start, len);
	buf[len] = NULL;

	return buf;
}

void TTextPane::UpdateWindow()
{
	while (cursory < windowy)
	{
		while (offset > 0 && text[--offset] != '\n')
			;

		while (offset > 0 && text[offset - 1] != '\n')
			offset--;

		windowy--;
	}

	while (cursory >= windowy + winheight)
	{
		offset += endofline(text + offset);
		if (text[offset])
			offset++;
		windowy++;
	}
}

BOOL TTextPane::SetCursor(int nx, int ny, BOOL ignorebounds)
{
	// do some quick bounds checking
	if (!ignorebounds)
	{
		if (nx < curstartx)
			nx = curstartx;
#if 0
		else if (nx >= curstartx + curwidth)
			nx = curstartx + curwidth - 1;
#endif

		if (ny < curstarty)
			ny = curstarty;
		else if (ny >= curstarty + curheight)
			ny = curstarty + curheight - 1;
	}

	// update needed?
	if (nx == cursorx && ny == cursory)
		return FALSE;

	// remove old cursor
	memmove(text + curoffset, text + curoffset + 1, strlen(text + curoffset));

	// compute new cursor position and update curoffset
	curoffset = 0;
	int x, y;

	for (y = 0; y < ny; y++, x = 0)
	{
		for ( ; text[curoffset] != '\n'; curoffset++, x++)
			if (!text[curoffset])
			{
				// uh oh...new cursor position is invalid
				ny = y;
				nx = x;
				goto insertcursor;		// get ALL the way out
			}
		curoffset++;
	}

	for (x = 0; x < nx; x++, curoffset++)
		if (!text[curoffset] || text[curoffset] == '\n')
		{
			// invalid x position
			nx = x;
			break;
		}

  insertcursor:
	memmove(text + curoffset + 1, text + curoffset, strlen(text) - curoffset + 1);
	text[curoffset] = CURSOR;

	// adjust in case curoffset is less than offset (cursor character was inserted)
	if (curoffset < offset)
		offset++;
	cursorx = nx;
	cursory = ny;
	UpdateWindow();

	return TRUE;
}

void TTextPane::KeyPress(int key, BOOL down)
{
	SObjectDef def;

	TPane::KeyPress(key, down);

	if (down)
	{
		switch (key)
		{
		  case VK_BACK:
			SetDirty(RemoveText(1, FALSE));		// remove 1 char backwards
			break;
		  case VK_DELETE:
			SetDirty(RemoveText(1, TRUE));		// remove 1 char forwards
			break;
		  case VK_UP:
			SetDirty(SetCursor(cursorx, cursory - 1));
			break;
		  case VK_DOWN:
			SetDirty(SetCursor(cursorx, cursory + 1));
			break;
		  case VK_LEFT:
			SetDirty(SetCursor(CtrlDown ? cursorx - 6 : cursorx - 1, cursory));
			break;
		  case VK_RIGHT:
			SetDirty(SetCursor(CtrlDown ? cursorx + 6 : cursorx + 1, cursory));
			break;
		  case VK_HOME:
			SetDirty(SetCursor(0, cursory));
			break;
		  case VK_END:
			SetDirty(SetCursor(cursorx + endofline(text+curoffset), cursory));
			break;
		  case VK_PRIOR:
			SetDirty(SetCursor(cursorx, cursory - winheight));
			break;
		  case VK_NEXT:
			SetDirty(SetCursor(cursorx, cursory + winheight));
			break;
		  case VK_TAB:
			//SetDirty(Input("  "));
			break;
		  case 'Y':
		  case 'y':
			if (CtrlDown)
			{
				int tmpx = cursorx;
				SetCursor(0, cursory);
				RemoveText(endofline(text+curoffset) + 1, TRUE);
				SetCursor(tmpx, cursory);
				SetDirty(TRUE);
			}
			break;
		}
	}
}

void TTextPane::CharPress(int key, BOOL down)
{
	TPane::CharPress(key, down);

	if (down)
	{
		if (key == '\r')
			key = '\n';		// Turn a return into a linefeed

		char keybuf[2];
		keybuf[0] = key;
		keybuf[1] = 0;

		if (isvalid(key))
			SetDirty(Input(keybuf));
	}
}

// ****************
// * TConsolePane *
// ****************

BOOL TConsolePane::Initialize()
{
	TTextPane::Initialize();

	curstartx = strlen(PROMPT);
	curheight = 1;
	head = tail = chained = NULL;

	box = axis = NULL;

	wrapwidth = GetWidth();

	// Create the kill event
	if ((cmdevents[KILL_EVENT] = CreateEvent(NULL, TRUE, FALSE, NULL)) == NULL)
		FatalError("Could not create kill event for command processor!");

	// Create the character available event
	if ((cmdevents[CHAR_AVAILABLE_EVENT] = CreateEvent(NULL, TRUE, FALSE, NULL)) == NULL)
		FatalError("Could not create character event for command processor!");

	// Begin the Command Processor thread
	unsigned threadid; // Dummy id handle
	cmdthreadhandle = (HANDLE)_beginthreadex(
		NULL, 0,
		TConsolePane::CommandThread,
		(void *)this, TRUE,
        &threadid );

	SetThreadPriority(cmdthreadhandle, THREAD_PRIORITY_ABOVE_NORMAL);

	return TRUE;
}

void TConsolePane::Close()
{
	// Trigger the Kill event and wait for the command processor thread to close
	SetEvent(cmdevents[KILL_EVENT]);
	WaitForSingleObject(cmdthreadhandle, INFINITE);

	// Close the events
	CloseHandle(cmdevents[CHAR_AVAILABLE_EVENT]);
	CloseHandle(cmdevents[KILL_EVENT]);
}

void TConsolePane::SetupMouseBitmap(int xspan, int yspan)
{
	if (xspan && yspan)
		SetMouseBitmap(PointerCursor);

	if (xspan && yspan == 0)
		SetMouseBitmap(EditorData->Bitmap("lrarrow"));

	if (yspan && xspan == 0)
		SetMouseBitmap(EditorData->Bitmap("udarrow"));
}

void TConsolePane::ChainMouse(void (*cfunc)(int, int), int x0, int x1, int xcur,
													   int y0, int y1, int ycur)
{
	// max sure values are in the right order
	if (x1 < x0)
	{
		int tmp = x0;
		x0 = x1;
		x1 = tmp;
	}
	if (y1 < y0)
	{
		int tmp = y0;
		y0 = y1;
		y1 = tmp;
	}

	// set up the vars
	PSChained c = new SChained;
	c->func = cfunc;
	c->xmin = x0;
	c->xspan = x1 - x0;
	c->ymin = y0;
	c->yspan = y1 - y0;
	c->oldxval = xcur;
	c->oldyval = ycur;

	// add to the end of the list
	c->prev = tail;
	c->next = NULL;

	if (tail)
		tail->next = c;
	else
	{
		head = chained = c;
		oldbuflen = 0;
		oldcx = x0 + 1;
		oldcy = y0 + 1;

		SetupMouseBitmap(c->xspan, c->yspan);
		PlayScreen.SetExclusivePane(&Console);
	}

	tail = c;
}

void TConsolePane::SetBounds()
{
	PTObjectInstance inst = MapPane.GetInstance(StatusBar.GetSelectedObj());
	if (!inst)
		return;

	SObjectDef def;
	memset(&def, 0, sizeof(SObjectDef));
	def.objclass = OBJCLASS_HELPER;
	def.objtype = HelperClass.FindObjType("box");
	inst->GetPos(def.pos);

	if (def.objtype < 0)
		return;

	box = MapPane.GetInstance(MapPane.NewObject(&def));
	if (!box)
		return;

	int w, l, h;
	inst->GetImagery()->GetWorldBoundBox(inst->GetState(), w, l, h);
	box->GetImagery()->SetWorldBoundBox(box->GetState(), w << WALKMAPSHIFT, l << WALKMAPSHIFT, h << WALKMAPSHIFT);

	int x = inst->GetImagery()->GetWorldRegX(inst->GetState());
	int y = inst->GetImagery()->GetWorldRegY(inst->GetState());
	int z = inst->GetImagery()->GetWorldRegZ(inst->GetState());
	box->GetImagery()->SetWorldReg(box->GetState(), x << WALKMAPSHIFT, y << WALKMAPSHIFT, z << WALKMAPSHIFT);

	PlayScreen.SetExclusivePane(this);

	sprintf(buf, "offset: (%d, %d, %d)  size: (%d, %d, %d)", x, y, z, w, l, h);
	Output(buf);
}

BOOL TConsolePane::AddAxis(PTObjectInstance inst)
{
	SObjectDef def;
	memset(&def, 0, sizeof(SObjectDef));
	def.objclass = OBJCLASS_HELPER;
	def.objtype = HelperClass.FindObjType("axis");
	inst->GetPos(def.pos);
	def.level = MapPane.GetMapLevel();

	if (def.objtype < 0)
		return FALSE;

	axis = MapPane.GetInstance(MapPane.NewObject(&def));

	return (axis != NULL);
}

void TConsolePane::ClearAxis()
{
	if (axis)
	{
		PTObjectInstance oi = MapPane.GetInstance(axis->GetMapIndex());
		if (oi) MapPane.DeleteObject(oi);
		axis = NULL;
	}
}

void TConsolePane::KeyPress(int key, BOOL down)
{
	TTextPane::KeyPress(key, down);

	if (box && down)
	{
		PTObjectInstance inst;

		int width, length, height;
		box->GetImagery()->GetWorldBoundBox(box->GetState(), width, length, height);

		int x = box->GetImagery()->GetWorldRegX(box->GetState());
		int y = box->GetImagery()->GetWorldRegY(box->GetState());
		int z = box->GetImagery()->GetWorldRegZ(box->GetState());

		int w, l, h;
		w = l = h = 0;

		switch (key)
		{
		  case VK_UP:
			l -= 1;
			break;
		  case VK_PRIOR:
			l -= 1;
			w += 1;
			break;
		  case VK_RIGHT:
			w += 1;
			break;
		  case VK_NEXT:
			l += 1;
			w += 1;
			break;
		  case VK_DOWN:
			l += 1;
			break;
		  case VK_END:
			l += 1;
			w -= 1;
			break;
		  case VK_LEFT:
			w -= 1;
			break;
		  case VK_HOME:
			l -= 1;
			w -= 1;
			break;
		  case VK_INSERT:
			h += 1;
			break;
		  case VK_DELETE:
			h -= 1;
			break;

		  case VK_ESCAPE:
			if (box)
			{
				if (box->GetImagery())
				{
					box->GetImagery()->SetWorldReg(box->GetState(), 0, 0, 0);
					box->GetImagery()->SetWorldBoundBox(box->GetState(), 0, 0, 0);
					box->GetImagery()->SetHeaderDirty(FALSE);
				}

				PTObjectInstance oi = MapPane.GetInstance(box->GetMapIndex());
				if (oi) MapPane.DeleteObject(oi);
				box = NULL;
			}

			inst = MapPane.GetInstance(StatusBar.GetSelectedObj());
			if (inst)
			{
				inst->GetImagery()->SetWorldReg(inst->GetState(), x >> WALKMAPSHIFT, y >> WALKMAPSHIFT, z >> WALKMAPSHIFT);
				inst->GetImagery()->SetWorldBoundBox(inst->GetState(), width >> WALKMAPSHIFT, length >> WALKMAPSHIFT, height >> WALKMAPSHIFT);
			}

			PlayScreen.ReleaseExclusivePane(this);

			Output("\n");
			Output(PROMPT);

			return;

		  default:
			return;
		}

		l *= (1 << WALKMAPSHIFT);
		w *= (1 << WALKMAPSHIFT);
		h *= (1 << WALKMAPSHIFT);

		if (CtrlDown)
		{
			x = max(0, x - w);
			y = max(0, y - l);
			z = max(0, z - h);
			box->GetImagery()->SetWorldReg(box->GetState(), x, y, z);
		}
		else
		{
			width  = max(0, width + w);
			length = max(0, length + l);
			height = max(0, height + h);
			box->GetImagery()->SetWorldBoundBox(box->GetState(), width, length, height);
		}

		sprintf(buf, "offset: (%d, %d, %d)  size: (%d, %d, %d)", x >> WALKMAPSHIFT, y >> WALKMAPSHIFT, z >> WALKMAPSHIFT, width >> WALKMAPSHIFT, length >> WALKMAPSHIFT, height >> WALKMAPSHIFT);
		SetCursor(0, cursory);
		RemoveText(endofline(text+curoffset) + 1, TRUE);
		Output(buf);
	}
}

void TConsolePane::CharPress(int key, BOOL down)
{
	TTextPane::CharPress(key, down);

	// Flag the command processor thread that a key has been typed
	// Unless the key is a Return (Returns are signaled in Input() which is called
	// by the TTextPane::CharPress())
	if (key != '\r')
	{
		cmdchar = key;
		SetEvent(cmdevents[CHAR_AVAILABLE_EVENT]);
	}
}

void TConsolePane::MouseMove(int button, int x, int y)
{
	if (chained)
	{
		cx = ((cursorx * chained->xspan) / Display->Width()) + chained->xmin;
		cy = ((cursory * chained->yspan) / Display->Height()) + chained->ymin;
	}
}

void TConsolePane::MouseClick(int button, int x, int y)
{
	if (chained)
	{
		if (button == MB_LEFTUP)
		{
			chained = chained->next;
			if (chained)
			{
				oldbuflen = 0;
				oldcx = chained->xspan + chained->xmin + 1;
				oldcy = chained->yspan + chained->ymin + 1;
				Console.Output(" ");
				SetupMouseBitmap(chained->xspan, chained->yspan);
				return;
			}
			else
			{
				// list traversal complete, nuke the list
				while (head)
				{
					PSChained tmp = head->next;
					delete head;
					head = tmp;
				}
				chained = head = tail = NULL;
				Console.Input("\n");			// send the command
			}
		}
		else if (button == MB_RIGHTUP)
		{
			// reset to default values and nuke the list
			while (head)
			{
				PSChained tmp = head->next;
				(*(head->func))(head->oldxval, head->oldyval);
				delete head;
				head = tmp;
			}
			Console.Output("\n");
			Console.Output(PROMPT);
		}
		else
			return;

		chained = head = tail = NULL;
		SetMouseBitmap(PointerCursor);
		PlayScreen.ReleaseExclusivePane(&Console);
		StatusBar.StopMoving();
	}
}

void TConsolePane::DrawBackground()
{
	TTextPane::DrawBackground();

	if (chained && (cx != oldcx || cy != oldcy))
	{
		RemoveText(oldbuflen, FALSE);

		if (chained->xspan)
		{
			if (chained->yspan)
				sprintf(buf, "(%d, %d)", cx, cy);
			else
				itoa(cx, buf, 10);

			(*(chained->func))(cx, cy);
		}
		else
		{
			itoa(cy, buf, 10);

			(*(chained->func))(cy, cx);
		}

		InsertText(buf);

		oldbuflen = strlen(buf);
		oldcx = cx;
		oldcy = cy;
	}
}

BOOL TConsolePane::Input(char *string)
{
	char tmpbuf[256];
	char *ptr = string;

	// check for paging
	if (strlen(text)+strlen(string) >= TEXTBUFSIZE)
	{/*
		int newoffset = offset - (TEXTBUFSIZE / 4);
		while (text[newoffset++] != '\n')
			if (newoffset >= offset)
			{
				newoffset = offset - (TEXTBUFSIZE / 4);
				break;
			}

		memmove(text, text + (TEXTBUFSIZE / 4), newoffset);
		memset(text + (TEXTLEN - newoffset), 0, newoffset);
		curoffset -= newoffset - offset;
		offset = newoffset;*/
	}

	// console needs to process each line individually
	while ((ptr = strchr(ptr, '\n')))
	{
		char *textoff = string;
		for (int i = 0; *textoff && *textoff != '\n' && i < 255; textoff++, i++)
			tmpbuf[i] = *textoff;
		tmpbuf[i] = 0;

		SetCursor(cursorx + endofline(text + curoffset), cursory, TRUE);
		InsertText(tmpbuf);
		InsertText("\n");

		// find the current input line in the buffer
		SetCursor(curstartx, cursory - 1, TRUE);
		textoff = text + curoffset + 1;

		SetCursor(0, cursory + 1, TRUE);
		curstarty++;

		if (*ptr)
			ptr++;
		string = ptr;

		// Flag the command processor thread that a line has been entered
		cmdchar = '\r';
		SetEvent(cmdevents[CHAR_AVAILABLE_EVENT]); // This causes the command thread to run

	  // Command processed, now reset the command line pointer to end of buffer
		cmdline = text + curoffset;
	}

	InsertText(string);

	return TRUE;
}

BOOL TConsolePane::Output(char *string)
{
	char *ptr = string;

	while ((ptr = strchr(ptr, '\n')))
	{
		curstarty++;
		ptr++;
	}

	BOOL dirty = InsertText(string);

  // Sending text to output resets beginning of current command line
	cmdline = text + curoffset;

	return dirty;
}

// This cannot be called from the main thread
int TConsolePane::GetChar()
{
	DWORD wait;

	wait = WaitForMultipleObjects(2, cmdevents, FALSE, INFINITE);

	if (wait != WAIT_OBJECT_0 + 1)
		return -1;

	ResetEvent(cmdevents[CHAR_AVAILABLE_EVENT]);

	return cmdchar;
}

// This cannot be called from the main thread
BOOL TConsolePane::GetLine(char *buffer, int buffersize)
{
	int key;

	// Wait until they enter a character
	while((key = GetChar()) != -1)
	{
		// See if they just pressed return to end a line
		if (key == '\r')
		{
			char *textoff = cmdline;
			if (!textoff)
				continue;

			if (strchr(textoff, '\n') != NULL)
			{
				// Copy the line to the buffer passed in
				for (int i = 0; *textoff && *textoff != '\n' && i < buffersize - 1; textoff++, i++)
					buffer[i] = *textoff;
				buffer[i] = 0;

				return TRUE;
			}
		}

	}

	return FALSE;
}

unsigned _stdcall TConsolePane::CommandThread(void *arg)
{
	PTConsolePane console = (PTConsolePane)arg;
	char tmpbuf[256];

	while (console->GetLine(tmpbuf, 256))
	{
	   	TStringParseStream s(tmpbuf, strlen(tmpbuf));
		TToken t(s);
		DWORD pos = s.GetPos();
		t.Get();

		if (StatusBar.GetSelectedObj() < 0)
			CommandInterpreter(NULL, t, MINCMDABREV);
		else
		{
			int list[MAXSELECTEDOBJS];
			int j = 0;

			// make a copy in case one of the commands corrupts the list
			for (int i = StatusBar.GetFirstObj(); i >= 0; i = StatusBar.GetNextObj())
				list[j++] = i;

			for (int n = 0; n < j; n++)
			{
				PTObjectInstance inst = MapPane.GetInstance(list[n]);
				if (inst)
					CommandInterpreter(inst, t, MINCMDABREV);

				s.SetPos(pos);
				t.Get();
			}
		}

		StatusBar.Validate();
		StatusBar.SetDirty(TRUE);

		if (console->cursorx != 0)				// make sure we're on a new line
			console->Output("\n");
		console->Output(PROMPT);
	}

	_endthreadex(0);

	return 0;
}

// ***************
// * TScriptPane *
// ***************

BOOL TScriptPane::Initialize()
{
	TTextPane::Initialize();
	inst = NULL;
	return TRUE;
}

void TScriptPane::LoadScript(PTObjectInstance oi)
{
	inst = oi;
	strcpy(text, ScriptManager.ObjectScript(oi)->Text());
	cursorx = windowx = cursory = windowy = offset = curoffset = 0;
}

void TScriptPane::SaveScript()
{
	if (inst && inst->GetScript())
	{
		// get rid of the cursor
		for (char *ptr = text; *ptr; )
			if (*ptr == CURSOR)
				memmove(ptr, ptr+1, strlen(ptr+1)+1);
			else
				ptr++;

		inst->GetScript()->SetText(text);
	}
}

void TScriptPane::KeyPress(int key, BOOL down)
{
	TTextPane::KeyPress(key, down);

	if (down)
	{
		switch (key)
		{
		  case VK_ESCAPE:
			SaveScript();
			PlayScreen.ReleaseExclusivePane(this);
			this->Hide();
			Console.Show();
			break;
		}
	}
}

// *********************
// * TScrollEditorPane *
// *********************

BOOL TScrollEditorPane::Initialize()
{
	TTextPane::Initialize();
	scroll = NULL;
	wrapwidth = GetWidth();
	return TRUE;
}

void TScrollEditorPane::SetScroll(PTObjectInstance s)
{
	scroll = (PTScroll)s;

	cursorx = windowx = cursory = windowy = offset = curoffset = 0;

	if (scroll && scroll->GetText())
		InsertText(scroll->GetText());
}

void TScrollEditorPane::SaveText()
{
	if (scroll)
	{
		// get rid of the cursor
		for (char *ptr = text; *ptr; )
			if (*ptr == CURSOR)
				memmove(ptr, ptr+1, strlen(ptr+1)+1);
			else
				ptr++;

		scroll->SetText(text);
	}
}

void TScrollEditorPane::KeyPress(int key, BOOL down)
{
	TTextPane::KeyPress(key, down);

	if (down)
	{
		switch (key)
		{
		  case VK_ESCAPE:
			SaveText();
			PlayScreen.ReleaseExclusivePane(this);
			this->Hide();
			Console.Show();
			break;
		}
	}
}

// ***************************
// * Various Editor Commands *
// ***************************

COMMAND(CmdSelect)
{
	if (t.Is("next"))
	{
		if (!StatusBar.Next())
			Output("Already at end of selection list.\n");
		return 0;
	}
	else if (t.Is("prev"))
	{
		if (!StatusBar.Prev())
			Output("Already at start of selection list.\n");
		return 0;
	}
	else if (t.Is("all"))
	{
		for (TMapIterator i; i; i++)
		{
			if (!StatusBar.Select(i.Item()->GetMapIndex(), TRUE))
			{
				Output("Selection overflowed, max objects selected.\n");
				break;
			}
		}

		return 0;
	}

	if (t.Type() == TKN_NUMBER)
	{
		// make the index number specified the current object
		int index;
		if (!Parse(t, "%d", &index))
			return CMD_BADPARAMS;

		if (!StatusBar.SetCurObj(index))
			Output("Invalid selection index.\n");

		return 0;
	}

	PTObjectInstance inst = MapPane.FindClosestObject(t.Text(), NULL, TRUE);

	if (!inst)
		Output("Can't find any object by that name.\n");
	else if (!StatusBar.Select(inst->GetMapIndex()))
		Output("Unable to select any more objects.\n");

	t.WhiteGet();
	return 0;
}

COMMAND(CmdDeselect)
{
	if (t.Is("all"))
		while (StatusBar.Deselect());
	else
		if (!StatusBar.Deselect())
			Output("Nothing to deselect.\n");

	t.WhiteGet();
	return 0;
}

COMMAND(CmdAdd)
{
	int objtype = -1;
	int number = 1;

	S3DPoint pos;
	MapPane.GetMapPos(pos);
	if (t.Type() == TKN_NUMBER)
	{
		if (!Parse(t, "%i %i %i", &pos.x, &pos.y, &pos.z))
			return CMD_BADPARAMS;
	}

	if (t.Type() == TKN_NUMBER)
	{
		number = t.Index();
		t.WhiteGet();
	}

	if (t.Is("next"))
	{
		S3DPoint zero;
		memset(&zero, 0, sizeof(S3DPoint));
		ClassPane.SelObjType(ClassPane.GetObjType() + 1);
		ClassPane.PutObject(zero);
		t.WhiteGet();
		return 0;
	}
	else if (t.Is("prev"))
	{
		S3DPoint zero;
		memset(&zero, 0, sizeof(S3DPoint));
		ClassPane.SelObjType(ClassPane.GetObjType() - 1);
		ClassPane.PutObject(zero);
		t.WhiteGet();
		return 0;
	}
	else if (t.Is("light", 1))
	{
		SObjectDef def;
		int intensity = 220, mult = 12;
		memset(&def, 0, sizeof(SObjectDef));

		def.objclass = OBJCLASS_TILE;
		def.objtype = TileClass.FindObjType("light");
        def.flags = OF_LIGHT | OF_EDITOR;

		def.pos = pos;
		def.pos.z = 60;
		def.level = MapPane.GetMapLevel();

		//t.WhiteGet();
		//if (!Parse(t, "<%d> <%d>", &intensity, &mult))
		//	return CMD_BADPARAMS;

		int index = MapPane.NewObject(&def);
		if (index < 0)
			Output("ERROR: Unable to add light\n");
		else
		{
			SColor color = { 255, 255, 255 };
			MapPane.GetInstance(index)->SetLightIntensity(intensity);
			MapPane.GetInstance(index)->SetLightColor(color);
			MapPane.GetInstance(index)->SetLightMultiplier(mult);

			S3DPoint lightpos(0, 0, 0);
			MapPane.GetInstance(index)->SetLightPos(lightpos);
			StatusBar.Select(index);
		}
	}
	else
	{
		PTObjectClass cl = TObjectClass::GetClass(TObjectClass::FindClass(t.Text()));

		if (cl)
		{
			t.WhiteGet();

			if (t.Is("type"))
			{
				t.WhiteGet();

				// Add a new type to this class
				char buf2[80];
				if (!Parse(t, "%s %s", buf, buf2))  // name, filename
					return CMD_BADPARAMS;

				objtype = cl->AddType(buf, buf2);
				if (objtype < 0)
					Output("ERROR: Adding object type\n");
				else
				{
					Output("New type %s added to class %s.\n", buf, cl->ClassName());
				}
			}
			else if (t.Is("stat"))
			{
				t.WhiteGet();

				if (!cl->ParseNewStat(t))
					return CMD_BADPARAMS;

				Output("Stat added.");
			}
			else if (t.Is("objstat"))
			{
				t.WhiteGet();

				if (!cl->ParseNewObjStat(t))
					return CMD_BADPARAMS;

				Output("Object stat added.");
			}
			else
			{
				// Add a new instance of a given object type in the map pane
				objtype = cl->FindObjType(t.Text(), FALSE);
				if (objtype < 0)
					objtype = cl->FindObjType(t.Text(), TRUE);

				if (objtype < 0)
				{
					Output("%s has no object named '%s'.\n", cl->ClassName(), t.Text());
				}
				else
				{
				    addobject:

					SObjectDef def;
					memset(&def, 0, sizeof(SObjectDef));

					def.objclass = cl->ClassId();
					def.objtype = objtype;
                    def.flags = 0;
					def.level = MapPane.GetMapLevel();

					def.pos = pos;

					int index = MapPane.NewObject(&def);
					if (index < 0)
						Output("ERROR: Creating object\n");
					else
					{
						StatusBar.Select(index);

						Output("%s:%s added at (%d, %d, %d).\n", cl->ClassName(),
							cl->GetObjType(objtype)->name, def.pos.x, def.pos.y, def.pos.z);

						if (number != 1)
							MapPane.GetInstance(index)->SetAmount(number);

						// If we added a player, add him to the player manager
						if (def.objclass == OBJCLASS_PLAYER)
						{
							PTObjectInstance oi = MapPane.GetInstance(index);
							if (oi)
							{
								PlayerManager.AddPlayer((PTPlayer)oi);
								PlayerManager.SetMainPlayer((PTPlayer)oi);
							}
						}
					}
				}

				t.WhiteGet();
			}
		}
		else
		{
			for (int i = 0; i < MAXOBJECTCLASSES; i++)
			{
				cl = TObjectClass::GetClass(i);
				if (cl && (objtype = cl->FindObjType(t.Text())) >= 0)
					break;
			}

			if (objtype >= 0)
				goto addobject;

			Output("No class named '%s'.\n", t.Text());
		}
	}

	return 0;
}

COMMAND(CmdAddInv)
{
	int objtype = -1;
	int number = 1;

	if (t.Type() == TKN_NUMBER)
	{
		number = t.Index();
		t.WhiteGet();
	}
	
	if (t.Type() != TKN_IDENT && t.Type() != TKN_TEXT)
		return CMD_BADPARAMS;

	if (!context->AddToInventory(t.Text(), number))
	{
		Output("Unable to add %s", t.Text());
		t.SkipLine();
		return 0;
	}

	t.WhiteGet();

	return 0;
}

COMMAND(CmdDelInv)
{
	int number = 1;

	if (t.Type() == TKN_NUMBER)
	{
		number = t.Index();
		t.WhiteGet();
	}
	
	if (t.Type() != TKN_IDENT && t.Type() != TKN_TEXT)
		return CMD_BADPARAMS;

	int count = context->DeleteFromInventory(t.Text(), number);
	Output("%d %s deleted", count, t.Text());

	t.WhiteGet();
	
	return 0;
}

COMMAND(CmdGive)
{
	int number = 1;

	if (t.Type() != TKN_IDENT && t.Type() != TKN_TEXT)
		return CMD_BADPARAMS;

	PTObjectInstance inst = MapPane.FindClosestObject(t.Text(), context);
	if (inst < 0)
	{
		Output("Unable to find object %s\n", t.Text());
		t.SkipLine();
		return 0;
	}

	t.WhiteGet();

	if (t.Type() == TKN_NUMBER)
	{
		number = t.Index();
		t.WhiteGet();
	}
	
	if (t.Type() != TKN_IDENT && t.Type() != TKN_TEXT)
		return CMD_BADPARAMS;

	int count = context->GiveInventoryTo(inst, t.Text(), number);
	Output("%d %s given", count, t.Text());

	t.WhiteGet();
	
	return 0;
}

COMMAND(CmdTake)
{
	int number = 1;

	if (t.Type() != TKN_IDENT && t.Type() != TKN_TEXT)
		return CMD_BADPARAMS;

	PTObjectInstance inst = MapPane.FindClosestObject(t.Text(), context);
	if (!inst)
	{
		Output("Unable to find object %s\n", t.Text());
		t.SkipLine();
		return 0;
	}

	t.WhiteGet();

	if (t.Type() == TKN_NUMBER)
	{
		number = t.Index();
		t.WhiteGet();
	}
	
	if (t.Type() != TKN_IDENT && t.Type() != TKN_TEXT)
		return CMD_BADPARAMS;

	int count = inst->GiveInventoryTo(context, t.Text(), number);
	Output("%d %s taken", count, t.Text());

	t.WhiteGet();
	
	return 0;
}

COMMAND(CmdGenerate)
{
	int sizex = 2;
    int sizey = 2;

	S3DPoint pos;
	MapPane.GetMapPos(pos);

	if (!Parse(t, "%d %d", &sizex, &sizey))
	{
		int x = pos.x & (SECTORWIDTH - 1);
		int y = pos.y & (SECTORHEIGHT - 1);

		if (x < 256)
			pos.x -= 256;
		else if (x >= (SECTORWIDTH - 256))
			pos.x += 256;
		else
			sizex = 1;

		if (y < 256)
			pos.y -= 256;
		else if (y >= (SECTORHEIGHT - 256))
			pos.y += 256;
		else
			sizey = 1;

	}

	pos.x >>= SECTORWSHIFT;
	pos.y >>= SECTORHSHIFT;

	GenerateMap(pos.x, pos.y, sizex, sizey);

	return 0;
}

COMMAND(CmdCalcWalkmap)
{
	MapPane.CalculateWalkmap();
	return 0;
}

COMMAND(CmdWalkmap)
{
	int deltaz;
	BOOL nonzero = FALSE, absolute = FALSE;

	while (t.Type() == TKN_IDENT)
	{
		if (t.Is("nonzero", 1))
			nonzero = TRUE;
		else if (t.Is("absolute", 1))
			absolute = TRUE;
		else if (t.Is("reset", 1))
		{
			MapPane.SetWalkmapReveal(0, 0, SECTORWIDTH >> WALKMAPSHIFT, SECTORHEIGHT >> WALKMAPSHIFT);
			t.WhiteGet();
			return 0;
		}
		else
			return CMD_BADPARAMS;

		t.WhiteGet();
	}

	if (!Parse(t, "%d", &deltaz))
		return CMD_BADPARAMS;

	MapPane.AdjustWalkmap(deltaz, nonzero);

	if (context)
		MapPane.SaveWalkmap(context);

	return 0;
}

COMMAND(CmdTileWalkmap)
{
	context->GetImagery()->SetWorldReg(context->GetState(), PLATEWIDTH >> (WALKMAPSHIFT+1), PLATEHEIGHT >> (WALKMAPSHIFT+1), 0);
	context->GetImagery()->SetWorldBoundBox(context->GetState(), PLATEWIDTH >> WALKMAPSHIFT, PLATEHEIGHT >> WALKMAPSHIFT, 0);
	return 0;
}

COMMAND(CmdState)
{
	int newstate;

	if (!Parse(t, "%d", &newstate))
		return CMD_BADPARAMS;

	if (!context->SetState(newstate))
		Output("Invalid state\n");

	return CMD_WAIT;
}


COMMAND(CmdTry)
{
	char newstate[80];

	if (!context->IsComplex())
		return 0;

	if (!Parse(t, "%t", &newstate))
		return CMD_BADPARAMS;

	((PTComplexObject)context)->Try(newstate);

	return CMD_WAIT;
}

COMMAND(CmdForce)
{
	char newstate[80];

	if (!context->IsComplex())
		return 0;

	if (!Parse(t, "%t", &newstate))
		return CMD_BADPARAMS;

	((PTComplexObject)context)->Force(newstate);

	return CMD_WAIT;
}

COMMAND(CmdReveal)
{
	if (context && context->GetFlags() & OF_REVEAL)
		context->ResetFlags(context->GetFlags() & ~OF_REVEAL);

	else if (context)
		context->SetFlags(OF_REVEAL);

	return 0;
}

COMMAND(CmdLevel)
{
	int level;
	if (!Parse(t, "%d", &level))
		return CMD_BADPARAMS;

	MapPane.SetMapLevel(level);
	return 0;
}

COMMAND(CmdTemplate)
{
	int index = TerrainTemplates->NewTemplate(context->GetTypeName());
	if (index < 0)
	{
		Output("Max number of templates reached\n");
		return 0;
	}

	S3DPoint pos;
	context->GetPos(pos);

	int objlist[MAXOBJECTREFS];
	int numfound = MapPane.FindObjectsInRange(pos, objlist, PLATEWIDTH, PLATEHEIGHT, OBJCLASS_TILE, MAXOBJECTREFS);
	int numadded = 0;

	for (int i = 0; i < numfound; i++)
	{
		PTObjectInstance inst = MapPane.GetInstance(objlist[i]);
		if (inst && inst != context)
		{
			S3DPoint ipos;
			inst->GetPos(ipos);
			ipos.x -= pos.x;
			ipos.y -= pos.y;
			ipos.z -= pos.z;

			if (TerrainTemplates->AddObject(index, inst, ipos) < 0)
			{
				Output("Too many objects nearby, the last %d were left out.\n", numfound - i);
				break;
			}

			numadded++;
		}
	}

	Output("%d objects added to template for '%s'.\n", numadded, context->GetTypeName());

	return 0;
}

COMMAND(CmdSmoothScroll)
{
	int retval = 0;

	if (t.Is("on"))
	{
		if (!SmoothScroll)
		{
			SmoothScroll = TRUE;
			MapPane.RedrawAll();
		}
	}
	else if (t.Is("off"))
	{
		if (SmoothScroll)
		{
			SmoothScroll = FALSE;
			MapPane.RedrawAll();
		}
	}
	else
		retval = CMD_BADPARAMS;

	t.Get();

	return retval;
}

COMMAND(CmdDLight)
{
	int intensity;

	if (!Parse(t, "%d", &intensity))
		return CMD_BADPARAMS;

	MapPane.SetDLightIntensity(intensity);
	return 0;
}


COMMAND(CmdText)
{
	Console.Hide();
	ScrollEditor.Show();
	PlayScreen.SetExclusivePane(&ScrollEditor);
	ScrollEditor.SetScroll(context);

	return 0;
}

COMMAND(CmdExit)
{
	if (t.Type() != TKN_IDENT && t.Type() != TKN_TEXT)
		return CMD_BADPARAMS;

	strcpy(buf, t.Text());
	t.WhiteGet();

	BOOL getamb = TRUE;
	if (t.Type() == TKN_IDENT && t.Is("noambient", 1))
	{
		getamb = FALSE;
		t.WhiteGet();
	}

	TExit::AddExit(buf, context, getamb);

	Output("Exit from '%s' added.\n", buf);

	TExit::WriteExitList();		// write immediately just to be safe

	return 0;
}

COMMAND(CmdFollow)
{
	if (!((PTExit)context)->Activate())
		Output("Nothing defined for this exit, can't follow\n");

	return 0;
}

COMMAND(CmdRestore)
{
	((PTCharacter)context)->RestoreHealth();
	return 0;
}

COMMAND(CmdGet)
{
	if (t.Type() != TKN_IDENT && t.Type() != TKN_TEXT)
		return CMD_BADPARAMS;

	int index = -1;
	PTObjectInstance inst = MapPane.FindClosestObject(t.Text(), NULL, TRUE);

	if (inst == NULL)
		Output("Can't find any object by that name.\n");
	else
	{
		if (inst->IsInInventory())
			inst->RemoveFromInventory();
		else
			inst->RemoveFromMap();

		context->AddToInventory(inst);
	}

	t.WhiteGet();

	return 0;
}

COMMAND(CmdSectorCommand)
{
	char command[512];
	int level;

	strcpy(command, (char *)t.GetPos());

	if (!Parse(t, "%d", &level))
		return CMD_BADPARAMS;

	if (t.Type() == TKN_EOF || t.Type() == TKN_RETURN)
		return CMD_BADPARAMS;

	sprintf(buf, "Processing command \"%s\" on level %d...\n", command, level);
	Output(buf);

	if (MapPane.GetMapLevel() == level)
	{
		MapPane.FreeAllSectors();
		MapPane.RedrawAll();
	}

	IsSectorCommand = TRUE;

	for (int sy = 0; sy < MAXSECTORY; sy++)
		for (int sx = 0; sx < MAXSECTORX; sx++)
		{
			PTSector sector = new TSector(level, sx, sy);
			sector->Load(FALSE);

			for (int i = 0; i < sector->NumItems(); i++)
			{
				PTObjectInstance inst = sector->GetInstance(i);
				if (inst)
				{
					TStringParseStream s(command, strlen(command));
					TToken t0(s);
					t0.Get();
					CommandInterpreter(inst, t0, MINCMDABREV);
				}
			}

			sector->Save();
			delete sector;
		}

	while (t.Type() != TKN_RETURN && t.Type() != TKN_EOF)
		t.WhiteGet();

	IsSectorCommand = FALSE;

	return 0;
}

COMMAND(CmdSwap)
{
	if (t.Type() != TKN_IDENT && t.Type() != TKN_TEXT)
		return CMD_BADPARAMS;

	PTObjectInstance inst = MapPane.FindClosestObject(t.Text(), NULL, TRUE);

	if (inst == NULL)
		Output("Can't find any object by that name.\n");
	else
		if (!MapPane.SwapDrawOrder(context, inst))
			Output("Hrm...the objects are in different sectors.  I guess you're screwed.\n");

	t.WhiteGet();

	return 0;
}

COMMAND(CmdToFront)
{
	MapPane.PushToFront(context);
	return 0;
}

COMMAND(CmdToBack)
{
	MapPane.PushToBack(context);
	return 0;
}

/*COMMAND(CmdAlias)
{
	if (t.Type() == TKN_IDENT)
	{
		// Get a list of aliases
		if (t.Is("list"))
		{
			t.WhiteGet();
			for (int c = 0; c < NumAliases(); c++)
			{
				sprintf(buf, "%s = %s\n", GetAliasName(c), GetAlias(c));
				Output(buf);
			}
			return 0;
		}
	
		// Set a new alias
		char aliasname[30], alias[30];
		if (!Parse(t, "%29s", aliasname))
			return CMD_BADPARAMS;

		if (t.Type() == TKN_IDENT)
			if (!Parse(t, "%30s", aliasname))
				return CMD_BADPARAMS;
		if (t.Type() == TKN_TEXT)
			if (!Parse(t, "%30t", aliasname))
				return CMD_BADPARAMS;
			
		if (SetAlias(aliasname, alias) >= 0)
			Output("Alias set");
		else
			Output("Too many aliases");
	}

	return 0;
}
*/
COMMAND(CmdGroup)
{
	int group;

	if (t.Type() == TKN_NUMBER)			// Set our group
	{
		if (!Parse(t, "%d", &group))
			return CMD_BADPARAMS;

		if (context)
			context->SetGroup(group);
	}
	else								// Show what group we're in
	{
		if (context)
		{
			sprintf(buf, "Group: %d\n", context->GetGroup());
			Output(buf);
		}
	}
	return 0;
}

COMMAND(CmdPlay)
{
	if (!Parse(t, "%t", buf))
		return CMD_BADPARAMS;

	PLAY(buf);

	return 0;
}

COMMAND(CmdTrigger)
{
	if (t.Type() != TKN_IDENT)
		return CMD_BADPARAMS;

	if (context->GetScript())
		context->GetScript()->Trigger(TRIGGER_TRIGGER, t.Text());

	t.WhiteGet();

	return 0;
}

COMMAND(CmdNewGame)
{
	PlayScreen.NewGame();

	return 0;
}

COMMAND(CmdCurPlayer)
{
	PlayerManager.SetMainPlayer((PTPlayer)context);
	
	Output("%s is now current player\n", context->GetName());

	return 0;
}

COMMAND(CmdUndo)
{
	StatusBar.Undo();
	return 0;
}

COMMAND(CmdResetScreenRect)
{
	if (!context->GetAnimator())
		Output("Context has no animator\n");
	else
	{
		int state;
		if (!Parse(t, "%d", &state))
			state = -1;

		((PT3DAnimator)context->GetAnimator())->RecordNewExtents(context, state);
	}

	return 0;
}

COMMAND(CmdBounds)
{
	int regx, regy, width, length;

	if (!Parse(t, "%d %d %d %d", &regx, &regy, &width, &length))
		return CMD_BADPARAMS;

	int state = context->GetState();
	if (t.Type() == TKN_NUMBER)
		Parse(t, "%d", &state);

	if (!context->GetImagery())
		Output("Sorry, context has no imagery\n");
	else
	{
		context->GetImagery()->SetWorldBoundBox(state, 0, 0, 1);
		context->GetImagery()->SetWorldReg(state, 0, 0, 0);
		context->GetImagery()->SetWorldBoundBox(state, width, length, 1);
		context->GetImagery()->SetWorldReg(state, regx, regy, 0);
		if (StatusBar.EditWalkmap() && state == context->GetState())
			MapPane.SnapWalkDisplay(context->GetMapIndex());
	}

	return 0;
}

COMMAND(CmdToggle)
{
	if (t.Type() != TKN_IDENT)
		return CMD_BADPARAMS;

	char *flagname = NULL;

	for (int i = 0; i < context->GetNumFlags(); i++)
	{
		flagname = context->GetFlagName(i);
		if (t.Is(flagname, 3))
			break;
	}

	if (!flagname)
	{
		Output("No object flag by that name\n");
		while (t.Type() != TKN_RETURN && t.Type() != TKN_EOF)
			t.Get();
		return 0;
	}
	else
	{
		t.WhiteGet();
		
		if (t.Is("="))
			t.WhiteGet();

		BOOL value;
		if (t.Is("on") || t.Is("1") || t.Is("true"))
		{
			value = 1;
			t.WhiteGet();
		}
		else if (t.Is("off") || t.Is("0") || t.Is("false"))
		{
			value = 0;
			t.WhiteGet();
		}
		else
		{
			value = !context->IsFlagSet(flagname);
		}

		context->SetFlag(flagname, value);
	}

	return 0;
}

COMMAND(CmdMove)
{
	int newx = 0, newy = 0, newz = 0;

	if (!Parse(t, "%i %i", &newx, &newy))
		return CMD_BADPARAMS;

	if (t.Type() == TKN_NUMBER)
		if (!Parse(t, "%i", &newz))
			return CMD_BADPARAMS;

	S3DPoint oldpos;
	context->GetPos(oldpos);
	S3DPoint newpos = oldpos;

	newpos.x += newx;
	newpos.y += newy;
	newpos.z += newz;

	MapPane.AddObjectUpdateRect(context->GetMapIndex());
	context->SetPos(newpos, -1, IsSectorCommand);
	MapPane.AddObjectUpdateRect(context->GetMapIndex());

	return 0;
}

COMMAND(CmdPos)
{
	S3DPoint newpos;
	context->GetPos(newpos);
	int newlevel = -1;

	if (!Parse(t, "%i %i", &newpos.x, &newpos.y))
		return CMD_BADPARAMS;

	if (t.Type() == TKN_NUMBER)
		if (!Parse(t, "%i", &newpos.z))
			return CMD_BADPARAMS;

	if (t.Type() == TKN_NUMBER)
		if (!Parse(t, "%i", &newlevel))
			return CMD_BADPARAMS;

	MapPane.AddObjectUpdateRect(context->GetMapIndex());
	context->SetPos(newpos, newlevel, IsSectorCommand);
	MapPane.AddObjectUpdateRect(context->GetMapIndex());

	return 0;
}

COMMAND(CmdDelete)
{
	MapPane.DeleteObject(context);
	return CMD_DELETED;
}

COMMAND(CmdStat)
{
	PTObjectClass cl = TObjectClass::GetClass(context->ObjClass());

	if (t.Type() == TKN_IDENT)
	{
		if (t.Is("list"))
		{
			int c;
			t.WhiteGet();
			Output("Class stats\n");
			for (c = 0; c < cl->NumStats(); c++)
			{
				Output("%s = %d\n", cl->GetStatDefString(c, buf), cl->GetStat(context->ObjType(), c));
				if (c != 0 && (c % 5) == 0)
				{
					Output("Press any key");
					Console.GetChar();
				}
			} 
			Output("Object stats\n");
			Console.GetChar();
			for (c = 0; c < cl->NumObjStats(); c++)
			{
				Output("%s (%d) = %d\n", cl->GetObjStatDefString(c, buf), cl->GetObjStat(context->ObjType(), c), context->GetObjStat(c));
				if (c != 0 && (c % 5) == 0)
				{
					Output("Press any key");
					Console.GetChar();
				}
			} 
			return 0;
		}

		strcpy(buf, t.Text());
		t.WhiteGet();

		int statid = cl->FindStat(buf);
		int objstatid = cl->FindObjStat(buf);
		if (statid < 0 && objstatid < 0)
		{
			Output("No stat by that name in that object's class\n");
			return 0;
		}

		if (t.Is("delete"))
		{
			t.WhiteGet();

			if (statid >= 0)
				cl->DeleteStat(statid);
			if (objstatid >= 0)
				cl->DeleteObjStat(objstatid);

			Output("Stat Deleted\n");
			return 0;
		}

		if (t.Is("="))
		{
			t.WhiteGet();

			int val;
			if (!Parse(t, "%i", &val))
				return CMD_BADPARAMS;
	
			context->SetStat(buf, val);

			Output("Stat Set: ");
		}

		if (t.Is("reset"))
		{
			t.WhiteGet();

			if (statid >= 0)
				cl->ResetStat(context->ObjType(), statid);
			else if (objstatid >= 0)
				context->ResetStat(objstatid);

			Output("Stat Reset: ");
		}

		if (t.Type() != TKN_EOF)
			return CMD_BADPARAMS;

		if (statid >= 0)
			Output("%s = %d\n", cl->GetStatDefString(statid, buf), cl->GetStat(context->ObjType(), statid));
		else if (objstatid >= 0)
			Output("%s (%d) = %d\n", cl->GetObjStatDefString(objstatid, buf), cl->GetObjStat(context->ObjType(), objstatid), context->GetObjStat(objstatid));
		return 0;
	}

	// if no params, just display the object's stats
	S3DPoint pos;
	context->GetPos(pos);
	sprintf(buf, "\"%s\" %s:%s (%d, %d, %d)\n", context->GetName(),
			context->GetTypeName(), context->GetClassName(), pos.x, pos.y, pos.z);
	Output(buf);

	strcpy(buf, "Flags:");
	if (context->GetFlags())
		sprintbit(context->GetFlags(), objflags, buf);
	else
		strcat(buf, " (none)");
	strcat(buf, "\n");
	Output(buf);

    PTObjectImagery i = context->GetImagery();
	int s = context->GetState();
    sprintf(buf, "Registration (%d, %d, %d)  AnimReg (%d, %d, %d)\n",
			i->GetRegX(s), i->GetRegY(s), i->GetRegZ(s),
			i->GetAnimRegX(s), i->GetAnimRegY(s), i->GetAnimRegZ(s));
	Output(buf);

	if (context->GetFlags() & OF_LIGHT)
	{
		PSLightDef def;
		def = context->GetLightDef();

		sprintf(buf, "Light: intensity %d, multiplier %d, flags [", def->intensity, def->multiplier);

		if (context->GetLightFlags())
			sprintbit(context->GetLightFlags(), lightflags, buf);
		else
			strcat(buf, "--");

		sprintf(buf, "%s]\n       color (%d, %d, %d), pos (%d, %d, %d)\n"
					 "       3d index: %d lightid: %d\n",
				buf, def->color.red, def->color.green, def->color.blue,
				def->pos.x, def->pos.y, def->pos.z,
				def->lightindex, def->lightid);
		Output(buf);
	}

	return 0;
}

COMMAND(CmdScript)
{
	if (context->GetScript())
	{
		Console.Hide();
		ScriptEditor.Show();
		PlayScreen.SetExclusivePane(&ScriptEditor);
		ScriptEditor.LoadScript(context);
	}

	return 0;
}

int CenterOnFunc(PTObjectInstance context, TToken &t, BOOL scroll)
{
	S3DPoint pos;

	if (Editor && context && t.Type() != TKN_IDENT && t.Type() != TKN_NUMBER)
	{
		context->GetPos(pos);
		MapPane.SetMapPos(pos);
	}
	else
	{
		if (t.Type() == TKN_IDENT)
		{
			PTObjectInstance inst = MapPane.FindClosestObject(t.Text());
			if (!inst)
			{
				Output("Object not found");
				return 0;
			}
			if (Editor)
			{
				inst->GetPos(pos);
				MapPane.SetMapPos(pos);
			}
			else
				MapPane.CenterOnObj(inst, scroll);

			t.WhiteGet();
		}
		else if (t.Type() == TKN_NUMBER)
		{
			if (!Parse(t, "%i %i %i", &pos.x, &pos.y, &pos.z))
				return CMD_BADPARAMS;
			int level = MapPane.GetMapLevel();
			if (t.Type() == TKN_NUMBER)
				if (!Parse(t, "%i", &level))
					return CMD_BADPARAMS;
			if (Editor)
			{
				MapPane.SetMapPos(pos);
			}
			else
				MapPane.CenterOnPos(pos, level, scroll);
		}
		else
			return CMD_BADPARAMS;
	}

	return 0;
}

COMMAND(CmdCenterOn)
{
	return CenterOnFunc(context, t, FALSE);
}

COMMAND(CmdScrollTo)
{
	return CenterOnFunc(context, t, TRUE);
}

#define MAX_MAP_LOCATIONS		32

struct { char name[RESNAMELEN]; struct { int x, y, z; } pos; int level; } MapLocations[MAX_MAP_LOCATIONS];
int numlocations = 0;

BOOL ReadMapLocationList()
{
	char fname[MAX_PATH];
	sprintf(fname, "%slocation.def", ClassDefPath);

	FILE *fp = TryOpen(fname, "rb");
	if (!fp)
		return FALSE;

	TFileParseStream s(fp, fname);
	TToken t(s);

	t.Get();

	numlocations = 0;

	do
	{
		if (numlocations >= MAX_MAP_LOCATIONS)
			break;

		if (t.Type() == TKN_RETURN || t.Type() == TKN_WHITESPACE)
			t.LineGet();

		if (t.Type() == TKN_EOF)
			break;

		if (!Parse(t, "%t (%d, %d, %d) level %d", MapLocations[numlocations].name, &MapLocations[numlocations].pos.x, &MapLocations[numlocations].pos.y, &MapLocations[numlocations].pos.z, &MapLocations[numlocations].level))
			return FALSE;

		t.SkipLine();		// skip past any other garbage on the line, including the newline

		numlocations++;
	} while (t.Type() != TKN_EOF);

	fclose(fp);
	return TRUE;
}

COMMAND(CmdMapPos)
{
	S3DPoint pos;
	int level = MapPane.GetMapLevel();

	if (t.Type() == TKN_IDENT)
	{
		if (t.Is("list"))
		{
			Output("The following map locations are availible:\n");

			for (int i = 0; i < numlocations; i++)
			{
				sprintf(buf, "%20s (%5d, %5d, %3d) level %2d\n", MapLocations[i].name, MapLocations[i].pos.x, MapLocations[i].pos.y, MapLocations[i].pos.z, MapLocations[i].level);
				Output(buf);
			}

			t.WhiteGet();
			return 0;
		}

		for (int i = 0; i < numlocations; i++)
			if (t.Is(MapLocations[i].name, 3))
			{
				pos.x = MapLocations[i].pos.x;
				pos.y = MapLocations[i].pos.y;
				pos.z = MapLocations[i].pos.z;
				level = MapLocations[i].level;
				break;
			}

		t.WhiteGet();

		if (i >= numlocations)
		{
			Output("No map location by that name exists.  Try 'map list' for a listing.\n");
			return CMD_BADPARAMS;
		}
	}
	else if (!Parse(t, "%d %d %d", &pos.x, &pos.y, &pos.z))
		return CMD_BADPARAMS;

	MapPane.SetMapPos(pos);
	MapPane.SetMapLevel(level);
	return 0;
}

BOOL ShowObjList(PTObjectClass cl, char *match)
{
	BOOL ismatch = FALSE;
	int cnt = 0;

	for (int i = 0; i < cl->NumTypes(); i++)
	{
		if (cl->GetObjType(i) == NULL || (match != NULL && abbrevcmp(match, cl->GetObjType(i)->name) < 1))
			continue;

		ismatch = TRUE;

		sprintf(buf, "%s %-19s", buf, cl->GetObjType(i)->name);
		if (++cnt >= 3)
		{
			strcat(buf, "\n");
			Output(buf);
			buf[0] = 0;
			cnt = 0;
		}
	}

	if (cnt)
	{
		strcat(buf, "\n");
		Console.Output(buf);
	}

	return ismatch;
}

void ShowObjTypeInfo(PTObjectClass cl, int objtype)
{
	PSObjectInfo inf = cl->GetObjType(objtype);

	if (!cl || !inf)
		return;
/*
	sprintf(buf, "Name: %s, Class: %s, Imagery: %s, Usecount: %d\n",
			inf->name, cl->ClassName(), img->GetUseCount(), img->Get);
	Output(buf);
  */
	if (cl->NumStats())
	{
		Output("Statistics:\n");

		int len = 0, add;

		for (int i = 0; i < cl->NumStats(); i++)
		{
			sprintf(buf+len, "%s = %d, ", cl->StatName(i), cl->GetStat(objtype, i));
			add = strlen(buf) - len;
			if ((len+add) >= Console.winwidth && len != 0)
			{
				if (i == (cl->NumStats() - 1))
					len -= 2;
				buf[len] = '\n';
				buf[len+1] = 0;
				Output(buf);
				strcpy(buf, buf+len+2);
				len = add;
			}
			else
				len += add;
		}

		if (len > 0)
		{
			len -= 2;
			buf[len] = '\n';
			buf[len+1] = 0;
			Output(buf);
		}
	}
}

COMMAND(CmdShow)
{
	PTObjectClass cl;
	buf[0] = 0;

	if (t.Is("classes"))
	{
		Output("Object Classes:\n");
		for (int i = 0, cnt = 0; i < TObjectClass::NumClasses(); i++)
		{
			cl = TObjectClass::GetClass(i);
			if (cl == NULL)
				continue;

			sprintf(buf, "%s %-19s", buf, cl->ClassName());
			if (++cnt >= 3)
			{
				strcat(buf, "\n");
				Output(buf);
				buf[0] = 0;
				cnt = 0;
			}
		}

		if (cnt)
		{
			strcat(buf, "\n");
			Output(buf);
		}
	}
	else
	{
		if ((cl = TObjectClass::GetClass(TObjectClass::FindClass(t.Text()))))
		{
			t.WhiteGet();
			if (t.Type() == TKN_IDENT)
			{
				int objtype = cl->FindObjType(t.Text());
				if (objtype < 0)
				{
					if (!ShowObjList(cl, t.Text()))
					{
						sprintf(buf, "%s contains no type named '%s'.\n", cl->ClassName(), t.Text());
						Output(buf);
					}
				}
				else
					ShowObjTypeInfo(cl, objtype);
			}
			else
				ShowObjList(cl, NULL);
		}
		else
			Output("No class by that name.\n");
	}

	t.WhiteGet();
	return 0;
}

COMMAND(CmdAmbient)
{
	int amb;
	if (!Parse(t, "%d", &amb))
		return CMD_BADPARAMS;

	MapPane.SetAmbientLight(amb);
	MapPane.RedrawAll();

	return 0;
}

COMMAND(CmdAmbColor)
{
	SColor color;
	if (!Parse(t, "%b %b %b", &color.red, &color.green, &color.blue))
		return CMD_BADPARAMS;

	MapPane.SetAmbientColor(color);
	MapPane.RedrawAll();

	return 0;
}

void Mono(int percent, int dummy = -1)
{
	SetMonoPercent(percent);
	MapPane.RedrawAll();
}

COMMAND(CmdMono)
{
	int percent;
	if (!Parse(t, "%d", &percent))
		return CMD_BADPARAMS;

	Mono(percent);
	return 0;
}

COMMAND(CmdDirLight)
{
	return 0;
}

COMMAND(CmdBaseLight)
{
	SColor color;
	int id, mult = -1;

	if (!Parse(t, "%d %b %b %b <%d>", &id, &color.red, &color.green, &color.blue, &mult))
		return CMD_BADPARAMS;

	SetLightColor(id, color, mult);
	return 0;
}

COMMAND(CmdReplace)
{
	PTObjectClass cl = TObjectClass::GetClass(TObjectClass::FindClass(t.Text()));
	if (cl)
		t.WhiteGet();
	else
		cl = TObjectClass::GetClass(context->ObjClass());

	if (cl)
	{
		// Add a new instance of a given object type in the map pane
		int objtype = cl->FindObjType(t.Text());
		if (objtype < 0)
		{
			sprintf(buf, "%s has no object named '%s'.\n", cl->ClassName(), t.Text());
			Output(buf);
		}
		else
		{
			SObjectDef def;
			memset(&def, 0, sizeof(SObjectDef));

			def.objclass = cl->ClassId();
			def.objtype = objtype;
			def.level = MapPane.GetMapLevel();

			context->GetPos(def.pos);
			int index = MapPane.NewObject(&def);
			if (index < 0)
				Console.Output("ERROR: Creating object\n");
			else
			{
				int oldindex = context->GetMapIndex();
				StatusBar.Deselect(oldindex);
				PTObjectInstance oi = MapPane.GetInstance(oldindex);
				MapPane.DeleteObject(oi);
				StatusBar.Select(index, TRUE);
			}
		}
	}
	else
	{
		sprintf(buf, "No class named '%s'.\n", t.Text());
		Output(buf);
	}

	return 0;
}

COMMAND(CmdLight)
{
	if (t.Is("on"))
	{
		if (!(context->GetFlags() & OF_LIGHT))
		{
			context->SetFlags(OF_LIGHT);
			MapPane.AddObjectUpdateRect(context->GetMapIndex());
		}
		t.WhiteGet();
		return 0;
	}

	if (t.Is("off"))
	{
		if (context->GetFlags() & OF_LIGHT)
		{
			context->ResetFlags(context->GetFlags() & (~OF_LIGHT));
			MapPane.AddObjectUpdateRect(context->GetMapIndex());
		}
		t.WhiteGet();
		return 0;
	}

	if (t.Type() == TKN_NUMBER)
	{
		t.WhiteGet();
		int intensity;
		if (!Parse(t, "%d", &intensity))
			return CMD_BADPARAMS;

		context->SetLightIntensity(intensity);
		return 0;
	}

	if (t.Is("directional", MINCMDABREV))
	{
		t.WhiteGet();
		DWORD oldflags = context->GetFlags();

		if (t.Is("on"))
			context->SetLightFlags(LIGHT_DIR);
		else if (t.Is("off"))
			context->ResetLightFlags(context->GetLightFlags() & (~LIGHT_DIR));
		else
		{
			t.WhiteGet();
			return CMD_BADPARAMS;
		}

		if (oldflags != context->GetFlags())
			MapPane.AddObjectUpdateRect(context->GetMapIndex());

		t.WhiteGet();
		return 0;
	}

	if (t.Is("intensity", MINCMDABREV))
	{
		t.WhiteGet();
		int intensity;
		if (!Parse(t, "%d", &intensity))
			return CMD_BADPARAMS;

		context->SetLightIntensity(intensity);
		return 0;
	}

	if (t.Is("color", MINCMDABREV))
	{
		t.WhiteGet();
		SColor color;
		if (!Parse(t, "%b %b %b", &color.red, &color.green, &color.blue))
			return CMD_BADPARAMS;

		context->SetLightColor(color);
		return 0;
	}

	if (t.Is("position", MINCMDABREV))
	{
		t.WhiteGet();
		S3DPoint lightpos;
		if (!Parse(t, "%d %d %d", &lightpos.x, &lightpos.y, &lightpos.z))
			return CMD_BADPARAMS;

		context->SetLightPos(lightpos);
		return 0;
	}

	if (t.Is("multiplier", MINCMDABREV))
	{
		t.WhiteGet();
		int mult;
		if (!Parse(t, "%d", &mult))
			return CMD_BADPARAMS;

		context->SetLightMultiplier(mult);
		return 0;
	}

	return CMD_BADPARAMS;
}

void ZOffset(int zoffset, int dummy = -1)
{
	PTObjectInstance oi = MapPane.GetInstance(StatusBar.GetSelectedObj());

	if (oi)
	{
		PTObjectImagery img = oi->GetImagery();

		if (img)
		{
			int x = img->GetRegX(oi->GetState());
			int y = img->GetRegY(oi->GetState());
			img->SetReg(oi->GetState(), x, y, zoffset);
		}
	}
}

COMMAND(CmdZOffset)
{
	if (t.Type() == TKN_RETURN || t.Type() == TKN_EOF)
	{
		sprintf(buf, "Current zoffset: %d\n", context->GetImagery()->GetRegZ(context->GetState()));
		Output(buf);
		t.WhiteGet();
		return 0;
	}

	int zoff;
	if (!Parse(t, "%d", &zoff))
		return CMD_BADPARAMS;

	PTObjectImagery img = context->GetImagery();

	if (img)
	{
		int x = img->GetRegX(context->GetState());
		int y = img->GetRegY(context->GetState());
		img->SetReg(context->GetState(), x, y, zoff);
	}

	MapPane.AddObjectUpdateRect(context->GetMapIndex());
	return 0;
}

COMMAND(CmdRegistration)
{
	int dx, dy;
	if (!Parse(t, "%d %d", &dx, &dy))
		return CMD_BADPARAMS;

	PTObjectImagery img = context->GetImagery();
	if (!img)
		return 0;

	int x = img->GetRegX(context->GetState());
	int y = img->GetRegY(context->GetState());
	int z = img->GetRegZ(context->GetState());
	img->SetReg(context->GetState(), x - dx, y - dy, z);
	MapPane.AddObjectUpdateRect(context->GetMapIndex());
	return 0;
}

COMMAND(CmdAnimRegistration)
{
	int dx, dy;
	if (!Parse(t, "%d %d", &dx, &dy))
		return CMD_BADPARAMS;

	PTObjectImagery img = context->GetImagery();
	if (!img)
		return 0;

	int x = img->GetAnimRegX(context->GetState());
	int y = img->GetAnimRegY(context->GetState());
	int z = img->GetAnimRegZ(context->GetState());
	img->SetAnimReg(context->GetState(), x - dx, y - dy, z);
	return 0;
}

COMMAND(CmdAnimZ)
{
	int dz;
	if (!Parse(t, "%d", &dz))
		return CMD_BADPARAMS;

	PTObjectImagery img = context->GetImagery();
	if (!img)
		return 0;

	int x = img->GetAnimRegX(context->GetState());
	int y = img->GetAnimRegY(context->GetState());
	img->SetAnimReg(context->GetState(), x, y, dz);
	return 0;
}

COMMAND(CmdName)
{
	if (t.Type() != TKN_IDENT)
		return CMD_BADPARAMS;

	if (t.Is("type"))
	{
		t.WhiteGet();
		if (t.Type() != TKN_IDENT)
			return CMD_BADPARAMS;

		context->SetTypeName(t.Text());
	}
	else if (t.Is("clear"))
		context->SetName("");
	else
		context->SetName(t.Text());

	t.WhiteGet();
	return 0;
}

COMMAND(CmdFlip)
{
	MapPane.AddObjectUpdateRect(context->GetMapIndex());

	if (context->GetFlags() & OF_DRAWFLIP)
		context->ResetFlags(context->GetFlags() & ~(OF_DRAWFLIP));
	else
		context->SetFlags(OF_DRAWFLIP);

	MapPane.AddObjectUpdateRect(context->GetMapIndex());
	return 0;
}

COMMAND(CmdLock)
{
	context->SetFlags(OF_EDITORLOCK);
	return 0;
}

COMMAND(CmdUnlock)
{
	context->ResetFlags(context->GetFlags() & (~OF_EDITORLOCK));
	return 0;
}

COMMAND(CmdImmobile)
{
	context->SetFlags(OF_IMMOBILE);
	return 0;
}

COMMAND(CmdUnimmobile)
{
	context->ResetFlags(context->GetFlags() & (~OF_IMMOBILE));
	return 0;
}

COMMAND(CmdLoad)
{
	Output("Reloading...\n");
	MapPane.ReloadSectors();
	return 0;
}

COMMAND(CmdSave)
{
	// suspend all activity while saving to avoid any nastiness
	TObjectImagery::PauseLoader();

	BOOL savegame, savemap, saveheaders, saveclasses, saveexits;

	savegame = FALSE; // This must be set specifically

	if (t.Type() != TKN_IDENT)
		savemap = saveheaders = saveclasses = saveexits = TRUE;
	else
	{
		savemap = saveheaders = saveclasses = saveexits = FALSE;

		while (t.Type() == TKN_IDENT)
		{
			if (t.Is("game"))
				savegame = TRUE;
			if (t.Is("map"))
				savemap = TRUE;
			if (t.Is("headers"))
				saveheaders = TRUE;
			if (t.Is("classes"))
				saveclasses = TRUE;
			if (t.Is("exits"))
				saveexits = TRUE;
			t.WhiteGet();
		}
	}

	if (savegame)
	{
		Output("Saving game...\n");
		SaveGame.WriteGame();
	}

	if (savemap)
	{
		Output("Saving map sectors...\n");
		PlayScreen.SaveMap();
	}

	if (saveheaders)
	{
		if (!Console.AdjustingBounds())
		{
			TObjectImagery::SaveAllHeaders();
			Output("Saving object headers...\n");
		}
		else
			Output(" (imagery headers not saved - currently being edited)\n");
	}

	if (saveclasses)
	{
		Output("Saving classes..\n");
		TObjectClass::SetClassesDirty(); // Force class def to save
		TObjectClass::SaveClasses();
		TerrainTemplates->Save();
	}

	if (saveexits)
	{
		Output("Saving exits...\n");
		TExit::WriteExitList();
	}
	
	TObjectImagery::ResumeLoader();

	return 0;
}

COMMAND(CmdDXStats)
{
	Output("Direct X Stats.\n");
	sprintf(buf, "Display bits per pixel: %d\n", Display->BitsPerPixel());
	Output(buf);
	sprintf(buf, "Video Memory Total    : %3.1f K\n",
		(float)(GetFreeVideoMem()) / 1024.0);
	Output(buf);

	sprintf(buf, "Video Memory Available: %3.1f K\n",
		(float)(GetFreeVideoMem()) / 1024.0);

	Output(buf);

	if (BlitHardware)
		Output("\nBlit hardware available.\n");
	else
		Output("\nBlit hardware not available.\n");

	sprintf(buf, "Number of 3D objects  : %d\n", Scene3D.GetNumAnimators());
	Output(buf);

	sprintf(buf, "Number of 3D lights   : %d\n", Scene3D.GetNumLights());
	Output(buf);

	if (GetColorMode() == MONO)
		Output("\nRAMP emulation mode on.\n");

	else if (GetColorMode() == COLOR)
		Output("\nRGB emulation mode on.\n");
	else
		Output("\nEmulation mode currently undefined.\n");

	if (IsUsingHardware())
		Output("Hardware 3D support.\n");
	else
		Output("Software 3D support.\n");

	return 0;
}

COMMAND(CmdMemory)
{
	extern MEMORYSTATUS StartMemory;
	extern DWORD ImageryMemUsage;
	extern TotalAllocated, MaxAllocated;

	MEMORYSTATUS mem;
	mem.dwLength = sizeof(MEMORYSTATUS);
	GlobalMemoryStatus(&mem);

	Output("Starting memory usage:\n");
	sprintf(buf, "   Percent used: %d%%\n", StartMemory.dwMemoryLoad);
	Output(buf);
	sprintf(buf, "   Physical: %4.1fM  Free: %4.1fM\n", (float)StartMemory.dwTotalPhys / 1024 / 1024, (float)StartMemory.dwAvailPhys / 1024 / 1024);
	Output(buf);
	sprintf(buf, "   Paged:    %4.1fM  Free: %4.1fM\n", (float)StartMemory.dwTotalPageFile / 1024 / 1024, (float)StartMemory.dwAvailPageFile / 1024 / 1024);
	Output(buf);
	sprintf(buf, "   Virtual:  %4.1fM  Free: %4.1fM\n", (float)StartMemory.dwTotalVirtual / 1024 / 1024, (float)StartMemory.dwAvailVirtual / 1024 / 1024);
	Output(buf);

	Output("Current memory usage:\n");
	sprintf(buf, "   Percent used: %d%%\n", mem.dwMemoryLoad);
	Output(buf);
	sprintf(buf, "   Physical: %4.1fM  Free: %4.1fM\n", (float)mem.dwTotalPhys / 1024 / 1024, (float)mem.dwAvailPhys / 1024 / 1024);
	Output(buf);
	sprintf(buf, "   Paged:    %4.1fM  Free: %4.1fM\n", (float)mem.dwTotalPageFile / 1024 / 1024, (float)mem.dwAvailPageFile / 1024 / 1024);
	Output(buf);
	sprintf(buf, "	Virtual:  %4.1fM  Free: %4.1fM\n", (float)mem.dwTotalVirtual / 1024 / 1024, (float)mem.dwAvailVirtual / 1024 / 1024);
	Output(buf);

	sprintf(buf, "Memory usaged by object imagery: %4.1fM\n", (float)ImageryMemUsage / 1024 / 1024);
	Output(buf);
	sprintf(buf, "Memory usaged by chunk cache: %4.1fM\n", (float)ChunkCache.MemUsed() / 1024 / 1024);
	Output(buf);
	sprintf(buf, "Memory allocated:  %4.1fM  Max: %4.1fM\n", (float)TotalAllocated / 1024 / 1024, (float)MaxAllocated / 1024 / 1024);
	Output(buf);

	return 0;
}

// *******************
// * TEditStatusPane *
// *******************

void BtnInvert()
{
	StatusBar.InvertAxisButtons();
}

void BtnPrev()
{
	StatusBar.Prev();
}

void BtnNext()
{
	StatusBar.Next();
}

void BtnDeselect()
{
	StatusBar.Deselect();
}

void BtnCenterOn()
{
	S3DPoint pos;
	PTObjectInstance inst = MapPane.GetInstance(StatusBar.GetSelectedObj());
	if (inst)
	{
		inst->GetPos(pos);
		MapPane.SetMapPos(pos);
	}
}

void BtnUndo()
{
	StatusBar.Undo();
}

void BtnWalkmap()
{
	MapPane.RedrawAll();
	MapPane.ResetDrag();

	int index = StatusBar.GetSelectedObj();
	PTObjectInstance oi = MapPane.GetInstance(index);
	if (oi)
		MapPane.SaveWalkmap(oi);
}

void BtnScroll()
{
	SmoothScroll = !SmoothScroll;
	MapPane.RedrawAll();
}

BOOL TEditStatusPane::Initialize()
{
	TButtonPane::Initialize();

	iterator = curobj = -1;
	numobjs = 0;

	// Grid, X, Y, and Z buttons must be the first buttons created in this pane
	NewButton("Grid",	0,			   0, 32, GetHeight(), 0xC0, NULL, NULL, NULL,  FALSE, TRUE);
	NewButton("X",		32,			   0, 16, GetHeight(), 'X', NULL, NULL, NULL, FALSE, TRUE);
	NewButton("Y",		48,			   0, 16, GetHeight(), 'Y', NULL, NULL, NULL,  FALSE, TRUE);
	NewButton("Z",		64,			   0, 16, GetHeight(), 'H', NULL, NULL, NULL,  FALSE, TRUE);
	NewButton("Inv",	80,			   0, 32, GetHeight(), VK_TAB, BtnInvert);
	NewButton("/\\",    GetWidth() - 200, 0, 20, GetHeight(),   0, BtnPrev);
	NewButton("\\/",    GetWidth() - 180, 0, 20, GetHeight(),   0, BtnNext);
	NewButton("Cen",	GetWidth() - 160, 0, 32, GetHeight(), 'C', BtnCenterOn);
	NewButton("Undo",	GetWidth() - 128, 0, 32, GetHeight(), 'Z', BtnUndo);
	NewButton("Des",	GetWidth() -  96, 0, 32, GetHeight(), 'D', BtnDeselect);
	NewButton("Walk",	GetWidth() -  64, 0, 32, GetHeight(), 'W', BtnWalkmap, NULL, NULL, FALSE, TRUE);
	NewButton("Scr",	GetWidth() -  32, 0, 32, GetHeight(), 'L', BtnScroll);

	Button(0)->SetState(TRUE);
	Button(1)->SetState(TRUE);
	Button(2)->SetState(TRUE);

	SetDirty(TRUE);
	canundo = FALSE;

	// Terrain template controller
	TerrainTemplates = new TTerrainTemplate;

	return TRUE;
}

void TEditStatusPane::Close()
{
	TButtonPane::Close();

	if (TerrainTemplates)
		delete TerrainTemplates;

	TerrainTemplates = NULL;
}

void TEditStatusPane::DrawBackground()
{
	TButtonPane::DrawBackground();

	if (IsDirty())
	{
		SetDirty(FALSE);
		SColor color;
		color.red = color.green = 10; color.blue = 50;
		WORD c = TranslateColor(color);
		Display->Box(112, 0, GetWidth() - 200 - 112, GetHeight(), c, 0xffff, 0, DM_BACKGROUND);

		if (curobj >= 0)
		{
			PTObjectInstance oi = MapPane.GetInstance(selected[curobj]);
			if (!oi)
				StatusBar.Validate();
			else
			{
				S3DPoint pos;
				oi->GetPos(pos);

				sprintf(buf, "\"%s\" %s : %s (%d, %d, %d)", oi->GetName(),
						TObjectClass::GetClass(oi->ObjClass())->ClassName(),
						oi->GetTypeName(), pos.x, pos.y, pos.z);
				Display->WriteText(buf, 270, 0, 1, SystemFont, NULL, DM_USEDEFAULT, -1, 0, JUSTIFY_CENTER);
			}
		}
		else
		{
			S3DPoint pos;
			MapPane.GetMapPos(pos);
			sprintf(buf, "Level %d - (%d, %d, %d)", MapPane.GetMapLevel(), pos.x, pos.y, pos.z);
			Display->WriteText(buf, 270, 0, 1, SystemFont, NULL, DM_USEDEFAULT, -1, 0, JUSTIFY_CENTER);
		}
	}
}

void TEditStatusPane::InvertAxisButtons()
{
	Button(1)->Invert();
	Button(2)->Invert();
	Button(3)->Invert();
}

BOOL TEditStatusPane::Select(int index, BOOL add)
{
	if (index < 0 || (add && numobjs >= MAXSELECTEDOBJS))
		return FALSE;

	canundo = FALSE;

	// first make sure we're not duplicating a selection
	for (int i = 0; i < numobjs; i++)
		if (selected[i] == index)
		{
			// just set it to be the current object
			SetCurObj(i);
			ClassPane.SelectSame(index);
			return TRUE;
		}

	if (!add)
	{
		// remove the selection highlights for the objects we are deselecting
		for (int i = 0; i < numobjs; i++)
			MapPane.AddObjectUpdateRect(selected[i]);

		numobjs = 0;
	}

	curobj = numobjs++;
	selected[curobj] = index;
	SetDirty(TRUE);
	ClassPane.SelectSame(index);
	MapPane.AddObjectUpdateRect(index);

	return TRUE;
}

BOOL TEditStatusPane::Deselect()
{
	if (curobj < 0)
		return FALSE;

	StopMoving();			// clear any drag flags that might be set

	if (MapPane.GetInstance(selected[curobj]))
		MapPane.AddObjectUpdateRect(selected[curobj]);

	memmove(&(selected[curobj]), &(selected[curobj+1]), (numobjs - curobj - 1) * sizeof(int));
	numobjs--;
	if (curobj >= numobjs)
		curobj--;
	SetDirty(TRUE);
	return TRUE;
}

BOOL TEditStatusPane::Deselect(int index)
{
	canundo = FALSE;

	for (int i = 0; i < numobjs; i++)
		if (selected[i] == index)
		{
			MapPane.AddObjectUpdateRect(selected[i]);
			memmove(&(selected[i]), &(selected[i+1]), (numobjs - i - 1) * sizeof(int));
			numobjs--;
			if (i <= curobj)
				curobj--;
			SetDirty(TRUE);
			return TRUE;
		}

	return FALSE;
}

BOOL TEditStatusPane::Reselect(int oldindex, int newindex)
{
	canundo = FALSE;

	for (int i = 0; i < numobjs; i++)
		if (selected[i] == oldindex)
		{
			selected[i] = newindex;
			return TRUE;
		}

	return FALSE;
}

BOOL TEditStatusPane::SetCurObj(int newcurobj)
{
	if ((DWORD)(newcurobj >= numobjs))
		return FALSE;

	curobj = newcurobj;
	SetDirty(TRUE);
	return TRUE;
}

BOOL TEditStatusPane::Next()
{
	if (curobj >= (numobjs - 1))
		return FALSE;

	curobj++;
	SetDirty(TRUE);
	return TRUE;
}

BOOL TEditStatusPane::Prev()
{
	if (curobj <= 0)
		return FALSE;

	curobj--;
	SetDirty(TRUE);
	return TRUE;
}

void TEditStatusPane::Validate()
{
	for (int i = 0; i < numobjs; i++)
		if (MapPane.GetInstance(selected[i]) == NULL)
			Deselect(selected[i]);
}

void TEditStatusPane::Delete()
{
	canundo = FALSE;

	while (numobjs > 0)
	{
		PTObjectInstance oi = MapPane.GetInstance(selected[--numobjs]);
		if (!oi)
			Console.Output("\nERROR: Index is invalid\n");
		else
			MapPane.DeleteObject(oi);
	}
	curobj = -1;
	SetDirty(TRUE);
}

void StartObjMoving(PTObjectInstance oi)
{
	if (oi && !(oi->GetFlags() & OF_EDITORLOCK))
	{
		S3DPoint pos;
		oi->GetPos(pos);
		if (!(oi->GetFlags() & OF_SELDRAW))
		{
			MapPane.AddObjectUpdateRect(oi->GetMapIndex());
			oi->SetFlags(OF_SELDRAW);
		}
	}
}

void TEditStatusPane::StartMoving()
{
	for (int i = 0; i < numobjs; i++)
	{
		canundo = TRUE;
		PTObjectInstance oi = MapPane.GetInstance(selected[i]);

		if (oi)
		{
			oi->GetPos(lastpos[i]);
			StartObjMoving(oi);

			if (oi->GetShadow() >= 0)
			{
				PTObjectInstance s = MapPane.GetInstance(oi->GetShadow());
				StartObjMoving(s);
			}
		}
	}
}

void StopObjMoving(PTObjectInstance oi)
{
	if (oi && (oi->GetFlags() & OF_SELDRAW))
	{
		oi->ResetFlags(oi->GetFlags() & (~OF_SELDRAW));
		if (!(oi->GetFlags() & OF_MOVING))
			MapPane.AddObjectUpdateRect(oi->GetMapIndex());
	}
}

void TEditStatusPane::StopMoving()
{
	for (int i = 0; i < numobjs; i++)
	{
		PTObjectInstance oi = MapPane.GetInstance(selected[i]);

		if (oi)
		{
			StopObjMoving(oi);

			if (oi->GetShadow() >= 0)
			{
				PTObjectInstance s = MapPane.GetInstance(oi->GetShadow());
				StopObjMoving(s);
			}
		}
	}

	SetDirty(TRUE);
}

void TEditStatusPane::Undo()
{
	for (int i = 0; i < numobjs; i++)
	{
		PTObjectInstance oi = MapPane.GetInstance(selected[i]);
		oi->SetPos(lastpos[i]);
	}
}

// ******************
// * TEditToolsPane *
// ******************

// Button functions for the edit tools pane
void BtnFullScr()
{
	Output("\nCurrently disabled\n");
	Output(PROMPT);
	/*
	if (FullScreen)
		ShutDownFullScreen();
	else
		StartFullScreen();
	*/
}

void BtnSave()
{
	Console.Input("save\n");
}

void BtnReveal()
{
	Console.Input("reveal\n");
}

void BtnStat()
{
	Console.Input("stat\n");
}

void BtnZOff()
{
	PTObjectInstance oi = MapPane.GetInstance(StatusBar.GetSelectedObj());
	if (oi)
	{
		StatusBar.StartMoving();
		Console.Output("zoffset ");
		Console.ChainMouse(ZOffset, -1, -1, -1, -80, 400, oi->GetImagery()->GetRegZ(oi->GetState()));
	}
}

int startx, starty;
S3DPoint startpos;

void Registration(S3DPoint pos)
{
	int dx, dy;

	PTObjectInstance inst = MapPane.GetInstance(StatusBar.GetSelectedObj());
	if (inst)
	{
		inst->GetPos(pos);
		WorldToScreen(pos, dx, dy);
		dx -= startx;
		dy -= starty;

		int x, y, z;
		x = inst->GetImagery()->GetRegX(inst->GetState());
		y = inst->GetImagery()->GetRegY(inst->GetState());
		z = inst->GetImagery()->GetRegZ(inst->GetState());

		inst->GetImagery()->SetReg(inst->GetState(), x - dx, y - dy, z);
		inst->SetPos(startpos);
	}

	StatusBar.StopMoving();
	Console.ClearAxis();
}

void RegistrationAbort()
{
	PTObjectInstance inst = MapPane.GetInstance(StatusBar.GetSelectedObj());
	if (inst)
		inst->SetPos(startpos);

	StatusBar.StopMoving();
	Console.ClearAxis();
}

void BtnReg()
{
	PTObjectInstance inst = MapPane.GetInstance(StatusBar.GetSelectedObj());
	if (inst)
	{
		inst->GetPos(startpos);				// save for later comparisson
		WorldToScreen(startpos, startx, starty);

		if (!Console.AddAxis(inst))
			return;

		StatusBar.StartMoving();
		MapPane.SetMode(Registration, RegistrationAbort, MODE_MOVE);
	}
}

void BtnDel()
{
	StatusBar.Delete();
}

void BtnAmb()
{
}

void BtnAmbCol()
{
}

void BtnMono()
{
}

void Clone(S3DPoint pos)
{
	StatusBar.StopMoving();

	for (int i = StatusBar.GetFirstObj(); i >= 0; i = StatusBar.GetNextObj())
	{
		PTObjectInstance inst = MapPane.GetInstance(i);
		if (!inst)
			Output("ERROR: Aquiring instance in clone\n");
		else
		{
			SObjectDef def;
			memset(&def, 0, sizeof(SObjectDef));
			def.objclass = inst->ObjClass();
			def.objtype = inst->ObjType();
			def.flags = inst->GetFlags();
			def.level = inst->GetLevel();
			inst->GetPos(def.pos);
			def.facing = inst->GetFace();
			def.state = inst->GetState();

			int index = MapPane.NewObject(&def);
			if (index < 0)
				Output("ERROR: Cloning object\n");
			else
			{
				// copy light stuff
				PTObjectInstance newinst = MapPane.GetInstance(index);
				if (newinst)
				{
					newinst->SetLightIntensity(inst->GetLightIntensity());
					S3DPoint pos;
					inst->GetLightPos(pos);
					newinst->SetLightPos(pos);
					SColor color;
					inst->GetLightColor(color);
					newinst->SetLightColor(color);
					newinst->ResetLightFlags(inst->GetLightFlags());
					newinst->SetLightMultiplier(inst->GetLightMultiplier());
				}

				StatusBar.Reselect(i, index);
			}

		}
	}

	StatusBar.StartMoving();
}

void CloneAbort()
{
	StatusBar.Delete();
}

void BtnClone()
{
	if (StatusBar.GetSelectedObj() >= 0)
	{
		S3DPoint dummy;
		Clone(dummy);
		MapPane.SetMode(Clone, CloneAbort, MODE_CLONE);
	}
}

void BtnFollow()
{
	Console.Input("follow\n");
}

void BtnCalc()
{
	MapPane.CalculateWalkmap();
}

void BtnSavWM()
{
}

void BtnBound()
{
	Console.SetBounds();
}

void AnimRegistration(int x, int y)
{
	PTObjectInstance inst = MapPane.GetInstance(StatusBar.GetSelectedObj());
	if (inst && inst->GetImagery())
	{
		int z = inst->GetImagery()->GetAnimRegZ(inst->GetState());
		inst->GetImagery()->SetAnimReg(inst->GetState(), x, y, z);
	}
}

void AnimZ(int z, int dummy = -1)
{
	PTObjectInstance inst = MapPane.GetInstance(StatusBar.GetSelectedObj());
	if (inst && inst->GetImagery())
	{
		int x = inst->GetImagery()->GetAnimRegX(inst->GetState());
		int y = inst->GetImagery()->GetAnimRegY(inst->GetState());
		inst->GetImagery()->SetAnimReg(inst->GetState(), x, y, z);
	}
}

void BtnAnReg()
{
	PTObjectInstance inst = MapPane.GetInstance(StatusBar.GetSelectedObj());
	if (inst && inst->GetImagery())
	{
		Console.Output("animreg ");
		Console.ChainMouse(AnimRegistration, -320, 320, inst->GetImagery()->GetAnimRegX(inst->GetState()),
							-320, 320, inst->GetImagery()->GetAnimRegY(inst->GetState()));
	}
}

void BtnAnimZ()
{
	PTObjectInstance inst = MapPane.GetInstance(StatusBar.GetSelectedObj());
	if (inst && inst->GetImagery())
	{
		Console.Output("animz ");
		Console.ChainMouse(AnimZ, -1, -1, -1, 0, 480, inst->GetImagery()->GetAnimRegZ(inst->GetState()));
	}
}

void BtnTemplate()
{
	Console.Input("template\n");
}

#define TOOLBUTTONWIDTH		36
#define TOOLBUTTONHEIGHT	20

struct { char *name; void (*btnfunc)(); int key; } ToolList[] =
{
	{ "Full",	BtnFullScr,	0			},
	{ "Save",	BtnSave,	'S'			},
	{ "Clone",	BtnClone,	VK_INSERT	},
	{ "Stat",	BtnStat,	'T'			},
	{ "Amb",	BtnAmb,		0			},
	{ "Amb C",	BtnAmbCol,	0			},
	{ "Mono",	BtnMono,	0			},
	{ "Del",	BtnDel,		VK_DELETE	},
	{ "Folow",	BtnFollow,	'F'			},
	{ "Revl",	BtnReveal,	0			},
	{ "Templ",	BtnTemplate,0,			},
	{ "Z Off",	BtnZOff,	0			},
	{ "Reg",	BtnReg,		0			},
	{ "Calc",	BtnCalc,	0			},
	{ "SavWM",	BtnSavWM,	0			},
	{ "Bound",	BtnBound,	0			},
	{ "AnReg",	BtnAnReg,	0			},
	{ "AnimZ",	BtnAnimZ,	0			},
	{ NULL,		NULL,		0			}			// end of list marker
};

BOOL TEditToolsPane::Initialize()
{
	TButtonPane::Initialize();

	int i = 0;

	for (int y = 0; y < GetHeight(); y += TOOLBUTTONHEIGHT)
		for (int x = 0; x < GetWidth(); x += TOOLBUTTONWIDTH)
		{
			NewButton(ToolList[i].name, x, y, TOOLBUTTONWIDTH, TOOLBUTTONHEIGHT,
					  ToolList[i].key, ToolList[i].btnfunc);

			if (ToolList[++i].name == NULL)
				return TRUE;
		}

	return (ToolList[i].name == NULL);
}

void TEditToolsPane::DrawBackground()
{
	if (IsDirty())
	{
		Display->Box(0, 0, GetWidth(), GetHeight(), 0, 0xffff, 0, DM_BACKGROUND);
		SetDirty(FALSE);
	}

	TButtonPane::DrawBackground();
}

void TEditToolsPane::KeyPress(int key, BOOL down)
{
	TButtonPane::KeyPress(key, down);

	if (down)
	{
		key -= VK_F1;
		if (key >= 0 && key <= NUMBOOKMARKS)
		{
			if (CtrlDown)
			{
				MapPane.GetMapPos(bookmark[key]);
				bookmarklev[key] = MapPane.GetMapLevel();
			}
			else
			{
				if (bookmark[key].x >= 0 || bookmark[key].y >= 0)
				{
					MapPane.SetMapPos(bookmark[key]);
					MapPane.SetMapLevel(bookmarklev[key]);
					StatusBar.SetDirty(TRUE);
				}
			}
		}
	}
}

void TEditToolsPane::AddBookmark(int mark, S3DPoint pos, int lev)
{
	if (mark < 0 || mark >= NUMBOOKMARKS)
		return;

	memcpy(&bookmark[mark], &pos, sizeof(S3DPoint));
	bookmarklev[mark] = lev;
}

void TEditToolsPane::GetBookmark(int mark, RS3DPoint pos, int &lev)
{
	if (mark < 0 || mark >= NUMBOOKMARKS)
		return;

	memcpy(&pos, &bookmark[mark], sizeof(S3DPoint));
	lev = bookmarklev[mark];
}

void TEditToolsPane::ClearBookmarks()
{
	for (int i = 0; i < NUMBOOKMARKS; i++)
		bookmark[i].x = bookmark[i].y = bookmark[i].z = bookmarklev[i] = -1;
}

// ******************
// * TEditClassPane *
// ******************

void BtnMaximize()
{
	static BOOL maximized = FALSE;

	if (maximized)
	{
		Console.Show();
		ToolBar.Show();
		ClassPane.Resize(EDMULTIPANEX, ClassPane.GetPosY(),
			Display->Width() - CONSOLEX - EDMULTIPANEX, ClassPane.GetHeight());
	}
	else
	{
		Console.Hide();
		ToolBar.Hide();
		ClassPane.Resize(CONSOLEX, ClassPane.GetPosY(), 
			Display->Width() - CONSOLEX - CONSOLEX, ClassPane.GetHeight());
	}

	int i = 0;
	for ( ; i < 5; i++)
		ClassPane.Button(i)->SetPosX(ClassPane.GetWidth() - 16);
	for ( ; i < 13; i++)
		ClassPane.Button(i)->SetPosX(ClassPane.GetWidth() - 32);

	ClassPane.Update();

	maximized = !maximized;
}

void BtnScrollUp()
{
	ClassPane.Scroll(-(ClassPane.GetMaxLines()));
}

void BtnScrollDown()
{
	ClassPane.Scroll(ClassPane.GetMaxLines());
}

void BtnTileClass()
{
	ClassPane.SelClass(OBJCLASS_TILE);
}

void BtnCharacterClass()
{
	ClassPane.SelClass(OBJCLASS_CHARACTER);
}

void BtnWeaponClass()
{
	ClassPane.SelClass(OBJCLASS_WEAPON);
}

void BtnArmorClass()
{
	ClassPane.SelClass(OBJCLASS_ARMOR);
}

void BtnTalismanClass()
{
	ClassPane.SelClass(OBJCLASS_TALISMAN);
}

void BtnFoodClass()
{
	ClassPane.SelClass(OBJCLASS_FOOD);
}

void BtnLightSourceClass()
{
	ClassPane.SelClass(OBJCLASS_LIGHTSOURCE);
}

void BtnToolClass()
{
	ClassPane.SelClass(OBJCLASS_TOOL);
}

void BtnContainerClass()
{
	ClassPane.SelClass(OBJCLASS_CONTAINER);
}

void BtnExitClass()
{
	ClassPane.SelClass(OBJCLASS_EXIT);
}

void ObjDownCallback(S3DPoint pos)
{
	ClassPane.PutObject(pos);
}

void ObjDownAbortCallback()
{
	StatusBar.Delete();
}

BOOL TEditClassPane::Initialize()
{
	TButtonPane::Initialize();

	NewButton("T", GetWidth() - 16, 28, 16, 16, 0, BtnTileClass);
	NewButton("C", GetWidth() - 16, 44, 16, 16, 0, BtnCharacterClass);
	NewButton("W", GetWidth() - 16, 60, 16, 16, 0, BtnWeaponClass);
	NewButton("A", GetWidth() - 16, 76, 16, 16, 0, BtnArmorClass);
	NewButton("T", GetWidth() - 16, 92, 16, 16, 0, BtnTalismanClass);

	NewButton("F", GetWidth() - 32, 28, 16, 16, 0, BtnFoodClass);
	NewButton("L", GetWidth() - 32, 44, 16, 16, 0, BtnLightSourceClass);
	NewButton("T", GetWidth() - 32, 60, 16, 16, 0, BtnToolClass);
	NewButton("C", GetWidth() - 32, 76, 16, 16, 0, BtnContainerClass);
	NewButton("E", GetWidth() - 32, 92, 16, 16, 0, BtnExitClass);

	NewButton("=", GetWidth() - 32,  0, 32, 12, VK_F9, BtnMaximize);
	NewButton("/\\", GetWidth()-32, 12, 32, 16, VK_PRIOR, BtnScrollUp);
	NewButton("\\/", GetWidth()-32,108, 32, 16, VK_NEXT, BtnScrollDown);

	curobj = -1;
	curclass = OBJCLASS_TILE;
	firstobj = 0;
	maxlines = GetHeight() / THUMBNAILHEIGHT;
	accumulator = 0;
	thumbnails = NULL;
	clicked = FALSE;

	SetDirty(TRUE);
	return TRUE;
}

void TEditClassPane::Close()
{
	TButtonPane::Close();

	PSBitmapList nextptr;
	for ( ; thumbnails; thumbnails = nextptr)
	{
		nextptr = thumbnails->next;
		if (thumbnails->bm)
			delete thumbnails->bm;

		delete thumbnails;
	}
}

#define OBJWIDTH	(143 - 32)
#define OBJHEIGHT	(THUMBNAILHEIGHT)

void TEditClassPane::DrawBackground()
{
	TButtonPane::DrawBackground();

	if (IsDirty())
	{
		Display->SetClipRect(GetPosX(), GetPosY(), GetWidth() - 32, GetHeight());
		Display->Box(0, 0, GetWidth() - 32, GetHeight(), 0, 0xffff, 0, DM_BACKGROUND);

		PTObjectClass cl = TObjectClass::GetClass(curclass);
		if (cl)
		{
			int col = 0, lines = 0;
			for (int o = firstobj; o < cl->NumTypes() && lines < maxlines; o++)
			{
				PSObjectInfo inf = cl->GetObjType(o);
				if (!inf)
					continue;

				int x = col * OBJWIDTH, y = lines * OBJHEIGHT;

				if (o == curobj)
				{
					SColor color;
					color.red = color.green = 20; color.blue = 120;
					Display->Box(x, y, OBJWIDTH, OBJHEIGHT, TranslateColor(color), 0xffff, 0, DM_BACKGROUND);
				}

				PSImageryEntry ie = TObjectImagery::GetImageryEntry(inf->imageryid);

				if (ie)
				{
					PTBitmap tn = GetThumbnail(ie->filename);
					if (tn)
						Display->Put(x, y, tn, DM_TRANSPARENT | DM_BACKGROUND);
				}

				Display->WriteText(inf->name, x+THUMBNAILWIDTH+2, y);

				col++;
				if ((col * OBJWIDTH) > (GetWidth() - 32 - OBJWIDTH))
				{
					lines++;
					col = 0;
				}
			}
		}

		SetDirty(FALSE);
	}
}

void TEditClassPane::MouseClick(int button, int x, int y)
{
	TButtonPane::MouseClick(button, x, y);

	if (x >= (GetWidth() - 32))
		return;

	if (button == MB_LEFTDOWN)
	{
		curobj = ((y / OBJHEIGHT) * ((GetWidth() - 32) / OBJWIDTH)) + (x / OBJWIDTH) + firstobj;
		clicked = TRUE;
		PlayScreen.SetExclusivePane(&ClassPane);
		SetDirty(TRUE);
	}
	else if (button == MB_LEFTUP && clicked)
	{
		if (InPane(x, y))
		{
			curobj = ((y / OBJHEIGHT) * ((GetWidth() - 32) / OBJWIDTH)) + (x / OBJWIDTH) + firstobj;
			S3DPoint center;
			MapPane.GetMapPos(center);
			PutObject(center);
			MapPane.SetMode(&ObjDownCallback, &ObjDownAbortCallback, MODE_CLONE);
		}
		PlayScreen.ReleaseExclusivePane(&ClassPane);
		clicked = FALSE;
		scrollrate = 0;
	}
}

void TEditClassPane::MouseMove(int button, int x, int y)
{
	if (button == MB_LEFTDOWN && clicked)
	{
		if (y <= 0)
			scrollrate = -3;
		else if (y >= (GetHeight() - (GetHeight() % OBJHEIGHT) - 1))
			scrollrate = 3;
		else
		{
			scrollrate = 0;
			int oldcurobj = curobj;
			curobj = ((y / OBJHEIGHT) * ((GetWidth() - 32) / OBJWIDTH)) + (x / OBJWIDTH) + firstobj;
			if (curobj != oldcurobj)
				SetDirty(TRUE);
		}
	}
}

void TEditClassPane::Animate(BOOL draw)
{
	if (clicked && scrollrate)
	{
		if (accumulator++ >= absval(scrollrate))
		{
			accumulator = 0;
			Scroll(scrollrate > 0 ? 1 : -1);

			curobj = curobj % ((GetWidth() - 32) / OBJWIDTH);
			if (scrollrate < 0)
				curobj = firstobj + curobj;
			else
				curobj = firstobj + ((maxlines - 1) * ((GetWidth() - 32) / OBJWIDTH)) + curobj;
		}
	}
}

PTBitmap TEditClassPane::GetThumbnail(char *fname)
{
	strcpy(buf, TObjectImagery::GetImageryPath());

	if (strncmp(fname, "IMAGERY", 7) == 0)
		sprintf(buf, "%sthumbnail.%s", buf, fname + 8);
	else
	{
		int j = strlen(buf);
		while (*fname != '.' && *fname)
			buf[j++] = *fname++;
		buf[j++] = '.';
		buf[j++] = 't';
		buf[j++] = 'n';
		buf[j++] = 0;
	}

	PSBitmapList i, prev = NULL;
	for (i = thumbnails; i; prev = i, i = i->next)
		if (stricmp(buf, i->filename) == 0)
			return i->bm;

	// not found - load it in from disk
	PSBitmapList tn = new SBitmapList;
	strcpy(tn->filename, buf);

	//if (ImageryBox.BoxOpen)
	/*
	if (0)
	{
		int fh = ImageryBox.GetFileHandle(tn->filename + 9);

		if (fh != -1)
		{
			tn->bm = TBitmap::NewBitmap(THUMBNAILWIDTH, THUMBNAILHEIGHT, BM_8BIT | BM_PALETTE);
			read(fh, tn->bm->palette, 256 * sizeof(WORD));
			read(fh, tn->bm->data8, tn->bm->width * tn->bm->height);
			ConvertPal15to16(tn->bm);
		}
		else
			tn->bm = NULL;			// make a blank entry
	}
	else*/
	{
		char filename[MAX_PATH];

		sprintf(filename, "%s%s", ResourcePath, tn->filename);

		FILE *fp = fopen(filename, "rb");
		if (fp)
		{
			tn->bm = TBitmap::NewBitmap(THUMBNAILWIDTH, THUMBNAILHEIGHT, BM_8BIT | BM_PALETTE);
			fread(tn->bm->palette, 256, sizeof(WORD), fp);
			fread(tn->bm->data8, tn->bm->width * tn->bm->height, sizeof(BYTE), fp);
			ConvertPal15to16(tn->bm);
			fclose(fp);
		}
		else
			tn->bm = NULL;			// make a blank entry
	}

	tn->next = i;
	if (prev)
		prev->next = tn;
	else
		thumbnails = tn;

	return tn->bm;
}

int TEditClassPane::PutObject(S3DPoint pos)
{
	SObjectDef def;
	memset(&def, 0, sizeof(SObjectDef));

	def.objclass = curclass;
	def.objtype = curobj;
	def.level = MapPane.GetMapLevel();
	def.pos = pos;

	int index = MapPane.NewObject(&def);
	if (index < 0)
	{
		Console.Output("ERROR: Creating object\n");
		return -1;
	}

	StatusBar.Select(index);
	PTObjectInstance oi = MapPane.GetInstance(index);

	return index;
}

void TEditClassPane::Scroll(int lines)
{
	firstobj += (GetWidth() / OBJWIDTH) * lines;
	if (firstobj < 0)
		firstobj = 0;

	SetDirty(TRUE);
}


void TEditClassPane::SelectSame(int index)
{
	PTObjectInstance inst = MapPane.GetInstance(index);
	if (inst && (curclass != inst->ObjClass() || curobj != inst->ObjType()))
	{
		curclass = inst->ObjClass();
		curobj = inst->ObjType();
		if (firstobj > curobj || firstobj <= (curobj - maxlines))
		{
			firstobj = curobj - (maxlines / 2);
			if (firstobj < 0)
				firstobj = 0;
		}

		SetDirty(TRUE);
	}
}


//==============================================================================
//    Function : UpdateCGSFile.
//------------------------------------------------------------------------------
// Description : This open the appropriate CGS file (as specified by 'dir') and
//               see if the 'type' Imagery entry is already in the file.  If it
//               is, the entry will be replaced with the new 'graphicname',
//               keeping the flags intact.  If it is not in the file, a new
//               entry will be added to the end of the file.
//
//  Parameters : dir         = Name of the CGS file (and directory where the
//                             imagery is to be stored).
//
//               type        = Name of the type being added.
//
//               graphicname = Name of the graphic file used for the type.
//
//     Returns : If successful, returns TRUE, otherwise, returns FALSE.
//
//==============================================================================

BOOL UpdateCGSFile(char *dir, char *type, char *graphicname)
{
	char string[256];
	char cgsname[MAX_PATH];
	char cgsnewname[MAX_PATH];
	char cgsbakname[MAX_PATH];
	char *buf;
	char *l;
	char *p;
	int depth = 0;
	int len;
	long size;
	FILE *fp;
	BOOL done = FALSE;
	BOOL found = FALSE;

	// Determine which master CGS file to update
	sprintf(cgsname, "%s%s.CGS", ExileRCPath, dir);

	buf = (char *)LoadFile(cgsname, (void *)NULL, &size);

	// Create the New Name
	strcpy(cgsnewname, cgsname);
	p = strchr(cgsnewname, '.');
	if (p != NULL)
		*p = 0;
	strcat(cgsnewname, ".New");

	// Create the BAK Name
	strcpy(cgsbakname, cgsname);
	p = strchr(cgsbakname, '.');
	if (p != NULL)
		*p = 0;
	strcat(cgsbakname, ".Bak");

	// Try to open the file
	fp = TryOpen(cgsnewname, "w+b");

	// If the file didn't open, then return with failure
	if (fp == NULL)
		return FALSE;

	// Create the Imagery string that we're looking for
	sprintf(string, "IMAGERY \"%s\\%s.I2D\"", dir, type);
	len = strlen(string);

	l = buf;

	do
	{
		// See if we found IMAGERY "dir\name" at the beginning of the line
		if ((*(DWORD *)l == *(DWORD *)string) && (!strnicmp(l, string, len)))
		{
			found = TRUE;

			// Find the end of the line
			while ((*l != 10) && (*l != 13) && (l - buf < size))
				l++;
			// Move to the next line
			while (((*l == 10) || (*l == 13)) && (l - buf < size))
				l++;

			// Write everything up to and including the imagery name
			fwrite(buf, 1, l - buf, fp);

			do
			{
				p = l;

				// Skip any white space at the beginning of a line
				while (((*p == 9) || (*p == 32)) && (p - buf < size))
					p++;

				// Check for BEGIN, END, & NEXT Tokens
				if (!strnicmp(p, "BEGIN", 5))
				{
					depth++;
				}
				else
				if (!strnicmp(p, "END", 3))
				{
					depth--;
					if (depth <= 0)
						done = TRUE;
				}
				else
				if (!strnicmp(p, "NEXT", 4))
				{
				}
				else
				{
					// p probably points to a BITMAP, INVENTORY, or similar
					// token, so find the filename after the token
					while ((*p != '\"') && (p - buf < size))
						p++;
					p++;

					// Write out the line up until the file name
					fwrite(l, 1, p - l, fp);

					// Write out the new file name
					fwrite(graphicname, 1, strlen(graphicname), fp);

					// find the closing quote
					while ((*p != '\"') && (p - buf < size))
						p++;

					// Reset l to p so the code below will write out the
					// rest of line
					l = p;
				}

				// Find the end of the line
				while ((*p != 10) && (*p != 13) && (p - buf < size))
					p++;
				// Move to the next line
				while (((*p == 10) || (*p == 13)) && (p - buf < size))
					p++;

				// Write out the last line
				fwrite(l, 1, p - l, fp);

				l = p;
			} while (!done);

			// Write everything after the END of the imagery statements
			fwrite(l, 1, size - (l - buf), fp);

		}
		else
		{
			// Find the end of the line
			while ((*l != 10) && (*l != 13) && (l - buf < size))
				l++;
			// Move to the next line
			while (((*l == 10) || (*l == 13)) && (l - buf < size))
				l++;
			if (l - buf >= size)
				done = TRUE;
		}

	} while (!done);

	// If we didn't find the imagery entry, add it to the end of the CGS
	if (!found)
	{
		// Write the existing CGS file
		fwrite(buf, 1, size, fp);

		// Add on the new entry
		size = strlen(MakeRCImagery);
		fwrite(MakeRCImagery, 1, size, fp);

		sprintf(string, "\"%s\\%s.I2D\"\r\n", dir, type);
		size = strlen(string);
		fwrite(string, 1, size, fp);

		size = strlen(MakeRCBegin);
		fwrite(MakeRCBegin, 1, size, fp);

		size = strlen(MakeRCBitmap);
		fwrite(MakeRCBitmap, 1, size, fp);

		sprintf(string, "\"%s\" ", graphicname);
		size = strlen(string);
		fwrite(string, 1, size, fp);

		size = strlen(MakeRCFlags);
		fwrite(MakeRCFlags, 1, size, fp);

		size = strlen(MakeRCEnd);
		fwrite(MakeRCEnd, 1, size, fp);
	}

	fclose(fp);

	free(buf);

	// Delete the CGS.Bak file (if it exists)
	if (TryDelete(cgsbakname) == FALSE)
		return FALSE;

	// Rename the CGS file to the BAK file
	if (TryRename(cgsname, cgsbakname) == FALSE)
		return FALSE;

	// Rename the NEW file to CGS file
	if (TryRename(cgsnewname, cgsname) == FALSE)
		return FALSE;

	return TRUE;
}


//==============================================================================
//    Function : CmdAddRC.
//------------------------------------------------------------------------------
// Description : This will prompt the user for all the information needed to
//               add a new resource to the game. It then calls the resource
//               compiler to generate the new resource and adds it to the
//               appropriate object class.
//
//==============================================================================

#define MAX_NEW_RESOURCES 50
COMMAND(CmdAddRC)
{
	SNewRC rclist[MAX_NEW_RESOURCES];
	char name[MAX_PATH];
	char tmpcgsname[MAX_PATH];
	char string[256];
    char *p;
	int numrcs = 0;
	long size;
	FILE *fp;
	BOOL done = FALSE;
	BOOL proceed;
	PTObjectClass cl;

	// Create the temporary CGS file
	sprintf(tmpcgsname, "%sTmpRC%c%c%c.CGS", ExileRCPath, random(65, 90), random(65, 90), random(65, 90));
	if ((fp = fopen(tmpcgsname, "w+b")) == NULL)
		return 0;

	size = strlen(MakeRCInclude);
	fwrite(MakeRCInclude, 1, size, fp);

	fclose(fp);


	// -------------------------------------------------------------------------
	//                     Get the class that they are adding to
	// -------------------------------------------------------------------------

	do
	{
		Output("Which Class are you adding to ?\n");
		Output("[1]  Item         [2]  Weapon    [3]  Armor\n");
		Output("[4]  Talisman     [5]  Food      [6]  Container\n");
		Output("[7]  Light Source [8]  Tool      [9]  Money\n");
		Output("[10] Tile         [11] Exit      [12] Player\n");
		Output("[13] Character    [14] Trap      [15] Shadow\n");
		Output("[16] Helper       [17] Fireball  [18] Ice\n");
		Output("[19] Freeze       [20] Lightning [21] Hole\n");
		Output("[22] Ammo         [23] Scroll    [24] Ranged Weapon\n");
		Output("[25] Effect\n");
		Output("> ");
		if (TConsolePane::GetLine(name, MAX_PATH) == FALSE)
			return 0;
		// If they didn't enter anything, return immediately
		if (!name[0])
			return 0;
		rclist[numrcs].objclass = atoi(name);
	} while((rclist[numrcs].objclass < 1) || (rclist[numrcs].objclass > 25));
	rclist[numrcs].objclass--;



	// See if they are inputing a Tile
	if (rclist[numrcs].objclass == 9)
	{
		// ---------------------------------------------------------------------
		//               Get which tile set they are insert into
		// ---------------------------------------------------------------------

		do
		{
			Output("\nWhat Tile Set does it belong to ?\n");
			Output("[1]  Misc       [2]  Cave\n");
			Output("[3]  Dungeon    [4]  Forest\n");
			Output("[5]  Keep       [6]  Keep Interior\n");
			Output("[7]  Labyrinth  [8]  Ruin\n");
			Output("[9]  Swamp      [10] Wasteland\n");
			Output("[11] Town       [12] Town Interior\n");
			Output("> ");
			if (TConsolePane::GetLine(name, MAX_PATH) == FALSE)
				return 0;
			// If they didn't enter anything, return immediately
			if (!name[0])
				return 0;
			rclist[numrcs].set = atoi(name);
		} while((rclist[numrcs].set < 1) || (rclist[numrcs].set > 12));
		rclist[numrcs].set--;

        strcpy(rclist[numrcs].dir, RCTileDirs[rclist[numrcs].set]);
	}
	else
	{
		rclist[numrcs].set = 0;
        strcpy(rclist[numrcs].dir, RCClassDirs[rclist[numrcs].objclass]);
	}


	do
	{
		// Set the Object Class & Tile Set for the new resource so they are the
		// same as the first resource added
		rclist[numrcs].objclass = rclist[0].objclass;
		rclist[numrcs].set = rclist[0].set;
		strcpy(rclist[numrcs].dir, rclist[0].dir);


		// ---------------------------------------------------------------------
		//               Get the name of the object for the editor
		// ---------------------------------------------------------------------

		Output("\nName of Object Type (ie. WallSW) ?\n");
		Output("> ");
		if (TConsolePane::GetLine(rclist[numrcs].type, MAXNAMELEN) == FALSE)
			return 0;
		// If they didn't enter anything, return immediately
		if (!rclist[numrcs].type[0])
			return 0;

		// Add the tile set prefix (if any) to the beginning of the name
		if (rclist[numrcs].set)
		{
            sprintf(name, "%s%s", RCPrefixes[rclist[numrcs].set], rclist[numrcs].type);
			strcpy(rclist[numrcs].type, name);
		}


		// ---------------------------------------------------------------------
		//           See if that type name already exists in the class
		// ---------------------------------------------------------------------

		proceed = TRUE;
		cl = TObjectClass::GetClass(rclist[numrcs].objclass);

		if (cl)
		{
			if (cl->FindObjType(rclist[numrcs].type) != -1)
			{
				do
				{
					Output("\nThis Object Type already exists.\n");
					Output("Do you wish to overwrite it (Y/N) ?\n");
					Output("> ");

					if (TConsolePane::GetLine(string, 256) == FALSE)
						return 0;
					// If they didn't enter anything, return immediately
					if (!string[0])
						return 0;

					string[0] = toupper(string[0]);
				} while ((*string != 'Y') && (*string != 'N'));

				if (*string == 'N')
					proceed = FALSE;
			}
		}


		// Only proceed if the Object type wasn't in the class or it was in
		// the class and they want to overwrite it
		if (proceed)
		{
            proceed = FALSE;

            do
            {
                // -------------------------------------------------------------
                //        Get which file they are using for the imagery
                // -------------------------------------------------------------

                Output("\nName of the Graphic file (ie. File.BMP) ?\n");
                Output("> ");
                if (TConsolePane::GetLine(rclist[numrcs].graphic, MAXNAMELEN) == FALSE)
                    return 0;
                // If they didn't enter anything, return immediately
                if (!rclist[numrcs].graphic[0])
                    return 0;

                // Default to .BMP if there is no extension
                if (strchr(rclist[numrcs].graphic, '.') == NULL)
                    strcat(rclist[numrcs].graphic, ".BMP");

                // Add the directory to the beginning of the filename
                sprintf(name, "%s\\%s", rclist[numrcs].dir, rclist[numrcs].graphic);
                strcpy(rclist[numrcs].graphic, name);


                // -------------------------------------------------------------
                //       See if the files exists in the source directory
                // -------------------------------------------------------------

                // Check for the Graphic file
                sprintf(string, "%s%s", ExileRCPath, rclist[numrcs].graphic);
                if (!FileExists(string))
                {
                    do
                    {
                        Output("\nThe specified file name does not exist.\n");
                        Output("Do you wish to re-enter it (Y/N) ?\n");
                        Output("> ");

                        if (TConsolePane::GetLine(string, 256) == FALSE)
                            return 0;
                        // If they didn't enter anything, return immediately
                        if (!string[0])
                            return 0;

                        string[0] = toupper(string[0]);
                    } while ((*string != 'Y') && (*string != 'N'));

                    if (*string == 'N')
                        break;
                }
                else
                {
                    // Check for the Z Buffer file
                    strcpy(name, string);
                    p = strchr(name, '.');
                    strcpy(p, ".ZBF");
                    p = strchr(string, '.');
                    strcpy(p, ".ZPIC");

                    if ((FileExists(name)) || (FileExists(string)))
                        proceed = TRUE;
                    else
                    {
                        do
                        {
                            Output("\nCannot find the matching Z buffer file.\n");
                            Output("Do you wish to re-enter it (Y/N) ?\n");
                            Output("> ");

                            if (TConsolePane::GetLine(string, 256) == FALSE)
                                return 0;
                            // If they didn't enter anything, return immediately
                            if (!string[0])
                                return 0;

                            string[0] = toupper(string[0]);
                        } while ((*string != 'Y') && (*string != 'N'));

                        if (*string == 'N')
                            break;
                    }
                }
            } while (!proceed);


            if (proceed)
            {
                // -------------------------------------------------------------
                //                  Write the TempRC CGS file
                // -------------------------------------------------------------

                if ((fp = fopen(tmpcgsname, "ab")) == NULL)
                    return 0;

                size = strlen(MakeRCImagery);
                fwrite(MakeRCImagery, 1, size, fp);

                sprintf(string, "\"%s\\%s.I2D\"\r\n", rclist[numrcs].dir, rclist[numrcs].type);
                size = strlen(string);
                fwrite(string, 1, size, fp);

                size = strlen(MakeRCBegin);
                fwrite(MakeRCBegin, 1, size, fp);

                size = strlen(MakeRCBitmap);
                fwrite(MakeRCBitmap, 1, size, fp);

                sprintf(string, "\"%s\" ", rclist[numrcs].graphic);
                size = strlen(string);
                fwrite(string, 1, size, fp);

                size = strlen(MakeRCFlags);
                fwrite(MakeRCFlags, 1, size, fp);

                size = strlen(MakeRCEnd);
                fwrite(MakeRCEnd, 1, size, fp);

                fclose(fp);
            }
		}


        // Only increment the number of resources added if they didn't abort out above
        if (proceed)
            numrcs++;

		// ---------------------------------------------------------------------
		//                See if they want to add another resource
		// ---------------------------------------------------------------------

        if (numrcs < MAX_NEW_RESOURCES)
		{
			do
			{
				Output("\nDo you want to add another resource (Y/N) ?\n");
				Output("> ");

				if (TConsolePane::GetLine(string, 256) == FALSE)
					return 0;
				// If they didn't enter anything, return immediately
				if (!string[0])
					return 0;

				string[0] = toupper(string[0]);
			} while ((*string != 'Y') && (*string != 'N'));

			if (*string == 'Y')
				Output("\n");
			else
				done = TRUE;
		}
		else
			done = TRUE;

	} while (!done);




	// ---------------------------------------------------------------------
	//                      Compile the TempRC CGS file
	// ---------------------------------------------------------------------

    if (numrcs)
    {
        Output("Compiling resource...");

        STARTUPINFO StartUpInfo;
        PROCESS_INFORMATION ProcessInfo;

        // Setup the StartUpInfo struct
        memset(&StartUpInfo, 0, sizeof(STARTUPINFO));
        StartUpInfo.cb = sizeof(STARTUPINFO);
        StartUpInfo.dwFlags = STARTF_USESHOWWINDOW;
        StartUpInfo.wShowWindow = SW_HIDE;

        // Create the command line
        sprintf(string, "%sExileRC.EXE %s %s%s normals false",
            ExileRCPath, tmpcgsname, ResourcePath, NONORMALPATH);

        // Run ExileRC to create the new resource
        CreateProcess(
            NULL,
            string,
            NULL,
            NULL,
            FALSE,
            HIGH_PRIORITY_CLASS,
            NULL,
            ExileRCPath,
            &StartUpInfo,
            &ProcessInfo);

        // Wait for ExileRC to finish
        WaitForSingleObject(ProcessInfo.hProcess, INFINITE);

        // Delete the TempRC.CGS file
        remove(tmpcgsname);

        Output("Done.\n");
    }


	// -------------------------------------------------------------------------
	//                     Add the new types to their classes
	// -------------------------------------------------------------------------

    for (int n = 0; n < numrcs; n++)
	{
		// Update the appropriate master CGS file
		UpdateCGSFile(rclist[n].dir, rclist[n].type, rclist[n].graphic);

		cl = TObjectClass::GetClass(rclist[n].objclass);

		if (cl)
		{
			// See if the Object Type already exists
			int objtype = cl->FindObjType(rclist[n].type);
			if (objtype != -1)
            {
				// Object Type already exists, so just change the imagery file name

				// Create the filename of the imagery to use
				sprintf(name, "%s\\%s.I2D", rclist[n].dir, rclist[n].type);

                // Rename the imagery file name to the new name
				TObjectImagery::RenameImageryFile(cl->GetObjType(objtype)->imageryid, name);

				for (int i = 0; i < cl->NumStats(); i++)
					cl->ResetStat(objtype, i);

				sprintf(buf, "Type %s updated in class %s.\n", rclist[n].type, cl->ClassName());
				Output(buf);
            }
            else
            {
                // Create the filename of the imagery to use
                sprintf(name, "%s\\%s.I2D", rclist[n].dir, rclist[n].type);

                objtype = cl->AddType(rclist[n].type, name, 0);
                if (objtype < 0)
                    Output("ERROR: Adding object type\n");
                else
                {
                    for (int i = 0; i < cl->NumStats(); i++)
                        cl->ResetStat(objtype, i);
                    sprintf(buf, "New type %s added to class %s.\n", rclist[n].type, cl->ClassName());
                    Output(buf);
                }
            }
		}
	}

	return 0;
}


//==============================================================================
//    Function : CmdDeleteRC.
//------------------------------------------------------------------------------
// Description : This will prompt the user for all the information needed to
//               delete a resource from the game.
//
//==============================================================================

COMMAND(CmdDeleteRC)
{
	char name[MAX_PATH];
    char imageryfilename[MAX_PATH];
	char string[256];
    char *p;
    int classnum;
    int objtype;
	PTObjectClass cl;

	// -------------------------------------------------------------------------
    //                  Get the class that they are deleting from
	// -------------------------------------------------------------------------

	do
	{
        Output("Which Class are you deleting from ?\n");
		Output("[1]  Item         [2]  Weapon    [3]  Armor\n");
		Output("[4]  Talisman     [5]  Food      [6]  Container\n");
		Output("[7]  Light Source [8]  Tool      [9]  Money\n");
		Output("[10] Tile         [11] Exit      [12] Player\n");
		Output("[13] Character    [14] Trap      [15] Shadow\n");
		Output("[16] Helper       [17] Fireball  [18] Ice\n");
		Output("[19] Freeze       [20] Lightning [21] Hole\n");
		Output("[22] Ammo         [23] Scroll    [24] Ranged Weapon\n");
		Output("[25] Effect\n");
		Output("> ");
		if (TConsolePane::GetLine(name, MAX_PATH) == FALSE)
			return 0;
		// If they didn't enter anything, return immediately
		if (!name[0])
			return 0;
        classnum = atoi(name);
    } while((classnum < 1) || (classnum > 25));
    classnum--;
    cl = TObjectClass::GetClass(classnum);

    if (cl)
    {
        // ---------------------------------------------------------------------
        //            Get the name of the resource they are deleting
        // ---------------------------------------------------------------------

        BOOL done = FALSE;
        do
        {
            Output("Enter the name of the resource to delete ?\n");
            Output("> ");
            if (TConsolePane::GetLine(name, MAX_PATH) == FALSE)
                return 0;
            // If they didn't enter anything, return immediately
            if (!name[0])
                return 0;

            // See if the resource exists
            objtype = cl->FindObjType(name);
            if (objtype == -1)
            {
                do
                {
                    Output("\nThe specified resource does not exist.\n");
                    Output("Do you wish to re-enter it (Y/N) ?\n");
                    Output("> ");

                    if (TConsolePane::GetLine(string, 256) == FALSE)
                        return 0;
                    // If they didn't enter anything, return immediately
                    if (!string[0])
                        return 0;

                    string[0] = toupper(string[0]);
                } while ((*string != 'Y') && (*string != 'N'));

                if (*string == 'N')
                    return 0;
            }
            else
                done = TRUE;
        } while (!done);


        // Get the imagery file name so we can remove it later
        strcpy(imageryfilename, cl->GetObjType(objtype)->imagery->GetResFilename());

        cl->RemoveType(objtype);

        // ---------------------------------------------------------------------
        //                       Remove the imagery files
        // ---------------------------------------------------------------------

        // See if they are deleting from the Tile class
        if (classnum == 9)
        {
            // Find which tile set they are deleting from
            name[0] = 0;
            for (int n = 0; n < 12; n++)
                if (!strnicmp(imageryfilename, RCPrefixes[n], 3))
                    sprintf(name, "%s%s\\%s", ResourcePath, RCTileDirs[n], imageryfilename);
            if (name[0] == 0)
            {
                Output("\nCould not determine graphics path.\n");
                Output("\nImagery files were not deleted.\n");
                return 0;
            }
        }
        else
            sprintf(name, "%s%s\\%s", ResourcePath, RCClassDirs[classnum], imageryfilename);

        // Add the I2D extension if there wasn't one
        if (strchr(name, '.') == NULL)
            strcat(name, ".I2D");
        remove(name);

        // Now remove the thumbnail
        p = strchr(name, '.');
        *p = 0;
        strcat(name, ".TN");
        remove(name);

    }

	return 0;
}


//==============================================================================
//    Function : CmdDeleteRC.
//------------------------------------------------------------------------------
// Description : This function saves the imagery for a tile into a BMP and ZBF 
//				 file.
//==============================================================================

COMMAND(CmdSaveTileBM)
{
	char filename[FILENAMELEN];
	char exists[FILENAMELEN];
	char buf[80];

	if (!context)
		return 0;

	char *objname = context->GetTypeName();

	for (int rctype = 0; rctype < NUMRCDIRS; rctype++)
	{
		if (!strnicmp(objname, RCPrefixes[rctype], 3))
			break;
	}
	if (rctype >= NUMRCDIRS)
		rctype = 0;

	sprintf(filename, "%s%s\\%s", ExileRCPath, RCTileDirs[rctype], context->GetTypeName());

  // Does file exist?
	strcpy(exists, filename);
	strcat(exists, ".BMP");
	FILE *f = fopen(exists, "rb");
	if (f)
	{
		fclose(f);
		sprintf(buf, "%s already exists.. Overwrite (Y/N)\n"
		        "> ", exists);
		Output(buf);
		char string[256];
        if (TConsolePane::GetLine(string, 256) == FALSE)
            return 0;
		if (!(string[0] == 'y' || string[0] == 'Y'))
			return 0;
	}

	if (context->GetImagery()->SaveBitmap(filename, 0, TRUE))
		sprintf(buf, "%s.BMP successfully saved.\n", filename);
	else
		sprintf(buf, "Error writing %s.BMP!\n", filename);

	Output(buf);

	return 0;
}
// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                     effect.cpp - TEffect module                       *
// *************************************************************************

#include <windows.h>
#include <ddraw.h>
#include <d3d.h>
#include <d3drmwin.h>
#include <math.h>
#include "d3dmacs.h"
#include "d3dmath.h"

#include "revenant.h"
#include "effect.h"
#include "mappane.h"	   
#include "character.h"
#include "statusbar.h"
#include "MissileEffect.H"
#include "StripEffect.H"
#include "food.h"
#include "textbar.h"

DWORD SaveBlendMode;
DWORD SaveZWriteEnable;
DWORD SaveZEnable;
DWORD SaveCullMode;

void RestoreZ(int x, int y, int width, int height)
{
	SRect r;

	r.left = x;
	r.top = y;
	r.right = x + width - 1;
	r.bottom = y + height - 1;
	Scene3D.RestoreZBuffer(r);
}


//==============================================================================
//    Function : SaveBlendState.
//------------------------------------------------------------------------------
// Description : This saves the current states of several of the 3DRenderState
//               settings which are modified by the Effects animators.
//==============================================================================

BOOL SaveBlendState()
{
	TRY_D3D(Scene3D.GetRenderState(D3DRENDERSTATE_TEXTUREMAPBLEND, &SaveBlendMode));
	TRY_D3D(Scene3D.GetRenderState(D3DRENDERSTATE_ZWRITEENABLE, &SaveZWriteEnable));
	TRY_D3D(Scene3D.GetRenderState(D3DRENDERSTATE_ZENABLE, &SaveZEnable));
	TRY_D3D(Scene3D.GetRenderState(D3DRENDERSTATE_CULLMODE, &SaveCullMode));

	return TRUE;
}

//==============================================================================
//    Function : RestoreBlendState.
//------------------------------------------------------------------------------
// Description : This restores the render states that were previously saved
//               by SaveBlendState.
//==============================================================================

BOOL RestoreBlendState()
{
	TRY_D3D(Scene3D.SetRenderState(D3DRENDERSTATE_TEXTUREMAPBLEND, SaveBlendMode));
	TRY_D3D(Scene3D.SetRenderState(D3DRENDERSTATE_ZWRITEENABLE, SaveZWriteEnable));
	TRY_D3D(Scene3D.SetRenderState(D3DRENDERSTATE_ZENABLE, SaveZEnable));
	TRY_D3D(Scene3D.SetRenderState(D3DRENDERSTATE_CULLMODE, SaveCullMode));

	return TRUE;
}

//==============================================================================
//    Function : SetBlendState.
//------------------------------------------------------------------------------
// Description : This sets several of the render states settings to values used
//               by most of the Effect animatiors.  This will need to be
//               modified to set the appropriate settings depending on the
//               capabilities of the users 3D card.
//==============================================================================

BOOL SetBlendState()
{
	TRY_D3D(Scene3D.SetRenderState(D3DRENDERSTATE_TEXTUREMAPBLEND, D3DTBLEND_DECAL));
	TRY_D3D(Scene3D.SetRenderState(D3DRENDERSTATE_ZWRITEENABLE, FALSE));
	TRY_D3D(Scene3D.SetRenderState(D3DRENDERSTATE_ZENABLE, TRUE));
	//if (D3DHWCaps == "FIRE GL 1000")
	//{
//	TRY_D3D(Scene3D.SetRenderState(D3DRENDERSTATE_TEXTUREMAPBLEND, D3DTBLEND_DECALALPHA));
//	TRY_D3D(Scene3D.SetRenderState(D3DRENDERSTATE_TEXTUREMAPBLEND, D3DTBLEND_INVSCRALPHA));
	//}

	return TRUE;
}

BOOL SetAddBlendState()
{
	TRY_D3D(Scene3D.SetRenderState(D3DRENDERSTATE_TEXTUREMAPBLEND, D3DTBLEND_DECALALPHA));
	TRY_D3D(Scene3D.SetRenderState(D3DRENDERSTATE_ZWRITEENABLE, FALSE));
	TRY_D3D(Scene3D.SetRenderState(D3DRENDERSTATE_SRCBLEND, D3DBLEND_ONE));
	TRY_D3D(Scene3D.SetRenderState(D3DRENDERSTATE_DESTBLEND, D3DBLEND_ONE));
	TRY_D3D(Scene3D.SetRenderState(D3DRENDERSTATE_ZENABLE, TRUE));

	return TRUE;
}

// Utility function for hurting folks (could probably be a lot better, but this will do for now)
void DamageCharactersInRange(PTObjectInstance invoker, RS3DPoint pos, int range, int minamount, int maxamount, int type)
{
	int targets[MAXFOUNDOBJS];
	int num = MapPane.FindObjectsInRange(pos, targets, range, 0, OBJCLASS_CHARACTER);
	for (int i = 0; i < num; i++) 
	{
		PTObjectInstance inst = MapPane.GetInstance(targets[i]);
		if (inst && inst != invoker)
			inst->Damage(random(minamount, maxamount), type);
	}
}

// Utility function for hurting folks (could probably be a lot better, but this will do for now)
void BlastCharactersInRange(PTObjectInstance invoker, RS3DPoint pos, int range, int minamount, int maxamount, int type, int angle, int speed)
{
	int targets[MAXFOUNDOBJS];
	int num = MapPane.FindObjectsInRange(pos, targets, range, 0, OBJCLASS_CHARACTER);
	for (int i = 0; i < num; i++) 
	{
		PTObjectInstance inst = MapPane.GetInstance(targets[i]);
		S3DPoint guy_pos;
		inst->GetPos(guy_pos);
		PulpGuy((PTCharacter)inst, guy_pos, pos);
	}
}

void PulpGuy(PTCharacter ch, S3DPoint pos, S3DPoint blast)
{
	S3DPoint vel;

	vel.x = pos.x - blast.x;
	vel.x /= 4;
	vel.y = pos.y - blast.y;
	vel.y /= 4;
	vel.z = pos.z - blast.z;
	vel.z = random(7, 12);

	int count = random(6, 16);
	ch->Pulp(vel, count, count * 30);
}

TObjectClass EffectClass("EFFECT", OBJCLASS_EFFECT, 0);
extern TObjectClass TileClass;

// ***********
// * TEffect *
// ***********

DEFINE_BUILDER("effect", TEffect)
REGISTER_BUILDER(TEffect)

void TEffect::Pulse()
{
	TObjectInstance::Pulse();

	if (commanddone)
		KillThisEffect();
}

void TEffect::KillThisEffect()
{
	if (spell)
	{
		spell->EffectDied();	// signal death of this effect to parent spell
		flags |= OF_KILL | OF_PULSE;// flag it for deletion next frame
	}
}

int TEffect::GetAngle()
{
	S3DPoint targetpos;
	PTObjectInstance invoker = spell->GetInvoker();
	PTObjectInstance target = spell->GetTarget();

	if ((target == NULL) || (target == invoker))
		angle = invoker->GetFace();
	else
	{
		target->GetPos(targetpos);
		// Aim the missile (in the X Y plane)
		angle = ConvertToFacing(pos, targetpos);
	}

	return angle;
}

// ***************
// * TFireEffect *
// ***************

DEFINE_BUILDER("fire", TFireEffect)
REGISTER_BUILDER(TFireEffect)

void TFireEffect::Pulse()
{
	TObjectInstance::Pulse();

	// since the fire effect doesn't set commanddone properly,
	// just use a random value for now
	if (spell)
	{
		if (random(0, 42) == 0)
		{
			DamageCharactersInRange(spell->GetInvoker(), pos, 80, 0, spell->GetPower() + spell->GetFire() / 8, DAMAGE_FIRE);
			KillThisEffect();
		}
	}
}

// **************
// * TIceEffect *
// **************

DEFINE_BUILDER("ice", TIceEffect)
REGISTER_BUILDER(TIceEffect)

void TIceEffect::Pulse()
{
	TObjectInstance::Pulse();

	if (spell)
	{
		pos.x += ICERATE;
		pos.y -= ICERATE;
		pos.z -= ICERATE;

		if (pos.z < MapPane.GetWalkHeight(pos))
		{
			if (spell)
					DamageCharactersInRange(spell->GetInvoker(), pos, 24, 0, spell->GetPower() + spell->GetIce() / 8, DAMAGE_ICE);

			if (state == ICE_FLY)
				SetState(ICE_IMPACT);
			else if (commanddone)
				KillThisEffect();
		}
	}
}

//*// ********************
//*// * TLightningEffect *
//*// ********************
//*
//*DEFINE_BUILDER("lightning", TLightningEffect)
//*REGISTER_BUILDER(TLightningEffect)
//*
//*void TLightningEffect::Pulse()
//*{
//*	TEffect::Pulse();
//*
//*	if (spell)
//*	{
//*		if (commanddone)
//*			DamageCharactersInRange(spell->GetInvoker(), pos, 90, 0, spell->GetPower() + spell->GetLightning() / 8, DAMAGE_LIGHTNING);
//*	}
//*
//*	if (firsttime)
//*	{
//*		firsttime = FALSE;
//*		SoundPlayer.Play(LIGHTNING_SOUND);
//*	}
//*}

// ***************
// * THealEffect *
// ***************

DEFINE_BUILDER("Heal", THealEffect)
REGISTER_BUILDER(THealEffect)

void THealEffect::Initialize()
{
}

void THealEffect::Pulse()
{
	TObjectInstance::Pulse();

	if ((spell) && (commanddone))
		KillThisEffect();
}

//*// *********************
//*// * TLightning2Effect *
//*// *********************
//*
//*DEFINE_BUILDER("lightning2", TLightning2Effect)
//*REGISTER_BUILDER(TLightning2Effect)
//*
//*void TLightning2Effect::Pulse()
//*{
//*	TObjectInstance::Pulse();
//*
//*	// Get the targets position
//*	S3DPoint targetpos;
//*
//*	spell->GetTarget()->GetPos(targetpos);
//*
//*	// Aim the missile (in the X Y plane)
//*	angle = ConvertToFacing(pos, targetpos);
//*	ConvertToVector(angle, 16 * ROLLOVER, vel);
//*	vel.z = (16 * ROLLOVER) / -3;
//*
//*	if ((spell) && (commanddone))
//*		KillThisEffect();
//*}

// ***************
// * TSpellBlock *
// ***************

BOOL TSpellBlock::Pulse(BOOL kill)
{
//	int	t;

	if (kill)
		return (numeffects < 1);

	SObjectDef def;
	memset(&def, 0, sizeof(SObjectDef));
	def.objclass = OBJCLASS_EFFECT;
	def.objtype = -1;
	def.level = MapPane.GetMapLevel();

	// Other spell types:
	//	def.objtype = EffectClass.FindObjType("lightning2");
	if (numeffects > 0)
		return FALSE;


    if (power == 0)	// Spell 1 - WindStrip
    {
		//PLAY("call lightning");
		PTStripEffect effect;
		S3DPoint pos;
        invoker->GetPos(pos);
        pos.z += 70;
		def.pos = pos;
		def.facing = invoker->GetFace();
        def.objtype = EffectClass.FindObjType("icebolt");

		effect = (PTStripEffect)MapPane.GetInstance(MapPane.NewObject(&def));
		effect->SetSpell(this);
		effect->SetSubSpell(3);
		numeffects++;
		/*def.objtype = EffectClass.FindObjType("halo");
		def.pos.z -= 50;
		effect = (PTStripEffect)MapPane.GetInstance(MapPane.NewObject(&def));
		effect->SetSpell(this);
		((PTHaloEffect)effect)->InitParams(100, (float)0.3);
		numeffects++;*/

        return FALSE;
    }

    if (power == 1)
    {
//		PLAY("call heal");
		PTEffect effect;
		S3DPoint pos;
        invoker->GetPos(pos);

		//for (int i = 0; i < 5; i++)
		{
			def.pos = pos;
			def.pos.z += 5;
			def.pos.y -= 100;
			def.pos.x -= 100;
			def.objtype = EffectClass.FindObjType("ripple");
			def.facing = 0;

			effect = (PTEffect)MapPane.GetInstance(MapPane.NewObject(&def));
			if (!effect)
				return FALSE;
			//effect->SetSpell(this);
			((PTRippleEffect)effect)->SetLength(64);
			numeffects++;
		}

        return FALSE;
    }

    if (power == 2)
    {
//		PLAY("call heal");
		PTEffect effect;
		S3DPoint pos;
        invoker->GetPos(pos);
		pos.z += 0;
		def.pos = pos;
		def.objtype = EffectClass.FindObjType("tornado");
		def.facing = invoker->GetFace();

		effect = (PTEffect)MapPane.GetInstance(MapPane.NewObject(&def));
		if (!effect)
			return FALSE;
		effect->SetSpell(this);
		effect->SetSubSpell(0);
		numeffects++;

        return FALSE;
    }

    if (power == 3)
    {
//		PLAY("call heal");
		PTEffect effect;
		S3DPoint pos;
        invoker->GetPos(pos);
		//pos.x = 0; pos.y = 0; pos.z = 0;
		def.pos = pos;
        def.objtype = EffectClass.FindObjType("Streamer");
		//def.facing = invoker->GetFace();
		def.facing = 0;

		effect = (PTEffect)MapPane.GetInstance(MapPane.NewObject(&def));
		if (!effect)
			return FALSE;
		effect->SetSpell(this);
		numeffects++;

        return FALSE;
    }

    if (power == 4)
    {
//		PLAY("call heal");
		PTEffect effect;
		S3DPoint pos;
        invoker->GetPos(pos);
		def.pos = pos;
		def.pos.z += 100;
        def.objtype = EffectClass.FindObjType("firecone");
		def.facing = invoker->GetFace();

		effect = (PTEffect)MapPane.GetInstance(MapPane.NewObject(&def));
		if (!effect)
			return FALSE;
		effect->SetSpell(this);
		numeffects++;

        return FALSE;
    }


#define FROST_HEIGHT 70
    if (power == 5)	// Spell 3 - Ice Bolt
    {
		PTEffect effect;
		S3DPoint pos;
        invoker->GetPos(pos);
		def.pos = pos;
        def.objtype = EffectClass.FindObjType("createfood");
		def.facing = invoker->GetFace();

		effect = (PTEffect)MapPane.GetInstance(MapPane.NewObject(&def));
		effect->SetSpell(this);
		//effect->SetSubSpell(3);
		numeffects++;

        return FALSE;
    }

	if (power == 6)	// Spell 4 - Quicksand
    {
//		PLAY("call heal");
		PTEffect effect;
		S3DPoint pos;
        invoker->GetPos(pos);
		
		//pos.z += 20;
		def.pos = pos;
		def.pos.z += 100;
        def.objtype = EffectClass.FindObjType("fireball");
		def.facing = 0;

		effect = (PTEffect)MapPane.GetInstance(MapPane.NewObject(&def));
		if (!effect)
			return FALSE;
		effect->SetSpell(this);
		numeffects++;

        return FALSE;
    }

	// determine which effects to use based on the spell's elemental properties
	if (power == 7)
	{
//		PLAY("call heal");
		PTEffect effect;
		S3DPoint pos;
        invoker->GetPos(pos);
		
		//pos.z += 20;
		def.pos = pos;
        def.objtype = EffectClass.FindObjType("cure");
		def.facing = invoker->GetFace();

		effect = (PTEffect)MapPane.GetInstance(MapPane.NewObject(&def));
		if (!effect)
			return FALSE;
		effect->SetSpell(this);
		numeffects++;

        return FALSE;
	}

	// determine which effects to use based on the spell's elemental properties
	if (power == 8)
	{
//		PLAY("call heal");
		PTEffect effect;
		S3DPoint pos;
        invoker->GetPos(pos);
		
		//pos.z += 20;
		def.pos = pos;
        def.objtype = EffectClass.FindObjType("firewind");
		def.facing = invoker->GetFace();

		effect = (PTEffect)MapPane.GetInstance(MapPane.NewObject(&def));
		if (!effect)
			return FALSE;
		effect->SetSpell(this);
		numeffects++;

        return FALSE;
	}

	// determine which effects to use based on the spell's elemental properties
	if (power == 9)
	{
//		PLAY("call heal");
		PTEffect effect;
		S3DPoint pos;
        invoker->GetPos(pos);
		
		//pos.z += 20;
		def.pos = pos;
        def.objtype = EffectClass.FindObjType("heal");
		def.facing = invoker->GetFace();

		effect = (PTEffect)MapPane.GetInstance(MapPane.NewObject(&def));
		if (!effect)
			return FALSE;
		effect->SetSpell(this);
		numeffects++;

        return FALSE;
	}


	// determine which effects to use based on the spell's elemental properties
	if (power == 10)
	{
//		PLAY("call heal");
		PTEffect effect;
		S3DPoint pos;
        invoker->GetPos(pos);
		
		//pos.z += 20;
		def.pos = pos;
		def.pos.z += 100;
        def.objtype = EffectClass.FindObjType("lightstrip");
		def.facing = invoker->GetFace();

		effect = (PTEffect)MapPane.GetInstance(MapPane.NewObject(&def));
		if (!effect)
			return FALSE;
		effect->SetSpell(this);
		numeffects++;

        return FALSE;
	}

	// determine which effects to use based on the spell's elemental properties
	if (power == 11)
	{
//		PLAY("call heal");
		PTEffect effect;
		S3DPoint pos;
        invoker->GetPos(pos);
		
		//pos.z += 20;
		def.pos = pos;
		def.pos.z += 100;
        def.objtype = EffectClass.FindObjType("meteorstorm");
		def.facing = invoker->GetFace();

		effect = (PTEffect)MapPane.GetInstance(MapPane.NewObject(&def));
		if (!effect)
			return FALSE;
		effect->SetSpell(this);
		numeffects++;

        return FALSE;
	}

	// determine which effects to use based on the spell's elemental properties
	if (power == 12)
	{
//		PLAY("call heal");
		PTEffect effect;
		S3DPoint pos;
        invoker->GetPos(pos);
		
		//pos.z += 20;
		def.pos = pos;
        def.objtype = EffectClass.FindObjType("fireflash");
		def.facing = invoker->GetFace();

		effect = (PTEffect)MapPane.GetInstance(MapPane.NewObject(&def));
		if (!effect)
			return FALSE;
		effect->SetSpell(this);
		numeffects++;

        return FALSE;
	}

	power = -1; // Don't create more spells!

  	return FALSE;
}

REGISTER_3DANIMATOR("Sphere", TTest3DAnimator)

void TTest3DAnimator:: Initialize()
{
	T3DAnimator::Initialize();

	for (int c = 0; c < NUMPARTICLES; c++)
	{
		p[c].x = p[c].y = p[c].z = (D3DVALUE)0;
		v[c].x = v[c].y = v[c].z = (D3DVALUE)0;
	}
}

//void TTest3DAnimator::SetupObjects()
//{
//	T3DAnimator::SetupObjects(); // Don't change
//}

void TTest3DAnimator::Animate(BOOL draw)
{
	T3DAnimator::Animate(draw);

	PS3DAnimObj obj = GetObject(0);

	for (int c = 0; c < 10; c++)
	{
		if (p[c].z <= 0)
		{
			p[c].z = 0;
			v[c].z = -v[c].z * (D3DVALUE)0.5;
			if (abs(v[c].z) < (D3DVALUE)0.4)
			{
				p[c].x = p[c].y = p[c].z = (D3DVALUE)0;
				v[c].x = (D3DVALUE)(random(0,6) - (D3DVALUE)3) / (D3DVALUE)2.0;
				v[c].y = (D3DVALUE)(random(0,6) - (D3DVALUE)3) / (D3DVALUE)2.0;
				v[c].z = (D3DVALUE)random(5,8);

				Get3DImagery()->GetMaterial(0, &mat[c]);

				D3DMATERIAL &m = mat[c].matdesc;
				m.ambient.r = D3DVAL(random(0,255)) / (D3DVALUE)255.0;
				m.ambient.g = D3DVAL(random(0,255)) / (D3DVALUE)255.0;
				m.ambient.b = D3DVAL(random(0,255)) / (D3DVALUE)255.0;
				m.ambient.a = D3DVAL(1.0); //random(0,255)) / (D3DVALUE)255.0;
				m.diffuse.r = m.ambient.r;
				m.diffuse.g = m.ambient.g;
				m.diffuse.b = m.ambient.b;
				m.diffuse.a = m.ambient.a;
				m.specular.r = D3DVAL(1.0);
				m.specular.g = D3DVAL(1.0);
				m.specular.b = D3DVAL(1.0);
				m.specular.a = D3DVAL(1.0);
				m.power = D3DVAL(4.0);
				m.dwRampSize = 16;
			}
		}
		v[c].z -= (D3DVALUE)0.5;

		p[c].x += v[c].x;
		p[c].y += v[c].y;
		p[c].z += v[c].z;
	}
}

BOOL TTest3DAnimator::Render()
{
	PS3DAnimObj obj = GetObject(0);

	for (int c = 0; c < 10; c++)
	{
		ResetExtents();				// Reset render extents

		obj->flags |= OBJ3D_SCL1 | OBJ3D_POS2;
		obj->scl.x = obj->scl.y = obj->scl.z = (D3DVALUE)0.4;
		obj->pos = p[c];

		Get3DImagery()->SetMaterial(0, &mat[c]);

		RenderObject(obj);

		UpdateExtents();			// Updates screen rect and bound rect
	}

	return TRUE;
}

// ******************
// * Flare Animator *
// ******************

REGISTER_3DANIMATOR("Flare", TFlareAnimator)

void TFlareAnimator::Initialize()
{
	T3DAnimator::Initialize();

	for (int c = 0; c < NUMFLARES; c++)
	{
		p[c].x = p[c].y = p[c].z = (D3DVALUE)0;
		v[c].x = v[c].y = v[c].z = (D3DVALUE)0;
	}

	Get3DImagery()->GetMaterial(0, &mat[0]);

	D3DMATERIAL &m = mat[0].matdesc;
	m.ambient.r = D3DVAL(0.0);
	m.ambient.g = D3DVAL(0.0);
	m.ambient.b = D3DVAL(0.0);
	m.ambient.a = D3DVAL(0.0);
	m.diffuse.r = D3DVAL(0.0);
	m.diffuse.g = D3DVAL(0.0);
	m.diffuse.b = D3DVAL(0.0);
	m.diffuse.a = D3DVAL(0.0);
	m.specular.r = D3DVAL(0.0);
	m.specular.g = D3DVAL(0.0);
	m.specular.b = D3DVAL(0.0);
	m.specular.a = D3DVAL(0.0);
	m.emissive.r = D3DVAL(0.0);
	m.emissive.g = D3DVAL(0.0);
	m.emissive.b = D3DVAL(0.0);
	m.emissive.a = D3DVAL(0.0);
	m.power = D3DVAL(0.0);
	m.dwRampSize = 0;

	Get3DImagery()->SetMaterial(0, &mat[0]);
}

//void TTest3DAnimator::SetupObjects()
//{
//	T3DAnimator::SetupObjects(); // Don't change
//}

void TFlareAnimator::Animate(BOOL draw)
{
	T3DAnimator::Animate(draw);
	inst->SetCommandDone(FALSE);

	for (int c = 0; c < 10; c++)
	{
		if (p[c].z <= 0)
		{
			p[c].z = 0;
			v[c].z = -v[c].z * (D3DVALUE)0.5;
			if (abs(v[c].z) < (D3DVALUE)0.4)
			{
				p[c].x = p[c].y = p[c].z = (D3DVALUE)0;
				v[c].x = (D3DVALUE)(random(0,6) - (D3DVALUE)3) / (D3DVALUE)2.0;
				v[c].y = (D3DVALUE)(random(0,6) - (D3DVALUE)3) / (D3DVALUE)2.0;
				v[c].z = (D3DVALUE)random(5,8);
			}
		}
		v[c].z -= (D3DVALUE)0.5;

		p[c].x += v[c].x;
		p[c].y += v[c].y;
		p[c].z += v[c].z;
	}
}

BOOL TFlareAnimator::Render()
{
	PS3DAnimObj obj = GetObject(0);

    SaveBlendState();
    SetBlendState();

	for (int c = 0; c < 10; c++)
	{
		Get3DImagery()->ResetExtents();				// Reset render extents

		obj->flags |= OBJ3D_ROT1 | OBJ3D_SCL2 | OBJ3D_POS3;
		obj->rot.x = D3DVAL(-(M_PI / 2.0));
		obj->rot.y = D3DVAL(0.0);
		obj->rot.z = D3DVAL(-(M_PI / 4.0));
		obj->scl.x = obj->scl.y = obj->scl.z = (D3DVALUE)4.0;
		obj->pos = p[c];

		RenderObject(obj);

		GetExtents(&extents);
		AddUpdateRect(&extents, UPDATE_BACKGROUND);
		UpdateBoundingRect(&extents);
	}

    RestoreBlendState();

	return TRUE;
}

// ***************************
// * Pulsating Ball Animator *
// ***************************

REGISTER_3DANIMATOR("PBall", TBallAnimator)

void TBallAnimator::Initialize()
{
    T3DAnimator::Initialize();				// init the animator

	S3DPoint effect;
	((PTEffect)inst)->GetPos(effect);

	p.x = p.y = p.z = 0;					// init the coords
	scale = 0.0;							// init the scale
	scale_factor = BALL_SCALE_FACTOR;		// scaling factor
}

void TBallAnimator::Animate(BOOL draw)
{
    T3DAnimator::Animate(draw);				// do the base animator

	inst->SetCommandDone(FALSE);			// turn on manual exitting

	if (scale >= BALL_MAX_SCALE)			// check to reverse scaling
	    scale_factor = -BALL_SCALE_FACTOR;

	if (scale < 0)							// check for end of scaling
	    inst->SetCommandDone(TRUE);
	else									// else do scaling
	    scale += scale_factor;	
}

BOOL TBallAnimator::Render()
{
    PS3DAnimObj obj = GetObject(0);			// get the render object

	SaveBlendState();						// save the render state
	SetBlendState();						// set the render state

	ResetExtents();							// reset the extents
	
	obj->flags = OBJ3D_SCL2 | OBJ3D_POS3;	// set how to draw stuff

	obj->scl.x = obj->scl.y = obj->scl.z = scale; // set scaling

	obj->pos = p;							// set position

	RenderObject(obj);						// render the object

	UpdateExtents();						// change the extents

	RestoreBlendState();					// restore the render state

	return TRUE;
}

// *****************
// * Fire Animator *
// *****************

REGISTER_3DANIMATOR("Fire", TFireAnimator)

void TFireAnimator::Initialize()
{
	T3DAnimator::Initialize();

	p[0].x = (D3DVALUE)0.0;
	p[0].y = (D3DVALUE)0.0;
	p[0].z = (D3DVALUE)0.0;
	f[0] = 0;

	for (int c = 1; c < NUMFIRES; c++)
	{
		p[c].x = (D3DVALUE)random(0,100) - (D3DVALUE)50;
		p[c].y = (D3DVALUE)random(0,100) - (D3DVALUE)50;
		p[c].z = (D3DVALUE)(0.0);
		f[c] = random(0, 20) - 22;
	}

	S3DMat mat;
	Get3DImagery()->GetMaterial(0, &mat);

	D3DMATERIAL &m = mat.matdesc;
	m.ambient.r = D3DVAL(0.0);
	m.ambient.g = D3DVAL(0.0);
	m.ambient.b = D3DVAL(0.0);
	m.ambient.a = D3DVAL(0.0);
	m.diffuse.r = D3DVAL(0.0);
	m.diffuse.g = D3DVAL(0.0);
	m.diffuse.b = D3DVAL(0.0);
	m.diffuse.a = D3DVAL(0.0);
	m.specular.r = D3DVAL(0.0);
	m.specular.g = D3DVAL(0.0);
	m.specular.b = D3DVAL(0.0);
	m.specular.a = D3DVAL(0.0);
	m.emissive.r = D3DVAL(0.0);
	m.emissive.g = D3DVAL(0.0);
	m.emissive.b = D3DVAL(0.0);
	m.emissive.a = D3DVAL(0.0);
	m.power = D3DVAL(0.0);
	m.dwRampSize = 0;

	Get3DImagery()->SetMaterial(0, &mat);
}

void TFireAnimator::Animate(BOOL draw)
{
	T3DAnimator::Animate(draw);
	inst->SetCommandDone(FALSE);

	for (int c = 0; c < 10; c++)
	{
		if (f[c] >= 30)
		{
			p[c].x = (D3DVALUE)random(0,100) - (D3DVALUE)50;
			p[c].y = (D3DVALUE)random(0,100) - (D3DVALUE)50;
			p[c].z = (D3DVALUE)(0.0);
			f[c] = random(0, 20) - 22;
		}
		else
			f[c]++;
	}
}

BOOL TFireAnimator::Render()
{
	PS3DAnimObj obj = GetObject(0);

    SaveBlendState();
    SetBlendState();

	for (int c = 0; c < 10; c++)
	{
		ResetExtents();				// Reset render extents

		if (f[c] >= 30)
		{
			p[c].x = (D3DVALUE)random(0,100) - (D3DVALUE)50;
			p[c].y = (D3DVALUE)random(0,100) - (D3DVALUE)50;
			p[c].z = (D3DVALUE)(0.0);
			f[c] = random(0, 20) - 22;
		}
		else
			f[c]++;

		if (f[c] < 0)
			continue;

		obj->flags |= OBJ3D_TEXFRAME | OBJ3D_ROT1 | OBJ3D_SCL2 | OBJ3D_POS3;
		obj->rot.x = D3DVAL(-(M_PI / 2.0));
		obj->rot.y = D3DVAL(M_PI);
		obj->rot.z = D3DVAL(-(M_PI / 4.0));
		obj->scl.x = obj->scl.y = obj->scl.z = (D3DVALUE)16.0;
		obj->pos = p[c];
		obj->textureframe[0] = f[c];
		obj->textureframe[1] = f[c];

		RenderObject(obj);

		UpdateExtents();			// Updates bound rect and screen rect
	}

    RestoreBlendState();

	return TRUE;
}

// ****************
// * Ice Animator *
// ****************

REGISTER_3DANIMATOR("CRYSTAL", TIceAnimator)

void TIceAnimator::Initialize()
{
	T3DAnimator::Initialize();

    for (int n = 0; n < NUM_ICE_CRYSTALS; n++)
	{
        p[n].x = (D3DVALUE)(random(-PHOTON_LAUNCH_RADIUS, PHOTON_LAUNCH_RADIUS));
        p[n].y = (D3DVALUE)(random(-PHOTON_LAUNCH_RADIUS, PHOTON_LAUNCH_RADIUS));
        p[n].z = (D3DVALUE)(random(-PHOTON_LAUNCH_RADIUS, PHOTON_LAUNCH_RADIUS));

        scale[n] = 0;
        framenum[n] = random(-10, 0);
	}
}

void TIceAnimator::Animate(BOOL draw)
{
	T3DAnimator::Animate(draw);

    for (int n = 0; n < NUM_ICE_CRYSTALS; n++)
	{
        framenum[n]++;
        if (framenum[n] > 0)
        {
            if (framenum[n] > 40)
            {
                if (scale[n])
                    scale[n] -= ICE_SCALE_STEP;
                else
                {
                    p[n].x = (D3DVALUE)(random(-PHOTON_LAUNCH_RADIUS, PHOTON_LAUNCH_RADIUS));
                    p[n].y = (D3DVALUE)(random(-PHOTON_LAUNCH_RADIUS, PHOTON_LAUNCH_RADIUS));
                    p[n].z = (D3DVALUE)(random(-PHOTON_LAUNCH_RADIUS, PHOTON_LAUNCH_RADIUS));

                    scale[n] = 0;
                    framenum[n] = random(-10, 0);
                }
            }

            if (framenum[n] < 30)
                scale[n] += ICE_SCALE_STEP;
        }
	}
}

BOOL TIceAnimator::Render()
{
    SaveBlendState();
    SetBlendState();

    for (int n = 0; n < 1; n++)
	{
        for (int o = 0; o < 2; o++)
        {
            PS3DAnimObj obj = GetObject(o);

            Get3DImagery()->ResetExtents();             // Reset render extents

            obj->flags |= /*OBJ3D_ROT1 |*/ OBJ3D_SCL2 | OBJ3D_POS3;
            obj->rot.x = D3DVAL(-(M_PI / 2.0));
            obj->rot.y = D3DVAL(0.0);
            obj->rot.z = D3DVAL(-(M_PI / 4.0));
            obj->scl.x = obj->scl.y = obj->scl.z = scale[n];
            obj->pos = p[n];

            RenderObject(obj);

            UpdateExtents();            // Updates bound rect and screen rect
        }
	}

    RestoreBlendState();

	return TRUE;
}

// *****************
// * Heal Animator *
// *****************

REGISTER_3DANIMATOR("Heal", THealAnimator)

//==============================================================================
//    Function : Initialize.
//------------------------------------------------------------------------------
// Description : This will setup the initial state for a heal animator. The
//               healing effect consists of a circular object at the players
//               feet and a number of bubbles rising out of it.
//==============================================================================

void THealAnimator::Initialize()
{
	T3DAnimator::Initialize();

	PLAY("heal sound");

	// change the health level
	((PTCharacter)Player)->RestoreHealth();
	HealthBar.ChangeLevel(((PTCharacter)Player)->Health());

    // Initialize the glow object at the players feet
    p[0].x = p[0].y = p[0].z = 0;
    scale[0] = 2.0;
    framenum[0] = 0;
    rotation = (D3DVALUE)0.0;

    // Initialize the starting positions of the magic bubbles
    for (int n = 1; n < NUM_HEAL_BUBBLES; n++)
	{
        p[n].x = (D3DVALUE)(random(-HEALING_RADIUS, HEALING_RADIUS));
        p[n].y = (D3DVALUE)(random(-HEALING_RADIUS, HEALING_RADIUS));
        p[n].z = (D3DVALUE)2.0;
        rise[n] = (D3DVALUE)(random(3, 6) * (D3DVALUE)4.0 / (D3DVALUE)3.0);
        scale[n] = 0;
        scale[n] = 4.5;
        framenum[n] = random(-NUM_HEAL_BUBBLES / 2, -1);
	}
}

//==============================================================================
//    Function : Animate.
//------------------------------------------------------------------------------
// Description : This updates the frame number, position, and scale values
//               of all the healing bubbles.
//==============================================================================

void THealAnimator::Animate(BOOL draw)
{
	T3DAnimator::Animate(draw);
	inst->SetCommandDone(FALSE);

    // Update the glow object under the players feet
    framenum[0]++;
    // It grows during the first half of the spell
    if (framenum[0] < HEAL_DURATION / 2)
	{
		if (scale[0] < 7.0)
			scale[0] += 1.0;
	}
    else
    // And shrinks once the spell is done with
    if ((framenum[0] > HEAL_DURATION) && (activebubbles == 0))
    {
        if (scale[0] > 0)
            scale[0] -= 1.0;
        else
        {
            inst->SetCommandDone(TRUE);
            return;
        }
    }

	// Rotate the cylindrical glow
    rotation += (D3DVALUE)0.1;

    // Update all the magic bubbles
    for (int n = 1; n < NUM_HEAL_BUBBLES; n++)
	{
        framenum[n]++;

        // Keep track of how many bubbles we are floating up
        if (framenum[n] == 0)
            activebubbles++;

        if (framenum[n] > 0)
        {
            // Float the bubbles up
            p[n].z += rise[n];

			if (scale[n] > 0)
			{
                // Scale the bubbles down
				scale[n] -= (D3DVALUE)HEAL_SCALE_STEP;
				if (scale[n] <= 0)
				{
                    // Once a bubbles scales out of sight, decrement how many we have
					activebubbles--;

                    // If the spells not over yet, start a new bubble
					if (framenum[0] < HEAL_DURATION)
					{
						p[n].x = (D3DVALUE)(random(-HEALING_RADIUS, HEALING_RADIUS));
						p[n].y = (D3DVALUE)(random(-HEALING_RADIUS, HEALING_RADIUS));
                        p[n].z = (D3DVALUE)2.0;
						rise[n] = (D3DVALUE)(random(3, 6) * (D3DVALUE)4.0 / (D3DVALUE)3.0);
                        scale[n] = 4.5;
                        framenum[n] = -1;
					}
				}
            }
        }
	}
}

//==============================================================================
//    Function : Render.
//------------------------------------------------------------------------------
// Description : This loops through all the healing bubbles and renders each
//               at the appropriate location and scale value.
//==============================================================================

BOOL THealAnimator::Render()
{
    SaveBlendState();
    SetBlendState();

    PS3DAnimObj obj = GetObject(0);

    for (int n = 0; n < NUM_HEAL_BUBBLES; n++)
	{
        if ((framenum[n] > 0) && (scale[n] > 0))
        {
            ResetExtents();             // Reset render extents

            // See if were doing the glow at the players feet or one of the bubbles
            // The glow doesn't get rotated, but the bubbles do
            obj->flags = OBJ3D_MATRIX;
			D3DMATRIXClear(&obj->matrix);
            if (n == 0)
			{
				D3DMATRIXRotateX(&obj->matrix, 0);
				D3DMATRIXRotateY(&obj->matrix, 0);
				D3DMATRIXRotateZ(&obj->matrix, 0);
			}
            else
            {
                obj->rot.x = D3DVAL(-(M_PI / 2.0));
				D3DMATRIXRotateX(&obj->matrix, -(float)(M_PI / 2.0));
				D3DMATRIXRotateY(&obj->matrix, 0.0f);
				D3DMATRIXRotateZ(&obj->matrix, -(float)(M_PI / 4.0));
				D3DMATRIXRotateZ(&obj->matrix, D3DVAL(-((inst->GetFace() * 360) / 256) * TORADIAN));
            }

            obj->scl.x = obj->scl.y = obj->scl.z = scale[n];
			D3DMATRIXScale(&obj->matrix, &obj->scl);
            obj->pos = p[n];
			D3DMATRIXTranslate(&obj->matrix, &obj->pos);

            RenderObject(obj);

            UpdateExtents();            // Updates bound rect and screen rect
        }
	}

    // Draw the cylindrical glow around the player
    obj = GetObject(1);

    ResetExtents();             // Reset render extents

    obj->flags = OBJ3D_ROT1 | OBJ3D_SCL2 | OBJ3D_POS3;
    obj->rot.x = obj->rot.y = D3DVAL(0.0);
    obj->rot.z = rotation;
    obj->scl.x = obj->scl.y = obj->scl.z = scale[0] * 3 / 4;
    obj->pos = p[0];

    RenderObject(obj);
    obj->rot.z = -rotation;
    RenderObject(obj);

    UpdateExtents();            // Updates bound rect and screen rect

    RestoreBlendState();

	return TRUE;
}

void THealAnimator::RefreshZBuffer()
{
	S3DPoint map, screen, effect;

	((PTEffect)inst)->GetPos(effect);

	map.x = (int)p[0].x + effect.x;
	map.y = (int)p[0].y + effect.y;
	map.z = (int)p[0].z + effect.z;

	int size_x = 100;
	int size_y = 220;

	WorldToScreen(map, screen);
	RestoreZ(screen.x - (size_x / 2), screen.y - size_y + 25, size_x, size_y);
}

// *********************
// * TCreateFoodEffect *
// *********************

_CLASSDEF(TCreateFoodEffect)

class TCreateFoodEffect : public TEffect
{
  public:
    TCreateFoodEffect(PTObjectImagery newim) : TEffect(newim) { }
    TCreateFoodEffect(PSObjectDef def, PTObjectImagery newim) : TEffect(def, newim) { }

	virtual void Initialize();
	virtual void Pulse();
};

DEFINE_BUILDER("CreateFood", TCreateFoodEffect)
REGISTER_BUILDER(TCreateFoodEffect)

void TCreateFoodEffect::Initialize()
{
}

void TCreateFoodEffect::Pulse()
{
	TObjectInstance::Pulse();

	if ((spell) && (commanddone))
		KillThisEffect();
}

// ***********************
// * CreateFood Animator *
// ***********************

// general defines for create food effect
#define CFD_SOUPS_ON				60		//	time (in frames) at which food appears
#define CFD_NOMOREOFTHISEFFECT		80		//	time when the effect must desist its behavior entirely
#define CFD_NUMPARTICLES			150		//	number of particles used in both flames and swirls

// defines for particles
#define CFD_STATE_USEME				0
#define CFD_STATE_SWIRLEY1			1
#define CFD_STATE_SWIRLEY2			2
#define CFD_STATE_SMOKEY			3

// swirley defines
#define CFD_SWIRLON			3		//	frame when swirling begins
#define CFD_SWIRLOFF		10		//	frame when swirleys stop being added
#define CFD_SMALLSWIRLEY	0.1f	//	smallest size of a swirley
#define CFD_LARGESWIRLEY	0.1f	//	largest size of a swirley
#define CFD_SWIRLSIZEVEL	0.02f	//	how fast the size changes
#define CFD_SWIRLMINDIST	20		//	minimum distance to pivot (stage 1)
#define CFD_SWIRLMINDIST2	15		//	minimum distance to pivot (stage 2)
#define CFD_SWIRLCHANGE		20		//	when zvalue is this, pivot is moved to center above fire
#define CFD_SWIRLDISTFUDGE	CFD_SWIRLMINDIST + 8	//	range for random 'distance to pivot' values
#define CFD_SWIRLDISTVEL	3		//	how fast swirley distance grows (first stage)
#define CFD_SWIRLDISTVEL2	4		//	how fast swirley distance shrinks (second stage)
#define CFD_SWIRLANGVEL		8		//	angular velocity (how fast particles rotate)
#define CFD_SWIRLZVEL1		2		//	up\down velocity for pivot of particle (first stage)
#define CFD_SWIRLZVEL2		2		//	up\down velocity for pivot of particle (second stage)

//	more defines to regulate the flow of the swirleys
#define CFD_SWIRLTIME1		(CFD_SWIRLON + 5)	//	for each of these frames...
#define CFD_ADDSWIRL1		1					//		add this many particles for swirl action
#define CFD_SWIRLTIME2		(CFD_SWIRLON + 10)	//	for each of these frames...
#define CFD_ADDSWIRL2		1					//		add this many particles for swirl action
#define CFD_SWIRLTIME3		CFD_SWIRLOFF		//	for each of these frames...
#define CFD_ADDSWIRL3		1					//		add this many particles for swirl action

// fire defines
#define CFD_SMOKEON			30		//	frame when fire begins
#define CFD_SMOKEOFF		70		//	frame when fire stops
#define CFD_MAXDIST			15		//	maximum radius at the base of the flame
#define CFD_FADEMIN			5		//	min height at which flame particles may begin fading
#define CFD_MAXFADE			15		//	max height at which flame particles must fade out
#define CFD_STARTPCT		20		//	used as a factor for fading smoke
#define CFD_BOTTOM			1		//	distance of flame above ground

//	the following gets the fire in front of the food
#define CFD_FLAMEINFRONT	500		//	offset for base of fire (towards camera- straight down) along the ground plane
#define CFD_FLAMEUPOFFSET	280		//	(56% of INFRONT) offset along Z-axis (straight up) to adjust for FLAMEINFRONT offset

//	more defines to regulate the flow of the flame
#define CFD_SMOKETIME1		40				//	for each of these frames...
#define CFD_ADDSMOKE1		1				//		add this many particles for smoke
#define CFD_MAINSCALE1		0.3f			//		each beginning about this size
#define CFD_SMOKETIME2		55				//	for each of these frames...
#define CFD_ADDSMOKE2		7				//		add this many particles for smoke
#define CFD_MAINSCALE2		0.3f			//		each beginning about this size
#define CFD_SMOKETIME3		65				//	for each of these frames...
#define CFD_ADDSMOKE3		7				//		add this many particles for smoke
#define CFD_MAINSCALE3		0.3f			//		each beginning about this size
#define CFD_SMOKETIME4		CFD_SMOKEOFF	//	for each of these frames...
#define CFD_ADDSMOKE4		2				//		add this many particles for smoke
#define CFD_MAINSCALE4		0.3f			//		each beginning about this size

// defines for the GLOWING GLOVES(tm)
#define CFD_GSCALEVEL		0.2f	//	glowing gloves scale velocity fading while raising\lowering hands
#define CFD_GSCALEFLICKER	0.03f	//	glowing gloves flickering rate while hands raised
#define CFD_MAXGSCALE		1.2f	//	maximum fade value of glowing gloves
#define CFD_GTIME1			10		//	fade-in time while raising hands
#define CFD_GTIME2			20		//	flicker time 1	(fade slightly out)
#define CFD_GTIME3			30		//	flicker time 2	(fade slightly in)
#define CFD_GTIME4			40		//	flicker time 3	(fade slightly out)
#define CFD_GTIME5			50		//	flicker time 4	(fade slightly in)
#define CFD_GTIME6			80		//	fade-out tim while lowering hands

_CLASSDEF(TCreateFoodAnimator)

typedef struct _CFD_PARTICLE
{
	S3DPoint pos;		//	x,y,z position of the particle
	S3DPoint pivot;		//	point around which particle rotates
	S3DPoint vel;		//	this is the velocity, my friend (up, down, sideways translation)
	S3DPoint angvel;	//	angular velocity (rotation speed around its pivot)
	int state;			//	particle is unused, a SWIRLEY, or a SMOKEY
	float size;			//	size of the particle, my friend
	int angle;			//	current angle around pivot point
	int dist;			//	distance from pivot point (or radius)
	int life;			//	the particle is alive (displayed while life > 0) or dead (0)
	int startfade;		//	used to control fading (size of particle)
	int stopfade;		//	used to control fading (size of particle)
	int color;
}CFD_PARTICLE;

class TCreateFoodAnimator : public T3DAnimator
{
  private:
	S3DPoint foodpos;
    S3DPoint localfoodpos;
	S3DPoint flameoffset;
	D3DVECTOR glove1;
	D3DVECTOR glove2;
	D3DVECTOR fxpos;
	D3DVECTOR fxscale;
    D3DVALUE facing;
	int fooddist;
	int framenum;
	float mainscale;
	float gscale;
	CFD_PARTICLE sm[CFD_NUMPARTICLES];	// array of particles used for both the flame and the swirls

  public:
    TCreateFoodAnimator(PTObjectInstance oi) : T3DAnimator(oi) {}
    virtual ~TCreateFoodAnimator() { Close(); }

	virtual void Initialize();
	virtual void Animate(BOOL draw);
	virtual BOOL Render();
	virtual void RefreshZBuffer();
};

REGISTER_3DANIMATOR("CreateFood", TCreateFoodAnimator)

void TCreateFoodAnimator::Initialize()
{
	T3DAnimator::Initialize();

	PLAY("heal sound");

	fxscale.x = 1.0f;
	fxscale.y = 1.0f;
	fxscale.z = 1.0f;
	framenum = 0;
	fooddist = 25;

	// Get the direction the fatman is facing.. will be used immediately and later on
	facing = (float)((PTEffect)inst)->GetAngle();

	ConvertToVector((int)facing, fooddist, localfoodpos);

	//	calculate the offset of the flame
	ConvertToVector((int)((255 - facing) + ((138 * 255) / 360)) & 255, CFD_FLAMEINFRONT, flameoffset);
	flameoffset.y -= (int)fooddist;
	flameoffset.z = CFD_FLAMEUPOFFSET;

	// Get the position of the fatman
	S3DPoint fatman;
	((PTEffect)inst)->GetPos(fatman);

	foodpos.x = fatman.x + localfoodpos.x;
	foodpos.y = fatman.y + localfoodpos.y;
	foodpos.z = fatman.z;

	fxpos.x = 0.0f;
	fxpos.y = (float)-fooddist;
	fxpos.z = 0.0f;
	
	memset(sm, 0, sizeof(CFD_PARTICLE) * CFD_NUMPARTICLES);

//	initialize the glowing gloves (the two effects near fatman's hands)
//	int objnum = ((PTEffect)inst)->GetSpell()->GetInvoker()->GetAnimator()->GetObject("lhand");

//	TextBar.Print("left hand: %d", objnum);

	glove1.x = 20.0f;
	glove1.y = -5.0f;
	glove1.z = 75.0f;

	glove2.x = -20.0f;
	glove2.y = -5.0f;
	glove2.z = 75.0f;

	gscale = 0.01f;
}

void TCreateFoodAnimator::Animate(BOOL draw)
{
	T3DAnimator::Animate(draw);
	inst->SetCommandDone(FALSE);

	framenum++;

//	Perform the glowing gloves action
	if(framenum < CFD_GTIME1)
	{
		if(gscale < CFD_MAXGSCALE)
			gscale += CFD_GSCALEVEL;
		else
			gscale = CFD_MAXGSCALE;
	}
	else if(framenum < CFD_GTIME2)
	{
		gscale -= CFD_GSCALEFLICKER;
	}
	else if(framenum < CFD_GTIME3)
	{
		gscale += CFD_GSCALEFLICKER;
	}
	else if(framenum < CFD_GTIME4)
	{
		gscale -= CFD_GSCALEFLICKER;
	}
	else if(framenum < CFD_GTIME5)
	{
		gscale += CFD_GSCALEFLICKER;
	}
	else if(framenum < CFD_GTIME6)
	{
		if(gscale > 0.0f)
			gscale -= CFD_GSCALEVEL;
		else
			gscale = 0.0f;
	}
	else
	{
		gscale = 0.0f;
	}


//	Handle swirl action
	int newswirleys = 0;

	if(framenum < CFD_SWIRLON)
		newswirleys = 0;
	
	else if(framenum < CFD_SWIRLTIME1)
		newswirleys = CFD_ADDSWIRL1;
	
	else if(framenum < CFD_SWIRLTIME2)
		newswirleys = CFD_ADDSWIRL2;
	
	else if(framenum < CFD_SWIRLTIME3)
		newswirleys = CFD_ADDSWIRL3;

//	Handle flame crap
	int newsmokeys = 0;

	if(framenum < CFD_SMOKEON)
	{
		newsmokeys = 0;
	}
	else if(framenum < CFD_SMOKETIME1)
	{
		newsmokeys = CFD_ADDSMOKE1;
		mainscale = CFD_MAINSCALE1;
	}
	else if(framenum < CFD_SMOKETIME2)
	{
		newsmokeys = CFD_ADDSMOKE2;
		mainscale = CFD_MAINSCALE2;
	}	
	else if(framenum < CFD_SMOKETIME3)
	{
		newsmokeys = CFD_ADDSMOKE3;
		mainscale = CFD_MAINSCALE3;
	}
	else if(framenum < CFD_SMOKETIME4)
	{
		newsmokeys = CFD_ADDSMOKE4;
		mainscale = CFD_MAINSCALE4;
	}

	for(int i = 0; i < CFD_NUMPARTICLES; i++)
	{
		if(sm[i].state == CFD_STATE_USEME)
		{
		//	particle is waiting to be assigned for duty	

			if(newswirleys)
			{
			//	add a new SWIRLEY

				sm[i].color = random(0, 1);

				sm[i].pivot.x = 0;
				sm[i].pivot.y = -fooddist;
				sm[i].pivot.z = (int)glove1.z - 10;

				sm[i].angvel.x = 0;
				sm[i].angvel.y = 0;
				sm[i].angvel.z = CFD_SWIRLANGVEL;

				sm[i].dist = random(CFD_SWIRLMINDIST, CFD_SWIRLDISTFUDGE);
				sm[i].angle = random(0, 255);
				sm[i].size = CFD_SMALLSWIRLEY;
				sm[i].state = CFD_STATE_SWIRLEY1;

				newswirleys--;
			}
			else if(newsmokeys)
			{
			//	add a new SMOKEY

				int dist = random(0, CFD_MAXDIST);
				int angle = random(0, 255);
				ConvertToVector(angle, dist, sm[i].pos);
				sm[i].pos.z = CFD_BOTTOM;
				sm[i].life = CFD_FADEMIN + CFD_MAXFADE * (CFD_MAXDIST - random(0, dist)) / CFD_MAXDIST;
				sm[i].startfade = sm[i].life * CFD_STARTPCT / 100;
				sm[i].stopfade = sm[i].life;
				sm[i].vel.z = 2 + random(0, 2);
				sm[i].state = CFD_STATE_SMOKEY;

				newsmokeys--;
			}
		}
		else if(sm[i].state == CFD_STATE_SMOKEY)
		{
		//	particle is a SMOKEY, so make it act like one
			
			sm[i].pos.z += sm[i].vel.z;
			sm[i].life--;

			if(sm[i].life == 0)
				sm[i].state = CFD_STATE_USEME;
		}
		else if(sm[i].state == CFD_STATE_SWIRLEY1)
		{
		//	particle is a SWIRLEY, hovering around the glowing glove

			sm[i].pivot.z += CFD_SWIRLZVEL1;
			
			if(sm[i].size < CFD_LARGESWIRLEY)
				sm[i].size += CFD_SWIRLSIZEVEL;

			sm[i].angle += sm[i].angvel.z;
			sm[i].dist += CFD_SWIRLDISTVEL;
			
			if(sm[i].pivot.z >= glove1.z + CFD_SWIRLCHANGE)
				sm[i].state = CFD_STATE_SWIRLEY2;
		}
		else if(sm[i].state == CFD_STATE_SWIRLEY2)
		{
		//	particle is a SWIRLEY, making its way toward the fire
			sm[i].pivot.z -= CFD_SWIRLZVEL2;
			sm[i].angle += sm[i].angvel.z;
			sm[i].size -= CFD_SWIRLSIZEVEL;

			if(sm[i].dist > CFD_SWIRLMINDIST2)
				sm[i].dist -= CFD_SWIRLDISTVEL2;
			else
				sm[i].dist = CFD_SWIRLMINDIST2;
			
			if(sm[i].pivot.z <= 10)
				sm[i].state = CFD_STATE_USEME;
		}
	}

//	make the food appear when the time is right
	if(framenum == CFD_SOUPS_ON)
	{
		// create the new food object
		PTObjectClass cl = TObjectClass::GetClass(OBJCLASS_FOOD);

		// Get the number of various food types (i.e. watermelon, cheese, beer)
		int num = cl->NumTypes();
		
		SObjectDef def;
		memset(&def, 0, sizeof(SObjectDef));
		def.objclass = OBJCLASS_FOOD;
		def.objtype = random(0, num - 1);
		def.level = MapPane.GetMapLevel();
		def.pos.x = foodpos.x;
		def.pos.y = foodpos.y;
		def.pos.z = foodpos.z;
		int index = MapPane.NewObject(&def);

		if(!stricmp(cl->GetObjType(def.objtype)->name, "bottle"))
			TextBar.Print("got milk?");
		else
			TextBar.Print("Created %s.", cl->GetObjType(def.objtype)->name);
	}

	if(framenum >= CFD_NOMOREOFTHISEFFECT)
		inst->SetCommandDone(TRUE);

	return;
}

BOOL TCreateFoodAnimator::Render()
{
	PS3DAnimObj obj;
	int i;
	
	SaveBlendState();
	SetAddBlendState();

	ResetExtents();

//	All this crap renders the flame
	for(i = 0; i < CFD_NUMPARTICLES; i++)
	{
		if(sm[i].state == CFD_STATE_SMOKEY)
		{
			if((sm[i].stopfade - sm[i].life) >= ((sm[i].stopfade - sm[i].startfade) / 2))
				obj = GetObject(0);
			else
				obj = GetObject(1);

			if(sm[i].life > 0)
			{
				obj->flags = OBJ3D_MATRIX;

				D3DMATRIXClear(&obj->matrix);

				D3DMATRIXRotateX(&obj->matrix, -(float)(M_2PI / 3.0));
				D3DMATRIXRotateZ(&obj->matrix, -(float)(M_PI / 4.0));
				D3DMATRIXRotateZ(&obj->matrix, D3DVAL(-((facing / 256.0f) * M_2PI)));

				float scale;

				if((sm[i].stopfade - sm[i].life) >= sm[i].startfade)
					scale = mainscale * sm[i].life / (sm[i].stopfade - sm[i].startfade);
				else
					scale = mainscale;

				obj->scl.x = scale;
				obj->scl.y = scale;
				obj->scl.z = scale;
				D3DMATRIXScale(&obj->matrix, &obj->scl);

				obj->pos.x = (float)sm[i].pos.x + (float)flameoffset.x;
				obj->pos.y = (float)sm[i].pos.y + (float)flameoffset.y;
				obj->pos.z = (float)sm[i].pos.z + (float)flameoffset.z;
				
				D3DMATRIXTranslate(&obj->matrix, &obj->pos);

				RenderObject(obj);
			}
		}
		else if(sm[i].state == CFD_STATE_SWIRLEY1 || sm[i].state == CFD_STATE_SWIRLEY2)
		{
			obj = GetObject(sm[i].color);

			obj->flags = OBJ3D_MATRIX;

			D3DMATRIXClear(&obj->matrix);

			D3DMATRIXRotateX(&obj->matrix, -(float)(M_2PI / 3.0));
			D3DMATRIXRotateZ(&obj->matrix, -(float)(M_PI / 4.0));
			D3DMATRIXRotateZ(&obj->matrix, D3DVAL(-((facing / 256.0f) * M_2PI)));

			obj->scl.x = sm[i].size;
			obj->scl.y = sm[i].size;
			obj->scl.z = sm[i].size;
			D3DMATRIXScale(&obj->matrix, &obj->scl);

			S3DPoint pt;
			ConvertToVector(sm[i].angle, sm[i].dist, pt);

			obj->pos.x = (float)sm[i].pivot.x + pt.x;
			obj->pos.y = (float)sm[i].pivot.y + pt.y;
			obj->pos.z = (float)sm[i].pivot.z;
			
			D3DMATRIXTranslate(&obj->matrix, &obj->pos);

			RenderObject(obj);
		}
	}

	if(gscale > 0.0f)
	{
	//	Render first glowing glove..	
		obj = GetObject(0);

		obj->flags = OBJ3D_MATRIX;

		D3DMATRIXClear(&obj->matrix);

		D3DMATRIXRotateX(&obj->matrix, -(float)(M_2PI / 3.0));
		D3DMATRIXRotateZ(&obj->matrix, -(float)(M_PI / 4.0));
		D3DMATRIXRotateZ(&obj->matrix, D3DVAL(-((facing / 256.0f) * M_2PI)));

		obj->scl.x = gscale;
		obj->scl.y = gscale;
		obj->scl.z = gscale;
		D3DMATRIXScale(&obj->matrix, &obj->scl);

		obj->pos.x = glove1.x;
		obj->pos.y = glove1.y;
		obj->pos.z = glove1.z;
		D3DMATRIXTranslate(&obj->matrix, &obj->pos);

		RenderObject(obj);

	//	Render glowing glove #2..	
		obj = GetObject(1);

		obj->flags = OBJ3D_MATRIX;

		D3DMATRIXClear(&obj->matrix);

		D3DMATRIXRotateX(&obj->matrix, -(float)(M_2PI / 3.0));
		D3DMATRIXRotateZ(&obj->matrix, -(float)(M_PI / 4.0));
		D3DMATRIXRotateZ(&obj->matrix, D3DVAL(-((facing / 256.0f) * M_2PI)));

		obj->scl.x = gscale;
		obj->scl.y = gscale;
		obj->scl.z = gscale;
		D3DMATRIXScale(&obj->matrix, &obj->scl);

		obj->pos.x = glove2.x;
		obj->pos.y = glove2.y;
		obj->pos.z = glove2.z;
		D3DMATRIXTranslate(&obj->matrix, &obj->pos);

		RenderObject(obj);
	}

	UpdateExtents();            // Updates bound rect and screen rect

	RestoreBlendState();

	return TRUE;
}

void TCreateFoodAnimator::RefreshZBuffer()
{
	S3DPoint map, screen, effect;

	int size_x = 200;
	int size_y = 200;

	WorldToScreen(foodpos, screen);
	RestoreZ(screen.x - (size_x / 2), screen.y - size_y, size_x, size_y);
//	Display->Box(screen.x - (size_x / 2), screen.y - size_y, size_x, size_y);
}

// *********************
// * TCureEffect *
// *********************

_CLASSDEF(TCureEffect)

class TCureEffect : public TEffect
{
  public:
    TCureEffect(PTObjectImagery newim) : TEffect(newim) { }
    TCureEffect(PSObjectDef def, PTObjectImagery newim) : TEffect(def, newim) { }

	virtual void Initialize();
	virtual void Pulse();
};

DEFINE_BUILDER("Cure", TCureEffect)
REGISTER_BUILDER(TCureEffect)

void TCureEffect::Initialize()
{
}

void TCureEffect::Pulse()
{
	TObjectInstance::Pulse();

	if ((spell) && (commanddone))
		KillThisEffect();
}

// ***********************
// * Cure Animator *
// ***********************

// general defines for create food effect
//#define CURE_NOMOREOFTHISEFFECT		80		//	time when the effect must desist its behavior entirely
#define CURE_NUMPARTICLES			80		//	number of particles used
#define CURE_NUMBALLS				5		//	number of balls (particles swirl around balls)
#define CURE_NUMCOLORS				1		//	number of different particle colors (must be supported by imagery, tho)
#define CURE_IS_COLOR_RANDOM		1		//	Is each ball its own color or random colors?
#define CURE_MINZ					10		//	stops the balls from going thru the ground

// defines for particles
#define CURE_STATE_INACTIVE			0
#define CURE_STATE_BALL				1
#define CURE_STATE_BALL2			2
#define CURE_STATE_SWIRLEY1			3
#define CURE_STATE_DEAD				4

// defines for balls
#define CURE_BALL_STARTDIST			60		//	distance ball is from its pivot
#define CURE_BALL_STARTDISTAMP		10		//	amplitude of in\out distance from pivot
#define CURE_BALL_DISTTHETAVEL		0.04f	//	in\out velocity for distance from pivot
#define CURE_BALL_MIN_STARTANGVEL	5		//	(0-360 degrees) starting angular velocity (min random value)
#define CURE_BALL_MAX_STARTANGVEL	9		//	(0-360 degrees) starting angular velocity (max random value)
#define CURE_BALL_MIN_STARTTIME		0		//	time when ball becomes active (min random value)
#define CURE_BALL_MAX_STARTTIME		15		//	time when ball becomes active (max random value)
#define CURE_BALL_SIZEVEL1			0.1f	//	rate at which ball size grows (stage 1)
#define CURE_BALL_STARTSIZE			10.0f	//	size of ball when first active
#define CURE_BALL_MAINDISTVEL		1.5f
#define CURE_BALL_MERGEVEL			0.5f
#define CURE_BALL_SIZEVEL2			0.0f	//	rate at which ball size shrinks (stage 2)
#define CURE_BALL_MINSIZE2			0.1f
#define CURE_BALL_SIZEVEL3			1.0f

// swirley defines
#define CURE_SWIRL_SMALL			0.01f	//	smallest size of a swirley
#define CURE_SWIRL_LARGE			0.5f	//	largest size of a swirley
#define CURE_SWIRL_SIZEVEL			0.03f	//	how fast the size changes
#define CURE_SWIRL_SIZEAMP			0.2f	//	amplitude of size
#define CURE_SWIRL_STARTDISTAMP		10		//	amplitude of in\out distance from pivot
#define CURE_SWIRL_DISTTHETAVEL		0.2f	//	in\out velocity for distance from pivot
#define CURE_SWIRL_MIN_DIST			3		//	distance to pivot (min random value)
#define CURE_SWIRL_MAX_DIST			20		//	distance to pivot (max random value)
#define CURE_SWIRL_MIN_STARTANGVEL	5		//	(0-360 degrees) starting angular velocity (min random value)
#define CURE_SWIRL_MAX_STARTANGVEL	10		//	(0-360 degrees) starting angular velocity (max random value)
#define CURE_SWIRL_SIZEVEL2			0.05f	//	rate at which ball size shrinks (stage 2)
#define CURE_SWIRL_MINSIZE2			0.01f
#define CURE_SWIRL_DISTVEL2			5		//	rate at which ball dist shrinks (stage 2)
#define CURE_SWIRL_MINDIST2			0
#define CURE_HOWMANYKILLS			1		//	How many swirls are killed per frame
#define CURE_MORESWIRLEYS			1		//	How many swirls are added per frame during the above interval

_CLASSDEF(TCureAnimator)

typedef struct _CURE_PARTICLE
{
	D3DVECTOR pos;		//	x,y,z position of the particle
	D3DVECTOR pivot;	//	point around which particle rotates
	D3DVECTOR angvel;	//	angular velocity in radians (rotation speed around its pivot)
	D3DVECTOR angle;	//	current angle of rotation around pivot point in radians (each axis)
	int state;			//	particle is unused, a SWIRLEY, or a SMOKEY
	float size;			//	size of the particle, my friend
	float dist;			//	distance from pivot point (or radius)
	float maindist;
	float disttheta;	//	factor used to change distance
	int starttime;		//	time at which particle becomes active
	int whichball;		//	which ball the particle is currently attached to
	int color;
	int linedup;
}CURE_PARTICLE;

class TCureAnimator : public T3DAnimator
{
  private:
	int framenum;
	CURE_PARTICLE sm[CURE_NUMPARTICLES];	// array of particles used for both the flame and the swirls
	CURE_PARTICLE balls[CURE_NUMBALLS];
	int numactiveballs;		//	current number of active balls
	int ballslinedup;
	float facing;			//	which way the fatman is facing
	int killing;

  public:
    TCureAnimator(PTObjectInstance oi) : T3DAnimator(oi) {}
    virtual ~TCureAnimator() { Close(); }

	virtual void Initialize();
	virtual void Animate(BOOL draw);
	virtual BOOL Render();
	virtual void RefreshZBuffer();
};

REGISTER_3DANIMATOR("Cure", TCureAnimator)

void TCureAnimator::Initialize()
{
	T3DAnimator::Initialize();

	PLAY("heal sound");

	framenum = 0;
	numactiveballs = 0;
	ballslinedup = 0;
	killing = 0;

	// Get the direction the fatman is facing.. will be used immediately and later on
	facing = (float)((PTEffect)inst)->GetAngle();

	memset(sm, 0, sizeof(CURE_PARTICLE) * CURE_NUMPARTICLES);
	memset(balls, 0, sizeof(CURE_PARTICLE) * CURE_NUMBALLS);

	for(int i = 0; i < CURE_NUMBALLS; i++)
	{
	//	balls are given random start times so they don't all start at the same time (duh!)
		if(i == 0)
			balls[i].starttime = 0;
		else
			balls[i].starttime = random(CURE_BALL_MIN_STARTTIME, CURE_BALL_MAX_STARTTIME);

	//	ball is set inactive and will become active later when starttime is reached
		balls[i].state = CURE_STATE_INACTIVE;
	}
}

void TCureAnimator::Animate(BOOL draw)
{
	T3DAnimator::Animate(draw);
	inst->SetCommandDone(FALSE);

	framenum++;

	for(int i = 0; i < CURE_NUMBALLS; i++)
	{
		if(balls[i].state == CURE_STATE_INACTIVE)
		{
			if(balls[i].starttime > 0)
				balls[i].starttime--;
			
			if(balls[i].starttime == 0)
			{
			//	the ball wants to start immediately so make it become active
				balls[i].pivot.x = 0;
				balls[i].pivot.y = 0;
				balls[i].pivot.z = 35.0f + (float)((i - (CURE_NUMBALLS / 2)) * (100 / CURE_NUMBALLS));
				balls[i].size = CURE_BALL_STARTSIZE;
				balls[i].angle.x = (float)random(0, 359) / 360.0f * (float)M_2PI;
				balls[i].angle.y = (float)random(0, 359) / 360.0f * (float)M_2PI;
				balls[i].angle.z = (float)random(0, 359) / 360.0f * (float)M_2PI;
				balls[i].maindist = CURE_BALL_STARTDIST;
				balls[i].disttheta = 0.0f;
				
				if(CURE_IS_COLOR_RANDOM)
					balls[i].color = random(0, CURE_NUMCOLORS - 1);
				else
					balls[i].color = i % CURE_NUMCOLORS;
				
			//	assign a random rotation velocity around only 2 axes				
				int arandomvalue = random(0, 2);
				
				if(arandomvalue == 0)
				{
					balls[i].angvel.x = (float)random(CURE_BALL_MIN_STARTANGVEL, CURE_BALL_MAX_STARTANGVEL) / 360.0f * (float)M_2PI;
					balls[i].angvel.y = (float)random(CURE_BALL_MIN_STARTANGVEL, CURE_BALL_MAX_STARTANGVEL) / 360.0f * (float)M_2PI;
				}
				else if(arandomvalue == 1)
				{
					balls[i].angvel.x = (float)random(CURE_BALL_MIN_STARTANGVEL, CURE_BALL_MAX_STARTANGVEL) / 360.0f * (float)M_2PI;
					balls[i].angvel.z = (float)random(CURE_BALL_MIN_STARTANGVEL, CURE_BALL_MAX_STARTANGVEL) / 360.0f * (float)M_2PI;
				}
				else
				{
					balls[i].angvel.y = (float)random(CURE_BALL_MIN_STARTANGVEL, CURE_BALL_MAX_STARTANGVEL) / 360.0f * (float)M_2PI;
					balls[i].angvel.z = (float)random(CURE_BALL_MIN_STARTANGVEL, CURE_BALL_MAX_STARTANGVEL) / 360.0f * (float)M_2PI;
				}

				balls[i].state = CURE_STATE_BALL;

				numactiveballs++;
			}
		}

		if(balls[i].state == CURE_STATE_BALL)
		{
			balls[i].angle.x += balls[i].angvel.x;
			balls[i].angle.y += balls[i].angvel.y;
			balls[i].angle.z += balls[i].angvel.z;
			
			balls[i].size += CURE_BALL_SIZEVEL1;
			balls[i].disttheta += CURE_BALL_DISTTHETAVEL;
			balls[i].dist = balls[i].maindist + CURE_BALL_STARTDISTAMP * (float)cos(balls[i].disttheta); 
			
			if(!balls[i].linedup)
			{
				if(balls[i].maindist > 2.0f)
					balls[i].maindist -= CURE_BALL_MAINDISTVEL;
				else
				{
					balls[i].maindist = 2.0f;
					balls[i].linedup = 1;
					ballslinedup++;

					if(ballslinedup == CURE_NUMBALLS)
					{
						for(int j = 0; j < CURE_NUMBALLS; j++)
							balls[j].state = CURE_STATE_BALL2;
					}
				}
			}

			D3DMATRIX mat;
			D3DMATRIXClear(&mat);
			
			D3DMATRIXRotateX(&mat, balls[i].angle.x);
			D3DMATRIXRotateY(&mat, balls[i].angle.y);
			D3DMATRIXRotateZ(&mat, balls[i].angle.z);
			
			D3DVECTOR v;
			
			v.x = 0.0f;
			v.y = 0.0f;
			v.z = balls[i].dist;

			D3DMATRIXTransform(&mat, &v, &v);

			balls[i].pos.x = balls[i].pivot.x + v.x;
			balls[i].pos.y = balls[i].pivot.y + v.y;
			balls[i].pos.z = balls[i].pivot.z + (v.z / 2.0f);

			if(balls[i].pos.z < CURE_MINZ)
				balls[i].pos.z = CURE_MINZ;
		}
		else if(balls[i].state == CURE_STATE_BALL2)
		{
			balls[i].angle.x += balls[i].angvel.x;
			balls[i].angle.y += balls[i].angvel.y;
			balls[i].angle.z += balls[i].angvel.z;

			float sizevel;

			if(balls[i].pivot.z > 35.0f - 5.0f || balls[i].pivot.z < 35.0f + 5.0f)
				sizevel = CURE_BALL_SIZEVEL3;
			else
				sizevel = CURE_BALL_SIZEVEL2;

			if(balls[i].size > CURE_BALL_MINSIZE2)
				balls[i].size -= sizevel;
			else
				balls[i].size = CURE_BALL_MINSIZE2;

			if(balls[i].pivot.z > 35.0f)
				balls[i].pivot.z -= CURE_BALL_MERGEVEL;
			else if(balls[i].pivot.z < 35.0f)
				balls[i].pivot.z += CURE_BALL_MERGEVEL;

			D3DMATRIX mat;
			D3DMATRIXClear(&mat);
			
			D3DMATRIXRotateX(&mat, balls[i].angle.x);
			D3DMATRIXRotateY(&mat, balls[i].angle.y);
			D3DMATRIXRotateZ(&mat, balls[i].angle.z);
			
			D3DVECTOR v;
			
			v.x = 0.0f;
			v.y = 0.0f;
			v.z = balls[i].dist;

			D3DMATRIXTransform(&mat, &v, &v);

			balls[i].pos.x = balls[i].pivot.x + v.x;
			balls[i].pos.y = balls[i].pivot.y + v.y;
			balls[i].pos.z = balls[i].pivot.z + (v.z / 2.0f);

			if(balls[i].pos.z < CURE_MINZ)
				balls[i].pos.z = CURE_MINZ;
		}
	}

//	Handle swirl action
	int newswirleys = 0;


	if(ballslinedup == CURE_NUMBALLS)
	{
		for(int i = 0; i < CURE_HOWMANYKILLS; i++)
		{
			sm[killing].state = CURE_STATE_DEAD;
			killing++;

			if(killing >= CURE_NUMPARTICLES)
			{
				inst->SetCommandDone(TRUE);
				break;
			}
		}
	}
	else
		newswirleys = CURE_MORESWIRLEYS;

	for(i = 0; i < CURE_NUMPARTICLES; i++)
	{
		if(sm[i].state == CURE_STATE_INACTIVE)
		{
		//	particle is waiting to be assigned for duty	

			if(newswirleys)
			{
			//	add a new SWIRLEY

				sm[i].whichball = random(0, numactiveballs - 1);
				sm[i].color = balls[sm[i].whichball].color;
				sm[i].angle.x = (float)random(0, 359) / 360.0f * (float)M_2PI;
				sm[i].angle.y = (float)random(0, 359) / 360.0f * (float)M_2PI;
				sm[i].angle.z = (float)random(0, 359) / 360.0f * (float)M_2PI;
				sm[i].disttheta = (float)random(0, 359) / 360.0f * (float)M_2PI;
				
				sm[i].size = CURE_SWIRL_SMALL;

			//	assign a random rotation velocity around only 2 axes				
				int arandomvalue = random(0, 2);
				
				if(arandomvalue == 0)
				{
					sm[i].angvel.x = (float)random(CURE_SWIRL_MIN_STARTANGVEL, CURE_SWIRL_MAX_STARTANGVEL) / 360.0f * (float)M_2PI;
					sm[i].angvel.y = (float)random(CURE_SWIRL_MIN_STARTANGVEL, CURE_SWIRL_MAX_STARTANGVEL) / 360.0f * (float)M_2PI;
				}
				else if(arandomvalue == 1)
				{
					sm[i].angvel.x = (float)random(CURE_SWIRL_MIN_STARTANGVEL, CURE_SWIRL_MAX_STARTANGVEL) / 360.0f * (float)M_2PI;
					sm[i].angvel.z = (float)random(CURE_SWIRL_MIN_STARTANGVEL, CURE_SWIRL_MAX_STARTANGVEL) / 360.0f * (float)M_2PI;
				}
				else
				{
					sm[i].angvel.y = (float)random(CURE_SWIRL_MIN_STARTANGVEL, CURE_SWIRL_MAX_STARTANGVEL) / 360.0f * (float)M_2PI;
					sm[i].angvel.z = (float)random(CURE_SWIRL_MIN_STARTANGVEL, CURE_SWIRL_MAX_STARTANGVEL) / 360.0f * (float)M_2PI;
				}

				sm[i].state = CURE_STATE_SWIRLEY1;

				newswirleys--;
			}
		}
		
		if(sm[i].state == CURE_STATE_SWIRLEY1)
		{
		//	particle is a SWIRLEY, hovering around one of the balls

			sm[i].angle.x += sm[i].angvel.x;
			sm[i].angle.y += sm[i].angvel.y;
			sm[i].angle.z += sm[i].angvel.z;

//			sm[i].disttheta += CURE_SWIRL_DISTTHETAVEL;
//			float cosval = (float)cos(sm[i].disttheta);
//			sm[i].dist = balls[sm[i].whichball].size + (CURE_SWIRL_STARTDISTAMP * cosval);
//			sm[i].size = CURE_SWIRL_LARGE + (CURE_SWIRL_SIZEAMP * (cosval + 1.0f));
			
			sm[i].dist = balls[sm[i].whichball].size;

			if(ballslinedup == CURE_NUMBALLS)
			{
/*
				float proportion = (float)fabs(balls[sm[i].whichball].pos.z - 35.0f) / 35.0f;
				sm[i].size = proportion * CURE_SWIRL_LARGE;
				sm[i].dist = proportion * balls[sm[i].whichball].size;
*/
/*
				if(sm[i].size > CURE_SWIRL_MINSIZE2)
					sm[i].size -= CURE_SWIRL_SIZEVEL2;
				else
					sm[i].size = CURE_SWIRL_MINSIZE2;
*/
/*
				if(sm[i].dist > CURE_SWIRL_MINDIST2)
					sm[i].dist -= CURE_SWIRL_DISTVEL2;
				else
					sm[i].dist = CURE_SWIRL_MINDIST2;
*/
			}
			else
			{
				if(sm[i].size < CURE_SWIRL_LARGE)
					sm[i].size += CURE_SWIRL_SIZEVEL;
				else
					sm[i].size = CURE_SWIRL_LARGE;
			}

			sm[i].pivot.x = balls[sm[i].whichball].pos.x;
			sm[i].pivot.y = balls[sm[i].whichball].pos.y;
			sm[i].pivot.z = balls[sm[i].whichball].pos.z;

			D3DMATRIX mat;
			D3DMATRIXClear(&mat);
			
			D3DMATRIXRotateX(&mat, sm[i].angle.x);
			D3DMATRIXRotateY(&mat, sm[i].angle.y);
			D3DMATRIXRotateZ(&mat, sm[i].angle.z);
			
			D3DVECTOR v;
			
			v.x = 0.0f;
			v.y = 0.0f;
			v.z = sm[i].dist;

			D3DMATRIXTransform(&mat, &v, &v);

			sm[i].pos.x = sm[i].pivot.x + v.x;
			sm[i].pos.y = sm[i].pivot.y + v.y;
			sm[i].pos.z = sm[i].pivot.z + v.z;
		}
	}

//	if(framenum >= CURE_NOMOREOFTHISEFFECT)
//		inst->SetCommandDone(TRUE);

	return;
}

BOOL TCureAnimator::Render()
{
	PS3DAnimObj obj;
	
	SaveBlendState();
	SetAddBlendState();

	ResetExtents();

	for(int i = 0; i < CURE_NUMPARTICLES; i++)
	{
		if(sm[i].state == CURE_STATE_SWIRLEY1)
		{
			if(sm[i].size > 0.0f)
			{
				obj = GetObject(sm[i].color);

				obj->flags = OBJ3D_MATRIX;

				D3DMATRIXClear(&obj->matrix);

				D3DMATRIXRotateX(&obj->matrix, -(float)(M_2PI / 3.0));
				D3DMATRIXRotateZ(&obj->matrix, -(float)(M_PI / 4.0));
				D3DMATRIXRotateZ(&obj->matrix, D3DVAL(-((facing / 256.0f) * M_2PI)));

				obj->scl.x = sm[i].size;
				obj->scl.y = sm[i].size;
				obj->scl.z = sm[i].size;
				D3DMATRIXScale(&obj->matrix, &obj->scl);

				obj->pos.x = (float)sm[i].pos.x;
				obj->pos.y = (float)sm[i].pos.y;
				obj->pos.z = (float)sm[i].pos.z;
				D3DMATRIXTranslate(&obj->matrix, &obj->pos);

				RenderObject(obj);
			}
		}
	}

	UpdateExtents();            // Updates bound rect and screen rect

	RestoreBlendState();

	return TRUE;
}

void TCureAnimator::RefreshZBuffer()
{
	S3DPoint map, screen, effect;

	int size_x = 225;
	int size_y = 220;

	S3DPoint fatman;
	((PTEffect)inst)->GetPos(fatman);

	WorldToScreen(fatman, screen);
	RestoreZ(screen.x - (size_x / 2), screen.y - (size_y / 2) - 45, size_x, size_y);
//	Display->Box(screen.x - (size_x / 2), screen.y - (size_y / 2) - 45, size_x, size_y);
}

// *********************
// * TFireFlashEffect *
// *********************

_CLASSDEF(TFireFlashEffect)

class TFireFlashEffect : public TEffect
{
  public:
    TFireFlashEffect(PTObjectImagery newim) : TEffect(newim) { }
    TFireFlashEffect(PSObjectDef def, PTObjectImagery newim) : TEffect(def, newim) { }

	virtual void Initialize();
	virtual void Pulse();
};

DEFINE_BUILDER("FireFlash", TFireFlashEffect)
REGISTER_BUILDER(TFireFlashEffect)

void TFireFlashEffect::Initialize()
{
}

void TFireFlashEffect::Pulse()
{
	TObjectInstance::Pulse();

	if ((spell) && (commanddone))
		KillThisEffect();
}

// ***********************
// * FireFlash Animator *
// ***********************

// general defines for create food effect
#define FFLASH_NOMOREOFTHISEFFECT		100
#define FFLASH_NUMPARTICLES				150		//	number of particles used in both flames and swirls

// defines for particles
#define FFLASH_STATE_USEME				0		//	particle is available for use
#define FFLASH_STATE_SMOKEY1			1		//	particle is part of initial flame
#define FFLASH_STATE_GSPHERE			2		//	particle is part of glowing sphere
#define FFLASH_STATE_RING				3		//	particle is part of explosion ring

// fire defines
#define FFLASH_F1_ON			0		//	frame when fire begins
#define FFLASH_F1_OFF			25		//	frame when fire ends
#define FFLASH_F1_MAXDIST		15		//	maximum radius at the base of the flame
#define FFLASH_F1_FADEMIN		20		//	min height at which flame particles may begin fading
#define FFLASH_F1_MAXFADE		25		//	max height at which flame particles must fade out
#define FFLASH_F1_FADEPCT		20		//	percent of its lifespan when particle starts fading
#define FFLASH_F1_BOTTOM		1		//	distance of flame above ground
#define FFLASH_F1_COLORPCT		70		//	color changes when particle reaches this percent of flame
#define FFLASH_F1_MINSIZE		0.05f	//	fade out to this size, then re-use particle

//	more defines to regulate the flow of the flame
#define FFLASH_F1_TIME1			5				//	for each of these frames...
#define FFLASH_F1_ADD1			4				//		add this many particles for smoke
#define FFLASH_F1_MAINSCALE1	0.3f			//		each beginning about this size
#define FFLASH_F1_TIME2			15				//	for each of these frames...
#define FFLASH_F1_ADD2			7				//		add this many particles for smoke
#define FFLASH_F1_MAINSCALE2	0.3f			//		each beginning about this size
#define FFLASH_F1_TIME3			16				//	for each of these frames...
#define FFLASH_F1_ADD3			7				//		add this many particles for smoke
#define FFLASH_F1_MAINSCALE3	0.3f			//		each beginning about this size
#define FFLASH_F1_TIME4			FFLASH_F1_OFF	//	for each of these frames...
#define FFLASH_F1_ADD4			2				//		add this many particles for smoke
#define FFLASH_F1_MAINSCALE4	0.3f			//		each beginning about this size

#define FFLASH_EXPLOSION		35		//	frame when explosion starts

#define FFLASH_GS_ON			26		//	frame when glowing sphere begins
#define FFLASH_GS_NUMPARTICLES	75		//	number of particles which compose the glowing sphere
#define FFLASH_GS_MINSIZE1		1.0f	//	size of glowing sphere initially
#define FFLASH_GS_MAXSIZE1		20.0f	//	size of glowing sphere when it explodes
#define FFLASH_GS_SIZEVEL1		2.0f	//	rate glowing sphere grows
#define FFLASH_GS_SIZETOSCALE	0.01f	//	size of each particle relative to the size of the sphere
#define FFLASH_GS_MINANGVEL		0.12f	//	initial rotation velocity of particles in sphere
#define FFLASH_GS_INFRONT		10		//	moves the glowing sphere towards the camera along the ground
#define FFLASH_GS_INFRONTUP		5		//	(56% of INFRONT) moves the glowing sphere up to adjust for INFRONT

#define FFLASH_RI_NUMPARTICLES	150		//	number of particles which compose the explosion ring
#define FFLASH_RI_MAXSIZE		300.0f	//	ring reaches this size and disappears
#define FFLASH_RI_SIZEVEL1		8.0f	//	rate ring grows
#define FFLASH_RI_MINANGVEL		0.3f	//	initial rotation velocity of particles in ring
#define FFLASH_RI_PSIZE1		0.1f	//	particles in ring start this big

_CLASSDEF(TFireFlashAnimator)

typedef struct _FFLASH_PARTICLE
{
	D3DVECTOR pos;		//	x,y,z position of the particle
	D3DVECTOR pivot;	//	point around which particle rotates
	D3DVECTOR vel;		//	this is the velocity, my friend (up, down, sideways translation)
	D3DVECTOR angle;	//	current angle of rotation around pivot point (in 255 degs)
	D3DVECTOR angvel;	//	angular velocity (rotation speed around its pivot)
	int state;			//	particle is unused, a SWIRLEY, or a SMOKEY
	float scale;		//	size of the particle, my friend
	float dist;			//	distance from pivot point (or radius)
	int life;			//	the particle is alive (displayed while life > 0) or dead (0)
	int startfade;		//	used to control fading (size of particle)
	int stopfade;		//	used to control fading (size of particle)
	int color;
}FFLASH_PARTICLE;

class TFireFlashAnimator : public T3DAnimator
{
  private:
    D3DVALUE facing;
    S3DPoint goffset;
	D3DVECTOR gsphere;
	int framenum;
	float mainscale;
	float gsize;
	float rsize;
	float gscale;
	FFLASH_PARTICLE sm[FFLASH_NUMPARTICLES];		// particles used for the flame

  public:
    TFireFlashAnimator(PTObjectInstance oi) : T3DAnimator(oi) {}
    virtual ~TFireFlashAnimator() { Close(); }

	virtual void Initialize();
	virtual void Animate(BOOL draw);
	virtual BOOL Render();
	virtual void RefreshZBuffer();
};

REGISTER_3DANIMATOR("FireFlash", TFireFlashAnimator)

void TFireFlashAnimator::Initialize()
{
	T3DAnimator::Initialize();

	PLAY("heal sound");

	framenum = 0;

	// Get the direction the fatman is facing.. will be used immediately and later on
	facing = (float)((PTEffect)inst)->GetAngle();

	//	calculate the offset of the flame
	ConvertToVector((int)((255 - facing) + ((138 * 255) / 360)) & 255, FFLASH_GS_INFRONT, goffset);
	goffset.z = FFLASH_GS_INFRONTUP;

	gsphere.x = 0.0f;
	gsphere.y = 0.0f;
	gsphere.z = 30.0f;
	gsize = FFLASH_GS_MINSIZE1;

	memset(sm, 0, sizeof(FFLASH_PARTICLE) * FFLASH_NUMPARTICLES);

//	assign the appropriate particles to be part of the glowing sphere instead of the fire
	for(int i = 0; i < FFLASH_GS_NUMPARTICLES; i++)
	{
		sm[i].angle.x = (float)random(0, 359) / 360.0f * (float)M_2PI;
		sm[i].angle.y = (float)random(0, 359) / 360.0f * (float)M_2PI;
		sm[i].angle.z = (float)random(0, 359) / 360.0f * (float)M_2PI;
		sm[i].angvel.x = FFLASH_GS_MINANGVEL;
		sm[i].angvel.y = FFLASH_GS_MINANGVEL;
		sm[i].angvel.z = FFLASH_GS_MINANGVEL;

		sm[i].state = FFLASH_STATE_GSPHERE;
	}
}

void TFireFlashAnimator::Animate(BOOL draw)
{
	T3DAnimator::Animate(draw);
	inst->SetCommandDone(FALSE);

	framenum++;

	int newringparts = 0;

//	Handle glowing sphere crap
	if(framenum >= FFLASH_GS_ON && framenum < FFLASH_EXPLOSION)
	{
		if(gsize < FFLASH_GS_MAXSIZE1)
			gsize += FFLASH_GS_SIZEVEL1;
		else 
			gsize = FFLASH_GS_MAXSIZE1;
	}
	else if(framenum == FFLASH_EXPLOSION)
	{
/*		
		for(int i = 0; i < FFLASH_NUMPARTICLES; i++)
		{
			if(sm[i].state == FFLASH_STATE_USEME || sm[i].state == FFLASH_STATE_GSPHERE)
			{
				if(newringparts > 0)
				{
					memset(&sm[i], 0, sizeof(FFLASH_PARTICLE));

					sm[i].angle.x = 0.0f;
					sm[i].angle.y = 0.0f;
					sm[i].angle.z = ((float)newringparts * (float)M_2PI) / (float)FFLASH_RI_NUMPARTICLES;
					sm[i].angvel.x = 0.0f;
					sm[i].angvel.y = 0.0f;
					sm[i].angvel.z = FFLASH_RI_MINANGVEL;
					sm[i].scale = FFLASH_RI_PSIZE1;

					sm[i].state = FFLASH_STATE_RING;

					newringparts--;
				}
				else
				{
					sm[i].state = FFLASH_STATE_USEME;
					continue;
				}
			}
		}
*/

	//	Make all the particles used for the glowing sphere available for use for the ring
		for(int i = 0; i < FFLASH_NUMPARTICLES; i++)
		{
			if(sm[i].state == FFLASH_STATE_GSPHERE)
				sm[i].state = FFLASH_STATE_USEME;
		}

	//	initialize the ring some more
		rsize = gsize;
				
		newringparts = FFLASH_RI_NUMPARTICLES;
	}
	else if(framenum > FFLASH_EXPLOSION)
	{
		rsize += FFLASH_RI_SIZEVEL1;

		if(rsize >= FFLASH_RI_MAXSIZE)
		{
			for(int i = 0; i < FFLASH_NUMPARTICLES; i++)
				sm[i].state = FFLASH_STATE_USEME;
		}
	}

//	Handle flame1 crap
	int newsmokey1s = 0;

	if(framenum < FFLASH_F1_ON)
	{
		newsmokey1s = 0;
	}
	else if(framenum < FFLASH_F1_TIME1)
	{
		newsmokey1s = FFLASH_F1_ADD1;
		mainscale = FFLASH_F1_MAINSCALE1;
	}
	else if(framenum < FFLASH_F1_TIME2)
	{
		newsmokey1s = FFLASH_F1_ADD2;
		mainscale = FFLASH_F1_MAINSCALE2;
	}	
	else if(framenum < FFLASH_F1_TIME3)
	{
		newsmokey1s = FFLASH_F1_ADD3;
		mainscale = FFLASH_F1_MAINSCALE3;
	}
	else if(framenum < FFLASH_F1_TIME4)
	{
		newsmokey1s = FFLASH_F1_ADD4;
		mainscale = FFLASH_F1_MAINSCALE4;
	}

	for(int i = 0; i < FFLASH_NUMPARTICLES; i++)
	{
		if(sm[i].state == FFLASH_STATE_USEME)
		{
		//	particle is waiting to be assigned for duty	

			if(newsmokey1s)
			{
			//	add a new SMOKEY1

				S3DPoint s3dp;
				int dist = random(0, FFLASH_F1_MAXDIST);
				int angle = random(0, 255);
				ConvertToVector(angle, dist, s3dp);
				sm[i].pos.x = (float)s3dp.x;
				sm[i].pos.y = (float)s3dp.y;
				sm[i].pos.z = FFLASH_F1_BOTTOM;
				sm[i].life = FFLASH_F1_FADEMIN + FFLASH_F1_MAXFADE * (FFLASH_F1_MAXDIST - random(0, dist)) / FFLASH_F1_MAXDIST;
				sm[i].startfade = (sm[i].life * FFLASH_F1_FADEPCT / 100);
				sm[i].stopfade = sm[i].life;
				sm[i].vel.z = 2.0f + (float)random(0, 2);
				sm[i].state = FFLASH_STATE_SMOKEY1;

				newsmokey1s--;
			}
			else if(newringparts)
			{
				S3DPoint s3dp;
				int dist = (int)rsize;
				int angle = random(0, 255);
				ConvertToVector(angle, dist, s3dp);
				sm[i].pos.x = gsphere.x + (float)s3dp.x;
				sm[i].pos.y = gsphere.y + (float)s3dp.y;
				sm[i].pos.z = gsphere.z;
				sm[i].life = FFLASH_F1_FADEMIN + FFLASH_F1_MAXFADE * (FFLASH_F1_MAXDIST - random(0, dist)) / FFLASH_F1_MAXDIST;
				sm[i].startfade = (sm[i].life * FFLASH_F1_FADEPCT / 100);
				sm[i].stopfade = sm[i].life;
				sm[i].vel.z = 2.0f + (float)random(0, 2);
				sm[i].state = FFLASH_STATE_SMOKEY1;

				newringparts--;
			}
		}
		else if(sm[i].state == FFLASH_STATE_SMOKEY1)
		{
		//	particle is a SMOKEY1, so throw it in with the other flames (hehe)
			
			sm[i].pos.z += sm[i].vel.z;
			sm[i].life--;

			if(sm[i].life == 0)
				sm[i].state = FFLASH_STATE_USEME;
		}
		else if(sm[i].state == FFLASH_STATE_GSPHERE)
		{
		//	particle is a GSPHERE, so make it glow around the sphere deal

			sm[i].pivot.x = gsphere.x;
			sm[i].pivot.y = gsphere.y;
			sm[i].pivot.z = gsphere.z;

			sm[i].angle.x += sm[i].angvel.x;
			sm[i].angle.y += sm[i].angvel.y;
			sm[i].angle.z += sm[i].angvel.z;

			sm[i].dist = gsize;
			sm[i].scale = gsize * FFLASH_GS_SIZETOSCALE;

			D3DMATRIX mat;
			D3DMATRIXClear(&mat);
			
			D3DMATRIXRotateX(&mat, sm[i].angle.x);
			D3DMATRIXRotateY(&mat, sm[i].angle.y);
			D3DMATRIXRotateZ(&mat, sm[i].angle.z);
			
			D3DVECTOR v;
			
			v.x = 0.0f;
			v.y = sm[i].dist;
			v.z = 0.0f;

			D3DMATRIXTransform(&mat, &v, &v);

			sm[i].pos.x = sm[i].pivot.x + v.x;
			sm[i].pos.y = sm[i].pivot.y + v.y;
			sm[i].pos.z = sm[i].pivot.z + v.z;
		}
		else if(sm[i].state == FFLASH_STATE_RING)
		{
		//	particle is a RING particle, make an explosion ring

			sm[i].pivot.x = gsphere.x;
			sm[i].pivot.y = gsphere.y;
			sm[i].pivot.z = gsphere.z;

			sm[i].angle.x += sm[i].angvel.x;
			sm[i].angle.y += sm[i].angvel.y;
			sm[i].angle.z += sm[i].angvel.z;

			sm[i].dist = rsize;

			D3DMATRIX mat;
			D3DMATRIXClear(&mat);
			
			D3DMATRIXRotateX(&mat, sm[i].angle.x);
			D3DMATRIXRotateY(&mat, sm[i].angle.y);
			D3DMATRIXRotateZ(&mat, sm[i].angle.z);
			
			D3DVECTOR v;
			
			v.x = 0.0f;
			v.y = sm[i].dist;
			v.z = 0.0f;

			D3DMATRIXTransform(&mat, &v, &v);

			sm[i].pos.x = sm[i].pivot.x + v.x;
			sm[i].pos.y = sm[i].pivot.y + v.y;
			sm[i].pos.z = sm[i].pivot.z + v.z;
		}
	}

	if(framenum >= FFLASH_NOMOREOFTHISEFFECT)
		inst->SetCommandDone(TRUE);

	return;
}

BOOL TFireFlashAnimator::Render()
{
	PS3DAnimObj obj;
	int i;
	
	SaveBlendState();
	SetAddBlendState();

	ResetExtents();

//	All this crap renders the flame
	for(i = 0; i < FFLASH_NUMPARTICLES; i++)
	{
		if(sm[i].state == FFLASH_STATE_SMOKEY1)
		{
			if((sm[i].stopfade - sm[i].life) >= ((sm[i].stopfade - sm[i].startfade) * FFLASH_F1_COLORPCT / 100))
				obj = GetObject(0);
			else
				obj = GetObject(1);

			if(sm[i].life > 0)
			{
				if((sm[i].stopfade - sm[i].life) >= sm[i].startfade)
					sm[i].scale = mainscale * sm[i].life / (sm[i].stopfade - sm[i].startfade) + FFLASH_F1_MINSIZE;
				else
					sm[i].scale = mainscale;
			}
		}
		else if(sm[i].state == FFLASH_STATE_GSPHERE)
		{
			if(framenum >= FFLASH_GS_ON)
			{
			//	Render glowing sphere
				obj = GetObject(1);
			}
			else
				continue;
		}
		else if(sm[i].state == FFLASH_STATE_RING)
		{
		//	Render glowing sphere
			obj = GetObject(1);
		}
		else
			continue;

		if(sm[i].scale > 0.0f)
		{
			obj->flags = OBJ3D_MATRIX;

			D3DMATRIXClear(&obj->matrix);

			D3DMATRIXRotateX(&obj->matrix, -(float)(M_2PI / 3.0));
			D3DMATRIXRotateZ(&obj->matrix, -(float)(M_PI / 4.0));
			D3DMATRIXRotateZ(&obj->matrix, D3DVAL(-((facing / 256.0f) * M_2PI)));

			obj->scl.x = sm[i].scale;
			obj->scl.y = sm[i].scale;
			obj->scl.z = sm[i].scale;
			D3DMATRIXScale(&obj->matrix, &obj->scl);

			obj->pos.x = (float)sm[i].pos.x;
			obj->pos.y = (float)sm[i].pos.y;
			obj->pos.z = (float)sm[i].pos.z;
			
			D3DMATRIXTranslate(&obj->matrix, &obj->pos);

			RenderObject(obj);
		}
	}

	UpdateExtents();            // Updates bound rect and screen rect

	RestoreBlendState();

	return TRUE;
}

void TFireFlashAnimator::RefreshZBuffer()
{
	S3DPoint map, screen;

	int size_x = 200;
	int size_y = 200;

	map.x = 0;
	map.y = 0;
	map.z = 0;
	WorldToScreen(map, screen);
	RestoreZ(screen.x - (size_x / 2), screen.y - size_y, size_x, size_y);
//	Display->Box(screen.x - (size_x / 2), screen.y - size_y, size_x, size_y);
}

// *********************
// * TFireWindEffect *
// *********************

_CLASSDEF(TFireWindEffect)

class TFireWindEffect : public TEffect
{
  public:
    TFireWindEffect(PTObjectImagery newim) : TEffect(newim) { }
    TFireWindEffect(PSObjectDef def, PTObjectImagery newim) : TEffect(def, newim) { }

	virtual void Initialize();
	virtual void Pulse();
};

DEFINE_BUILDER("FireWind", TFireWindEffect)
REGISTER_BUILDER(TFireWindEffect)

void TFireWindEffect::Initialize()
{
}

void TFireWindEffect::Pulse()
{
	TObjectInstance::Pulse();

	if ((spell) && (commanddone))
		KillThisEffect();
}

// ***********************
// * FireWind Animator *
// ***********************

// general defines for create food effect
#define FWIND_NUMPARTICLES			400		//	total number of particles used for everything (size of the particle array)
#define FWIND_RI_NUMPARTICLES		200		//	number of particles which compose the explosion ring (this amount comes out of the total number of particles, they aren't extra)

// defines for particles
#define FWIND_STATE_USEME			0		//	particle is available for use
#define FWIND_STATE_SMOKEY1			1		//	particle is part of a flame
#define FWIND_STATE_GSPHERE			2		//	particle is part of glowing sphere
#define FWIND_STATE_RING			3		//	particle is part of explosion ring
#define FWIND_STATE_FIRERING		4		//	particle is part of a fire ring

// fire defines
#define FWIND_F1_ON				0		//	frame when fire begins
#define FWIND_F1_OFF			25		//	frame when fire ends
#define FWIND_F1_MAXDIST		15		//	maximum radius at the base of the flame
#define FWIND_F1_FADEMIN		20		//	min height at which flame particles may begin fading
#define FWIND_F1_MAXFADE		25		//	max height at which flame particles must fade out
#define FWIND_F1_FADEPCT		20		//	percent of its lifespan when particle starts fading
#define FWIND_F1_BOTTOM			1		//	distance of flame above ground
#define FWIND_F1_COLORPCT		70		//	color changes when particle reaches this percent of flame
#define FWIND_F1_MINSIZE		0.05f	//	fade out to this size, then re-use particle

//	more defines to regulate the flow of the flame
#define FWIND_F1_TIME1			5				//	for each of these frames...
#define FWIND_F1_ADD1			4				//		add this many particles for smoke
#define FWIND_F1_MAINSCALE1		0.3f			//		each beginning about this size
#define FWIND_F1_TIME2			16				//	for each of these frames...
#define FWIND_F1_ADD2			7				//		add this many particles for smoke
#define FWIND_F1_MAINSCALE2		0.3f			//		each beginning about this size
#define FWIND_F1_TIME3			FWIND_F1_OFF	//	for each of these frames...
#define FWIND_F1_ADD3			2				//		add this many particles for smoke
#define FWIND_F1_MAINSCALE3		0.3f			//		each beginning about this size

#define FWIND_GS_ON				28		//	frame when glowing sphere begins
#define FWIND_GS_NUMPARTICLES	100		//	number of particles which compose the glowing sphere
#define FWIND_GS_MINSIZE1		1.0f	//	size of glowing sphere initially
#define FWIND_GS_MAXSIZE1		40.0f	//	size of glowing sphere when it explodes
#define FWIND_GS_SIZEVEL1		3.0f	//	rate glowing sphere grows
#define FWIND_GS_SIZETOSCALE	0.01f	//	size of each particle relative to the size of the sphere
#define FWIND_GS_MINANGVEL		0.12f	//	initial rotation velocity of particles in sphere
#define FWIND_GS_INFRONT		10		//	moves the glowing sphere towards the camera along the ground
#define FWIND_GS_INFRONTUP		5		//	(56% of INFRONT) moves the glowing sphere up to adjust for INFRONT

#define FWIND_RI_MAXSIZE		300.0f	//	ring reaches this size and disappears
#define FWIND_RI_SIZEVEL1		13.0f	//	rate ring grows
#define FWIND_RI_MINANGVEL		0.3f	//	initial rotation velocity of particles in ring
#define FWIND_RI_FADEMIN		3		//	min height at which particles may begin fading
#define FWIND_RI_MAXFADE		6		//	max height at which particles must fade out
#define FWIND_RI_FADEPCT		20		//	percent of its lifespan when particle starts fading
#define FWIND_RI_COLORPCT		70		//	color changes when particle reaches this percent of flame
#define FWIND_RI_MINSIZE		0.05f	//	fade out to this size, then re-use particle
#define FWIND_RI_PSIZE1			0.55f	//	particles in ring start this big

//	defines to regulate the flow of each flame ring
#define FWIND_FR_LIFERAND		10		//	just use it and love it
#define FWIND_FR_FADEMIN		10		//	min height at which flame particles may begin fading
#define FWIND_FR_MAXFADE		15		//	max height at which flame particles must fade out
#define FWIND_FR_FADEPCT		20		//	percent of its lifespan when particle starts fading
#define FWIND_FR_BOTTOM			1		//	distance of flame above ground
#define FWIND_FR_COLORPCT		80		//	color changes when particle reaches this percent of lifespan
#define FWIND_FR_MINSIZE		0.05f	//	fade out to this size, then re-use particle
#define FWIND_FR_NUMKEYS		3		//	number of keyframes (time intervals)
#define FWIND_FR_RINGSIZE1		30		//	number of keyframes (time intervals)
#define FWIND_FR_RINGSPACING	30		//	number of keyframes (time intervals)
#define FWIND_RINGSIZEVEL		4

#define FWIND_FR_RINGTIME1			5		//	wait this many frames before starting first ring
#define FWIND_NEXTRINGWAITOFFSET	0		//	frame difference when last ring ends and next ring starts (can be a negative value to begin before the previous one ends)
#define FWIND_HOWMANYRINGS			1		//	how many fire rings occur after the explosion ring

#define FWIND_EXPLOSION					40		//	frame when explosion starts

#define FWIND_WAITTOEND					5		//	wait this many frames before ending to cleanup any leftovers

_CLASSDEF(TFireWindAnimator)

typedef struct _FWIND_PARTICLE
{
	D3DVECTOR pos;		//	x,y,z position of the particle
	D3DVECTOR pivot;	//	point around which particle rotates
	D3DVECTOR vel;		//	this is the velocity, my friend (up, down, sideways translation)
	D3DVECTOR angle;	//	current angle of rotation around pivot point (in 255 degs)
	D3DVECTOR angvel;	//	angular velocity (rotation speed around its pivot)
	int state;			//	particle is unused, a SWIRLEY, or a SMOKEY
	float scale;		//	size of the particle, my friend
	float dist;			//	distance from pivot point (or radius)
	int life;			//	the particle is alive (displayed while life > 0) or dead (0)
	int startfade;		//	used to control fading (size of particle)
	int stopfade;		//	used to control fading (size of particle)
	int color;
	int whichring;
}FWIND_PARTICLE;

typedef struct _FWIND_FIRERING
{
	int starttime;						//	time when this fire ring begins
	float keyscale[FWIND_FR_NUMKEYS];	//	particles begin about this size for each time interval
	int keyadd[FWIND_FR_NUMKEYS];		//	add this many particles to fire ring per frame during each time interval
	int keytime[FWIND_FR_NUMKEYS];		//	time intervals for controlling flow of fire (how many particles are added at which times)
	int newparticles;					//	counter to help add the particles for each time interval
	int ringsize;						//	size of the ring (or distance to the pivot point if you prefer)
	int dead;							//	Ring is dead after it has gone thru all its keys
}FWIND_FIRERING;

class TFireWindAnimator : public T3DAnimator
{
  private:
    D3DVALUE facing;
    S3DPoint goffset;
	D3DVECTOR gsphere;
	int framenum;
	float mainscale1;
	float mainscale2;
	float gsize;
	float rsize;
	float gscale;
	int howmanyrings;
	int stopclock;
	int waitingtofinish;
	FWIND_PARTICLE sm[FWIND_NUMPARTICLES];	// particles used for the flame
	FWIND_FIRERING fr[FWIND_HOWMANYRINGS];	// properties for each fire ring

  public:
    TFireWindAnimator(PTObjectInstance oi) : T3DAnimator(oi) {}
    virtual ~TFireWindAnimator() { Close(); }

	virtual void Initialize();
	virtual void Animate(BOOL draw);
	virtual BOOL Render();
	virtual void RefreshZBuffer();
};

REGISTER_3DANIMATOR("FireWind", TFireWindAnimator)

void TFireWindAnimator::Initialize()
{
	T3DAnimator::Initialize();

	PLAY("heal sound");

	framenum = 0;

	// Get the direction the fatman is facing.. will be used immediately and later on
	facing = (float)((PTEffect)inst)->GetAngle();

	//	calculate the offset of the flame
	ConvertToVector((int)((255 - facing) + ((138 * 255) / 360)) & 255, FWIND_GS_INFRONT, goffset);
	goffset.z = FWIND_GS_INFRONTUP;

	gsphere.x = 0.0f;
	gsphere.y = 0.0f;
	gsphere.z = 30.0f;
	gsize = FWIND_GS_MINSIZE1;

	waitingtofinish = 0;
	howmanyrings = 0;		//	number of active fire rings (of course 0 until the explosion)

//	setup the properties of each fire ring ahead of time
	memset(fr, 0, sizeof(FWIND_FIRERING) * FWIND_HOWMANYRINGS);
	
	fr[0].starttime = FWIND_EXPLOSION + FWIND_FR_RINGTIME1;
	fr[0].ringsize = FWIND_FR_RINGSIZE1;
	fr[0].keyscale[0] = 0.5f;
	fr[0].keyscale[1] = 0.5f;
	fr[0].keyscale[2] = 0.5f;
	fr[0].keyadd[0] = 28;
	fr[0].keyadd[1] = 28;
	fr[0].keyadd[2] = 28;
	fr[0].keytime[0] = 5;
	fr[0].keytime[1] = 70;
	fr[0].keytime[2] = 75;
/*
	fr[0].starttime = FWIND_EXPLOSION + FWIND_FR_RINGTIME1;
	fr[0].ringsize = FWIND_FR_RINGSIZE1;
	fr[0].keyscale[0] = 0.5f;
	fr[0].keyscale[1] = 0.5f;
	fr[0].keyscale[2] = 0.5f;
	fr[0].keyadd[0] = 10;
	fr[0].keyadd[1] = 15;
	fr[0].keyadd[2] = 8;
	fr[0].keytime[0] = 5;
	fr[0].keytime[1] = 11;
	fr[0].keytime[2] = 15;

	fr[1].keyscale[0] = 0.6f;
	fr[1].keyscale[1] = 0.6f;
	fr[1].keyscale[2] = 0.6f;
	fr[1].keyadd[0] = 10;
	fr[1].keyadd[1] = 15;
	fr[1].keyadd[2] = 8;
	fr[1].keytime[0] = 5;
	fr[1].keytime[1] = 11;
	fr[1].keytime[2] = 15;

	fr[2].keyscale[0] = 0.7f;
	fr[2].keyscale[1] = 0.7f;
	fr[2].keyscale[2] = 0.7f;
	fr[2].keyadd[0] = 22;
	fr[2].keyadd[1] = 30;
	fr[2].keyadd[2] = 20;
	fr[2].keytime[0] = 5;
	fr[2].keytime[1] = 11;
	fr[2].keytime[2] = 15;

	fr[3].keyscale[0] = 0.7f;
	fr[3].keyscale[1] = 0.7f;
	fr[3].keyscale[2] = 0.7f;
	fr[3].keyadd[0] = 22;
	fr[3].keyadd[1] = 30;
	fr[3].keyadd[2] = 20;
	fr[3].keytime[0] = 5;
	fr[3].keytime[1] = 11;
	fr[3].keytime[2] = 15;
*/
	for(int i = 1; i < FWIND_HOWMANYRINGS; i++)
	{
		fr[i].starttime = fr[i - 1].starttime + fr[i - 1].keytime[FWIND_FR_NUMKEYS - 1] + FWIND_NEXTRINGWAITOFFSET;
		fr[i].ringsize = fr[i - 1].ringsize + FWIND_FR_RINGSPACING;
	}

//	assign the particles to their first positions
	memset(sm, 0, sizeof(FWIND_PARTICLE) * FWIND_NUMPARTICLES);

//	assign the appropriate particles to be part of the glowing sphere instead of the fire
	for(i = 0; i < FWIND_GS_NUMPARTICLES; i++)
	{
		sm[i].angle.x = (float)random(0, 359) / 360.0f * (float)M_2PI;
		sm[i].angle.y = (float)random(0, 359) / 360.0f * (float)M_2PI;
		sm[i].angle.z = (float)random(0, 359) / 360.0f * (float)M_2PI;
		sm[i].angvel.x = FWIND_GS_MINANGVEL;
		sm[i].angvel.y = FWIND_GS_MINANGVEL;
		sm[i].angvel.z = FWIND_GS_MINANGVEL;

		sm[i].state = FWIND_STATE_GSPHERE;
	}
}

void TFireWindAnimator::Animate(BOOL draw)
{
	T3DAnimator::Animate(draw);
	inst->SetCommandDone(FALSE);

	framenum++;

//	Handle glowing sphere crap
	if(framenum >= FWIND_GS_ON && framenum < FWIND_EXPLOSION)
	{
		if(gsize < FWIND_GS_MAXSIZE1)
			gsize += FWIND_GS_SIZEVEL1;
		else 
			gsize = FWIND_GS_MAXSIZE1;
	}
	else if(framenum == FWIND_EXPLOSION)
	{
		int newringparts = FWIND_RI_NUMPARTICLES;
		
		for(int i = 0; i < FWIND_NUMPARTICLES; i++)
		{
			if(sm[i].state == FWIND_STATE_USEME || sm[i].state == FWIND_STATE_GSPHERE)
			{
				if(newringparts > 0)
				{
					memset(&sm[i], 0, sizeof(FWIND_PARTICLE));

					sm[i].angle.x = 0.0f;
					sm[i].angle.y = 0.0f;
					sm[i].angle.z = ((float)newringparts * (float)M_2PI) / (float)FWIND_RI_NUMPARTICLES;
					sm[i].angvel.x = 0.0f;
					sm[i].angvel.y = 0.0f;
					sm[i].angvel.z = FWIND_RI_MINANGVEL;
					sm[i].scale = FWIND_RI_PSIZE1;

					sm[i].state = FWIND_STATE_RING;

					newringparts--;
				}
				else
				{
					sm[i].state = FWIND_STATE_USEME;
					continue;
				}
			}
		}

	//	initialize the explosion ring and some more
		rsize = gsize;
	}
	else if(framenum > FWIND_EXPLOSION)
	{
		rsize += FWIND_RI_SIZEVEL1;

		if(rsize >= FWIND_RI_MAXSIZE)
		{
			for(int i = 0; i < FWIND_NUMPARTICLES; i++)
				sm[i].state = FWIND_STATE_USEME;

			rsize = 0.0f;
		}
	}

//	Handle flame1 crap
	int newsmokey1s = 0;

	if(framenum < FWIND_F1_ON)
	{
		newsmokey1s = 0;
	}
	else if(framenum < FWIND_F1_TIME1)
	{
		newsmokey1s = FWIND_F1_ADD1;
		mainscale1 = FWIND_F1_MAINSCALE1;
	}
	else if(framenum < FWIND_F1_TIME2)
	{
		newsmokey1s = FWIND_F1_ADD2;
		mainscale1 = FWIND_F1_MAINSCALE2;
	}	
	else if(framenum < FWIND_F1_TIME3)
	{
		newsmokey1s = FWIND_F1_ADD3;
		mainscale1 = FWIND_F1_MAINSCALE3;
	}

//	Handle fire rings
	for(int i = 0; i < FWIND_HOWMANYRINGS; i++)
	{
		fr[i].newparticles = 0;

		if(!fr[i].dead)		//	if the ring is dead, don't need to do anything further with it
		{
			if(framenum >= fr[i].starttime && framenum < fr[i].starttime + fr[i].keytime[FWIND_FR_NUMKEYS - 1])
			{
				if(framenum == fr[i].starttime)
					howmanyrings++;

				fr[i].ringsize += FWIND_RINGSIZEVEL;

				for(int key = 0; key < FWIND_FR_NUMKEYS; key++)
				{
					if(framenum < fr[i].starttime + fr[i].keytime[key])
					{
						fr[i].newparticles = fr[i].keyadd[key];
						mainscale1 = fr[i].keyscale[key];
						break;
					}
				}

				if(key == FWIND_FR_NUMKEYS)
				{
					fr[i].dead = 1;

					if(howmanyrings == FWIND_HOWMANYRINGS)
					{
					//	done with effect.. set the flag to wait a couple more frames then end
						stopclock = framenum;
						waitingtofinish = 1;
					}
				}
			}
		}
	}

	if(waitingtofinish && framenum >= stopclock + FWIND_WAITTOEND)
		inst->SetCommandDone(TRUE);
	
	for(i = 0; i < FWIND_NUMPARTICLES; i++)
	{
		if(sm[i].state == FWIND_STATE_USEME)
		{
		//	particle is waiting to be assigned for duty	

			if(newsmokey1s)
			{
			//	add a new SMOKEY1 as part of the initial base fire

				memset(&sm[i], 0, sizeof(FWIND_PARTICLE));

				S3DPoint s3dp;
				int dist = random(0, FWIND_F1_MAXDIST);
				int angle = random(0, 255);
				ConvertToVector(angle, dist, s3dp);
				sm[i].pos.x = (float)s3dp.x;
				sm[i].pos.y = (float)s3dp.y;
				sm[i].pos.z = FWIND_F1_BOTTOM;
				sm[i].life = FWIND_F1_FADEMIN + FWIND_F1_MAXFADE * (FWIND_F1_MAXDIST - random(0, dist)) / FWIND_F1_MAXDIST;
				sm[i].startfade = (sm[i].life * FWIND_F1_FADEPCT / 100);
				sm[i].stopfade = sm[i].life;
				sm[i].vel.z = 2.0f + (float)random(0, 2);
				sm[i].state = FWIND_STATE_SMOKEY1;

				newsmokey1s--;
			}
			else
			{
				for(int ring = 0; ring < FWIND_HOWMANYRINGS; ring++)
				{
					if(fr[ring].newparticles)
					{
					//	add a new SMOKEY2 as part of a fire ring

						memset(&sm[i], 0, sizeof(FWIND_PARTICLE));

						sm[i].whichring = ring;

						S3DPoint s3dp;
						sm[i].angle.z = (float)random(0, 255);
						ConvertToVector((int)sm[i].angle.z, fr[sm[i].whichring].ringsize, s3dp);
						sm[i].pos.x = (float)s3dp.x;
						sm[i].pos.y = (float)s3dp.y;
						sm[i].pos.z = FWIND_FR_BOTTOM;
						sm[i].life = FWIND_FR_FADEMIN + FWIND_FR_MAXFADE * random(0, FWIND_FR_LIFERAND) / FWIND_FR_LIFERAND;
						sm[i].startfade = (sm[i].life * FWIND_FR_FADEPCT / 100);
						sm[i].stopfade = sm[i].life;
						sm[i].vel.z = 1.0f + (float)random(0, 3);
						sm[i].state = FWIND_STATE_FIRERING;

						fr[ring].newparticles--;
						break;
					}
				}
			}
		}
		else if(sm[i].state == FWIND_STATE_SMOKEY1)
		{
		//	particle is a SMOKEY1, so throw it in with the other flames (hehe)
			
			sm[i].pos.z += sm[i].vel.z;
			sm[i].life--;

			if(sm[i].life == 0)
				sm[i].state = FWIND_STATE_USEME;
		}
		else if(sm[i].state == FWIND_STATE_FIRERING)
		{
		//	particle is a SMOKEY1, so throw it in with the other flames (hehe)
			
			S3DPoint s3dp;
			ConvertToVector((int)sm[i].angle.z, fr[sm[i].whichring].ringsize, s3dp);
			sm[i].pos.x = (float)s3dp.x;
			sm[i].pos.y = (float)s3dp.y;
			sm[i].pos.z += sm[i].vel.z;
			sm[i].life--;

			if(sm[i].life == 0)
				sm[i].state = FWIND_STATE_USEME;
		}
		else if(sm[i].state == FWIND_STATE_GSPHERE)
		{
		//	particle is a GSPHERE, so make it glow around the sphere deal

			sm[i].pivot.x = gsphere.x;
			sm[i].pivot.y = gsphere.y;
			sm[i].pivot.z = gsphere.z;

			sm[i].angle.x += sm[i].angvel.x;
			sm[i].angle.y += sm[i].angvel.y;
			sm[i].angle.z += sm[i].angvel.z;

			sm[i].dist = gsize;
			sm[i].scale = gsize * FWIND_GS_SIZETOSCALE;

			D3DMATRIX mat;
			D3DMATRIXClear(&mat);
			
			D3DMATRIXRotateX(&mat, sm[i].angle.x);
			D3DMATRIXRotateY(&mat, sm[i].angle.y);
			D3DMATRIXRotateZ(&mat, sm[i].angle.z);
			
			D3DVECTOR v;
			
			v.x = 0.0f;
			v.y = sm[i].dist;
			v.z = 0.0f;

			D3DMATRIXTransform(&mat, &v, &v);

			sm[i].pos.x = sm[i].pivot.x + v.x;
			sm[i].pos.y = sm[i].pivot.y + v.y;
			sm[i].pos.z = sm[i].pivot.z + v.z;
		}
		else if(sm[i].state == FWIND_STATE_RING)
		{
		//	particle is a RING particle, make an explosion ring

			sm[i].pivot.x = gsphere.x;
			sm[i].pivot.y = gsphere.y;
			sm[i].pivot.z = gsphere.z;

			sm[i].angle.x += sm[i].angvel.x;
			sm[i].angle.y += sm[i].angvel.y;
			sm[i].angle.z += sm[i].angvel.z;

			sm[i].dist = rsize;

			D3DMATRIX mat;
			D3DMATRIXClear(&mat);
			
			D3DMATRIXRotateX(&mat, sm[i].angle.x);
			D3DMATRIXRotateY(&mat, sm[i].angle.y);
			D3DMATRIXRotateZ(&mat, sm[i].angle.z);
			
			D3DVECTOR v;
			
			v.x = 0.0f;
			v.y = sm[i].dist;
			v.z = 0.0f;

			D3DMATRIXTransform(&mat, &v, &v);

			sm[i].pos.x = sm[i].pivot.x + v.x;
			sm[i].pos.y = sm[i].pivot.y + v.y;
			sm[i].pos.z = sm[i].pivot.z + v.z;
		}
	}

//	if(framenum >= FWIND_NOMOREOFTHISEFFECT)
//		inst->SetCommandDone(TRUE);

	return;
}

BOOL TFireWindAnimator::Render()
{
	PS3DAnimObj obj;
	int i;
	
	SaveBlendState();
	SetAddBlendState();

	ResetExtents();

//	All this crap renders the flame
	for(i = 0; i < FWIND_NUMPARTICLES; i++)
	{
		if(sm[i].state == FWIND_STATE_SMOKEY1)
		{
			if((sm[i].stopfade - sm[i].life) >= ((sm[i].stopfade - sm[i].startfade) * FWIND_F1_COLORPCT / 100))
				obj = GetObject(0);
			else
				obj = GetObject(1);

			if(sm[i].life > 0)
			{
				if((sm[i].stopfade - sm[i].life) >= sm[i].startfade)
					sm[i].scale = mainscale1 * sm[i].life / (sm[i].stopfade - sm[i].startfade) + FWIND_F1_MINSIZE;
				else
					sm[i].scale = mainscale1;
			}
		}
		else if(sm[i].state == FWIND_STATE_FIRERING)
		{
			if((sm[i].stopfade - sm[i].life) >= ((sm[i].stopfade - sm[i].startfade) * FWIND_F1_COLORPCT / 100))
				obj = GetObject(0);
			else
				obj = GetObject(1);

			if(sm[i].life > 0)
			{
				if((sm[i].stopfade - sm[i].life) >= sm[i].startfade)
					sm[i].scale = mainscale1 * sm[i].life / (sm[i].stopfade - sm[i].startfade) + FWIND_F1_MINSIZE;
				else
					sm[i].scale = mainscale1;
			}
		}
		else if(sm[i].state == FWIND_STATE_GSPHERE)
		{
			if(framenum >= FWIND_GS_ON)
			{
			//	Render glowing sphere
				obj = GetObject(1);
			}
			else
				continue;
		}		
		else if(sm[i].state == FWIND_STATE_RING)
		{
		//	Render glowing sphere
			obj = GetObject(1);
		}
		else
			continue;

		if(sm[i].scale > 0.0f)
		{
			obj->flags = OBJ3D_MATRIX;

			D3DMATRIXClear(&obj->matrix);

			D3DMATRIXRotateX(&obj->matrix, -(float)(M_2PI / 3.0));
			D3DMATRIXRotateZ(&obj->matrix, -(float)(M_PI / 4.0));
			D3DMATRIXRotateZ(&obj->matrix, D3DVAL(-((facing / 256.0f) * M_2PI)));

			obj->scl.x = sm[i].scale;
			obj->scl.y = sm[i].scale;
			obj->scl.z = sm[i].scale;
			D3DMATRIXScale(&obj->matrix, &obj->scl);

			obj->pos.x = (float)sm[i].pos.x;
			obj->pos.y = (float)sm[i].pos.y;
			obj->pos.z = (float)sm[i].pos.z;
			
			D3DMATRIXTranslate(&obj->matrix, &obj->pos);

			RenderObject(obj);
		}
	}

	UpdateExtents();            // Updates bound rect and screen rect

	RestoreBlendState();

	return TRUE;
}

void TFireWindAnimator::RefreshZBuffer()
{
	S3DPoint map, screen;

	int size_x = 640;
	int size_y = 480;

	((PTEffect)inst)->GetPos(map);
	WorldToScreen(map, screen);
	RestoreZ(screen.x - (size_x / 2), screen.y - (size_y / 2), size_x, size_y);
//	Display->Box(screen.x - (size_x / 2), screen.y - (size_y / 2), size_x, size_y);
}

DEFINE_BUILDER("BURNBABYBURN", TBurnBabyBurnEffect)
REGISTER_BUILDER(TBurnBabyBurnEffect)

void TBurnBabyBurnEffect::Set(PTCharacter ch)
{
	character = ch;

	valid = TRUE;
}

void TBurnBabyBurnEffect::Initialize()
{
	character = NULL; 
	valid = FALSE; 
}

void TBurnBabyBurnEffect::Pulse()
{
	TEffect::Pulse();
}

REGISTER_3DANIMATOR("BurnBabyBurn", TBurnBabyBurnAnimator)

void TBurnBabyBurnAnimator::Initialize()
{
	T3DAnimator::Initialize();

	framenum = 0;
	animm = (PT3DAnimator)((PTBurnBabyBurnEffect)inst)->GetCharacter()->GetAnimator();
	memset(sm, 0, sizeof(BURNBABYBURN_PARTICLE) * BURNBABYBURN_NUMPARTICLES);

	numvalidobjs = animm->NumObjects();
	
	if(numvalidobjs > BURNBABYBURN_MAXOBJS)
		numvalidobjs = BURNBABYBURN_MAXOBJS;

	for(int i = 0; i < numvalidobjs; i++)
	{
		obj_ptrs[i] = animm->GetObject(i);
		animm->GetVerts(obj_ptrs[i], D3DVT_VERTEX);
	}
}

void TBurnBabyBurnAnimator::Animate(BOOL draw)
{
	T3DAnimator::Animate(draw);
	inst->SetCommandDone(FALSE);

	framenum++;

//	Handle flame1 crap
	int newsmokey1s = 0;

	if(framenum < BURNBABYBURN_F1_ON)
	{
		newsmokey1s = 0;
	}
	else if(framenum < BURNBABYBURN_F1_TIME1)
	{
		newsmokey1s = BURNBABYBURN_F1_ADD1;
		mainscale1 = BURNBABYBURN_F1_MAINSCALE1;
	}
	else if(framenum < BURNBABYBURN_F1_TIME2)
	{
		newsmokey1s = BURNBABYBURN_F1_ADD2;
		mainscale1 = BURNBABYBURN_F1_MAINSCALE2;
	}	
	else if(framenum < BURNBABYBURN_F1_TIME3)
	{
		newsmokey1s = BURNBABYBURN_F1_ADD3;
		mainscale1 = BURNBABYBURN_F1_MAINSCALE3;
	}

	PS3DAnimObj obj = NULL;

	if(newsmokey1s)
		obj = obj_ptrs[random(0, numvalidobjs - 1)];

	for(int i = 0; i < BURNBABYBURN_NUMPARTICLES; i++)
	{
		if(sm[i].state == BURNBABYBURN_STATE_USEME)
		{
		//	particle is waiting to be assigned for duty	

			if(newsmokey1s)
			{
			//	add a new SMOKEY1 as part of the initial base fire

				memset(&sm[i], 0, sizeof(BURNBABYBURN_PARTICLE));

				LPD3DVERTEX vp = &obj->verts[random(0, obj->numverts - 1)];
				sm[i].pos.x = (float)obj->pos.x + (float)vp->x;
				sm[i].pos.y = (float)obj->pos.y + (float)vp->y;
				sm[i].pos.z = (float)obj->pos.z + (float)vp->z;
				sm[i].life = BURNBABYBURN_F1_FADEMIN + BURNBABYBURN_F1_MAXFADE * (BURNBABYBURN_F1_MAXDIST - random(0, BURNBABYBURN_F1_MAXDIST)) / BURNBABYBURN_F1_MAXDIST;
				sm[i].startfade = (sm[i].life * BURNBABYBURN_F1_FADEPCT / 100);
				sm[i].stopfade = sm[i].life;
				sm[i].vel.z = 2.0f + (float)random(0, 2);
				sm[i].state = BURNBABYBURN_STATE_SMOKEY1;

				newsmokey1s--;
			}
		}
		else if(sm[i].state == BURNBABYBURN_STATE_SMOKEY1)
		{
		//	particle is a SMOKEY1, so throw it in with the other flames (hehe)
			
//			sm[i].pos.z += sm[i].vel.z;
//			sm[i].life--;

			if(sm[i].life == 0)
				sm[i].state = BURNBABYBURN_STATE_USEME;
		}
	}

	if(framenum >= BURNBABYBURN_THISEFFECTISDONE)
		inst->SetCommandDone(TRUE);

	return;
}

BOOL TBurnBabyBurnAnimator::Render()
{
	PS3DAnimObj obj;
	int i;
	
	SaveBlendState();
	SetAddBlendState();

//	ResetExtents();

//	All this crap renders the flame
	for(i = 0; i < BURNBABYBURN_NUMPARTICLES; i++)
	{
		if(sm[i].state == BURNBABYBURN_STATE_SMOKEY1)
		{
			if((sm[i].stopfade - sm[i].life) >= ((sm[i].stopfade - sm[i].startfade) * BURNBABYBURN_F1_COLORPCT / 100))
				obj = GetObject(0);
			else
				obj = GetObject(1);

			if(sm[i].life > 0)
			{
				if((sm[i].stopfade - sm[i].life) >= sm[i].startfade)
					sm[i].scale = mainscale1 * sm[i].life / (sm[i].stopfade - sm[i].startfade) + BURNBABYBURN_F1_MINSIZE;
				else
					sm[i].scale = mainscale1;
			}
	
			if(sm[i].scale > 0.0f)
			{
				obj->flags = OBJ3D_MATRIX | OBJ3D_ABSPOS;

				D3DMATRIXClear(&obj->matrix);

				D3DMATRIXRotateX(&obj->matrix, -(float)(M_2PI / 3.0));
				D3DMATRIXRotateZ(&obj->matrix, -(float)(M_PI / 4.0));

				obj->scl.x = sm[i].scale;
				obj->scl.y = sm[i].scale;
				obj->scl.z = sm[i].scale;
				D3DMATRIXScale(&obj->matrix, &obj->scl);

				S3DPoint fatman;
				((PTBurnBabyBurnEffect)inst)->GetCharacter()->GetPos(fatman);

				obj->pos.x = (float)fatman.x + (float)sm[i].pos.x;
				obj->pos.y = (float)fatman.y + (float)sm[i].pos.y;
				obj->pos.z = (float)fatman.z + (float)sm[i].pos.z;
				
				D3DMATRIXTranslate(&obj->matrix, &obj->pos);

				RenderObject(obj);
			}
		}
	}

//	UpdateExtents();            // Updates bound rect and screen rect

	RestoreBlendState();

	return TRUE;
}

void TBurnBabyBurnAnimator::RefreshZBuffer()
{
	S3DPoint map, screen;

	int size_x = 200;
	int size_y = 200;

	map.x = 0;
	map.y = 0;
	map.z = 0;
	WorldToScreen(map, screen);
	RestoreZ(screen.x - (size_x / 2), screen.y - size_y, size_x, size_y);
//	Display->Box(screen.x - (size_x / 2), screen.y - size_y, size_x, size_y);
}

//*// **********************
//*// * Lightning Animator *
//*// **********************
//*
//*REGISTER_3DANIMATOR("LIGHTNING2", TLightningAnimator)
//*
//*//==============================================================================
//*//    Function : Initialize.
//*//------------------------------------------------------------------------------
//*// Description :
//*//
//*//==============================================================================
//*
//*void TLightningAnimator::Initialize()
//*{
//*	T3DAnimator::Initialize();
//*	S3DPoint pos;
//*    S3DPoint dir;
//*
//*    inst->GetPos(pos);
//*    inst->GetVel(dir);
//*
//*    for (int n = 0; n < NUM_LIGHTNING_SEGMENTS; n++)
//*    {
//*        p[n].x = (D3DVALUE)pos.x + dir.x / ROLLOVER * n;
//*        p[n].y = (D3DVALUE)pos.y + dir.y / ROLLOVER * n;
//*        p[n].z = FIX_Z_VALUE(pos.z);
//*    }
//*
//*    framenum = 0;
//*}
//*
//*//==============================================================================
//*//    Function : Animate.
//*//------------------------------------------------------------------------------
//*// Description :
//*//
//*//==============================================================================
//*
//*void TLightningAnimator::Animate(BOOL draw)
//*{
//*	T3DAnimator::Animate(draw);
//*
//*    framenum++;
//*    if (framenum >= LIGHTNING_DURATION)
//*        inst->SetCommandDone(TRUE);
//*}
//*
//*//==============================================================================
//*//    Function : Render.
//*//------------------------------------------------------------------------------
//*// Description :
//*//
//*//==============================================================================
//*
//*BOOL TLightningAnimator::Render()
//*{
//*    SaveBlendState();
//*    SetBlendState();
//*
//*    PS3DAnimObj obj = GetObject(0);
//*
//*    for (int n = 0; n < NUM_LIGHTNING_SEGMENTS; n++)
//*	{
//*        int r = random(1, 2);
//*        for (int c = 0; c < r; c++)
//*        {
//*            Get3DImagery()->ResetExtents();             // Reset render extents
//*
//*            //obj->flags = OBJ3D_SCL1 | OBJ3D_POS2 | OBJ3D_ABSPOS;
//*            obj->flags = OBJ3D_ROT1 | OBJ3D_SCL2 | OBJ3D_POS3 | OBJ3D_ABSPOS;
//*            obj->rot.x = obj->rot.y = D3DVAL(0.0);
//*            obj->rot.z = (D3DVALUE)((PTLightning2Effect)inst)->angle * (D3DVALUE)M_PI * 2 / 255;
//*            obj->scl.x = obj->scl.y = obj->scl.z = (D3DVALUE)1.75;
//*            obj->pos = p[n];
//*
//*            if ((c) && (random(0, 1)))
//*            {
//*                obj->flags = OBJ3D_ROT1 | OBJ3D_SCL2 | OBJ3D_POS3 | OBJ3D_ABSPOS;
//*                obj->rot.x = obj->rot.y = D3DVAL(0.0);
//*                obj->rot.z = D3DVAL(random(1, 20)) / D3DVAL(3.0);
//*            }
//*
//*            frame = random(0, 2);
//*
//*            RenderObject(obj);
//*
//*            UpdateExtents();            // Updates bound rect and screen rect
//*        }
//*	}
//*
//*    RestoreBlendState();
//*
//*	return TRUE;
//*}

// *****************************
// * Fountain Sparkle Animator *
// *****************************

//==============================================================================
//    Function : Initialize.
//------------------------------------------------------------------------------
// Description :
//
//==============================================================================

void TFountainAnimator::Initialize()
{
	T3DAnimator::Initialize();

    // Initialize the starting positions of the bubbles
    for (int n = 0; n < NUM_FOUNTAIN_BUBBLES; n++)
	{
        p[n].x = (D3DVALUE)(random(-FOUNTAIN_RADIUS, FOUNTAIN_RADIUS));
        p[n].y = (D3DVALUE)(random(-FOUNTAIN_RADIUS, FOUNTAIN_RADIUS));
        p[n].z = (D3DVALUE)0.0;
        rise[n] = (D3DVALUE)(random(1, 3) / (D3DVALUE)2.0);
        scale[n] = 2.0;
        framenum[n] = random(-NUM_FOUNTAIN_BUBBLES / 2, 0);
	}

    SetColorObject();
}

//==============================================================================
//    Function : Animate.
//------------------------------------------------------------------------------
// Description : This updates the frame number, position, and scale values
//               of all the bubbles.
//==============================================================================

void TFountainAnimator::Animate(BOOL draw)
{
	T3DAnimator::Animate(draw);

    // Update all the bubbles
    for (int n = 0; n < NUM_FOUNTAIN_BUBBLES; n++)
	{
        // Update the frame counter
        framenum[n]++;

        if (framenum[n] > 0)
        {
            // Float the bubbles up
            p[n].z += rise[n];

            // Scale the bubbles down
            scale[n] -= (D3DVALUE)FOUNTAIN_SCALE_STEP;

            // See if the bubble has shrunk out of sight, and reset it if it has
            if (scale[n] <= 0)
            {
                p[n].x = (D3DVALUE)(random(-FOUNTAIN_RADIUS, FOUNTAIN_RADIUS));
                p[n].y = (D3DVALUE)(random(-FOUNTAIN_RADIUS, FOUNTAIN_RADIUS));
                p[n].z = (D3DVALUE)0.0;
                rise[n] = (D3DVALUE)(random(1, 3) / (D3DVALUE)2.0);
                scale[n] = 2.0;
                framenum[n] = random(-NUM_FOUNTAIN_BUBBLES / 2, 0);
            }
        }
	}
}

//==============================================================================
//    Function : Render.
//------------------------------------------------------------------------------
// Description : This loops through all the fountain bubbles and renders each
//               at the appropriate location and scale value.
//==============================================================================

BOOL TFountainAnimator::Render()
{
    SaveBlendState();
    SetBlendState();

    PS3DAnimObj obj = GetObject(colorobj);

    for (int n = 0; n < NUM_FOUNTAIN_BUBBLES; n++)
	{
        if (framenum[n] > 0)
        {
            Get3DImagery()->ResetExtents();             // Reset render extents

            obj->flags = OBJ3D_SCL1 | OBJ3D_POS2;
            obj->scl.x = obj->scl.y = obj->scl.z = scale[n];
            obj->pos = p[n];

            RenderObject(obj);

            UpdateExtents();            // Updates bound rect and screen rect
        }
	}

    RestoreBlendState();

	return TRUE;
}


void TFountainAnimator::RefreshZBuffer()
{
	S3DPoint screen, effect;

	((PTEffect)inst)->GetPos(effect);


	int size_x = 100;
	int size_y = 75;

	WorldToScreen(effect, screen);
	RestoreZ((screen.x - (size_x / 2))+0, screen.y - size_y + 30, size_x, size_y);
	//Display->Box((screen.x - (size_x / 2))+0, screen.y - size_y + 30, size_x, size_y);
}

// **************************
// * Cyan Fountain Animator *
// **************************

REGISTER_3DANIMATOR("CYANFONT", TCyanFountainAnimator)

// *************************
// * Red Fountain Animator *
// *************************

REGISTER_3DANIMATOR("REDFONT", TRedFountainAnimator)

// ***************************
// * Green Fountain Animator *
// ***************************

REGISTER_3DANIMATOR("GREENFONT", TGreenFountainAnimator)

// **************************
// * Blue Fountain Animator *
// **************************

REGISTER_3DANIMATOR("BLUEFONT", TBlueFountainAnimator)

// *******************
// * Ribbon Animator *
// *******************

REGISTER_3DANIMATOR("RIBBON", TRibbonAnimator)

//==============================================================================
//    Function : Initialize.
//------------------------------------------------------------------------------
// Description :
//
//==============================================================================

void TRibbonAnimator::Initialize()
{
	int n;
    S3DTex tex;

	T3DAnimator::Initialize();

    // Get how many frames are in the texture
    Get3DImagery()->GetTexture(0, &tex);
    numtexframes = tex.numframes;

    ribbontimer = 0;

    // Initialize the starting positions of the ribbons
    ribpos.x = ribpos.y = 0;
    ribpos.z = -200;
    ribscale = (D3DVALUE)4.5;
    for (n = 0; n < NUM_RIBBONS; n++)
        rotation[n] = (D3DVALUE)n * 2;

    centerscale = (D3DVALUE)6.5;

    // Initialize the starting positions of the ribbon sparks
    for (n = 0; n < NUM_RIBBON_SPARKS; n++)
	{
        p[n].x = (D3DVALUE)(random(-RIBBON_RADIUS, RIBBON_RADIUS));
        p[n].y = (D3DVALUE)(random(-RIBBON_RADIUS, RIBBON_RADIUS));
        p[n].z = (D3DVALUE)(random(0, RIBBON_RADIUS / 2));

        v[n].x = -p[n].x / RIBBON_SPARK_DURATION / 2;
        v[n].y = -p[n].y / RIBBON_SPARK_DURATION / 2;
        v[n].z = .5;

        scale[n] = 0.0;
        framenum[n] = random(-NUM_RIBBON_SPARKS, 0);
	}
}

//==============================================================================
//    Function : Animate.
//------------------------------------------------------------------------------
// Description :
//
//==============================================================================

void TRibbonAnimator::Animate(BOOL draw)
{
    int n;

	T3DAnimator::Animate(draw);
	inst->SetCommandDone(FALSE);

    // Update the ribbon timer
    ribbontimer++;

    // Update all ribbons
    for (n = 0; n < NUM_RIBBONS; n++)
	{
        // Rotate the ribbons
        rotation[n] += (D3DVALUE)0.2;
	}

    // See if the effect has run its course
    if (ribbontimer < RIBBON_DURATION)
    {
        // Raise the ribbons out of the ground
        if (ribpos.z < 0)
        {
            ribpos.z += 10;
            if (ribpos.z > 0)
                ribpos.z = 0;
        }
    }
	/*
    else
    {
        // Collapse the ribbons
        ribscale = ribscale * 9 / 10;
        centerscale = centerscale * 9 / 10;
        if (ribscale < .5)
            inst->SetCommandDone(TRUE);
    }
	*/

    // Update all ribbon sparks
    for (n = 0; n < NUM_RIBBON_SPARKS; n++)
	{
        framenum[n]++;

        if (framenum[n] > 0)
        {
            // See if this spark is done
            if (framenum[n] >= RIBBON_SPARK_DURATION)
            {
                //if (ribbontimer < RIBBON_DURATION)
                {
                    p[n].x = (D3DVALUE)(random(-RIBBON_RADIUS, RIBBON_RADIUS));
                    p[n].y = (D3DVALUE)(random(-RIBBON_RADIUS, RIBBON_RADIUS));
                    p[n].z = (D3DVALUE)(random(0, RIBBON_RADIUS / 2));

                    v[n].x = -p[n].x / RIBBON_SPARK_DURATION / 2;
                    v[n].y = -p[n].y / RIBBON_SPARK_DURATION / 2;
                    v[n].z = .5;

                    framenum[n] = 0;
                }
                scale[n] = 0.0;
            }
            else
            if (framenum[n] > RIBBON_SPARK_DURATION / 2)
                scale[n] -= RIBBON_SPARK_SCALE_STEP;
            else
                scale[n] += RIBBON_SPARK_SCALE_STEP;

            // Move the sparks
            p[n].x += v[n].x;
            p[n].y += v[n].y;
            p[n].z += v[n].z;

            // Accelerate the sparks movements upward
            v[n].z += 0.5;
        }
	}

}

//==============================================================================
//    Function : Render.
//------------------------------------------------------------------------------
// Description :
//
//==============================================================================

BOOL TRibbonAnimator::Render()
{
	int n;

    SaveBlendState();
    SetBlendState();

    //
    // Draw the ribbons sparks here
    //

    PS3DAnimObj obj = GetObject(0);

    for (n = 0; n < NUM_RIBBON_SPARKS; n++)
	{
        if ((framenum[n] > 0) && (scale[n] > 0))
        {
            Get3DImagery()->ResetExtents();             // Reset render extents

            obj->flags = OBJ3D_ROT1 | OBJ3D_SCL2 | OBJ3D_POS3;
            obj->rot.x = D3DVAL(-(M_PI / 2.0));
            obj->rot.y = D3DVAL(0.0);
            obj->rot.z = D3DVAL(-(M_PI / 4.0));
            obj->scl.x = obj->scl.y = obj->scl.z = scale[n];
            obj->pos = p[n];

            // Set the frame number manually
            frame = framenum[n] % numtexframes;

            RenderObject(obj);

            UpdateExtents();            // Updates bound rect and screen rect
        }
	}

    //
    // Draw the center floor spark here
    //

    Get3DImagery()->ResetExtents();             // Reset render extents

    obj->flags = OBJ3D_SCL1;
    obj->scl.x = obj->scl.y = obj->scl.z = centerscale;

    // Set the frame number manually
    frame = ribbontimer % numtexframes;

    RenderObject(obj);

    UpdateExtents();            // Updates bound rect and screen rect


    //
    // Draw the ribbons here
    //

    obj = GetObject(1);

    for (n = 0; n < NUM_RIBBONS; n++)
	{
        Get3DImagery()->ResetExtents();             // Reset render extents

        obj->flags = OBJ3D_ROT1 | OBJ3D_SCL2 | OBJ3D_POS3;
        obj->scl.x = obj->scl.y = ribscale;
        obj->scl.z = 9.0;
		obj->rot.z = rotation[n];
        obj->pos = ribpos;

        RenderObject(obj);

        UpdateExtents();            // Updates bound rect and screen rect
	}

    RestoreBlendState();

	return TRUE;
}

// *******************
// * Shield Animator *
// *******************

REGISTER_3DANIMATOR("SHIELD", TShieldAnimator)

//==============================================================================
//    Function : Initialize.
//------------------------------------------------------------------------------
// Description :
//
//==============================================================================

void TShieldAnimator::Initialize()
{
	T3DAnimator::Initialize();

	pos.x = pos.y = 0;
	pos.z = 40;
}

//==============================================================================
//    Function : Animate.
//------------------------------------------------------------------------------
// Description :
//
//==============================================================================

void TShieldAnimator::Animate(BOOL draw)
{
	T3DAnimator::Animate(draw);

}

//==============================================================================
//    Function : Render.
//------------------------------------------------------------------------------
// Description :
//
//==============================================================================

BOOL TShieldAnimator::Render()
{
    SaveBlendState();
    SetBlendState();

    PS3DAnimObj obj = GetObject(0);

    Get3DImagery()->ResetExtents();             // Reset render extents

    obj->flags = OBJ3D_MATRIX;
    obj->scl.x = obj->scl.y = obj->scl.z = SHIELD_SCALE;
	obj->pos = pos;

    D3DMATRIXClear(&obj->matrix);

    D3DMATRIXRotateX(&obj->matrix, D3DVAL(-(M_PI / 3.0)));
    D3DMATRIXRotateZ(&obj->matrix, D3DVAL(-(M_PI / 4.0)));

    D3DMATRIXScale(&obj->matrix, &obj->scl);
    D3DMATRIXTranslate(&obj->matrix, &obj->pos);

    RenderObject(obj);

    UpdateExtents();            // Updates bound rect and screen rect

    RestoreBlendState();

	return TRUE;
}

// ******************
// * Flame Animator *
// ******************

REGISTER_3DANIMATOR("FLAME", TFlameAnimator)

//==============================================================================
//    Function : Initialize.
//------------------------------------------------------------------------------
// Description :
//
//==============================================================================

void TFlameAnimator::Initialize()
{
	T3DAnimator::Initialize();

	PS3DAnimObj obj = GetObject(0);
	GetVerts(obj, D3DVT_LVERTEX);
	
	frame = 0;
}

//==============================================================================
//    Function : Animate.
//------------------------------------------------------------------------------
// Description :
//
//==============================================================================

void TFlameAnimator::Animate(BOOL draw)
{
	T3DAnimator::Animate(draw);

    ++frame;
    if (frame >= 18)
        frame = 0;
}

//==============================================================================
//    Function : Render.
//------------------------------------------------------------------------------
// Description :
//
//==============================================================================

BOOL TFlameAnimator::Render()
{
    SaveBlendState();
    SetBlendState();

    PS3DAnimObj obj = GetObject(0);

    ResetExtents();             // Reset render extents

    obj->flags = OBJ3D_MATRIX | OBJ3D_VERTS;
	D3DMATRIXClear(&obj->matrix);

	D3DMATRIXRotateX( &obj->matrix, D3DVAL( 45 * TORADIAN));
	D3DMATRIXRotateY( &obj->matrix, D3DVAL( 30 * TORADIAN));
	D3DMATRIXRotateZ( &obj->matrix, D3DVAL(160 * TORADIAN));

    obj->scl.x = .5f;
	obj->scl.y = .5f;
	obj->scl.z = .5f;
	D3DMATRIXScale(&obj->matrix, &obj->scl);

	obj->pos.x = obj->pos.y = obj->pos.z = 0.0f;
	D3DMATRIXTranslate(&obj->matrix, &obj->pos);

	float xpos = (float)((int)(frame * 11 / 24) % 4) * .25f;
	float ypos = (float)((int)(frame * 11 / 24) / 4) * .5f;

	obj->lverts[0].tu = xpos;
	obj->lverts[0].tv = ypos;

	obj->lverts[1].tu = xpos + .25f;
	obj->lverts[1].tv = ypos;

	obj->lverts[2].tu = xpos;
	obj->lverts[2].tv = ypos + .5f;

	obj->lverts[3].tu = xpos + .25f;
	obj->lverts[3].tv = ypos + .5f;

    RenderObject(obj);

    UpdateExtents();            // Updates bound rect and screen rect

    RestoreBlendState();

	return TRUE;
}

void TFlameAnimator::RefreshZBuffer()
{
	S3DPoint effect, screen, size;

	size.x = (int)(50.0f * .5f);
	size.y = (int)(125.0f * .5f);

	((PTEffect)inst)->GetPos(effect);

	WorldToScreen(effect, screen);
	RestoreZ(screen.x - (size.x / 2), screen.y - size.y / 2, size.x, size.y);
}

// ********************
// * SymGlow Animator *
// ********************

REGISTER_3DANIMATOR("SymGlow", TSymGlowAnimator)

// Sets up the objects to animate (simply uses whatever objects are in the imagery)
// Override this function to set up whatever objects you need for your effect, etc.
void TSymGlowAnimator::SetupObjects()
{
	timer = 0;
	zscale = (D3DVALUE)2.0;
	dz = (D3DVALUE)0.1;

	for (int c = 0; c < Get3DImagery()->NumObjects(); c++)
	{
		PS3DAnimObj o = NewObject(c);
        GetVerts(o, D3DVT_VERTEX);
		AddObject(o);
		for (int v = 0; v < o->numverts; v++)
		{
	//		objBarrier->lverts[v].tu += 0.01f;
			o->lverts[v].tv -= 0.01f;
		}
	}

}

//==============================================================================
//    Function : Animate.
//------------------------------------------------------------------------------
// Description :
//
//==============================================================================

void TSymGlowAnimator::Animate(BOOL draw)
{
	T3DAnimator::Animate(draw);

    timer++;

	if (!(timer % 40))
		dz *= -1;

	zscale += dz;

	if (zscale < 2.0)
		zscale = 2.0;
	else
	if (zscale > 5.0)
		zscale = 5.0;

	u = (D3DVALUE)random(2, 8) / (D3DVALUE)100.0;
}

//==============================================================================
//    Function : Render.
//------------------------------------------------------------------------------
// Description :
//
//==============================================================================

BOOL TSymGlowAnimator::Render()
{
    SaveBlendState();
    SetBlendState();

    PS3DAnimObj obj = GetObject(0);

    Get3DImagery()->ResetExtents();             // Reset render extents

	for (int n = 0; n < obj->numverts; n++)
        obj->verts[n].tu += u;

    obj->flags = OBJ3D_SCL1 | OBJ3D_VERTS;
    obj->scl.x = obj->scl.y = (D3DVALUE)1.4;
	obj->scl.z = zscale;
	
	RenderObject(obj);

    UpdateExtents();            // Updates bound rect and screen rect

    RestoreBlendState();

	return TRUE;
}


void TSymGlowAnimator::RefreshZBuffer()
{
	S3DPoint screen, effect;

	((PTEffect)inst)->GetPos(effect);


	int size_x = 100;
	int size_y = 170;

	WorldToScreen(effect, screen);
	RestoreZ(screen.x - (size_x / 2), screen.y - size_y + 30, size_x, size_y);
	//Display->Box(screen.x - (size_x / 2), screen.y - size_y + 30, size_x, size_y);
}

// *********************
// * Particle Animator *
// *********************

REGISTER_MULTI_3DANIMATOR_("blood", TBloodAnimator, TParticle3DAnimator)								\
REGISTER_MULTI_3DANIMATOR_("sparks", TSparkAnimator, TParticle3DAnimator)								\
REGISTER_MULTI_3DANIMATOR_("icedsparks", TIcedSparksAnimator, TParticle3DAnimator)						\
REGISTER_MULTI_3DANIMATOR_("sand", TSandAnimator, TParticle3DAnimator)
REGISTER_MULTI_3DANIMATOR_("snow", TSnowAnimator, TParticle3DAnimator)

void TParticle3DAnimator::Initialize()
{
	T3DAnimator::Initialize();

	memset(&params, 0, sizeof(SParticleParams));
	p = NULL;
	v = NULL;
	l = NULL;
	s = NULL;
	o = NULL;
	ti = NULL;
}

void TParticle3DAnimator::Close()
{
	if (p)
		delete p;
	if (v)
		delete v;
	if (l)
		delete l;
	if (s)
		delete s;
	if (o)
		delete o;
	if (ti)
		delete ti;

	T3DAnimator::Close();
}

//void TParticle3DAnimator::SetupObjects()
//{
//	T3DAnimator::SetupObjects(); // Don't change
//}


void TParticle3DAnimator::ResetTargetInfo(SParticleParams nparams)
{
	int i;
	params.seektargets = nparams.seektargets;
	params.seekspeed = nparams.seekspeed;
	params.turnang = nparams.turnang;
	params.autorange = nparams.autorange;
	params.hitrange = nparams.hitrange;
	if (ti)
		delete ti;
	if (params.numtargets)
		ti = new int[params.particles];
	params.numtargets = nparams.numtargets;
	for (i = 0; i < params.numtargets; i++)
		params.targetpos[i] = nparams.targetpos[i];
	for (i = 0; i < params.particles; i++)
		if (params.numtargets > 0)
			ti[i] = random(0, params.numtargets - 1);
}

// Sets up particle animator
void TParticle3DAnimator::InitParticles(PSParticleParams nparams)
{
	memcpy(&params, nparams, sizeof(SParticleParams)); 

	p = new D3DVECTOR[params.particles];
	v = new D3DVECTOR[params.particles];
	s = new int[params.particles];
	l = new int[params.particles];
	o = new int[params.particles];
	if (params.numtargets)
		ti = new int[params.particles];

	BYTE objs[32];
	int numobjs = 0;
	for (int c = 0; c < NumObjects(); c++)
	{
		if (params.objflags & (1 << c))
			objs[numobjs++] = c;
	}
	if (numobjs <= 0)
		objs[numobjs++] = 0;

	for (c = 0; c < params.particles; c++)
	{
		p[c].x = params.pos.x + params.pspread.x * ((D3DVALUE)random(-100, 100) / (D3DVALUE)100.0); 
		p[c].y = params.pos.y + params.pspread.y * ((D3DVALUE)random(-100, 100) / (D3DVALUE)100.0); 
		p[c].z = params.pos.z + params.pspread.z * ((D3DVALUE)random(-100, 100) / (D3DVALUE)100.0); 
		v[c].x = params.dir.x + params.spread.x * ((D3DVALUE)random(-100, 100) / (D3DVALUE)100.0); 
		v[c].y = params.dir.y + params.spread.y * ((D3DVALUE)random(-100, 100) / (D3DVALUE)100.0); 
		v[c].z = params.dir.z + params.spread.z * ((D3DVALUE)random(-100, 100) / (D3DVALUE)100.0); 
		l[c] = random(params.minlife, params.maxlife);
		s[c] = random(params.minstart, params.maxstart);
		o[c] = objs[random(0, numobjs - 1)]; 
		if (params.numtargets > 0)
			ti[c] = random(0, params.numtargets - 1);
	}
}

void TParticle3DAnimator::Animate(BOOL draw)
{
	T3DAnimator::Animate(draw);

	if (params.particles == 0) // Do sample particles
	{
		SParticleParams pr;
		pr.particles = 10;
		pr.pos.x = (D3DVALUE)0.0;
		pr.pos.y = (D3DVALUE)0.0;
		pr.pos.z = (D3DVALUE)70.0;
		pr.pspread.x = (D3DVALUE)3.0;
		pr.pspread.y = (D3DVALUE)3.0;
		pr.pspread.z = (D3DVALUE)3.0;
		pr.dir.x = (D3DVALUE)1.0;
		pr.dir.y = (D3DVALUE)-1.0;
		pr.dir.z = (D3DVALUE)0.5;
		pr.spread.x = (D3DVALUE)0.5;
		pr.spread.y = (D3DVALUE)0.5;
		pr.spread.z = (D3DVALUE)0.5;
		pr.gravity = (D3DVALUE)0.2;
		pr.trails = 1;
		pr.minstart = 0;
		pr.maxstart = 8;
		pr.minlife = 10;
		pr.maxlife= 30;
		pr.bounce = FALSE;
		pr.killobj = FALSE; 
		pr.objflags = 0xF;
		pr.numtargets = 0;
		pr.seektargets = FALSE;
		pr.seekz = FALSE;
		
		InitParticles(&pr);
	}

	BOOL isdone = TRUE;
	D3DVALUE tx, ty, tz, dx, dy, dz,
		angxy, angz, actang, actangz, rightdif, leftdif, rad, actrad;
	for (int c = 0; c < params.particles; c++)
	{
		if (l[c] <= 0)
			continue;

		isdone = FALSE;

		if (s[c] > 0)
		{
			s[c]--;
			continue;
		}

		p[c].x += v[c].x;
		p[c].y += v[c].y;
		p[c].z += v[c].z;
		// decrease time //(if not seeking targets)
			l[c]--;
		if (!params.seektargets)
		{
			// apply gravity (if not seeking targets)
			v[c].z -= params.gravity;
		}
		if (params.bounce && p[c].z < (D3DVALUE)0.0)
		{
			p[c].z = -p[c].z;
			v[c].z = -v[c].z * (D3DVALUE)0.5;
			if (v[c].z < (D3DVALUE)2.0)		// Don't bounce too much
				l[c] = 0;
		}
		if (params.seektargets && params.numtargets > 0)
		{
			// acquire target x, y, z
			tx = params.targetpos[ti[c]].x;
			ty = params.targetpos[ti[c]].y;
			tz = params.targetpos[ti[c]].z;
			// if close, interpolate
			if (p[c].x > tx - params.autorange && p[c].x < tx + params.autorange &&
				p[c].y > ty - params.autorange && p[c].y < ty + params.autorange)
			{
				p[c].x = (D3DVALUE)(p[c].x + tx) / 2;
				p[c].y = (D3DVALUE)(p[c].y + ty) / 2;
				p[c].z = (D3DVALUE)(p[c].z + tz) / 2;
				v[c].x = (D3DVALUE)0.0;
				v[c].y = (D3DVALUE)0.0;
				v[c].z = (D3DVALUE)0.0;
			}
			else
			// far away, seek with turning
			{
				// calculate angle in the x-y plane
				dx = tx - p[c].x;
				dy = ty - p[c].y;
				dz = tz - p[c].z;
				angxy = (D3DVALUE)atan2(dy, dx),
				rad = (D3DVALUE)sqrt((dy * dy) + (dx * dx));
				angz = (D3DVALUE)atan2(dz, rad);

				// in the up-down direction
				actang = (D3DVALUE)atan2(v[c].y, v[c].x);
				actrad = (D3DVALUE)sqrt((v[c].y * v[c].y) + (v[c].x * v[c].x));
				actangz = (D3DVALUE)atan2(v[c].z, actrad);

				leftdif = angxy - actang; // calculate which way to turn . . .
				if (leftdif < 0.0)
					leftdif += (D3DVALUE)(M_2PI);
				if (leftdif > M_2PI)
					leftdif -= (D3DVALUE)M_2PI;
				rightdif = actang - angxy;
				if (rightdif < 0.0)
					rightdif += (D3DVALUE)(M_2PI);
				if (rightdif > M_2PI)
					rightdif -= (D3DVALUE)M_2PI;
				if (leftdif < rightdif) // turn left
					actang += min(params.turnang, leftdif);
				else // turn right
					actang -= min(params.turnang, rightdif);

				if (params.seekz)
				{
					leftdif = angz - actangz; // calculate which way to turn (not really right
					if (leftdif < 0.0)			// or left, but up and down)
						leftdif += (D3DVALUE)(M_2PI);
					if (leftdif > M_2PI)
						leftdif -= (D3DVALUE)M_2PI;
					rightdif = actangz - angz;
					if (rightdif < 0.0)
						rightdif += (D3DVALUE)(M_2PI);
					if (rightdif > M_2PI)
						rightdif -= (D3DVALUE)M_2PI;
					if (leftdif < rightdif) // turn left
						actangz += params.turnang;
					else // turn right
						actangz -= params.turnang;
				}

				v[c].x = (D3DVALUE)(params.seekspeed * cos(actang));
				v[c].y = (D3DVALUE)(params.seekspeed * sin(actang));
				rad = (float)sqrt((v[c].y * v[c].y) + (v[c].x * v[c].x));
				v[c].z = (D3DVALUE)(rad * sin(actangz));
			}
			// hit target! be done!
			if (p[c].x > tx - params.hitrange && p[c].x < tx + params.hitrange &&
				p[c].y > ty - params.hitrange && p[c].y < ty + params.hitrange)
			{
				l[c] = 0;
			}
		}
	}

	inst->SetCommandDone(isdone);
	if (params.killobj && isdone)
		inst->SetFlags(OF_KILL);  // Causes object to commit suicide
}

BOOL TParticle3DAnimator::Render()
{
	SaveBlendState();
    SetBlendState();

	ResetExtents();				// Reset render extents

	for (int c = 0; c < params.particles; c++)
	{
		if (s[c] > 0 || l[c] <= 0)
			continue;

		D3DVECTOR pp = p[c];
		D3DVECTOR vv = v[c];

		PS3DAnimObj obj = GetObject(o[c]);

		for (int d = 0; d < params.trails; d++)
		{
			obj->flags |= OBJ3D_POS1;
			obj->pos = pp;
			RenderObject(obj);

			pp.x += vv.x;
			pp.y += vv.y;
			pp.z += vv.z;
			vv.z -= params.gravity;
			if (params.bounce && pp.z < (D3DVALUE)0.0)
			{
				pp.z = -pp.z;
				vv.z = -vv.z * (D3DVALUE)0.5;
				if (vv.z < (D3DVALUE)2.0)		// Don't bounce too much
					break;
			}
		}

	}

	UpdateExtents();			// Updates screen rect and bound rect
	RestoreBlendState();

	return TRUE;
}


void TParticle3DAnimator::RefreshZBuffer()
{
	S3DPoint screen, effect;

	((PTEffect)inst)->GetPos(effect);


	int size_x = 75;
	int size_y = 50;

	WorldToScreen(effect, screen);
	RestoreZ((screen.x - (size_x / 2))+25, screen.y - size_y - 50, size_x, size_y);
	//Display->Box((screen.x - (size_x / 2))+25, screen.y - size_y - 50, size_x, size_y);
}

// **********************
// * TIrisFlareAnimator *
// **********************

_CLASSDEF(TIrisFlareAnimator)
class TIrisFlareAnimator : public T3DAnimator
{
  public:
    D3DVALUE rotation;
    D3DVECTOR p[5];       // Position of the flares
	int iterations,ticks;
	float cylsize1, cylsize2;
	D3DVALUE growx, growy;

	TIrisFlareAnimator(PTObjectInstance oi) : T3DAnimator(oi) { }
	virtual ~TIrisFlareAnimator() { Close(); }

	virtual void Initialize();
	  // Initializes velocity vectors and positions

	virtual void Animate(BOOL draw);
	virtual BOOL Render();
};

REGISTER_3DANIMATOR("IrisFlare", TIrisFlareAnimator)

void TIrisFlareAnimator::Initialize()
{
	int i;

	T3DAnimator::Initialize();

	inst->Face( -32);

	for (i = 0; i < 5; i++)
	{
		p[i].y = 20;
		p[i].z = 45;
	}
	p[1].x = -5;
	p[2].x = 5;
	p[3].z += 20;
	p[4].z -= 20;

	iterations = 0;
	ticks = 0;
	cylsize1 = cylsize2 = 1.0;
	growx = D3DVAL(15.0 / 50);
	growy = growx / 3;
}

void TIrisFlareAnimator::Animate(BOOL draw)
{
	T3DAnimator::Animate(draw);
	inst->SetCommandDone(FALSE);

	// Rotate the cylindrical glow
    rotation += (D3DVALUE)0.1;

	if (iterations < 50)
	{
		if (iterations >= 25)
		{
			p[1].x += D3DVAL( 0.5);
			p[2].x -= D3DVAL( 0.5);
		}
		p[3].z -= D3DVAL( 1);
		p[4].z += D3DVAL( 1);

		iterations++;
	}
	ticks++;
	
	if (ticks > 200)
	{
		iterations = 0;
		ticks = 0;
		for (int i = 0; i < 5; i++)
		{
			p[i].y = 20;
			p[i].z = 45;
		}
		p[1].x = -5;
		p[2].x = 5;
		p[3].z += 20;
		p[4].z -= 20;

		iterations = 0;
		ticks = 0;
		cylsize1 = cylsize2 = 1.0;
		growx = D3DVAL(15.0 / 50);
		growy = growx / 3;
	}

}

BOOL TIrisFlareAnimator::Render()
{
	int	i;

    SaveBlendState();
    SetBlendState();

    PS3DAnimObj obj;

	// Draw the Flare
    obj = GetObject(0);

    Get3DImagery()->ResetExtents();             // Reset render extents

	obj->flags = OBJ3D_MATRIX;

    obj->scl.x = obj->scl.y = D3DVAL(growx * iterations);
	obj->scl.z = 15;
	obj->pos = p[0];

    D3DMATRIXClear( &obj->matrix);

	D3DMATRIXScale( &obj->matrix, &obj->scl);
    D3DMATRIXRotateX( &obj->matrix, D3DVAL( -90 * TORADIAN));

    D3DMATRIXTranslate( &obj->matrix, &obj->pos);

    RenderObject(obj);

	// Vertical flares
	obj->scl.x = obj->scl.y = D3DVAL(growy * iterations);
	obj->scl.z = 8 + D3DVAL(growy * iterations);

	for (i = 1; i < 3; i++)
	{
		D3DMATRIXClear( &obj->matrix);

		D3DMATRIXScale( &obj->matrix, &obj->scl);
		D3DMATRIXRotateX( &obj->matrix, D3DVAL( -90 * TORADIAN));

		obj->pos = p[i];

		D3DMATRIXTranslate( &obj->matrix, &obj->pos);

		RenderObject(obj);

	    UpdateExtents();            // Updates bound rect and screen rect
	}
	
	// Horizontal flares
    obj->flags = OBJ3D_SCL1 | OBJ3D_ROT2; // | OBJ3D_POS3;
	obj->scl.x = obj->scl.y = D3DVAL(growy * iterations);
	obj->scl.z = 8 + D3DVAL(growy * iterations);

	for (i = 3; i < 5; i++)
	{
		D3DMATRIXClear( &obj->matrix);

		D3DMATRIXScale( &obj->matrix, &obj->scl);
		D3DMATRIXRotateX( &obj->matrix, D3DVAL( -90 * TORADIAN));
		D3DMATRIXRotateY( &obj->matrix, D3DVAL( 90 * TORADIAN));

		obj->pos = p[i];

		D3DMATRIXTranslate( &obj->matrix, &obj->pos);

		RenderObject(obj);

	    UpdateExtents();            // Updates bound rect and screen rect
	}
    obj->rot.z = D3DVAL((float)(ticks*(360.0 / 50.0)) *TORADIAN);

    // Draw the cylindrical glow around the player
    obj = GetObject(1);

    Get3DImagery()->ResetExtents();             // Reset render extents

    obj->flags = OBJ3D_ROT1 | OBJ3D_SCL2; // | OBJ3D_POS3;

    obj->rot.x = obj->rot.y = D3DVAL(0.0);
    obj->rot.z = rotation;

	if (iterations < 50)
	{
		cylsize1 = (float)((float)(iterations) / 10.0);
		cylsize2 = (float)((float)(iterations) / 10.0);
	}
	else if (iterations > 150)
	{
		cylsize1 -= (float)0.1;
		cylsize2 -= (float)0.1;
	}

	// funky code to make it go zweerree vwweerree zweeree (etc..)
	/*
	int change = (ticks % 10) - 5;
	if (change < 0)
	{
		cylsize1 -= 0.2;
		cylsize2 += 0.2;
	}	
	else
	{
		cylsize1 += 0.2;
		cylsize2 -= 0.2;
	}*/

	obj->scl.x = obj->scl.y = obj->scl.z = cylsize1;

    RenderObject(obj);
    obj->rot.z = -rotation;
    obj->scl.x = obj->scl.y = obj->scl.z = cylsize2;
    RenderObject(obj);

	if (ticks < 20)
	{
		obj->scl.z = (float)(20 - ticks);
		if (obj->scl.z > 10)
			obj->scl.z = 10;
		obj->scl.x = obj->scl.y = (float)ticks*3;
		RenderObject(obj);
	}

    UpdateExtents();            // Updates bound rect and screen rect

    RestoreBlendState();

	return TRUE;
}

#if 0

void MakeFractal(int numpoints, int points[], int start, int stop, int min, int max)
{
	int range = max - min;

	int *p = points;

	

	for (int c = 0; c < ; )
	{
	}


}

#endif

// **********************
// * TTeleporterAnimator *
// **********************

_CLASSDEF(TTeleporterAnimator)
class TTeleporterAnimator : public T3DAnimator
{
  public:
    D3DVALUE rotation;
    D3DVECTOR p[5];       // Position of the flares
	int iterations,ticks;
	float cylsize[5];
	D3DVALUE growx, growy;

	TTeleporterAnimator(PTObjectInstance oi) : T3DAnimator(oi) { }
	virtual ~TTeleporterAnimator() { Close(); }

	virtual void Initialize();
	  // Initializes velocity vectors and positions

	virtual void Animate(BOOL draw);
	virtual BOOL Render();
};

REGISTER_3DANIMATOR("Teleporter", TTeleporterAnimator)

void TTeleporterAnimator::Initialize()
{
	int i;

	T3DAnimator::Initialize();

	inst->Face( -32);

	for (i = 0; i < 5; i++)
	{
		p[i].y = 20;
		p[i].z = 45;
		cylsize[i] = 0.0;
	}
	p[1].x = -5;
	p[2].x = 5;
	p[3].z += 20;
	p[4].z -= 20;

	iterations = 0;
	ticks = 0;
	growx = D3DVAL(15.0 / 50);
	growy = growx / 3;
}

void TTeleporterAnimator::Animate(BOOL draw)
{
	T3DAnimator::Animate(draw);
	inst->SetCommandDone(FALSE);

	// Rotate the cylindrical glow
    rotation += (D3DVALUE)0.1;

	if (iterations < 50)
	{
		if (iterations >= 25)
		{
			p[1].x += D3DVAL( 0.5);
			p[2].x -= D3DVAL( 0.5);
		}
		p[3].z -= D3DVAL( 1);
		p[4].z += D3DVAL( 1);

		iterations++;
	}
	ticks++;
}

BOOL TTeleporterAnimator::Render()
{
    SaveBlendState();
    SetBlendState();

    PS3DAnimObj obj;

    // Draw the cylindrical glow around the player
    obj = GetObject(1);

    Get3DImagery()->ResetExtents();             // Reset render extents

    obj->flags = OBJ3D_ROT1 | OBJ3D_SCL2; // | OBJ3D_POS3;

    obj->rot.x = obj->rot.y = D3DVAL(0.0);

	int curticks = ticks % 100;
	if (curticks < 50)
	{
		for (int z = 0; z < 5; z++)
		{
			obj->rot.z = rotation+(float)((float)z*(float)0.5);
			obj->scl.z = (float)(10 - 5.0f*((float)curticks / 30.0f) - (float)z);
			obj->scl.x = obj->scl.y = (float)((0.5f * (float)z) + 2.5f*((float)curticks / 30.0f));
			if (obj->scl.z > .01)
				RenderObject(obj);
		}
	}
	else
	{
		for (int z = 0; z < 5; z++)
		{
			int tempticks = 50 - (curticks - 50);
			obj->rot.z = rotation+(float)((float)z*(float)0.5);
			obj->scl.z = (float)(10 - 5.0f*((float)tempticks / 30.0f) - (float)z);
			obj->scl.x = obj->scl.y = (float)((0.5f * (float)z) + 2.5f*((float)tempticks / 30.0f));
			if (obj->scl.z > .01)
				RenderObject(obj);
		}
	}
    UpdateExtents();            // Updates bound rect and screen rect

    RestoreBlendState();

	return TRUE;
}

// ********************
// * Barrier Animator *
// ********************

#define MAXFLARES 30

_CLASSDEF(TBarrierAnimator)
class TBarrierAnimator : public T3DAnimator
{
  private:
	enum
	{
		FL_INACTIVE,
		FL_BLUE,
		FL_CYAN
	};
	enum
	{
		M_LEFTTORIGHT,
		M_RIGHTTOLEFT,
		M_TOPTOBOTTOM,
		M_BOTTOMTOTOP
	};

	D3DVECTOR vel[MAXFLARES];	// velocity
	D3DVECTOR pos[MAXFLARES];	// position
	int type[MAXFLARES];		// type, 0 = inactive, 1 = blue flare, 2 = cyan flare
	int motion[MAXFLARES];		// motion, 0 = L->R, 1 = R->L, 2 = T->B, 3 = B->T
	int spawndelay;

	D3DVALUE ybarmid;
	D3DVECTOR upperleft;
	D3DVECTOR lowerright;

	inline int FindEmptyFlare()
		{ for (int i = 0; i < MAXFLARES; i++) if (type[i] == FL_INACTIVE) return i; return -1; }

  public:
	TBarrierAnimator(PTObjectInstance oi) : T3DAnimator(oi) {}
	  // Constructor (initialization handled by Initialize)
	virtual ~TBarrierAnimator() { Close(); }
	  // Call close function

	virtual void Initialize();
	  // Initializes velocity vectors and positions
	virtual void SetupObjects();
	  // Called to create S3DAnimObj's and add to object array
	virtual void Animate(BOOL draw);
	  // Called to update frame state
	virtual BOOL Render();
	  // Called to render a frame
	virtual void RefreshZBuffer();
};

REGISTER_MULTI_3DANIMATOR_("BarrierEW", TBarrierEW, TBarrierAnimator)								\
REGISTER_MULTI_3DANIMATOR_("BarrierNS", TBarrierNS, TBarrierAnimator)								\

void TBarrierAnimator::Initialize()
{
	T3DAnimator::Initialize();
}

void TBarrierAnimator::SetupObjects()
{
	upperleft.x = upperleft.y = 100000;
	lowerright.x = lowerright.y = -100000;

	upperleft.z = -100000;
	lowerright.z = 100000;

	spawndelay = 0;

	for (int i = 0; i < MAXFLARES; i++)
	{
		vel[i].x = vel[i].y = vel[i].z = 0;
		pos[i].x = pos[i].y = pos[i].z = 0;
		type[i] = FL_INACTIVE;
		motion[i] = 0;
	}

	ybarmid = 0;

	for (int c = 0; c < Get3DImagery()->NumObjects(); c++)
	{
		PS3DAnimObj o = NewObject(c);
		GetVerts(o, D3DVT_LVERTEX);
		AddObject(o);

		// if this is the barrier object, determine middle y, 
		// and upper left and lower right coordinates
		if (c == 0)
		{
			for (int v = 0; v < o->numverts; v++)
			{
				if (o->lverts[v].x <= upperleft.x && o->lverts[v].y <= upperleft.y && o->lverts[v].z >= upperleft.z)
				{
					upperleft.x = o->lverts[v].x;
					upperleft.y = o->lverts[v].y;
					upperleft.z = o->lverts[v].z;
				}

				if (o->lverts[v].x >= lowerright.x && o->lverts[v].y >= lowerright.y && o->lverts[v].z <= lowerright.z)
				{
					lowerright.x = o->lverts[v].x;
					lowerright.y = o->lverts[v].y;
					lowerright.z = o->lverts[v].z;
				}
				ybarmid += o->lverts[v].y;
			}

			ybarmid /= o->numverts;
		}
	}
}

void TBarrierAnimator::Animate(BOOL draw)
{
	int i;

	T3DAnimator::Animate(draw);
	inst->SetCommandDone(FALSE);

	for (i = 0; i < MAXFLARES; i++)
	{
		if (type[i] != FL_INACTIVE)
		{
			pos[i].x += vel[i].x;
			pos[i].z += vel[i].z;

			switch (motion[i])
			{
				case M_LEFTTORIGHT:
				{
					if (pos[i].x > lowerright.x)
						type[i] = FL_INACTIVE;
					break;
				}
				case M_RIGHTTOLEFT:
				{
					if (pos[i].x < upperleft.x)
						type[i] = FL_INACTIVE;
					break;
				}
				case M_TOPTOBOTTOM:
				{
					if (pos[i].z < lowerright.z)
						type[i] = FL_INACTIVE;
					break;
				}
				case M_BOTTOMTOTOP:
				{
					if (pos[i].z > upperleft.z)
						type[i] = FL_INACTIVE;
					break;
				}
			}

		}
	}

	if (spawndelay)
		spawndelay--;
	else
	{
		i = FindEmptyFlare();

		if (i != -1)
		{
			vel[i].y = 0;
			pos[i].y = ybarmid;
			motion[i] = random(M_LEFTTORIGHT,M_BOTTOMTOTOP);

			switch (motion[i])
			{
				case M_LEFTTORIGHT:
				{
					pos[i].x = upperleft.x;
					pos[i].z = D3DVALUE(random((int)lowerright.z, (int)upperleft.z));

					vel[i].x = D3DVALUE(random(2,10));
					vel[i].z = 0;

					break;
				}
				case M_RIGHTTOLEFT:
				{
					pos[i].x = lowerright.x;
					pos[i].z = D3DVALUE(random((int)lowerright.z, (int)upperleft.z));

					vel[i].x = D3DVALUE(-(random(2,10)));
					vel[i].z = 0;

					break;
				}
				case M_TOPTOBOTTOM:
				{
					pos[i].x = D3DVALUE(random((int)upperleft.x*100, (int)lowerright.x*100) / 100);
					pos[i].z = upperleft.z;

					vel[i].x = 0;
					vel[i].z = D3DVALUE(-(random(2,10)));

					break;
				}
				case M_BOTTOMTOTOP:
				{
					pos[i].x = D3DVALUE(random((int)upperleft.x, (int)lowerright.x));
					pos[i].z = lowerright.z;

					vel[i].x = 0;
					vel[i].z = D3DVALUE(random(2,10));

					break;
				}
			}

			type[i] = random(FL_BLUE, FL_CYAN);
		}

		spawndelay = random(1, 5);
	}
}

BOOL TBarrierAnimator::Render()
{
	int i, v; 

    SaveBlendState();
    SetBlendState();

	PS3DAnimObj objBarrier = GetObject(0);
	PS3DAnimObj objFlare;

	ResetExtents();

	for (i = 0; i < MAXFLARES; i++)
	{
		objFlare = NULL;

		switch (type[i])
		{
			case FL_BLUE:
			{
				objFlare = GetObject(2);
				break;
			}
			case FL_CYAN:
			{
				objFlare = GetObject(4);
				break;
			}
		}

		if (objFlare)
		{
			switch (motion[i])
			{
				case M_LEFTTORIGHT:
				case M_RIGHTTOLEFT:
				{
					objFlare->flags = OBJ3D_SCL1 | OBJ3D_POS2;
					objFlare->pos = pos[i];
					objFlare->scl.x = D3DVALUE(2.0);
					objFlare->scl.y = 0;
					objFlare->scl.z = D3DVALUE(0.5);

					break;
				}

				case M_TOPTOBOTTOM:
				case M_BOTTOMTOTOP:
				{
					objFlare->flags = OBJ3D_SCL1 | OBJ3D_POS2;
					objFlare->pos = pos[i];
					objFlare->scl.x = D3DVALUE(0.5);
					objFlare->scl.y = 0;
					objFlare->scl.z = D3DVALUE(2.0);

					break;
				}
			}

			RenderObject(objFlare);
		}
	}

	// reset animation so we can mess with vertices...
	objBarrier->flags |= OBJ3D_POS1;
	objBarrier->pos.x = objBarrier->pos.y = objBarrier->pos.z = 0;

 	for (v = 0; v < objBarrier->numverts; v++)
	{
		objBarrier->lverts[v].tu += 0.01f;
		objBarrier->lverts[v].tv += 0.01f;
	}

	RenderObject(objBarrier);

	UpdateExtents();

    RestoreBlendState();

	return TRUE;
}

void TBarrierAnimator::RefreshZBuffer()
{
	S3DPoint effect, size, screen;

	((PTEffect)inst)->GetPos(effect);

	size.x = 150;
	size.y = 225;

	WorldToScreen(effect, screen);
	RestoreZ(screen.x - 20, screen.y - (size.y / 2) - (size.y / 4), size.x, size.y);
}

// **********************
// * TSmokeEffectAnimator *
// **********************


_CLASSDEF(TSmokeEffectAnimator)
class TSmokeEffectAnimator : public T3DAnimator
{
  public:
	int ticks;
	float centerx, centery;
	float centervx, centervy;
	SSmoke smoke[NUMSMOKEBALLS];

	TSmokeEffectAnimator(PTObjectInstance oi) : T3DAnimator(oi) { }
	virtual ~TSmokeEffectAnimator() { Close(); }

	virtual void Initialize();
	  // Initializes velocity vectors and positions

	virtual void Animate(BOOL draw);
	virtual BOOL Render();
	virtual void RefreshZBuffer();
	void ResetBall(int b);
};

void TSmokeEffectAnimator::ResetBall(int b)
{
	SSmoke *s = &smoke[b];
	s->x = ((float)rand() / (float)RAND_MAX) * 50.0f - 25.0f + centerx;
	s->y = ((float)rand() / (float)RAND_MAX) * 50.0f - 25.0f + centery;
	s->z = 0;
	s->rot = 0;
	s->vx = (((float)rand() / (float)RAND_MAX) * 1.0f - 0.5f);
	s->vy = (((float)rand() / (float)RAND_MAX) * 1.0f - 0.5f);
	s->vz = (((float)rand() / (float)RAND_MAX) * 1.0f);
	s->life = (int)(((float)rand() / (float)RAND_MAX) * 100.0f);
	s->size = ((float)rand() / (float)RAND_MAX) * 2.7f + 0.1f;
}

REGISTER_3DANIMATOR("Smoke", TSmokeEffectAnimator)

void TSmokeEffectAnimator::Initialize()
{
	int i;
	centerx = centery = 0.0f;
	centervx = centervy = 0.2f;

	T3DAnimator::Initialize();

	for (i = 0; i < NUMSMOKEBALLS; i++)
		ResetBall(i);

//	inst->Face( -32);

	ticks = 0;
}

void TSmokeEffectAnimator::Animate(BOOL draw)
{
	T3DAnimator::Animate(draw);
	inst->SetCommandDone(FALSE);

	centerx += centervx;
	centery += centervy;

	if (centerx > 50 || centerx < -50)
		centervx = -centervx;
	if (centery > 50 || centery < -50)
		centervy = -centervy;
	
	SSmoke *s = smoke;	
	for (int i = 0; i < NUMSMOKEBALLS; i++, s++)
	{
		s->vz += SMOKE_GRAV;
		s->x += s->vx;
		s->y += s->vy;
		if (s->z > 0)
			s->z += s->vz;
		else
			s->z -= 0.008f;

		s->life++;
		s->size += 0.02f;

		if (s->life > 200)
		{
			s->size -= 0.2f;
			if (s->size <= 0.01f)
				ResetBall(i);
		}
	}

	ticks++;
}

BOOL TSmokeEffectAnimator::Render()
{
    SaveBlendState();
    SetBlendState();

    PS3DAnimObj obj;

    // Draw the cylindrical glow around the player
    obj = GetObject(0);

    ResetExtents();             // Reset render extents

    obj->flags = OBJ3D_SCL1 | OBJ3D_POS2;

	for (int i = 0; i < NUMSMOKEBALLS; i++)
	{
		SSmoke s = smoke[i];
		obj->scl.x = obj->scl.y = s.size;
		obj->scl.z = s.size;
		obj->pos.x = s.x;
		obj->pos.y = s.y;
		obj->pos.z = s.z;

		RenderObject(obj);
	}

    UpdateExtents();            // Updates bound rect and screen rect

    RestoreBlendState();

	return TRUE;

}

void TSmokeEffectAnimator::RefreshZBuffer()
{
	S3DPoint map, effect, screen, size;

	size.x = 450;
	size.y = 300;

	((PTEffect)inst)->GetPos(effect);

	map.x = effect.x;
	map.y = effect.y;
	map.z = effect.z;

	WorldToScreen(map, screen);
	RestoreZ(screen.x - (size.x / 2), screen.y - (size.y / 2), size.x, size.y);
}

// ****************
// * Meteor Storm *
// ****************
DEFINE_BUILDER("MeteorStorm", TMeteorStormEffect)
REGISTER_BUILDER(TMeteorStormEffect)

void TMeteorStormEffect::Initialize()
{
}

void TMeteorStormEffect::Pulse()
{
	TEffect::Pulse();
}

REGISTER_3DANIMATOR("MeteorStorm", TMeteorStormAnimator)

void TMeteorStormAnimator::Initialize()
{
	T3DAnimator::Initialize();

	PS3DAnimObj o = GetObject(0);
	meteor_storm.Init(this,	o);

	SStormParams params;

	ticks = 0;
	tracker = 0;

	S3DPoint effect_pos;
	((PTEffect)inst)->GetPos(effect_pos);
//	if(!((PTEffect)inst)->GetSpell()->GetTarget())
//	{
//		float angle = ((float)((PTEffect)inst)->GetAngle() / 255.0f) * 360.0f * (float)TORADIAN;
//
//		float x = 100.0f * (float)cos(angle);
//		float y = 100.0f * (float)sin(angle);
//
//		effect_pos.x += (int)x;
//		effect_pos.y += (int)y;
//	}

	// how many meteors
	params.particles = 0;
	// their texture size
	params.tex_u = params.tex_v = 64;
	// what is the meteor grid
	params.particle_u = 8;
	params.particle_v = 2;
	// where do the frames begin and end
	params.particle_begin = 0;
	params.particle_end = 7;
	// what is the impact grid
	params.impact_u = 4;
	params.impact_v = 4;
	// where do the frames begin and end
	params.impact_begin = 8;
	params.impact_end = 15;
	// gravity, duh...take physics
	params.gravity = .37f;
	// velocity, see above suggestion
	params.velocity.y = 0.0f;
	params.velocity.x = -10.0f;
	params.velocity.z = -15.0f;
	// base position value
	params.pos.x = (float)effect_pos.x + 120.0f;
	params.pos.y = (float)effect_pos.y - 20.0f;
	params.pos.z = (float)effect_pos.z + 300.0f;
	// the spread
	params.pos_spread.x = 100.0f;
	params.pos_spread.y = 100.0f;
	params.pos_spread.z = 0.0f;
	// frame incrementors
	params.impact_frame_inc = 0.7f;
	params.particle_frame_inc = 0.5f;
	// scaling
	params.impact_scale.x = 1.0f;
	params.impact_scale.y = 1.0f;
	params.impact_scale.z = 1.0f;
	// scaling
	params.particle_scale.x = 0.5f;
	params.particle_scale.y = 1.5f;
	params.particle_scale.z = 1.0f;

	params.rot.x = 0.0f;
	params.rot.y = 0.0f;
	params.rot.z = 0.0f;

	meteor_storm.Set(&params);

	// init the rotation
	rot.x = 0.0f;
	rot.y = 0.0f;
	rot.z = 0.0f;
}

void TMeteorStormAnimator::Animate(BOOL draw)
{
	T3DAnimator::Animate(draw);
	inst->SetCommandDone(FALSE);

	if(!(ticks%10))
	{
		if(tracker<METEOR_STORM_SIZE&&ticks<=METEOR_STORM_TICKS)
			tracker++;

		if(ticks>METEOR_STORM_TICKS&&tracker!=0)
			tracker--;

		SStormParams params;
		meteor_storm.Get(&params);
		params.particles = tracker;
		meteor_storm.Set(&params);
	}

/*	if(!(ticks%10))
	{
		SStormParams params;
		meteor_storm.Get(&params);
		params.particles = 1;
		meteor_storm.Set(&params);
	}*/


	// animate the storm!
	meteor_storm.Animate();

	// check to see if finished
	if(meteor_storm.IsDone() && ticks >= METEOR_STORM_TICKS)
		inst->SetCommandDone(TRUE);

	++ticks;
}

BOOL TMeteorStormAnimator::Render()
{
	SaveBlendState();
	SetBlendState();

	// render the storm!
	
	meteor_storm.Render();

	RestoreBlendState();

	return TRUE;
}

void TMeteorStormAnimator::RefreshZBuffer()
{
	// refresh the storm!
	meteor_storm.RefreshZBuffer();
}

// VORTEX is a teleport spell of sorts
DEFINE_BUILDER("Vortex", TVortexEffect)
REGISTER_BUILDER(TVortexEffect)

void TVortexEffect::Initialize()
{
	// add code here if necessary
	PLAY("vortex sound");
}

void TVortexEffect::Pulse()
{
	TEffect::Pulse();
}

REGISTER_3DANIMATOR("Vortex", TVortexAnimator)

void TVortexAnimator::Initialize()
{
	T3DAnimator::Initialize();

	// get the vertices
	PS3DAnimObj obj = GetObject(0);
	GetVerts(obj, D3DVT_LVERTEX);

	// set the colors
	float r;
	for(int i = 0; i < VORTEX_VERTEX; ++i)
	{
		r = (float)random(100, 200) / 100.0f;
		obj->lverts[i].color = D3DRGBA(min(0.15f * r, 1.0f), min(0.15f * r, 1.0f), min(.5f * r, 1.0f), 0.0f);
	}
	// set the alpha
	for(int j = 0; j < VORTEX_RING; ++j)
	{
		for(int i = 0; i < VORTEX_COUNT; ++i)
		{
			switch(j)
			{
				case VORTEX_RING - 1:
					vertex[(j * VORTEX_COUNT) + i] = .0f;
					break;
				case VORTEX_RING - 2:
					vertex[(j * VORTEX_COUNT) + i] = .1429f + (.00125f * (float)random(-20, 20));
					break;
				case VORTEX_RING - 3:
					vertex[(j * VORTEX_COUNT) + i] = .2857f + (.0025f * (float)random(-20, 20));
					break;
				case VORTEX_RING - 4:
					vertex[(j * VORTEX_COUNT) + i] = .5714f + (.005f * (float)random(-20, 20));
					break;
				default:
					vertex[(j * VORTEX_COUNT) + i] = .6f + (.0125f * (float)random(0, 32));
					break;
			}
		}
	}
	for(i = VORTEX_VERTEX - VORTEX_BASE; i < VORTEX_VERTEX; ++i)
	{
		if(i % 2)
			vertex[i] = .8f;
		else
			vertex[i] = 0.0f;
		r = (float)random(100, 200) / 100.0f;
		obj->lverts[i].color = D3DRGBA(min(0.15f * r, 1.0f), min(0.15f * r, 1.0f), min(.5f * r, 1.0f), 0.0f);
	}

	obj = GetObject(1);
	GetVerts(obj, D3DVT_LVERTEX);

	for(i = 0; i < 36; ++i)
	{
		r = (float)random(100, 200) / 100.0f;
		obj->lverts[i].color = D3DRGBA(min(0.15f * r, 1.0f), min(0.15f * r, 1.0f), min(.5f * r, 1.0f), 0.0f);
	}

	for(i = 0; i < 9; ++i)
	{
		glow[i] = .0f;
	}
	for(i = 9; i < 18; ++i)
	{
		switch(i)
		{
			case 9:
				glow[i] = .0f;
				break;
			case 10:
				glow[i] = .1679f;
				break;
			case 11:
				glow[i] = .3357f;
				break;
			case 12:
				glow[i] = .6714f;
				break;
			case 17:
				glow[i] = .0f;
				break;
			default:
				glow[i] = .9f;
				break;
		}
	}
	for(i = 18; i < 27; ++i)
	{
		glow[i] = .0f;
	}
	for(i = 27; i < 36; ++i)
	{
		switch(i)
		{
			case 27:
				glow[i] = .0f;
				break;
			case 28:
				glow[i] = .1679f;
				break;
			case 29:
				glow[i] = .3357f;
				break;
			case 30:
				glow[i] = .6714f;
				break;
			case 35:
				glow[i] = .0f;
				break;
			default:
				glow[i] = .9f;
				break;
		}
	}

	// the particles!
	obj = GetObject(2);
	S3DPoint size;
	size.x = 75;
	size.y = 75;
	particle_system.Init(this, obj, size);

	alpha_blend = 0.0f;
	vortex_state = VORTEX_STATE_GROW;
	count = 0;

	// init the scaling
	scale.x = 0.0f;
	scale.y = 0.0f;
	scale.z = 0.0f;

	// init the position
	pos.x = 0.0f;
	pos.y = 0.0f;
	pos.z = 0.0f;

	// init the rotation
	rot.x = 0.0f;
	rot.y = 0.0f;
	rot.z = 0.0f;

	int ticks = (int)(VORTEX_ALPHA_MAX / VORTEX_ALPHA_FACTOR) + 1;
	// others
	scale_factor.x = VORTEX_SCALE_X_MAX / (float)ticks;
	scale_factor.y = VORTEX_SCALE_Y_MAX / (float)ticks;
	scale_factor.z = VORTEX_SCALE_Z_MAX / (float)ticks;
	rot_factor = (VORTEX_ROT_MAX / ((float)ticks + (float)(VORTEX_LIFE_SPAN / 2)));
	//rot_speed = 0.0f;
	rot_speed = 16.0f;
	frame = 0;
}

void TVortexAnimator::Animate(BOOL draw)
{
	T3DAnimator::Animate(draw);

	inst->SetCommandDone(FALSE);

	int flag = random(0, 1);
	int done = 1;

	for(int i = 0; i < VORTEX_PARTICLE_COUNT; ++i)
	{
		PSParticleSystemInfo particle = particle_system.Get(i);

		if(!particle->used && flag && vortex_state != VORTEX_STATE_SHRINK)
		{
			done = 0;
			// create a particle
			// set the position
			particle_info[i].rot = (float)random(0, 360);
			particle_info[i].rot_inc = (float)random(1, 20);
			particle_info[i].height_inc = (float)random(40, 100) / 20.0f;
			particle_info[i].face_rot = (float)random(0, 360);
			particle_info[i].face_rot_inc = (float)random(1, 15);
			particle_info[i].flicker = random(0, 1);
			particle_info[i].radius = VORTEX_RADIUS;

			particle->pos.x = particle_info[i].radius * (float)cos(particle_info[i].rot * TORADIAN);
			particle->pos.y = particle_info[i].radius * (float)sin(particle_info[i].rot * TORADIAN);
			particle->pos.z = 0.0f;
			// set the rotation
			particle->rot.x = 0.0f;
			particle->rot.y = particle_info[i].face_rot;
			particle->rot.z = 0.0f;
			// set the scale
			particle_info[i].scale = (float)random(50, 125) / 400.0f;
			if(particle_info[i].flicker)
			{
				particle->scl.x = particle_info[i].scale;
				particle->scl.y = particle_info[i].scale;
				particle->scl.z = particle_info[i].scale;
			}
			else
			{
				particle->scl.x = particle_info[i].scale * .5f;
				particle->scl.y = particle_info[i].scale * .5f;
				particle->scl.z = particle_info[i].scale * .5f;
			}

			particle->used = TRUE;

			flag = 0;
		}
		else if(particle->used)
		{
			done = 0;
			particle_info[i].rot += particle_info[i].rot_inc;
			if(particle_info[i].rot > 360.0f)
				particle_info[i].rot -= 360.0f;
			particle_info[i].face_rot += particle_info[i].face_rot_inc;
			if(particle_info[i].face_rot > 360.0f)
				particle_info[i].face_rot -= 360.0f;
			particle_info[i].flicker = random(0, 3);

			particle->pos.x = particle_info[i].radius * (float)cos(particle_info[i].rot * TORADIAN);
			particle->pos.y = particle_info[i].radius * (float)sin(particle_info[i].rot * TORADIAN);
			particle->pos.z += particle_info[i].height_inc;
			if(particle->pos.z > VORTEX_HEIGHT)
				particle->used = FALSE;
			particle->rot.y = particle_info[i].face_rot;

			particle_info[i].flicker = random(0, 1);
			if(particle_info[i].flicker)
			{
				particle->scl.x = particle_info[i].scale;
				particle->scl.y = particle_info[i].scale;
				particle->scl.z = particle_info[i].scale;
			}
			else
			{
				particle->scl.x = particle_info[i].scale * .5f;
				particle->scl.y = particle_info[i].scale * .5f;
				particle->scl.z = particle_info[i].scale * .5f;
			}
		}
		if(particle->pos.z < VORTEX_SCALE_POINT)
		{
			particle->scl.x *= (float)(particle->pos.z) / (float)VORTEX_SCALE_POINT;
			particle->scl.y *= (float)(particle->pos.z) / (float)VORTEX_SCALE_POINT;
			particle->scl.z *= (float)(particle->pos.z) / (float)VORTEX_SCALE_POINT;
		}
		else if(VORTEX_HEIGHT - particle->pos.z < VORTEX_SCALE_POINT && VORTEX_HEIGHT - particle->pos.z > 0)
		{
			particle->scl.x *= (float)(VORTEX_HEIGHT - particle->pos.z) / (float)VORTEX_SCALE_POINT;
			particle->scl.y *= (float)(VORTEX_HEIGHT - particle->pos.z) / (float)VORTEX_SCALE_POINT;
			particle->scl.z *= (float)(VORTEX_HEIGHT - particle->pos.z) / (float)VORTEX_SCALE_POINT;
		}
	}

	rot.z += rot_speed;
	if(rot.z > 360.0f)
		rot.z -= 360.0f;

	//if(count < (VORTEX_LIFE_SPAN / 2))
	//	rot_speed += rot_factor;
	//else
	//	rot_speed -= rot_factor;

	switch(vortex_state)
	{
		// when the vortex is fading in
		case VORTEX_STATE_GROW:
			alpha_blend += VORTEX_ALPHA_FACTOR;
			//scale.y += scale_factor.y;
			//scale.x += scale_factor.x;
			scale.x = VORTEX_SCALE_X_MAX;
			scale.y = VORTEX_SCALE_Y_MAX;
			scale.z += scale_factor.z;
			if(alpha_blend >= VORTEX_ALPHA_MAX)
			{
				alpha_blend = VORTEX_ALPHA_MAX;
				vortex_state = VORTEX_STATE_CONSTANT;
			}
			break;
		// when the vortex is fading out
		case VORTEX_STATE_SHRINK:
			alpha_blend -= VORTEX_ALPHA_FACTOR;
			//scale.y -= scale_factor.y;
			//scale.x -= scale_factor.x;
			scale.x = VORTEX_SCALE_X_MAX;
			scale.y = VORTEX_SCALE_Y_MAX;
			scale.z -= scale_factor.z;
			if(alpha_blend <= 0.0f)
			{
				alpha_blend = 0.0f;
				if(done)
					inst->SetCommandDone(TRUE);
			}
			break;
		// when the vortex is constant
		case VORTEX_STATE_CONSTANT:
			scale.y = VORTEX_SCALE_Y_MAX;
			scale.x = VORTEX_SCALE_X_MAX;
			scale.z = VORTEX_SCALE_Z_MAX;
			if(count >= VORTEX_LIFE_SPAN)
			{
				vortex_state = VORTEX_STATE_SHRINK;
			}
			++count;
			break;
	}
}

BOOL TVortexAnimator::Render()
{
	
	SaveBlendState();
	SetBlendState();

	DWORD oldcullmode;
	Scene3D.GetRenderState(D3DRENDERSTATE_CULLMODE, &oldcullmode);
	Scene3D.SetRenderState(D3DRENDERSTATE_CULLMODE, D3DCULL_NONE);

	particle_system.Render();

	// BEGIN VORTEX
	PS3DAnimObj obj = GetObject(0);
	ResetExtents();

	obj->flags = OBJ3D_ROT1 | OBJ3D_SCL2 | OBJ3D_POS3 | OBJ3D_VERTS;

	float r, g, b, a;
	for(int i = 0; i < VORTEX_VERTEX; ++i)
	{
		r = (float)RGBA_GETRED(obj->lverts[i].color) / 255.0f;
		g = (float)RGBA_GETGREEN(obj->lverts[i].color) / 255.0f;
		b = (float)RGBA_GETBLUE(obj->lverts[i].color) / 255.0f;
		a = vertex[i] * alpha_blend;
		obj->lverts[i].color = D3DRGBA(r, g, b, a);
	}

	// rotate
	obj->rot.x = (float)(rot.x * TORADIAN);
	obj->rot.y = (float)(rot.y * TORADIAN);
	obj->rot.z = (float)(rot.z * TORADIAN);

	// scale
	obj->scl.x = scale.x;
	obj->scl.y = scale.y;
	obj->scl.z = scale.z;

	// translate
	obj->pos.x = pos.x;
	obj->pos.y = pos.y;
	obj->pos.z = pos.z;

	RenderObject(obj);

	UpdateExtents();
	// END VORTEX

	// BEGIN GLOW
	obj = GetObject(1);

	ResetExtents();

	obj->flags = OBJ3D_ROT1 | OBJ3D_SCL2 | OBJ3D_POS3 | OBJ3D_VERTS;

	float factor;
	for(i = 0; i < VORTEX_GLOW_COUNT; ++i)
	{
		r = (float)RGBA_GETRED(obj->lverts[i].color) / 255.0f;
		g = (float)RGBA_GETGREEN(obj->lverts[i].color) / 255.0f;
		b = (float)RGBA_GETBLUE(obj->lverts[i].color) / 255.0f;
		factor = .75f + (.0125f * (float)random(0, 40));
		if(frame == 2)
		{
			a = min(glow[i] * factor * alpha_blend, 1.0f);
			frame = 0;
		}
		else
		{
			a = min(glow[i] * alpha_blend, 1.0f);
			++frame;
		}
		obj->lverts[i].color = D3DRGBA(r, g, b, a);
	}

	// rotate
	obj->rot.x = 0.0f;
	obj->rot.y = 0.0f;
	obj->rot.z = (float)(-45.0f * TORADIAN);

	// scale
	obj->scl.x = scale.x;
	obj->scl.y = scale.y;
	obj->scl.z = scale.z;

	// position
	obj->pos.x = pos.x;
	obj->pos.y = pos.y;
	obj->pos.z = pos.z;

	RenderObject(obj);

	UpdateExtents();
	// END GLOW

	Scene3D.SetRenderState(D3DRENDERSTATE_CULLMODE, oldcullmode);

	RestoreBlendState();

	return TRUE;
}

void TVortexAnimator::RefreshZBuffer()
{
	D3DVECTOR size;
	size.x = 225;
	size.y = 225;
	S3DPoint effect, map, screen;

	((PTEffect)inst)->GetPos(effect);

	map.x = (int)pos.x + effect.x;
	map.y = (int)pos.y + effect.y;
	map.z = (int)pos.z + effect.z;

	WorldToScreen(map, screen);

	RestoreZ(screen.x - ((int)size.x / 2), screen.y - ((int)size.y / 2) - ((int)size.y / 3), (int)size.x, (int)size.y);

	//particle_system.RefreshZBuffer();
	// don't need the above line...because well the vortex zbuffer is enough
}


// FLIES, FLIES, FLIES!

DEFINE_BUILDER("Flies", TFlyEffect)
REGISTER_BUILDER(TFlyEffect)

void TFlyEffect::Initialize()
{
}

void TFlyEffect::Pulse()
{
	TEffect::Pulse();
}

REGISTER_3DANIMATOR("Flies", TFlyAnimator)

void TFlyAnimator::Initialize()
{
	// create all the flies
	T3DAnimator::Initialize();

	PS3DAnimObj o = GetObject(0);
	S3DPoint size;
	size.x = 10;
	size.y = 10;
	flies.Init(this, o, size);

	for(int i = 0; i < FLY_COUNT; ++i)
	{
		PSParticleSystemInfo fly = flies.Get(i);
		fly->pos.x = (float)random(-FLY_RANGE_X, FLY_RANGE_X);
		fly->pos.y = (float)random(-FLY_RANGE_Y, FLY_RANGE_Y);
		fly->pos.z = (float)random(-FLY_RANGE_Z, FLY_RANGE_Z);
		fly->used = FALSE;
		fly->scl.x = .1f;
		fly->scl.y = .2f;
		fly->scl.z = .2f;
		fly->rot.x = 0.0f;
		fly->rot.y = 0.0f;
		fly->rot.z = 0.0f;
	}
}

void TFlyAnimator::Animate(BOOL draw)
{
	T3DAnimator::Animate(draw);
	inst->SetCommandDone(FALSE);
	// restrict their flying range
	int chance = random(0, 1);

	for(int i = 0; i < FLY_COUNT; ++i)
	{
		PSParticleSystemInfo fly = flies.Get(i);

		if(fly->used == FALSE && chance)
		{
			fly->used = TRUE;
			chance = 0;
		}

		D3DVECTOR velocity;
		velocity.x = (float)random(-2, 2);
		velocity.y = (float)random(-2, 2);
		velocity.z = (float)random(-2, 2);

		fly->pos.x += velocity.x;
		fly->pos.y += velocity.y;
		fly->pos.z += velocity.z;

		if(fly->pos.x > (float)FLY_RANGE_X || fly->pos.x < (float)-FLY_RANGE_X)
			fly->pos.x -= velocity.x + velocity.x;
		if(fly->pos.y > (float)FLY_RANGE_Y || fly->pos.y < (float)-FLY_RANGE_Y)
			fly->pos.y -= velocity.y + velocity.y;
		if(fly->pos.z > (float)FLY_RANGE_Z || fly->pos.z < (float)-FLY_RANGE_Z)
			fly->pos.z -= velocity.z + velocity.z;
	}
}

BOOL TFlyAnimator::Render()
{
	SaveBlendState();
	SetBlendState();

	DWORD oldcullmode;
	Scene3D.GetRenderState(D3DRENDERSTATE_CULLMODE, &oldcullmode);
	Scene3D.SetRenderState(D3DRENDERSTATE_CULLMODE, D3DCULL_NONE);

	flies.Render();

	Scene3D.SetRenderState(D3DRENDERSTATE_CULLMODE, oldcullmode);

	RestoreBlendState();

	return TRUE;
}

void TFlyAnimator::RefreshZBuffer()
{
	S3DPoint size, map, screen;

	((PTEffect)inst)->GetPos(map);

	WorldToScreen(map, screen);

	size.x = FLY_RANGE_X * 3;
	size.y = FLY_RANGE_Y * 3;

	RestoreZ(screen.x - (size.x / 2), screen.y - (size.y / 2), size.x, size.y);
}

REGISTER_3DANIMATOR("Fog", TFogAnimator)

void TFogAnimator::Initialize()
{
	T3DAnimator::Initialize();

	PS3DAnimObj obj = GetObject(0);
	GetVerts(obj, D3DVT_LVERTEX);

	for(int i = 0; i < FOG_VERTEX; ++i)
	{
		if(i == 0 || i == 4 || i == 6 || i == 8 || i == 10 || i == 3 || i == 13 || i == 19 || i == 25 ||
			i == 31 || i == 30 || i == 32 || i == 33 || i == 34 || i == 35 || i == 29 || i == 23 ||
			i == 17 || i == 11 || i == 1)
		{
			color[i].c = .7f;
			color[i].a = .125f;
			dpos[i].x = 0.0f;
			dpos[i].y = 0.0f;
			dpos[i].z = 0.0f;
		}
		else
		{
			color[i].c = (float)random(400, 1000) / 1000.0f;
			color[i].a = (float)random(100, 400) / 1000.0f;
			dpos[i].x = (float)random(-50, 50) / 100.0f;
			dpos[i].y = (float)random(-50, 50) / 100.0f;
			dpos[i].z = (float)random(-50, 50) / 100.0f;
		}
		pos[i].x = obj->lverts[i].x;
		pos[i].y = obj->lverts[i].y;
		pos[i].z = obj->lverts[i].z;
		velocity[i].x = 0.0f;		
		velocity[i].y = 0.0f;
		velocity[i].z = 0.0f;
		color_velocity[i] = 0.0f;		
		alpha_velocity[i] = 0.0f;		
	}
}

void TFogAnimator::Animate(BOOL draw)
{
	T3DAnimator::Animate(draw);
	inst->SetCommandDone(FALSE);
	
	for(int i = 0; i < FOG_VERTEX; ++i)
	{
		if(i == 0 || i == 4 || i == 6 || i == 8 || i == 10 || i == 3 || i == 13 || i == 19 || i == 25 ||
			i == 31 || i == 30 || i == 32 || i == 33 || i == 34 || i == 35 || i == 29 || i == 23 ||
			i == 17 || i == 11 || i == 1)
			continue;
		color_velocity[i] += (float)random(-10, 10) / 1000.0f;
		alpha_velocity[i] += (float)random(-10, 10) / 1000.0f;

		color[i].c += color_velocity[i];
		if(color_velocity[i] > 1.0f || color_velocity[i] < .4f)
			color_velocity[i] = 0.0f;
		color[i].c = min(1.0f, max(.4f, color[i].c));
		color[i].a += alpha_velocity[i];
		if(alpha_velocity[i] > .4f || alpha_velocity[i] < .1f)
			alpha_velocity[i] = 0.0f;
		color[i].a = min(.4f, max(.1f, color[i].a));

		velocity[i].x += (float)random(-10, 10) / 1000.0f;
		velocity[i].y += (float)random(-10, 10) / 1000.0f;
		velocity[i].z += (float)random(-10, 10) / 1000.0f;

		dpos[i].x += velocity[i].x;
		if(dpos[i].x < -.5f || dpos[i].x > .5f)
			velocity[i].x = 0.0f;
		dpos[i].x = min(.5f, max(-.5f, dpos[i].x));
		dpos[i].y += velocity[i].y;
		if(dpos[i].y < -.5f || dpos[i].y > .5f)
			velocity[i].y = 0.0f;
		dpos[i].y = min(.5f, max(-.5f, dpos[i].y));
		dpos[i].z += velocity[i].z;
		if(dpos[i].z < -.5f || dpos[i].z > .5f)
			velocity[i].z = 0.0f;
		dpos[i].z = min(.5f, max(-.5f, dpos[i].z));
	}
}

BOOL TFogAnimator::Render()
{
	SaveBlendState();
	SetBlendState();

	PS3DAnimObj obj = GetObject(0);

	ResetExtents();
	obj->flags = OBJ3D_ROT1 | OBJ3D_SCL2 | OBJ3D_POS3 | OBJ3D_VERTS;

	for(int i = 0; i < FOG_VERTEX; ++i)
	{
		obj->lverts[i].color = D3DRGBA(color[i].c, color[i].c, color[i].c, color[i].a);
		obj->lverts[i].x = pos[i].x + dpos[i].x;
		obj->lverts[i].y = pos[i].y + dpos[i].y;
		obj->lverts[i].z = pos[i].z + dpos[i].z;
	}

	obj->rot.x = 0.0f;
	obj->rot.y = 0.0f;
	obj->rot.z = 0.0f;

	obj->scl.x = 7.475f;
	obj->scl.y = 7.475f;
	obj->scl.z = 1.0f;

	obj->pos.x = 0.0f;
	obj->pos.y = 0.0f;
	obj->pos.z = 0.0f;

	RenderObject(obj);
	UpdateExtents();

	RestoreBlendState();

	return TRUE;
}

void TFogAnimator::RefreshZBuffer()
{
	S3DPoint size, effect, screen;

	size.x = 225;
	size.y = 125;

	((PTEffect)inst)->GetPos(effect);

	WorldToScreen(effect, screen);

	RestoreZ(screen.x - (size.x / 2), screen.y - (size.y / 2), size.x, size.y);
}

// *******************
// * PULP CHARACTERS *
// *******************

REGISTER_3DANIMATOR("PULP", TPulpAnimator)

void TPulpAnimator::Initialize()
{
	T3DAnimator::Initialize();
}

void TPulpAnimator::Animate(BOOL draw)
{
	T3DAnimator::Animate(draw);
	
	// catch notified deletion and not initialized pulp stuff
	inst->SetCommandDone(TRUE);
	if(((PTPulpEffect)inst)->IsDone() || ((PTPulpEffect)inst)->GetCharacter() == NULL)
		return;

	PTCharAnimator charanim = (PTCharAnimator)((PTPulpEffect)inst)->GetCharacter()->GetAnimator();

	// *** if(not notified) ***
	inst->SetCommandDone(FALSE);

	// do blood stuff!
	int i = 0;
	PSBloodDrop blood;
	while(blood = ((PTPulpEffect)inst)->GetBlood(i))
	{
		++i;
		if(!blood->used)
			continue;

		blood->pos.x += blood->vel.x;
		blood->pos.y += blood->vel.y;
		blood->pos.z += blood->vel.z;

		blood->vel.x *= .75f;
		blood->vel.y *= .75f;

		S3DPoint map;
		map.x = (int)blood->pos.x;
		map.y = (int)blood->pos.y;
		map.z = (int)blood->pos.z;

		int height = MapPane.GetWalkHeight(map);
		if(blood->pos.z <= height)
			blood->used = FALSE;

		blood->vel.z -= (PULP_GRAVITY * .75f);
	}

	// animate stuff

	// animate body parts
	PSBodyPartPulp body_part;
	i = 0;
	while(body_part = ((PTPulpEffect)inst)->GetBodyPart(i))
	{
		if(body_part->done)
		{
			++i;
			continue;
		}

		// rotate the x axis
		body_part->rot.x += body_part->rot_vel.x;
		while(body_part->rot.x > (float)(float)M_2PI)
			body_part->rot.x -= (float)M_2PI;
		while(body_part->rot.x < 0)
			body_part->rot.x += (float)M_2PI;

		// rotate the y axis
		body_part->rot.y += body_part->rot_vel.y;
		while(body_part->rot.y > (float)M_2PI)
			body_part->rot.y -= (float)M_2PI;
		while(body_part->rot.y < 0)
			body_part->rot.y += (float)M_2PI;

		// rotate the z axis
		body_part->rot.z += body_part->rot_vel.z;
		while(body_part->rot.z > (float)M_2PI)
			body_part->rot.z -= (float)M_2PI;
		while(body_part->rot.z < 0)
			body_part->rot.z += (float)M_2PI;

		// get the walk map height above him
		S3DPoint test_point, point;
		int height;
		point.x = (int)body_part->pos.x;
		point.y = (int)body_part->pos.y;
		point.z = (int)body_part->pos.z;

		// check for x axis collision
		test_point = point;
		test_point.x += (int)body_part->vel.x;
		height = MapPane.GetWalkHeight(test_point);
		if(test_point.z <= height || !height)
		{
			body_part->vel.x = -body_part->vel.x * PULP_SLOW_RATE;
			body_part->vel.y *= PULP_SIDE_SLOW;
			body_part->vel.z *= PULP_SIDE_SLOW;
			body_part->rot_vel.x *= PULP_ANG_SLOW_RATE;
			body_part->rot_vel.y *= PULP_ANG_SLOW_RATE;
			body_part->rot_vel.z *= PULP_ANG_SLOW_RATE;
		}

		// check for y axis collision
		test_point = point;
		test_point.y += (int)body_part->vel.y;
		height = MapPane.GetWalkHeight(test_point);
		if(test_point.z <= height || !height)
		{
			body_part->vel.y = -body_part->vel.y * PULP_SLOW_RATE;
			body_part->vel.x *= PULP_SIDE_SLOW;
			body_part->vel.z *= PULP_SIDE_SLOW;
			body_part->rot_vel.x *= PULP_ANG_SLOW_RATE;
			body_part->rot_vel.y *= PULP_ANG_SLOW_RATE;
			body_part->rot_vel.z *= PULP_ANG_SLOW_RATE;
		}

		// check for z axis collision
		test_point = point;
		test_point.z += (int)body_part->vel.z;
		height = MapPane.GetWalkHeight(test_point);
		if(test_point.z <= height || !height)
		{
			int n;
			char buf[128];

			if(abs(body_part->vel.z) < (PULP_GRAVITY + PULP_CUTOFF) * 2.0f)
			{
				body_part->done = TRUE;
				body_part->vel.x = 0.0f;
				body_part->vel.y = 0.0f;
				body_part->vel.z = 0.0f;
				body_part->pos.z = (float)height;
				body_part->rot_vel.x = 0.0f;
				body_part->rot_vel.y = 0.0f;
				body_part->rot_vel.z = 0.0f;
				n = random(1, 4);
				sprintf(buf, "Splat%d", n);
			}
			else
			{
				body_part->vel.z = -body_part->vel.z * PULP_SLOW_RATE * .75f;
				body_part->vel.x *= PULP_SIDE_SLOW;
				body_part->vel.y *= PULP_SIDE_SLOW;
				body_part->rot_vel.x *= PULP_ANG_SLOW_RATE;
				body_part->rot_vel.y *= PULP_ANG_SLOW_RATE;
				body_part->rot_vel.z *= PULP_ANG_SLOW_RATE;
				n = random(1, 4);
				sprintf(buf, "BloodS%d", n);
			}

			SObjectDef def;
			S3DPoint pos;

			memset(&def, 0, sizeof(SObjectDef));
			def.level = MapPane.GetMapLevel();
			pos.z = height + 1;
			pos.x = test_point.x;
			pos.y = test_point.y;
			def.pos = pos;
			def.objclass = OBJCLASS_TILE;
			def.objtype = TileClass.FindObjType(buf);
			MapPane.NewObject(&def);
		}

		body_part->pos.x += body_part->vel.x;
		body_part->pos.y += body_part->vel.y;
		body_part->pos.z += body_part->vel.z;

		if(abs(body_part->vel.x) < PULP_CUTOFF)
			body_part->vel.x = 0.0f;
		if(abs(body_part->vel.y) < PULP_CUTOFF)
			body_part->vel.y = 0.0f;
		// gravity
		if(!body_part->done)
			body_part->vel.z -= PULP_GRAVITY;

		// make blood drops
		for(int j = 0; j < 2; ++j)
		{
			int x = 0;
			while(blood = ((PTPulpEffect)inst)->GetBlood(x))
			{
				++x;
				if(blood->used)
					continue;
				blood->used = TRUE;

				blood->scl.x = blood->scl.y = blood->scl.z = (float)random(30, 60) * .001f;

				blood->pos = body_part->pos;

				blood->vel = body_part->vel;
				blood->vel.x *= (float)random(60, 140) * .01f;
				blood->vel.y *= (float)random(60, 140) * .01f;
				blood->vel.z *= (float)random(60, 140) * .01f;

				break;
			}
		}

		++i;
	}

	// animate blood
	
	// animate blood splotches
}

BOOL TPulpAnimator::Render()
{
	// catch not initialized pulp stuff
	if(((PTPulpEffect)inst)->IsDone())
		return FALSE;

	PS3DAnimObj obj;
	int i;

	PSBodyPartPulp body_part;
	S3DPoint pos;

	// cyle through the parts
	i = 0;
	while(body_part = ((PTPulpEffect)inst)->GetBodyPart(i))
	{
		ResetExtents();

		obj = GetObject(body_part->object);

		obj->flags = OBJ3D_ROT1 | OBJ3D_SCL2 | OBJ3D_POS3 | OBJ3D_ABSPOS;

		obj->pos = body_part->pos;
		obj->rot = body_part->rot;
		obj->scl = body_part->scl;

	  // Reset lights	
		Scene3D.LightAffectObject((int)body_part->pos.x, (int)body_part->pos.y, (int)body_part->pos.z); // Add 50 to get middle of guy
		RenderObject(obj);
		Scene3D.ResetAllLights();

		UpdateExtents();
		++i;
	}

	// draw all the blood drops
	obj = GetObject(1);
	i = 0;
	PSBloodDrop blood;
	while(blood = ((PTPulpEffect)inst)->GetBlood(i))
	{
		++i;
		if(!blood->used)
			continue;

		ResetExtents();

		obj->flags = OBJ3D_ROT1 | OBJ3D_SCL2 | OBJ3D_POS3 | OBJ3D_ABSPOS;

		obj->pos = blood->pos;

		obj->scl = blood->scl;

		obj->rot.x = -30.0f * (float)TORADIAN;
		obj->rot.y = 0.0f * (float)TORADIAN;
		obj->rot.z = -45.0f * (float)TORADIAN;

		RenderObject(obj);

		UpdateExtents();
	}

	return TRUE;
}

void TPulpAnimator::RefreshZBuffer()
{
	//  refresh stuff
}

// **********************
// * TPulpEffect Object *
// **********************

DEFINE_BUILDER("PULP", TPulpEffect)
REGISTER_BUILDER(TPulpEffect)

void TPulpEffect::Set(S3DPoint vel, PTCharacter ch, int num_body_part, int num_blood, int num_splat)
{
	// create all the info
	character = ch;
	PTCharAnimator charanim = (PTCharAnimator)character->GetAnimator();
	if(!charanim)
		return;
	int maxnum = charanim->NumObjects();
	if (maxnum < num_body_part)
		num_body_part = maxnum;

	body_part = new SBodyPartPulp[num_body_part];
	body_part_count = num_body_part;
	blood_splat = new SBloodSplat[num_splat];
	blood_splat_count = num_splat;
	blood = new SBloodDrop[num_blood];
	blood_count = num_blood;

	// give all the body parts unique object numbers
	int j;
	for(int i = 0; i < num_body_part; ++i)
	{
		BOOL flag;
		do
		{
			flag = FALSE;
			body_part[i].obj_num = random(0, maxnum - 1);
			for(j = 0; j < i; ++j)
			{
				if(body_part[j].obj_num == body_part[i].obj_num)
				{
					flag = TRUE;
					break;
				}
			}
		}
		while(flag);
	}

	// modify the velocity
	float vel_avg = (vel.x + vel.y + vel.z) / 3.0f;
	float overall = (abs(vel.x) + abs(vel.y) + abs(vel.z)) / 6.0f;

	// get the cool stuff
	// cycle through all he needed body parts
	PS3DAnimObj obj;
	for(i = 0; i < num_body_part; ++i)
	{
		// get the object
		obj = charanim->GetObject(body_part[i].obj_num);
		obj->flags = OBJ3D_ROT1 | OBJ3D_SCL2 | OBJ3D_POS3;
		// velocity
		body_part[i].vel.x = vel.x + (float)random((int)-overall, (int)overall);
		body_part[i].vel.y = vel.y + (float)random((int)-overall, (int)overall);
		body_part[i].vel.z = vel.z + (float)random((int)-overall, (int)overall);
		// angular velocity
		body_part[i].rot_vel.x = (float)random(-30, 30) * (float)TORADIAN;
		body_part[i].rot_vel.y = (float)random(-30, 30) * (float)TORADIAN;
		body_part[i].rot_vel.z = (float)random(-30, 30) * (float)TORADIAN;

		S3DPoint char_pos;
		character->GetPos(char_pos);
		body_part[i].pos.x = obj->pos.x + (int)char_pos.x;
		body_part[i].pos.y = obj->pos.y + (int)char_pos.y;
		body_part[i].pos.z = obj->pos.z + (int)char_pos.z;
		S3DPoint test_pos;
		test_pos.x = (int)body_part[i].pos.x;
		test_pos.y = (int)body_part[i].pos.x;
		test_pos.z = (int)body_part[i].pos.x;
		int height = MapPane.GetWalkHeight(test_pos);
		if(test_pos.z <= height)
			body_part[i].pos.z = (float)height + 1.0f;

		body_part[i].rot = obj->rot;
		/*
		body_part[i].scl.x = (float)random(5, 600) * .001f;
		body_part[i].scl.y = (float)random(5, 600) * .001f;
		body_part[i].scl.z = (float)random(5, 600) * .001f;
		*/
		body_part[i].scl.x = .4f * (float)random(75, 125) * .01f;
		body_part[i].scl.y = .4f * (float)random(75, 125) * .01f;
		body_part[i].scl.z = .4f * (float)random(75, 125) * .01f;
		body_part[i].done = FALSE;
		body_part[i].object = random(2, 10);
	}

	character->SetFlags(OF_INVISIBLE);

	for(i = 0; i < num_blood; ++i)
		blood[i].used = FALSE;

	for(i = 0; i < num_blood / 2; ++i)
	{
		blood[i].used = TRUE;
		blood->scl.x = blood->scl.y = blood->scl.z = (float)random(1, 25) * .001f;

		blood->pos = body_part->pos;
 
		blood->vel.x = ((float)vel.x + vel_avg * 2.0f) / 3.0f * ((float)random(60, 140) * .01f);
		blood->vel.y = ((float)vel.y + vel_avg * 2.0f) / 3.0f * ((float)random(60, 140) * .01f);
		blood->vel.z = ((float)vel.z + vel_avg * 2.0f) / 3.0f * ((float)random(60, 140) * .01f);
	}

	// init the splats
	for(i = 0; i < num_splat; ++i)
		blood_splat[i].used = FALSE;

	valid = TRUE;
}

void TPulpEffect::Initialize()
{
	// init all the vars
	character = NULL; 
	blood = NULL; 
	blood_splat = NULL; 
	body_part = NULL; 
	valid = FALSE; 
	is_loaded = FALSE;
	SetNotify(N_DELETING);			// Check for deleted objs in action blocks
}

void TPulpEffect::Pulse()
{
	TEffect::Pulse();

	if(is_loaded)
	{
		// get a pointer to the character
		is_loaded = FALSE;
		character = (PTCharacter)MapPane.GetInstance(index);
	}
}

void TPulpEffect::Load(RTInputStream is, int version)
{
}

void TPulpEffect::Save(RTOutputStream os)
{
}

void TPulpEffect::Notify(int notify, void *ptr)
{
	// **** WARNING!!! MAKE SURE YOU CHECK FOR BROKEN LINKS AND DELETED OBJECTS HERE!!! ****
	// If you want to be notified, you must call SetNotify() in your contsructor

	if (sector == (PTSector)ptr)
		return;

	TObjectInstance::Notify(notify, ptr);

	if (character && NOTIFY_DELETED(ptr, character))
	{
		SetFlags(OF_KILL);
		character = NULL;
	}
}

// ***************************
// *** THE DREAD FIRE CONE ***
// ***************************

// effect
_CLASSDEF(TFireConeEffect)
class TFireConeEffect : public TEffect
{
  public:
    TFireConeEffect(PTObjectImagery newim) : TEffect(newim) { Initialize(); }
    TFireConeEffect(PSObjectDef def, PTObjectImagery newim) : TEffect(def, newim) { Initialize(); }
	virtual ~TFireConeEffect() {}

    virtual void Initialize();			// init

	virtual void Pulse();				// da heartbeat of america...
};

//#define FLAME_COUNT			300
#define FLAME_COUNT			200
#define FLAME_BURST			100
#define FLAME_SMOKE			(FLAME_COUNT / 2)
#define FLAME_VEL			10
#define FLAME_ANG			15
#define FLAME_MIN_H			83
#define FLAME_MAX_H			87
#define FLAME_MIN_V			20
#define FLAME_MAX_V			30
#define FLAME_FRAME_COUNT	25
//#define FLAME_CREATE		17
#define FLAME_CREATE		10
#define FLAME_MIN_LIFE		10
#define FLAME_MAX_LIFE		45
#define FLAME_STATE_START	1
#define FLAME_STATE_MID		2
#define FLAME_STATE_BLAST	3

// animator for the fire cone class
_CLASSDEF(TFireConeAnimator)
class TFireConeAnimator : public T3DAnimator
{
  private:
	TParticleSystem fire;
	TParticleSystem smoke;
	TParticleSystem burst;
	BOOL done;
	int frame_count;
	int state;
  public:
	TFireConeAnimator(PTObjectInstance oi) : T3DAnimator(oi), fire(FLAME_COUNT), smoke(FLAME_COUNT), burst(FLAME_BURST) {}
	virtual ~TFireConeAnimator() { Close(); }

	virtual void Initialize();
	virtual void Animate(BOOL draw);
	virtual BOOL Render();
	virtual void RefreshZBuffer();
};


// **************************
// * TFireConeEffect Object *
// **************************

DEFINE_BUILDER("FIRECONE", TFireConeEffect)
REGISTER_BUILDER(TFireConeEffect)

// initialize the fire cone effect
void TFireConeEffect::Initialize()
{
}

// pulse through the fire cone
void TFireConeEffect::Pulse()
{
	TEffect::Pulse();
}

// ****************************
// * TFireConeAnimator Object *
// ****************************

REGISTER_3DANIMATOR("FIRECONE", TFireConeAnimator)

// initialize the fire particles
void TFireConeAnimator::Initialize()
{
	T3DAnimator::Initialize();

	S3DPoint size;
	size.x = 10;
	size.y = 10;

	//fire.Init(this, obj, size, -((float)(inst->GetFace() * 360.0f) / 256.0f) * (float)TORADIAN);

	float facing = -(((float)inst->GetFace() * 360.0f) / 256.0f) * (float)TORADIAN;

	PS3DAnimObj obj = GetObject(0);
	fire.Init(this, obj, size, TRUE, facing);
	burst.Init(this, obj, size, TRUE, facing);

	obj = GetObject(1);
	smoke.Init(this, obj, size, TRUE, facing);

	done = FALSE;
	frame_count = 0;
	state = FLAME_STATE_START;
}

// animate the fire particles
void TFireConeAnimator::Animate(BOOL draw)
{
	// animate stuff
	T3DAnimator::Animate(draw);

	inst->SetCommandDone(FALSE);

	PSParticleSystemInfo flame;
	SParticleSystemInfo new_flame;
	int flame_count = 0;

	smoke.Animate();

	for(int i = 0; i < FLAME_COUNT; ++i)
	{
		flame = fire.Get(i);
		if(!flame->used)		
			continue;
		if(flame->life >= flame->life_span)
		{
			new_flame.pos = flame->pos;
			new_flame.temp = flame->temp;
			new_flame.vel.x = 0.0f;
			new_flame.vel.y = 0.0f;
			new_flame.vel.z = flame->vel.z;
			new_flame.acc.x = 0.0f;
			new_flame.acc.y = 0.0f;
			new_flame.acc.z = flame->acc.z;
			new_flame.scl = flame->scl;
			new_flame.rot = flame->rot;
			new_flame.life_span = 15;
			smoke.Add(&new_flame);
		}
	}

	fire.Animate();
	burst.Animate();

	if(state == FLAME_STATE_START)
	{
		if(frame_count >= 30)
		{
			state = FLAME_STATE_MID;
			frame_count = 0;
		}
		else
			++frame_count;
		for(i = 0; i < FLAME_CREATE / 2 && !done; ++i)
		{
			// create a new flame structure
			new_flame.pos.x = (float)random(-4, 4) + 20.0f;
			new_flame.pos.y = (float)random(-4, 4);
			new_flame.pos.z = (float)random(-4, 4) - 7.0f;

			new_flame.rot.x = 0.0f;
			new_flame.rot.y = 0.0f;
			new_flame.rot.z = 0.0f;

			float scale = (float)random(5, 25) * .01f;

			new_flame.temp.x = scale;
			new_flame.temp.y = scale;
			new_flame.temp.z = scale;

			new_flame.vel.x = (float)random(-100, 100) * .01f;
			new_flame.vel.y = (float)random(-100, 100) * .01f;
			new_flame.vel.z = (float)random(100, 400) * .01f;

			new_flame.acc.x = (float)random(FLAME_MIN_H, FLAME_MAX_H) * .01f;
			new_flame.acc.y = (float)random(FLAME_MIN_H, FLAME_MAX_H) * .01f;
			new_flame.acc.z = (float)random(FLAME_MIN_V, FLAME_MAX_V) * .01f;

			new_flame.life_span = random(3, 15);

			fire.Add(&new_flame);
		}
		for(i = 0; i < FLAME_CREATE / 2 && !done; ++i)
		{
			// create a new flame structure
			new_flame.pos.x = (float)random(-4, 4) - 20.0f;
			new_flame.pos.y = (float)random(-4, 4);
			new_flame.pos.z = (float)random(-4, 4) - 7.0f;

			new_flame.rot.x = 0.0f;
			new_flame.rot.y = 0.0f;
			new_flame.rot.z = 0.0f;

			float scale = (float)random(5, 25) * .01f;

			new_flame.temp.x = scale;
			new_flame.temp.y = scale;
			new_flame.temp.z = scale;

			new_flame.vel.x = (float)random(-100, 100) * .01f;
			new_flame.vel.y = (float)random(-100, 100) * .01f;
			new_flame.vel.z = (float)random(0, 300) * .01f;

			new_flame.acc.x = (float)random(FLAME_MIN_H, FLAME_MAX_H) * .01f;
			new_flame.acc.y = (float)random(FLAME_MIN_H, FLAME_MAX_H) * .01f;
			new_flame.acc.z = (float)random(FLAME_MIN_V, FLAME_MAX_V) * .01f;

			new_flame.life_span = random(3, 15);

			fire.Add(&new_flame); 
		}
	}
	else if(state == FLAME_STATE_MID)
	{
		if(frame_count >= 12)
		{
			state = FLAME_STATE_BLAST;
			frame_count = 0;

			int r = random(30, 50);
			for(i = 0; i < r; ++i)
			{

				new_flame.rot.x = 0.0f;
				new_flame.rot.y = 0.0f;
				new_flame.rot.z = 0.0f;

				new_flame.vel.x = (float)random(-800, 800) * .01f;
				new_flame.vel.y = (float)random(-800, 800) * .01f;
				new_flame.vel.z = (float)random(-800, 800) * .01f;

				new_flame.acc.x = (float)random(65, 95) * .01f;
				new_flame.acc.y = (float)random(65, 95) * .01f;
				new_flame.acc.z = (float)random(65, 95) * .01f;

				int j = random(1, 5);
				for(int x = 0; x < j; ++x)
				{
					// create a new flame structure
					new_flame.pos.x = (float)random(-2, 2);
					new_flame.pos.y = (float)random(-2, 2) - 30.0f;
					new_flame.pos.z = (float)random(-2, 2) - 30.0f;

					float scale = (float)random(5, 25) * .01f;

					new_flame.scl.x = scale;
					new_flame.scl.y = scale;
					new_flame.scl.z = scale;

					new_flame.life_span = random(10, 25);
					burst.Add(&new_flame);
				}
			}
		}
		else
			++frame_count;
	}
	else if(state == FLAME_STATE_BLAST)
	{
		if(frame_count >= FLAME_FRAME_COUNT)
			done = TRUE;
		else
			++frame_count;

		for(i = 0; i < FLAME_CREATE && !done; ++i)
		{
			// create a new flame structure
			new_flame.pos.x = (float)random(-4, 4);
			new_flame.pos.y = (float)random(-4, 4) - 30.0f;
			new_flame.pos.z = (float)random(-4, 4) - 30.0f;

			new_flame.rot.x = 0.0f;
			new_flame.rot.y = 0.0f;
			new_flame.rot.z = 0.0f;

			float scale = (float)random(5, 25) * .01f;

			new_flame.temp.x = scale;
			new_flame.temp.y = scale;
			new_flame.temp.z = scale;

			new_flame.vel.x = (float)random(-200, 200) * .01f;
			new_flame.vel.y = -(float)1500 * .01f;
			new_flame.vel.z = (float)random(0, 300) * .01f;

			new_flame.acc.x = (float)random(FLAME_MIN_H, FLAME_MAX_H) * .01f;
			new_flame.acc.y = (float)random(FLAME_MIN_H, FLAME_MAX_H) * .01f;
			new_flame.acc.z = (float)random(FLAME_MIN_V, FLAME_MAX_V) * .01f;

			new_flame.life_span = random(FLAME_MIN_LIFE, FLAME_MAX_LIFE);

			fire.Add(&new_flame);
		}
	}

	// do the red particles
	for(i = 0; i < FLAME_COUNT; ++i)
	{
		flame = fire.Get(i);
		if(!flame->used)
			continue;
		++flame_count;

		if(state == FLAME_STATE_START)
			flame->vel.z += 1.5f;
		else if(state == FLAME_STATE_MID)
		{
			flame->acc.x = 0.0f;
			flame->acc.y = 0.0f;
			flame->acc.z = 0.0f;
			flame->vel.x = 0.0f;
			flame->vel.y = 0.0f;
			flame->vel.z = 0.0f;
			float diff;
			if(flame->pos.x != 0.0f)
			{
				diff = (0.0f - flame->pos.x) * .15f;
				flame->pos.x += diff;
			}
			if(flame->pos.y != -30.0f)
			{
				diff = (-30.0f - flame->pos.y) * .15f;
				flame->pos.y += diff;
			}
			if(flame->pos.z != -30.0f)
			{
				diff = (-30.0f - flame->pos.z) * .15f;
				flame->pos.z += diff;
			}
		}
		else if((float)flame->life / (float)flame->life_span > .5f)
			flame->vel.z += 1.5f;

		float equ = (125.0f - flame->pos.z) * .01f;
		flame->scl.x = flame->temp.x * equ;
		flame->scl.y = flame->temp.y * equ;
		flame->scl.z = flame->temp.z * equ;
	}

	for(i = 0; i < FLAME_COUNT; ++i)
	{
		flame = smoke.Get(i);
		if(!flame->used)
			continue;
		++flame_count;
		
		flame->vel.z += 3.0f;

		float equ = (125.0f - flame->pos.z) * .01f;
		if(equ < 0.0f)
			equ = 0.0f;

		flame->scl.x = flame->temp.x * equ;
		flame->scl.y = flame->temp.y * equ;
		flame->scl.z = flame->temp.z * equ;
	}

	for(i = 0; i < FLAME_BURST; ++i)
	{
		flame = burst.Get(i);
		if(!flame->used)
			continue;

		++flame_count;

		flame->scl.x *= .95f;
		flame->scl.y *= .95f;
		flame->scl.z *= .95f;
	}

	// finish the effect
	if(!flame_count && done)
		inst->SetCommandDone(TRUE);
}

// render the fire particles
BOOL TFireConeAnimator::Render()
{
	SaveBlendState();
	SetAddBlendState();

	fire.Render();
	smoke.Render();
	burst.Render();

	RestoreBlendState();

	return TRUE;
}

// refresh the z buffer
void TFireConeAnimator::RefreshZBuffer()
{
	S3DPoint size;
	S3DPoint map, screen;

	size.x = 500;
	size.y = 250;

	((PTEffect)inst)->GetPos(map);

	WorldToScreen(map, screen);

	RestoreZ(screen.x - (size.x / 2), screen.y - (size.y / 2), size.x, size.y);
}

// ***************************
// *** THE DREAD FIRE CONE ***
// ***************************

// effect
_CLASSDEF(TDragonFireEffect)
class TDragonFireEffect : public TEffect
{
  public:
    TDragonFireEffect(PTObjectImagery newim) : TEffect(newim) { Initialize(); }
    TDragonFireEffect(PSObjectDef def, PTObjectImagery newim) : TEffect(def, newim) { Initialize(); }
	virtual ~TDragonFireEffect() {}

    virtual void Initialize();			// init

	virtual void Pulse();				// da heartbeat of america...
};

// animator for the fire cone class
_CLASSDEF(TDragonFireAnimator)
class TDragonFireAnimator : public T3DAnimator
{
  private:
	TParticleSystem fire;
	TParticleSystem smoke;
	BOOL done;
	int frame_count;
  public:
	TDragonFireAnimator(PTObjectInstance oi) : T3DAnimator(oi), fire(FLAME_COUNT), smoke(FLAME_COUNT) {}
	virtual ~TDragonFireAnimator() { Close(); }

	virtual void Initialize();
	virtual void Animate(BOOL draw);
	virtual BOOL Render();
	virtual void RefreshZBuffer();
};


// **************************
// * TFireConeEffect Object *
// **************************

DEFINE_BUILDER("DragonFire", TDragonFireEffect)
REGISTER_BUILDER(TDragonFireEffect)

// initialize the fire cone effect
void TDragonFireEffect::Initialize()
{
}

// pulse through the fire cone
void TDragonFireEffect::Pulse()
{
	TEffect::Pulse();
}

// ****************************
// * TFireConeAnimator Object *
// ****************************

REGISTER_3DANIMATOR("DragonFire", TDragonFireAnimator)

// initialize the fire particles
void TDragonFireAnimator::Initialize()
{
	T3DAnimator::Initialize();

	S3DPoint size;
	size.x = 10;
	size.y = 10;

	//fire.Init(this, obj, size, -((float)(inst->GetFace() * 360.0f) / 256.0f) * (float)TORADIAN);

	float facing = -(((float)inst->GetFace() * 360.0f) / 256.0f) * (float)TORADIAN;

	PS3DAnimObj obj = GetObject(0);
	fire.Init(this, obj, size, TRUE, facing);

	obj = GetObject(1);
	smoke.Init(this, obj, size, TRUE, facing);

	done = FALSE;
	frame_count = 0;
}

// animate the fire particles
void TDragonFireAnimator::Animate(BOOL draw)
{
	// animate stuff
	T3DAnimator::Animate(draw);

	inst->SetCommandDone(FALSE);

	if(frame_count >= FLAME_FRAME_COUNT * 2)
		done = TRUE;
	else
		++frame_count;

	PSParticleSystemInfo flame;
	SParticleSystemInfo new_flame;
	int flame_count = 0;

	smoke.Animate();

	for(int i = 0; i < FLAME_COUNT; ++i)
	{
		flame = fire.Get(i);
		if(!flame->used)		
			continue;
		if(flame->life >= flame->life_span)
		{
			new_flame.pos = flame->pos;
			new_flame.temp = flame->temp;
			new_flame.vel.x = 0.0f;
			new_flame.vel.y = 0.0f;
			new_flame.vel.z = flame->vel.z;
			new_flame.acc.x = 0.0f;
			new_flame.acc.y = 0.0f;
			new_flame.acc.z = flame->acc.z;
			new_flame.scl = flame->scl;
			new_flame.rot = flame->rot;
			new_flame.life_span = 15;
			smoke.Add(&new_flame);
		}
	}

	fire.Animate();

	for(i = 0; i < FLAME_CREATE && !done; ++i)
	{
		// create a new flame structure
		new_flame.pos.x = (float)random(-4, 4);
		new_flame.pos.y = (float)random(-4, 4) - 5.0f;
		new_flame.pos.z = (float)random(-4, 4);

		new_flame.rot.x = 0.0f;
		new_flame.rot.y = 0.0f;
		new_flame.rot.z = 0.0f;

		float scale = (float)random(5, 25) * .01f;

		new_flame.temp.x = scale;
		new_flame.temp.y = scale;
		new_flame.temp.z = scale;

		new_flame.vel.x = (float)random(-200, 200) * .01f;
		new_flame.vel.y = -(float)1500 * .01f;
		new_flame.vel.z = (float)random(0, 300) * .01f;

		new_flame.acc.x = (float)random(FLAME_MIN_H, FLAME_MAX_H) * .01f;
		new_flame.acc.y = (float)random(FLAME_MIN_H, FLAME_MAX_H) * .01f;
		new_flame.acc.z = (float)random(FLAME_MIN_V, FLAME_MAX_V) * .01f;

		new_flame.life_span = random(FLAME_MIN_LIFE, FLAME_MAX_LIFE);

		fire.Add(&new_flame);
	}

	// do the red particles
	for(i = 0; i < FLAME_COUNT; ++i)
	{
		flame = fire.Get(i);
		if(!flame->used)
			continue;
		++flame_count;

		if((float)flame->life / (float)flame->life_span > .5f)
			flame->vel.z += 1.5f;

		float equ = (125.0f - flame->pos.z) * .01f;
		flame->scl.x = flame->temp.x * equ;
		flame->scl.y = flame->temp.y * equ;
		flame->scl.z = flame->temp.z * equ;
	}

	for(i = 0; i < FLAME_COUNT; ++i)
	{
		flame = smoke.Get(i);
		if(!flame->used)
			continue;
		++flame_count;
		
		flame->vel.z += 3.0f;

		float equ = (125.0f - flame->pos.z) * .01f;
		if(equ < 0.0f)
			equ = 0.0f;

		flame->scl.x = flame->temp.x * equ;
		flame->scl.y = flame->temp.y * equ;
		flame->scl.z = flame->temp.z * equ;
	}

	// finish the effect
	if(!flame_count && done)
		inst->SetCommandDone(TRUE);
}

// render the fire particles
BOOL TDragonFireAnimator::Render()
{
	SaveBlendState();
	SetAddBlendState();

	fire.Render();
	smoke.Render();

	RestoreBlendState();

	return TRUE;
}

// refresh the z buffer
void TDragonFireAnimator::RefreshZBuffer()
{
	S3DPoint size;
	S3DPoint map, screen;

	size.x = 500;
	size.y = 250;

	((PTEffect)inst)->GetPos(map);

	WorldToScreen(map, screen);

	RestoreZ(screen.x - (size.x / 2), screen.y - (size.y / 2), size.x, size.y);
}

// ******************
// * IceBolt Effect *
// ******************

#define	GROW_DURATION		10
#define SPHERE_STEP			0.5
#define RING_SPEED			20
#define SPIRAL_STEP			1.0
#define SPIRAL_SCALE_STEP	0.1
#define FROST_INIT_SIZE		0.5
#define FROST_STEP			0.03
#define FROST_DAMAGE_MIN	10
#define FROST_DAMAGE_MAX	25
#define SW_ROTSPEED			0.5
#define	SW_SCALESPEED		0.2

DEFINE_BUILDER("IceBolt", TIceBoltEffect)
REGISTER_BUILDER(TIceBoltEffect)

void TIceBoltEffect::Initialize()
{
//	TMissileEffect::Initialize();

//	SetSpeed(ELECTRIC_BOLT_SPEED);
}

void TIceBoltEffect::Pulse()
{
//	TMissileEffect::Pulse();
	TEffect::Pulse();

	if ((spell) && (commanddone))
		KillThisEffect();
}

// ********************
// * IceBolt Animator *
// ********************

REGISTER_3DANIMATOR("IceBolt", TIceBoltAnimator)

//==============================================================================
//    Function : Initialize.
//------------------------------------------------------------------------------
// Description : This will setup the initial state for an electric bolt animator.
//				 The bolt effect consists of sparks that gather together
//				 to form a big spark which fires
//
//==============================================================================

void TIceBoltAnimator::Initialize()
{
	T3DAnimator::Initialize();
	int i;
	frameon = 0;
	spherescale[0] = (D3DVALUE)SPHERE_STEP;
	spherescale[1] = (D3DVALUE)1.0;
	cylscale = (D3DVALUE)SPHERE_STEP;
	ringout = (D3DVALUE)0.0;
	spiralang = (D3DVALUE)0.0;
	spiralscale = (D3DVALUE)SPIRAL_SCALE_STEP;
	for (i = 0; i < MAX_FROST_PARTICLES; i++)
	{
		p[i].x = (D3DVALUE)random(-10, 10);
		p[i].y = (D3DVALUE)random(-10, 10);
		p[i].z = (D3DVALUE)random(-10, 10);
		v[i].x = (D3DVALUE)random(-3, 3);
		v[i].y = (D3DVALUE)random(-3, 3);
		v[i].z = (D3DVALUE)random(-3, 3);
		s[i] = (D3DVALUE)FROST_INIT_SIZE;
		t[i] = (float)random(0, (int)(FROST_INIT_SIZE * 2 / FROST_STEP));
	}

	angle = ((PTEffect)inst)->GetAngle();

	int subspell = ((PTEffect)inst)->GetSubSpell();
	/*if (subspell > 2)
	{
		SObjectDef def;
		memset(&def, 0, sizeof(SObjectDef));
		def.objclass = OBJCLASS_EFFECT;

		def.objtype = EffectClass.FindObjType("snow");
		def.level = MapPane.GetMapLevel();
		S3DPoint pos;
		((PTEffect)inst)->GetPos(pos);
		def.pos = pos;
		PTObjectInstance instance = MapPane.GetInstance(MapPane.NewObject(&def));
		if (!instance)
			return;

		instance->CreateAnimator();
		PTParticle3DAnimator anim = (PTParticle3DAnimator)instance->GetAnimator();
		particleanim = anim;

		//int ang = (angle + 64) & 0xff; // fly back
		int ang = angle;

		S3DPoint vect;
		ConvertToVector(ang, 100, vect);

		if (anim)
		{
			SParticleParams pr;

			pr.particles = random(50, 100);
			pr.pos.x = (D3DVALUE)0.0;
			pr.pos.y = (D3DVALUE)0.0;
			pr.pos.z = (D3DVALUE)0.0;
			pr.pspread.x = (D3DVALUE)25.0;
			pr.pspread.y = (D3DVALUE)25.0;
			pr.pspread.z = (D3DVALUE)50.0;
			pr.dir.x = (D3DVALUE)((float)vect.x / (float)100.0);
			pr.dir.y = (D3DVALUE)((float)vect.y / (float)100.0);
			pr.dir.z = (D3DVALUE)((float)vect.z / (float)100.0);
			pr.spread.x = (D3DVALUE)0.0;
			pr.spread.y = (D3DVALUE)0.0;
			pr.spread.z = (D3DVALUE)0.0;
			pr.gravity = (D3DVALUE)0.0;
			pr.trails = 1;
			pr.minstart = 0;
			pr.maxstart = pr.particles / 2;
			pr.minlife = 100;
			pr.maxlife = 150;
			pr.bounce = FALSE;
			pr.killobj = TRUE;
			pr.objflags = 0xF;

			pr.numtargets = 1;
			pr.targetpos[0].x = (D3DVALUE)0.0;
			pr.targetpos[0].y = (D3DVALUE)0.0;
			pr.targetpos[0].z = (D3DVALUE)0.0;
			
			pr.seektargets = TRUE;
			pr.turnang = (D3DVALUE)0.1;
			pr.seekspeed = (D3DVALUE)5.0;
			pr.autorange = 0.0;
			pr.hitrange = 0.0;
			pr.seekz = FALSE;

			anim->InitParticles(&pr);
		}
	}*/
	if (subspell > 2)
	{
		for (i = 0; i < MAX_SNOW_PARTICLES; i++)
		{
			h[i] = (float)random(-50, 50);
			th[i] = (float)(random(0, 359) * TORADIAN);
			rs[i] = (float)(random(5, 15) / 100.0);
			sz[i] = (float)(random((int)(FROST_STEP * 100), (int)(FROST_STEP * GROW_DURATION * 100)) / 100.0);
			r[i] = (float)random(25, 50);
		}
		cy = (float)0;
		/*sws = (float)0.5;
		rx = (float)0.0;
		ry = (float)0.0;
		rz = (float)0.0;*/
	}
}

//==============================================================================
//    Function : Animate.
//------------------------------------------------------------------------------
// Description : This updates the sparks and bolt
//
//==============================================================================

void TIceBoltAnimator::Animate(BOOL draw)
{
	T3DAnimator::Animate(draw);
	inst->SetCommandDone(FALSE);
	int subspell = ((PTEffect)inst)->GetSubSpell();
	S3DPoint effect_pos;
	S3DPoint pos;
		
	if (frameon == 0)
	{
		float r = 10.0f;
		float dx = r * (float)sin((float)TORADIAN * (((float)inst->GetFace() * 360.0f) / 256.0f));
		float dy = -r * (float)cos((float)TORADIAN * (((float)inst->GetFace() * 360.0f) / 256.0f));
		S3DPoint effect;
		((PTEffect)inst)->GetPos(effect);
		D3DVECTOR point;
		point.x = (float)effect.x;
		point.y = (float)effect.y;
		point.z = (float)effect.z;
		int ticks = 0;
		float zheight;
		int num;
		BOOL flag = FALSE;
		S3DPoint new_pos;
		do
		{
			point.x += dx;
			point.y += dy;

			effect.x = (int)point.x;
			effect.y = (int)point.y;
			effect.z = (int)point.z;

			zheight = (float)MapPane.GetWalkHeight(effect);

			int targets[MAXFOUNDOBJS];

			new_pos.x = (int)point.x;
			new_pos.y = (int)point.y;
			new_pos.z = (int)point.z - FROST_HEIGHT;

			// See if we've hit a character
			num = MapPane.FindObjectsInRange(new_pos, targets, 10, 0, OBJCLASS_CHARACTER);

			for(int i = 0; i < num; ++i) 
			{
				PTObjectInstance inst = MapPane.GetInstance(targets[i]);
				if (inst && inst != ((PTEffect)inst)->GetSpell()->GetInvoker() &&
					!((PTCharacter)inst)->IsDead())
						flag = TRUE;
			}

			++ticks;
		}
		while(point.z > zheight && flag == FALSE && ticks < MAX_MAXPOINTS);
		length = (float)(ticks * 10.0);
	}
	frameon++;
//
	if (subspell > 2)
	{
		for (int i = 0; i < MAX_SNOW_PARTICLES; i++)
		{
			th[i] += rs[i];
			if (th[i] > M_2PI)
				th[i] -= (float)M_2PI;
			rs[i] += (float)0.01;
		}
		if (frameon > GROW_DURATION * 2)
		{
			cy += (float)(length / (GROW_DURATION * 2));
			if (cy >= length)
				cy = (float)length;
		}
		if (frameon > GROW_DURATION * 5)
		{
			/*rx += (float)SW_ROTSPEED;
			ry += (float)SW_ROTSPEED;
			rz += (float)SW_ROTSPEED;
			if (rx > M_2PI)
				rx -= (float)M_2PI;
			if (ry > M_2PI)
				ry -= (float)M_2PI;
			if (rz > M_2PI)
				rz -= (float)M_2PI;
			sws += (float)SW_SCALESPEED;*/
			// float up, together, and faster
			for (int i = 0; i < MAX_SNOW_PARTICLES; i++)
			{
				h[i] += (float)5.0;
				r[i] -= (float)1.0;
				if (r[i] < 1)
					r[i] = (float)1.0;
				rs[i] += (float)0.05;
			}
		}
	}
	/*if (subspell > 2 && frameon < GROW_DURATION * 4)
	{
		SParticleParams pr;
		pr.numtargets = 1;

		pr.targetpos[0].x = (D3DVALUE)0.0;
		pr.targetpos[0].y = (D3DVALUE)0.0;
		pr.targetpos[0].z = (D3DVALUE)0.0;
		
		pr.seektargets = TRUE;
		pr.seekz = FALSE;
		pr.turnang = (D3DVALUE)0.1;
		pr.seekspeed = (D3DVALUE)(5.0 + (frameon / 16));
		pr.autorange = 0.0;
		pr.hitrange = 0.0;

		particleanim->ResetTargetInfo(pr);
	}
	if (subspell > 2 && frameon == GROW_DURATION * 4)
	{
		SParticleParams pr;
		pr.numtargets = 0;

		int targets[MAXFOUNDOBJS];
		S3DPoint effect_pos;
		((PTEffect)inst)->GetPos(effect_pos);
		effect_pos.y -= (int)length;
		PTObjectInstance caster = ((PTEffect)inst)->GetSpell()->GetInvoker();
		int num = MapPane.FindObjectsInRange(effect_pos, targets, 200, 0, OBJCLASS_CHARACTER);
		effect_pos.y += (int)length;
		for (int i = 0; i < num && pr.numtargets < 5; i++)
		{
			PTObjectInstance instan = MapPane.GetInstance(targets[i]);
			if (instan && instan != caster && !((PTCharacter)instan)->IsDead())// && !(instan->GetFlags() & OF_ICED))
			{
				S3DPoint putpos;
				((PTCharacter)instan)->GetPos(putpos);

				pr.targetpos[pr.numtargets].x = (float)(putpos.x - effect_pos.x);
				pr.targetpos[pr.numtargets].y = (float)(putpos.y - effect_pos.y);
				pr.targetpos[pr.numtargets].z = (float)(putpos.z - effect_pos.z);// + 70;
				pr.numtargets++;
			}
		}
		//
		if (pr.numtargets == 0)
			pr.seektargets = FALSE;
		else
			pr.seektargets = TRUE;
		pr.seekz = FALSE;
		pr.turnang = (D3DVALUE)0.1;
		pr.seekspeed = (D3DVALUE)5.0;
		pr.autorange = 0.0;
		pr.hitrange = 0.0;

		particleanim->ResetTargetInfo(pr);
	}*/
	for (int i = 0; i < MAX_FROST_PARTICLES; i++)
	{
		t[i]--;
		if (t[i] > 0)
			continue;
		else
			t[i] = 0;
		p[i].x += v[i].x;
		p[i].y += v[i].y;
		p[i].z += v[i].z;
		s[i] -= (float)FROST_STEP;
		if (s[i] < 0)
		{
			p[i].x = (D3DVALUE)random(-10, 10);
			p[i].y = (D3DVALUE)random(-10, 10);
			p[i].z = (D3DVALUE)random(-10, 10);
			v[i].x = (D3DVALUE)random(-3, 3);
			v[i].y = (D3DVALUE)random(-3, 3);
			v[i].z = (D3DVALUE)random(-3, 3);
			s[i] = (D3DVALUE)FROST_INIT_SIZE;
			t[i] = (float)random(0, (int)(FROST_INIT_SIZE / FROST_STEP));
			if (frameon > GROW_DURATION * 3)
				t[i] = 100;
		}
	}
	if (frameon < GROW_DURATION)
	{
		spherescale[0] += (D3DVALUE)SPHERE_STEP;
		spherescale[1] += (D3DVALUE)(SPHERE_STEP * 2);
		cylscale += (D3DVALUE)SPHERE_STEP;
		spiralscale += (D3DVALUE)SPIRAL_SCALE_STEP;
		spiralang += (D3DVALUE)SPIRAL_STEP;
		if (spiralang > M_2PI)
			spiralang -= (D3DVALUE)M_2PI;
	}
	if (frameon >= GROW_DURATION && frameon < GROW_DURATION * 2)
	{
		cylscale -= (D3DVALUE)(SPHERE_STEP / 2);
		spherescale[0] += (D3DVALUE)SPHERE_STEP;
		spherescale[1] += (D3DVALUE)SPHERE_STEP;
		spiralang += (D3DVALUE)SPIRAL_STEP;
		if (spiralang > M_2PI)
			spiralang -= (D3DVALUE)M_2PI;
	}
	if (frameon >= GROW_DURATION * 2 && frameon < GROW_DURATION * 3)
	{
		cylscale -= (D3DVALUE)(SPHERE_STEP / 2);
		spherescale[0] -= (D3DVALUE)SPHERE_STEP;
		spherescale[1] -= (D3DVALUE)(SPHERE_STEP * 1);
		spiralang += (D3DVALUE)SPIRAL_STEP;
		if (spiralang > M_2PI)
			spiralang -= (D3DVALUE)M_2PI;
	}
	if (frameon >= GROW_DURATION * 3 && frameon < GROW_DURATION * 4)
	{
		spherescale[0] -= (D3DVALUE)SPHERE_STEP;
		spherescale[1] -= (D3DVALUE)(SPHERE_STEP * 2);
		spiralscale -= (D3DVALUE)SPIRAL_SCALE_STEP;
	}
	ringout += RING_SPEED;
	if (ringout > length)
		ringout -= length;
	if (frameon == GROW_DURATION)
	{
		// deal damage proporational to subspell level
		((PTEffect)inst)->GetPos(effect_pos);
		effect_pos.y -= (int)length;
		PTObjectInstance caster = ((PTEffect)inst)->GetSpell()->GetInvoker();
		DamageCharactersInRange(caster, effect_pos, 200, FROST_DAMAGE_MIN * ((subspell % 2) + 1), FROST_DAMAGE_MAX * ((subspell % 2) + 1), DAMAGE_ICE);
	}
	if (frameon == GROW_DURATION * 5 && subspell > 2) // kill them dead
	{
		((PTEffect)inst)->GetPos(effect_pos);
		effect_pos.y -= (int)length;
		PTObjectInstance caster = ((PTEffect)inst)->GetSpell()->GetInvoker();
		DamageCharactersInRange(caster, effect_pos, 200, 250, 250, DAMAGE_ICE);
	}
	// freeze guys (if high enough spell level)
	if (frameon == GROW_DURATION * 2 && subspell > 1)
	{
		((PTEffect)inst)->GetPos(effect_pos);
		PTObjectInstance caster = ((PTEffect)inst)->GetSpell()->GetInvoker();

		// find me some characters to ice!
		S3DPoint putpos, vel;
		((PTEffect)inst)->GetPos(putpos);
		ConvertToVector((int)angle, (int)length, vel);
		effect_pos.x = putpos.x + vel.x;
		effect_pos.y = putpos.y + vel.y;
		effect_pos.z = putpos.z;

		PTObjectInstance toice = NULL;
		int targets[MAXFOUNDOBJS];
		int num = MapPane.FindObjectsInRange(effect_pos, targets, 200, 0, OBJCLASS_CHARACTER);
		for (int i = 0; i < num; i++)
		{
			PTObjectInstance instan = MapPane.GetInstance(targets[i]);
			if (instan && instan != caster && !((PTCharacter)instan)->IsDead() && !(instan->GetFlags() & OF_ICED))
			{
				// create the iced effect
				SObjectDef def;
				memset(&def, 0, sizeof(SObjectDef));
				def.objclass = OBJCLASS_EFFECT;
				def.level = MapPane.GetMapLevel();
				S3DPoint putpos;
				((PTCharacter)instan)->GetPos(putpos);
				def.pos = putpos;
				def.objtype = EffectClass.FindObjType("Iced");
				PTIcedEffect effect = (PTIcedEffect)MapPane.GetInstance(MapPane.NewObject(&def));

				// now ice them!
				if (!effect->HasAnimator())
					effect->CreateAnimator();
				PTIcedAnimator ia = (PTIcedAnimator)effect->GetAnimator();
				if (ia)
					ia->InitIced(instan);
			}
		}
	}
	if (frameon == GROW_DURATION * 12) // 4
	{
		inst->SetCommandDone(TRUE);
	}
}

//==============================================================================
//    Function : Render.
//------------------------------------------------------------------------------
// Description : Renders spheres and cylinders, etc.
//
//==============================================================================

BOOL TIceBoltAnimator::Render()
{
    SaveBlendState();
    SetBlendState();

	PS3DAnimObj obj;
	int i, j, subspell = ((PTEffect)inst)->GetSubSpell();

	// draw the cylinder
	if (subspell > 1)
	{
		for (i = 0; i < 4; i++)
		{
			obj = GetObject(i);
			D3DMATRIXClear(&obj->matrix);
			obj->flags = OBJ3D_MATRIX;
			// scale to size of spark
			//obj->scl.x = (D3DVALUE)((4 - i) * cylscale / 4);
			//obj->scl.y = (D3DVALUE)((4 - i) * cylscale / 4);
			obj->scl.x = (D3DVALUE)(cylscale / 2);
			obj->scl.y = (D3DVALUE)(cylscale / 2);
			obj->scl.z = (D3DVALUE)((float)length / 64.0f); // scale to length...?
			D3DMATRIXScale(&obj->matrix, &obj->scl);

			D3DMATRIXRotateX(&obj->matrix, D3DVALUE((M_PI / 2.0)));//-
			D3DMATRIXRotateY(&obj->matrix, 0.0f);
			D3DMATRIXRotateZ(&obj->matrix, 0.0f);

			/*S3DPoint vel;
			ConvertToVector((angle + 64) & 255, -32, vel); 
			obj->pos.x = (D3DVALUE)vel.x;
			obj->pos.y = (D3DVALUE)vel.y;*/
			obj->pos.x = (D3DVALUE)0.0;
			obj->pos.y = (D3DVALUE)0.0;
			obj->pos.z = (D3DVALUE)0.0;
			D3DMATRIXTranslate(&obj->matrix, &obj->pos);
			
			ResetExtents();
			RenderObject(obj);
			UpdateExtents();
		}
	}

	if (frameon < GROW_DURATION * 3)
	{
		// draw the spirals around the cylinder
		if (subspell > 0)
		{
			obj = GetObject(6);
			int numrevs = (int)length / 100;
			D3DVALUE zscale = (D3DVALUE)(length / numrevs),
				ypos;
			for (j = 0; j < numrevs; j++)
			{
				ypos = (D3DVALUE)(-j * zscale);
				for (i = 0; i < 2; i++)
				{
					D3DMATRIXClear(&obj->matrix);
					obj->flags = OBJ3D_MATRIX;
					// scale to size of spark
					obj->scl.x = (D3DVALUE)(spiralscale);
					obj->scl.y = (D3DVALUE)(spiralscale);
					//obj->scl.z = (D3DVALUE)(0.1250); // scale to make ring look fat, not long
					obj->scl.z = (D3DVALUE)(zscale / 64.0f); // scale to length...?
					D3DMATRIXScale(&obj->matrix, &obj->scl);
					
					D3DMATRIXRotateX(&obj->matrix, D3DVALUE((M_PI / 2.0)));//-
					D3DMATRIXRotateY(&obj->matrix, (float)(i ? M_PI - spiralang : spiralang));
					D3DMATRIXRotateZ(&obj->matrix, 0.0f);

					// translate to place should be
					obj->pos.x = (D3DVALUE)0.0f;
					obj->pos.y = (D3DVALUE)ypos;
					obj->pos.z = (D3DVALUE)0.0f;
					D3DMATRIXTranslate(&obj->matrix, &obj->pos);

					ResetExtents();
					RenderObject(obj);
					UpdateExtents();
				}
			}
		}
		// draw the rings around the cylinder
		obj = GetObject(5);
		for (i = 0; i < int(length / 100); i++) // draw more if longer
		{
			D3DMATRIXClear(&obj->matrix);
			obj->flags = OBJ3D_MATRIX;
			// scale to size of spark
			obj->scl.x = (D3DVALUE)(cylscale / 2);
			obj->scl.y = (D3DVALUE)(cylscale / 2);
			obj->scl.z = (D3DVALUE)(1.0); // scale to make ring look fat, not long
			D3DMATRIXScale(&obj->matrix, &obj->scl);
			
			D3DMATRIXRotateX(&obj->matrix, D3DVALUE((M_PI / 2.0)));//-
			D3DMATRIXRotateY(&obj->matrix, spiralang);
			D3DMATRIXRotateZ(&obj->matrix, 0.0f);

			obj->pos.x = (D3DVALUE)0.0f;
			obj->pos.y = (D3DVALUE)(-((int)(ringout + 100 * i) % (int)(length)));
			obj->pos.z = (D3DVALUE)0.0f;
			D3DMATRIXTranslate(&obj->matrix, &obj->pos);

			ResetExtents();
			RenderObject(obj);
			UpdateExtents();
		}
	}
	
	obj = GetObject(4);
	if (subspell > 0)
	{
		for (i = 0; i < 2; i++) // draw one glow sphere on each end
		{
			// draw the ball thing
			ResetExtents();
			// clear matrix and get ready to transform and render
			D3DMATRIXClear(&obj->matrix);
			obj->flags = OBJ3D_MATRIX;
			// scale to size of spark
			obj->scl.x = obj->scl.y = obj->scl.z = (D3DVALUE)(spherescale[i] / 2.0);
			D3DMATRIXScale(&obj->matrix, &obj->scl);
			// rotate to face screen
			D3DMATRIXRotateX(&obj->matrix, -(float)(M_PI / 2.0));
			D3DMATRIXRotateX(&obj->matrix, -(float)(M_PI / 6.0));
			D3DMATRIXRotateZ(&obj->matrix, -(float)(M_PI / 4.0));
			D3DMATRIXRotateZ(&obj->matrix, D3DVAL(-((inst->GetFace() * 360) / 256) * TORADIAN));
			//
			//D3DMATRIXRotateY(&obj->matrix, (float)(M_PI / 8.0));
			// translate to place should be
			obj->pos.x = (D3DVALUE)0.0f;
			obj->pos.y = (D3DVALUE)(-length * i); // one on Locke, one on target
			obj->pos.z = (D3DVALUE)0.0f;
			D3DMATRIXTranslate(&obj->matrix, &obj->pos);
			RenderObject(obj);
			UpdateExtents();
		}
	}
	// draw frost particles
	for (i = 0; i < MAX_FROST_PARTICLES; i++)
	{
		if (t[i] > 0)
			continue;
		ResetExtents();
		// clear matrix and get ready to transform and render
		D3DMATRIXClear(&obj->matrix);
		obj->flags = OBJ3D_MATRIX;
		// scale to size of spark
		obj->scl.x = obj->scl.y = obj->scl.z = (D3DVALUE)(s[i]);
		D3DMATRIXScale(&obj->matrix, &obj->scl);
		// rotate to face screen
		D3DMATRIXRotateX(&obj->matrix, -(float)(M_PI / 2.0));
		D3DMATRIXRotateX(&obj->matrix, -(float)(M_PI / 6.0));
		D3DMATRIXRotateZ(&obj->matrix, -(float)(M_PI / 4.0));
		D3DMATRIXRotateZ(&obj->matrix, D3DVAL(-((inst->GetFace() * 360) / 256) * TORADIAN));
		//
		//D3DMATRIXRotateY(&obj->matrix, (float)(M_PI / 8.0));
		// translate to place should be
		obj->pos.x = (D3DVALUE)p[i].x;
		obj->pos.y = (D3DVALUE)(p[i].y - length);
		obj->pos.z = (D3DVALUE)p[i].z;
		D3DMATRIXTranslate(&obj->matrix, &obj->pos);
		RenderObject(obj);
		UpdateExtents();
	}
	// draw snow flurry and a shockwave
	if (subspell > 2)
	{
		for (i = 0; i < MAX_SNOW_PARTICLES; i++)
		{
			ResetExtents();
			// clear matrix and get ready to transform and render
			D3DMATRIXClear(&obj->matrix);
			obj->flags = OBJ3D_MATRIX;
			// scale to size of spark
			obj->scl.x = obj->scl.y = obj->scl.z = (D3DVALUE)(sz[i]);
			D3DMATRIXScale(&obj->matrix, &obj->scl);
			// rotate to face screen
			D3DMATRIXRotateX(&obj->matrix, -(float)(M_PI / 2.0));
			D3DMATRIXRotateX(&obj->matrix, -(float)(M_PI / 6.0));
			D3DMATRIXRotateZ(&obj->matrix, -(float)(M_PI / 4.0));
			D3DMATRIXRotateZ(&obj->matrix, D3DVAL(-((inst->GetFace() * 360) / 256) * TORADIAN));
			//
			//D3DMATRIXRotateY(&obj->matrix, (float)(M_PI / 8.0));
			// translate to place should be
			obj->pos.x = (D3DVALUE)(r[i] * cos(th[i]));
			obj->pos.y = (D3DVALUE)(r[i] * sin(th[i]));
			if (frameon > GROW_DURATION * 2)
				obj->pos.y -= (float)(cy);
			obj->pos.z = (D3DVALUE)h[i];
			D3DMATRIXTranslate(&obj->matrix, &obj->pos);
			RenderObject(obj);
			UpdateExtents();		
		}
		/*if (frameon > GROW_DURATION * 5)
		{
			obj = GetObject(7);
			ResetExtents();
			// clear matrix and get ready to transform and render
			D3DMATRIXClear(&obj->matrix);
			obj->flags = OBJ3D_MATRIX;
			// scale to size of spark
			obj->scl.x = obj->scl.y = obj->scl.z = (D3DVALUE)(sws);
			D3DMATRIXScale(&obj->matrix, &obj->scl);
			// rotate to face screen
			D3DMATRIXRotateX(&obj->matrix, rx);
			D3DMATRIXRotateX(&obj->matrix, ry);
			D3DMATRIXRotateZ(&obj->matrix, rz);
			//
			//D3DMATRIXRotateY(&obj->matrix, (float)(M_PI / 8.0));
			// translate to place should be
			obj->pos.x = (D3DVALUE)(r[i] * cos(th[i]));
			obj->pos.y = (D3DVALUE)(r[i] * sin(th[i]));
			if (frameon > GROW_DURATION * 2)
				obj->pos.y -= (float)(cy);
			obj->pos.z = (D3DVALUE)h[i];
			D3DMATRIXTranslate(&obj->matrix, &obj->pos);
			RenderObject(obj);
			UpdateExtents();			
		}*/
	}
    RestoreBlendState();

	return TRUE;
}

void TIceBoltAnimator::RefreshZBuffer()
{
	S3DPoint mapstart, mapend, screenstart, screenend, effect, vel;

	((PTEffect)inst)->GetPos(effect);

	ConvertToVector((int)angle, (int)length, vel); 
	
	mapstart.x = (int)effect.x;
	mapstart.y = (int)effect.y;
	mapstart.z = (int)effect.z;
	WorldToScreen(mapstart, screenstart);

	mapend.x = (int)effect.x + vel.x;
	mapend.y = (int)effect.y + vel.y;
	mapend.z = (int)effect.z;
	WorldToScreen(mapend, screenend);

	int x1 = min(screenstart.x, screenend.x) - 100,
		x2 = max(screenstart.x, screenend.x) + 100,
		y1 = min(screenstart.y, screenend.y) - 100,
		y2 = max(screenstart.y, screenend.y) + 100;
	RestoreZ(x1, y1, x2 - x1, y2 - y1);
}

// ***************
// * Iced Effect *
// ***************

#define ICED_LENGTH			10
#define	ICED_DURATION		(24 * ICED_LENGTH)
#define ICED_CHUNK_GRAVITY	0.25

DEFINE_BUILDER("Iced", TIcedEffect)
REGISTER_BUILDER(TIcedEffect)

void TIcedEffect::Initialize()
{
}

void TIcedEffect::Pulse()
{
	TEffect::Pulse();
}

// *****************
// * Iced Animator *
// *****************

REGISTER_3DANIMATOR("Iced", TIcedAnimator)

//==============================================================================
//    Function : Initialize.
//------------------------------------------------------------------------------
// Description : This will setup the initial state for the Iced effect.
//				 The iced effect consists of a big crystal thing over
//				 a character who is disabled, then it shatters
//==============================================================================

void TIcedAnimator::Initialize()
{
	T3DAnimator::Initialize();
	frameon = 0;
	angle = (D3DVALUE)(random(0, 359) * TORADIAN);
	icedchar = NULL;
	donebouncing = 0;
}

void TIcedAnimator::InitIced(PTObjectInstance iceme)
{
	icedchar = iceme;
	if (icedchar)
	{
		//icedchar->SetFlag(OF_DISABLED);
		((PTCharacter)icedchar)->Disable();
		icedchar->SetFlag(OF_ICED);
	}
}

//==============================================================================
//    Function : Animate.
//------------------------------------------------------------------------------
// Description : This updates the sparks and bolt
//
//==============================================================================

void TIcedAnimator::Animate(BOOL draw)
{
	T3DAnimator::Animate(draw);
	inst->SetCommandDone(FALSE);
	S3DPoint pos;

	frameon++;
	if (icedchar && ((PTCharacter)icedchar)->IsDead() && frameon < ICED_DURATION)
	{
		frameon = ICED_DURATION;
	}
	if (frameon == ICED_DURATION)
	{
		if (icedchar)
		{
			icedchar->SetFlag(OF_DISABLED, FALSE);
			icedchar->SetFlag(OF_ICED, FALSE);
		}
		// init ice chunks
		int a = 0, b = 0, c, d;
		for (int i = 0; i < MAX_ICED_CHUNKS; i++)
		{
			c = (a ? 1 : -1);
			d = (b ? 1 : -1);
			// velocity
			v[i].x = (D3DVALUE)(c * random(5, 10) / 10.0 + random(-5, 5) / 10.0);
			v[i].y = (D3DVALUE)(d * random(5, 10) / 10.0 + random(-5, 5) / 10.0);
			v[i].z = (D3DVALUE)(random(0, 10) / 10.0);
			// position
			p[i].x = (D3DVALUE)(c * random(20, 40) + random(-20, 20));
			p[i].y = (D3DVALUE)(d * random(20, 40) + random(-20, 20));
			p[i].z = (D3DVALUE)((int)(i / 6) * 25); // spread in rows of 4, 25 apart
			// angular velocity
			w[i].x = w[i].y = (D3DVALUE)(random(0, 25) / 100.0);
			//w[i].z = (D3DVALUE)(random(-25, 25) / 100.0);
			// angular position
			//t[i].x = (D3DVALUE)random(0, 6);
			//t[i].y = (D3DVALUE)random(0, 6);
			t[i].z = (D3DVALUE)(atan2(v[i].y, v[i].x));
			// scale
			if (random(0, 1))
			{
				s[i].x = (D3DVALUE)(random(25, 75) / 100.0);
				s[i].y = (D3DVALUE)(random(25, 75) / 100.0);
				s[i].z = (D3DVALUE)(random(25, 75) / 100.0);
			}
			else
			{
				s[i].x = (D3DVALUE)(random(10, 15) / 100.0);
				s[i].y = (D3DVALUE)(random(10, 15) / 100.0);
				s[i].z = (D3DVALUE)(random(10, 15) / 100.0);
			}
			// life (bounces left)
			l[i] = random(2, 3);
			// separator
			a = 1 - a;
			if (a)
				b = 1 - b;
		}
	}
	if (frameon > ICED_DURATION)
	{
		donebouncing = 1;
		for (int i = 0; i < MAX_ICED_CHUNKS; i++)
		{
			if (l[i] == 0)
				continue;
			donebouncing = 0;
			p[i].x += v[i].x;
			p[i].y += v[i].y;
			p[i].z += v[i].z;
			v[i].z -= ICED_CHUNK_GRAVITY;
			t[i].x += w[i].x;
			t[i].y += w[i].y;
			t[i].z += w[i].z;
			if (t[i].x > M_2PI)
				t[i].x -= (float)M_2PI;
			if (t[i].y > M_2PI)
				t[i].y -= (float)M_2PI;
			if (t[i].z > M_2PI)
				t[i].z -= (float)M_2PI;
			if (t[i].x < 0)
				t[i].x += (float)M_2PI;
			if (t[i].y < 0)
				t[i].y += (float)M_2PI;
			if (t[i].z < 0)
				t[i].z += (float)M_2PI;
			// bounce
			if (p[i].z <= 16) // fix this
			{
				p[i].z = 20;
				v[i].z *= (float)(-0.5);
				w[i].x *= (D3DVALUE)2.0;
				w[i].y *= (D3DVALUE)2.0;
				w[i].z *= (D3DVALUE)2.0;
				l[i]--;
			}
		}
	}
	if (donebouncing)
	{
		inst->SetCommandDone(TRUE);
	}
}

//==============================================================================
//    Function : Render.
//------------------------------------------------------------------------------
// Description : Renders ice chunk, possibly shattered chunks
//
//==============================================================================

BOOL TIcedAnimator::Render()
{
	int i;
    SaveBlendState();
    SetBlendState();

	PS3DAnimObj obj;
	if (frameon < ICED_DURATION)
	{
		for (i = 1; i < min(frameon * 4, 50); i++)
		{
			obj = GetObject(i);

			D3DMATRIXClear(&obj->matrix);
			obj->flags = OBJ3D_MATRIX;
			D3DMATRIXRotateZ(&obj->matrix, angle);
			ResetExtents();
			RenderObject(obj);
			UpdateExtents();
		}
	}
	else
	{
		obj = GetObject(0);
		for (int i = 0; i < MAX_ICED_CHUNKS; i++)
		{
			if (l[i] == 0)
				continue;
			ResetExtents();
			// clear matrix and get ready to transform and render
			D3DMATRIXClear(&obj->matrix);
			obj->flags = OBJ3D_MATRIX;
			// scale to size of chunk
			obj->scl.x = s[i].x;
			obj->scl.y = s[i].y;
			obj->scl.z = s[i].z;
			D3DMATRIXScale(&obj->matrix, &obj->scl);
			// rotate to face correct way
			D3DMATRIXRotateX(&obj->matrix, t[i].x);
			D3DMATRIXRotateY(&obj->matrix, t[i].y);
			D3DMATRIXRotateZ(&obj->matrix, t[i].z);
			// translate to place should be
			obj->pos.x = (D3DVALUE)p[i].x;
			obj->pos.y = (D3DVALUE)p[i].y;
			obj->pos.z = (D3DVALUE)p[i].z;
			D3DMATRIXTranslate(&obj->matrix, &obj->pos);
			RenderObject(obj);
			UpdateExtents();
		}
	}
    RestoreBlendState();

	return TRUE;
}

void TIcedAnimator::RefreshZBuffer()
{
	S3DPoint screen, effect, pos, po;
	((PTEffect)inst)->GetPos(effect);
	if (frameon < ICED_DURATION)
	{
		WorldToScreen(effect, screen);
		int size_x = 150,
			size_y = 200;
		RestoreZ(screen.x - (size_x / 2), screen.y - (size_y / 2) - 50, size_x, size_y);
	}
	else
	{
		int size_x = 70,
			size_y = 70;
		for (int i = 0; i < MAX_ICED_CHUNKS; i++)
		{
			if (l[i] == 0)
				continue;
			((PTEffect)inst)->GetPos(effect);
			WorldToScreen(effect, screen);
			po.x = (int)p[i].x;
			po.y = (int)p[i].y;
			po.z = (int)p[i].z;
			WorldToScreen(po, pos);
			screen.x += pos.x;
			screen.y += pos.y;
			RestoreZ(screen.x - (size_x / 2), screen.y - (size_y / 2) - 10, size_x, size_y);
		}
	}
}

// ********************
// * Quicksand Effect *
// ********************

DEFINE_BUILDER("Quicksand", TQuicksandEffect)
REGISTER_BUILDER(TQuicksandEffect)

void TQuicksandEffect::Initialize()
{
}

void TQuicksandEffect::Pulse()
{
	TEffect::Pulse();
}

// **********************
// * Quicksand Animator *
// **********************

#define QUICKSAND_DURATION		40
#define QUICKSAND_SWITCH		10.0
#define QUICKSAND_CYLROT		0.5

#define SANDSWIRL_DURATION		75.0

REGISTER_3DANIMATOR("Quicksand", TQuicksandAnimator)

//==============================================================================
//    Function : Initialize.
//------------------------------------------------------------------------------
// Description : This will setup the initial state for the quicksand
//==============================================================================

void TQuicksandAnimator::Initialize()
{
	T3DAnimator::Initialize();
	frameon = 0;
	scalesize = 1.0;
	stage = 0;
	count = 0;
	cylscale = (D3DVALUE)0.0;
	cylheight = (D3DVALUE)1.0;
	cylrot = (D3DVALUE)0.0;
	cylcount = 0;
	PS3DAnimObj o = GetObject(0);
    GetVerts(o, D3DVT_LVERTEX);
}

void TQuicksandAnimator::InitQuicksand(PTObjectInstance quicksandme, int delay)
{
	frameon = -delay;
	quicksandchar = quicksandme;
	if (quicksandchar)
	{
		quicksandchar->SetFlag(OF_DISABLED);
		//quicksandchar->SetFlag(OF_ICED);
	}
}

//==============================================================================
//    Function : Animate.
//------------------------------------------------------------------------------
// Description : This updates the sparks and bolt
//
//==============================================================================

void TQuicksandAnimator::Animate(BOOL draw)
{
	T3DAnimator::Animate(draw);
	inst->SetCommandDone(FALSE);
	S3DPoint pos;

	frameon++;
	cylrot += (D3DVALUE)QUICKSAND_CYLROT;
	if (cylrot > M_2PI)
		cylrot -= (float)M_2PI;
	if (frameon < 0)
	{
		cylscale += (D3DVALUE)(0.125 / QUICKSAND_SWITCH);
		cylheight += (float)0.025;
	}
	if (frameon > 0 && frameon < QUICKSAND_DURATION)
	{
		cylscale -= (D3DVALUE)(0.125 / QUICKSAND_SWITCH);
		cylheight -= (float)0.025;
	}
	if (frameon < 0)
		return;
	if (quicksandchar && ((PTCharacter)quicksandchar)->IsDead() && frameon < ICED_DURATION)
	{
		frameon = QUICKSAND_DURATION * 2;
	}
	if (frameon > 0 && frameon < QUICKSAND_DURATION)
	{
		if (stage == 0)
			scalesize += (D3DVALUE)(1.0 / QUICKSAND_SWITCH);
		if (stage == 1)
			scalesize += (D3DVALUE)(0.5 / QUICKSAND_SWITCH);
		count++;
		if (count == QUICKSAND_SWITCH)
		{
			scalesize = 1.0;
			count = 0;
			stage++;
			if (stage > 3)
				stage = 3;
		}
	}
	if (frameon == QUICKSAND_DURATION)
	{
		stage = 3;
		count = 0;
		scalesize = 1.0;
	}
	if (frameon > QUICKSAND_DURATION && frameon < QUICKSAND_DURATION * 2)
	{
		if (stage == 0)
			scalesize -= (D3DVALUE)(1.0 / QUICKSAND_SWITCH);
		if (stage == 1)
			scalesize -= (D3DVALUE)(0.5 / QUICKSAND_SWITCH);
		count++;
		if (count == QUICKSAND_SWITCH && stage > 0)
		{
			count = 0;
			stage--;
			if (stage < 0)
				stage = 0;
			if (stage == 1)
				scalesize = 1.5;
			else if (stage == 0)
				scalesize = 2.0;
			else
				scalesize = 1.0;
		}
	}
	if (frameon == QUICKSAND_DURATION * 2)
	{
		if (quicksandchar)
		{
			quicksandchar->SetFlag(OF_DISABLED, FALSE);
			//icedchar->SetFlag(OF_ICED, FALSE);
		}
	}
	if (frameon > QUICKSAND_DURATION * 2)
	{
		inst->SetCommandDone(TRUE);
	}
}

//==============================================================================
//    Function : Render.
//------------------------------------------------------------------------------
// Description : Renders quicksand
//
//==============================================================================

void TQuicksandAnimator::SetAnimFrame(int frame_num, PS3DAnimObj obj)
{
	if (!obj->lverts)
		return;
	frame_num = (frame_num + 2) % 4; // this fixes it to do the right frame...(hack)
	float u = (float)(frame_num % 2) * .5f;
	float v = (float)(frame_num / 2) * .5f;

	obj->flags |= OBJ3D_VERTS;

	obj->lverts[0].tu = u + .05f;
	obj->lverts[0].tv = v + .05f;
	obj->lverts[2].tu = u + .5f - .05f;
	obj->lverts[2].tv = v + .05f;
	obj->lverts[1].tu = u + .05f;
	obj->lverts[1].tv = v + .5f - .05f;
	obj->lverts[3].tu = u + .5f - .05f;
	obj->lverts[3].tv = v + .5f - .05f;
}

BOOL TQuicksandAnimator::Render()
{
	SaveBlendState();
    SetBlendState();

	PS3DAnimObj obj;
	if (frameon < QUICKSAND_DURATION * 2)
	{
		// render spinny sand thing
		obj = GetObject(0);
		// clear matrix and get ready to transform and render
		obj->flags = OBJ3D_MATRIX;
		D3DMATRIXClear(&obj->matrix);		
		// set frame
		SetAnimFrame(stage, obj);
		
		obj->scl.x = (D3DVALUE)(scalesize);
		obj->scl.y = (D3DVALUE)(scalesize);
		obj->scl.z = 1.0;
		D3DMATRIXScale(&obj->matrix, &obj->scl);
		// rotate to face correct way
		int ang = (int)(frameon * 360 / QUICKSAND_SWITCH) % 360;
		D3DMATRIXRotateZ(&obj->matrix, (D3DVALUE)(ang * TORADIAN));
		// translate to place should be
		obj->pos.x = (D3DVALUE)0;
		obj->pos.y = (D3DVALUE)0;
		obj->pos.z = (D3DVALUE)0;
		D3DMATRIXTranslate(&obj->matrix, &obj->pos);

		ResetExtents();
		RenderObject(obj);
		UpdateExtents();
	}
	if (frameon < QUICKSAND_DURATION)
	{
		// render cylinder(s)
		obj = GetObject(1);
		for (int i = 0; i < 2; i++)
		{
			// clear matrix and get ready to transform and render
			obj->flags = OBJ3D_MATRIX;
			D3DMATRIXClear(&obj->matrix);		
			// scale up and sideways
			obj->scl.x = (D3DVALUE)cylscale;
			obj->scl.y = (D3DVALUE)cylscale;
			obj->scl.z = cylheight;
			D3DMATRIXScale(&obj->matrix, &obj->scl);
			// rotate to face correct way
			D3DMATRIXRotateZ(&obj->matrix, (float)(i ? M_PI - cylrot : cylrot));
			// translate to place should be
			obj->pos.x = (D3DVALUE)0;
			obj->pos.y = (D3DVALUE)0;
			obj->pos.z = (D3DVALUE)0;
			D3DMATRIXTranslate(&obj->matrix, &obj->pos);

			ResetExtents();
			RenderObject(obj);
			UpdateExtents();
		}
	}
    RestoreBlendState();

	return TRUE;
}

void TQuicksandAnimator::RefreshZBuffer()
{
	int size_x = 100,
		size_y = 50;
	S3DPoint effect, screen;

	((PTEffect)inst)->GetPos(effect);

	WorldToScreen(effect, screen);

	RestoreZ(screen.x - (size_x / 2), screen.y - (size_y / 2), size_x, size_y);
}

// ********************
// * Sandswirl Effect *
// ********************

DEFINE_BUILDER("Sandswirl", TSandswirlEffect)
REGISTER_BUILDER(TSandswirlEffect)

void TSandswirlEffect::Initialize()
{
}

void TSandswirlEffect::Pulse()
{
	TEffect::Pulse();	
}


// **********************
// * Sandswirl Animator *
// **********************

//#define SANDSWIRL_DURATION		50.0

REGISTER_3DANIMATOR("Sandswirl", TSandswirlAnimator)

//==============================================================================
//    Function : Initialize.
//------------------------------------------------------------------------------
// Description : This will setup the initial state for the sandswirl effect
//==============================================================================

void TSandswirlAnimator::Initialize()
{
	T3DAnimator::Initialize();
	frameon = 0;
	angle = ((PTEffect)inst)->GetAngle();

	SObjectDef def;
	memset(&def, 0, sizeof(SObjectDef));
	def.objclass = OBJCLASS_EFFECT;

	def.objtype = EffectClass.FindObjType("sand");
	def.level = MapPane.GetMapLevel();
	S3DPoint pos;
	((PTEffect)inst)->GetPos(pos);
	def.pos = pos;
	PTObjectInstance instance = MapPane.GetInstance(MapPane.NewObject(&def));
	if (!instance)
		return;

	instance->CreateAnimator();
	PTParticle3DAnimator anim = (PTParticle3DAnimator)instance->GetAnimator();
	particleanim = anim;

	//int ang = (angle + 128) & 0xff; // fly back
	int ang = angle;

	S3DPoint vect;
	ConvertToVector(ang, 100, vect);

	if (anim)
	{
		SParticleParams pr;

		pr.particles = random(50, 100);
		pr.pos.x = (D3DVALUE)0.0;
		pr.pos.y = (D3DVALUE)0.0;
		pr.pos.z = (D3DVALUE)70.0;
		pr.pspread.x = (D3DVALUE)50.0;
		pr.pspread.y = (D3DVALUE)50.0;
		pr.pspread.z = (D3DVALUE)50.0;
		pr.dir.x = (D3DVALUE)((float)vect.x / (float)100.0);
		pr.dir.y = (D3DVALUE)((float)vect.y / (float)100.0);
		pr.dir.z = (D3DVALUE)((float)vect.z / (float)100.0);
		pr.spread.x = (D3DVALUE)0.5;
		pr.spread.y = (D3DVALUE)0.5;
		pr.spread.z = (D3DVALUE)0.5;
		pr.gravity = (D3DVALUE)0.0;
		pr.trails = 1;
		pr.minstart = 0;
		pr.maxstart = pr.particles / 2;
		pr.minlife = 100;
		pr.maxlife = 150;
		pr.bounce = FALSE;
		pr.killobj = TRUE;
		pr.objflags = 0xF;

		pr.numtargets = 1;
		pr.targetpos[0].x = (D3DVALUE)0;
		pr.targetpos[0].y = (D3DVALUE)0;
		pr.targetpos[0].z = (D3DVALUE)100;
		//
		pr.seektargets = TRUE;
		pr.turnang = (float)0.5;
		pr.seekspeed = (float)5.0;
		pr.autorange = (float)0.0;
		pr.hitrange = (float)0.0;

		anim->InitParticles(&pr);
	}
}

//==============================================================================
//    Function : Animate.
//------------------------------------------------------------------------------
//
//==============================================================================

void TSandswirlAnimator::Animate(BOOL draw)
{
	T3DAnimator::Animate(draw);
	inst->SetCommandDone(FALSE);
	S3DPoint pos;

	frameon++;
	if (frameon < SANDSWIRL_DURATION)
	{
		SParticleParams pr;
		pr.numtargets = 1;
		pr.targetpos[0].x = (D3DVALUE)0;
		pr.targetpos[0].y = (D3DVALUE)0;
		pr.targetpos[0].z = (D3DVALUE)100;
		//
		pr.seektargets = TRUE;
		pr.turnang = (D3DVALUE)0.5;
		pr.seekspeed = (D3DVALUE)(5.0 + frameon / 10.0);
		pr.autorange = 0.0;
		pr.hitrange = 0.0;

		particleanim->ResetTargetInfo(pr);
	}
	else if (frameon == SANDSWIRL_DURATION)
	{
		SParticleParams pr;
		pr.numtargets = 0;

		int targets[MAXFOUNDOBJS];
		S3DPoint effect_pos;
		((PTEffect)inst)->GetPos(effect_pos);
		//effect_pos.y -= length;
		PTObjectInstance caster = ((PTEffect)inst)->GetSpell()->GetInvoker();
		int num = MapPane.FindObjectsInRange(effect_pos, targets, 400, 0, OBJCLASS_CHARACTER);
		for (int i = 0; i < num && pr.numtargets < 5; i++)
		{
			PTObjectInstance instan = MapPane.GetInstance(targets[i]);
			if (instan && instan != caster && !((PTCharacter)instan)->IsDead()/* && !(instan->GetFlags() & OF_ICED)*/)
			{
				// create the quicksand effect
				SObjectDef def;
				memset(&def, 0, sizeof(SObjectDef));
				def.objclass = OBJCLASS_EFFECT;
				def.level = MapPane.GetMapLevel();
				S3DPoint putpos;
				((PTCharacter)instan)->GetPos(putpos);
				def.pos = putpos;
				def.objtype = EffectClass.FindObjType("Quicksand");
				PTIcedEffect effect = (PTIcedEffect)MapPane.GetInstance(MapPane.NewObject(&def));

				// now quicksand them!
				if (!effect->HasAnimator())
					effect->CreateAnimator();
				PTQuicksandAnimator qa = (PTQuicksandAnimator)effect->GetAnimator();
				if (qa)
					qa->InitQuicksand(instan, (int)QUICKSAND_DURATION);

				pr.targetpos[pr.numtargets].x = (float)(putpos.x - effect_pos.x);
				pr.targetpos[pr.numtargets].y = (float)(putpos.y - effect_pos.y);
				pr.targetpos[pr.numtargets].z = (float)(putpos.z - effect_pos.z)  - 32;
				pr.numtargets++;
			}
		}
		//
		if (pr.numtargets == 0)
			pr.seektargets = FALSE;
		else
			pr.seektargets = TRUE;
		pr.turnang = (D3DVALUE)0.5;
		pr.seekspeed = (D3DVALUE)7.5;
		//pr.autorange = 25.0;
		//pr.hitrange = 10.0;
		pr.autorange = 0.0;
		pr.hitrange = 10.0;

		particleanim->ResetTargetInfo(pr);
	}
	//
	if (frameon == SANDSWIRL_DURATION * 4)
	{
		inst->SetCommandDone(TRUE);
	}
}

//==============================================================================
//    Function : Render.
//------------------------------------------------------------------------------
// Description : Renders sandswirl effect
//
//==============================================================================

BOOL TSandswirlAnimator::Render()
{

	/*SaveBlendState();
    SetBlendState();

	PS3DAnimObj obj;
	if (frameon < QUICKSAND_DURATION * 2)
	{
		obj = GetObject(0);
		// clear matrix and get ready to transform and render
		/*obj->flags = OBJ3D_MATRIX;
		D3DMATRIXClear(&obj->matrix);		
		// set frame
		SetAnimFrame(stage, obj);
		
		obj->scl.x = (D3DVALUE)(scalesize);
		obj->scl.y = (D3DVALUE)(scalesize);
		obj->scl.z = 1.0;
		D3DMATRIXScale(&obj->matrix, &obj->scl);
		// rotate to face correct way
		int ang = (int)(frameon * 360 / QUICKSAND_SWITCH) % 360;
		D3DMATRIXRotateZ(&obj->matrix, (D3DVALUE)(ang * TORADIAN));
		// translate to place should be
		obj->pos.x = (D3DVALUE)0;
		obj->pos.y = (D3DVALUE)0;
		obj->pos.z = (D3DVALUE)0;
		D3DMATRIXTranslate(&obj->matrix, &obj->pos);

		ResetExtents();
		RenderObject(obj);
		UpdateExtents();
	}
    RestoreBlendState();*/

	return TRUE;
}

void TSandswirlAnimator::RefreshZBuffer()
{
	/*int size_x = 100,
		size_y = 50;
	S3DPoint effect, screen;

	((PTEffect)inst)->GetPos(effect);

	WorldToScreen(effect, screen);

	RestoreZ(screen.x - (size_x / 2), screen.y - (size_y / 2), size_x, size_y);*/
}

// ******************
// * Tornado Effect *
// ******************

DEFINE_BUILDER("Tornado", TTornadoEffect)
REGISTER_BUILDER(TTornadoEffect)

void TTornadoEffect::Initialize()
{
}

void TTornadoEffect::Pulse()
{
	TEffect::Pulse();
	if (commanddone)
		KillThisEffect();
}

// ********************
// * Tornado Animator *
// ********************

/*

This could be a cure/restore spell

#define TORNADO_MAXPARTICLES	15
#define TORNADO_DURATION		15
#define TORNADO_MODIFIER		70
#define TORNADO_MODIFIERV		30

#define _INIT_TORNADO_PARTICLE(i)  {torn[i].scl = (float)(random(10, 15) / 100.0);	\
									torn[i].dscl = (float)(random(5, 10) / 100.0);	\
									torn[i].r = (float)0.0;							\
									torn[i].dr = (float)(random(1, 10) / 100.0);	\
									torn[i].th = (float)(random(0, 359) * TORADIAN);\
									torn[i].dth = (float)(random(5, 15) / 100.0);	\
									torn[i].h = (float)0.0;							\
									torn[i].dh = (float)(random(1, 10) / 100.0);		\
									torn[i].count = random(30, 40);}

*/

#define TORNADO_MAXPARTICLES		100
#define TORNADO_DURATION			100
#define TORNADO_MODIFIER			200
#define TORNADO_MODIFIERV			100
#define TORNADO_MAXICECHUNKS		(5 * 6)
#define TORNADO_ICEGRAVITY			0.2
#define TORNADO_FLAMEUP				3
#define TORNADO_FLAMEMULTIPLIER		1
#define TORNADO_MAXFLAMES			(TORNADO_MAXICECHUNKS / 2)

REGISTER_3DANIMATOR("Tornado", TTornadoAnimator)

//==============================================================================
//    Function : Initialize.
//------------------------------------------------------------------------------
// Description : This will setup the initial state for the Tornado
//==============================================================================

void TTornadoAnimator::InitTornadoParticle(int i)
{
	torn[i].scl = (float)(random(3, 7) / 100.0);
	torn[i].dscl = (float)(random(2, 6) / 1000.0);
	torn[i].r = (float)(random(0, 359) * TORADIAN);
	torn[i].dr = (float)0;
	torn[i].th = (float)(random(0, 359) * TORADIAN);
	torn[i].dth = (float)(random(1, 3) / 100.0);
	torn[i].h = (float)(random(0, 359) * TORADIAN);
	torn[i].dh = (float)(random(3, 5) / 100.0);
	torn[i].count = random(10, 20);
}

void TTornadoAnimator::InitFlameParticle(float x, float y, float z, float vx, float vy, float vz, int sc)
{
	flame[flameon].scl = (float)(random(1, 5));
	flame[flameon].dscl = (float)(sc * random(1, 5) / 10.0);
	flame[flameon].pos.x = x;
	flame[flameon].pos.y = y;
	flame[flameon].pos.z = z;
	flame[flameon].vel.x = vx;
	flame[flameon].vel.y = vy;
	flame[flameon].vel.z = vz;
	flameon++;
	if (flameon >= TORNADO_MAXFLAMES)
		flameon = 0;
}

void TTornadoAnimator::InitIceParticle(int i)
{
	ice[i].pos.x = (float)(random(-TORNADO_MODIFIER, TORNADO_MODIFIER));
	ice[i].pos.y = (float)(random(-TORNADO_MODIFIER, TORNADO_MODIFIER));
	ice[i].pos.z = (float)TORNADO_MODIFIERV * 2;
	ice[i].vel.x = (float)(random(0, TORNADO_MODIFIER) / 100.0);
	ice[i].vel.y = (float)(random(0, TORNADO_MODIFIER) / 100.0);
	ice[i].vel.z = (float)(random(-TORNADO_MODIFIERV, -TORNADO_MODIFIERV / 2) / 25.0);
	ice[i].th.x = (float)random(0, 6);
	ice[i].th.y = (float)random(0, 6);
	ice[i].th.z = (float)random(0, 6);
	ice[i].w.x = (float)(random(-50, 50) / 100.0);
	ice[i].w.y = (float)(random(-50, 50) / 100.0);
	ice[i].w.z = (float)(random(-50, 50) / 100.0);
	ice[i].scl.x = (float)(random(50, 100) / 100.0);
	ice[i].scl.y = (float)(random(50, 100) / 100.0);
	ice[i].scl.z = (float)(random(50, 100) / 100.0);
	ice[i].time = random(0, TORNADO_DURATION);
	ice[i].stage = 0;
}

void TTornadoAnimator::Initialize()
{
	int i;
	T3DAnimator::Initialize();
	frameon = 0;
	flameon = 0;

	torn = new STornadoParticle[TORNADO_MAXPARTICLES];
	ice = new SIceChunkParticle[TORNADO_MAXICECHUNKS];
	flame = new SFlameParticle[TORNADO_MAXFLAMES];
	for (i = 0; i < TORNADO_MAXPARTICLES; i++)
	{
		InitTornadoParticle(i);
	}

	for (i = 0; i < TORNADO_MAXICECHUNKS; i++)
	{
		ice[i].time = 1;
	}
	for (i = 0; i < TORNADO_MAXICECHUNKS; i += 6) // every sixth is an ice chunk, rest splash
	{
		InitIceParticle(i);
	}

	for (i = 0; i < TORNADO_MAXFLAMES; i++)
	{
		flame[i].scl = 0;
		flame[i].dscl = 0;
	}
}

//==============================================================================
//    Function : Animate.
//------------------------------------------------------------------------------
// Description : This updates the 
//
//==============================================================================

void TTornadoAnimator::Animate(BOOL draw)
{
	T3DAnimator::Animate(draw);
	inst->SetCommandDone(FALSE);
	int i, j, k;

	frameon++;

	BOOL done = TRUE;

	if (torn == NULL || ice == NULL || flame == NULL)
		return;

	for (i = 0; i < TORNADO_MAXPARTICLES; i++)
	{
		torn[i].pos.x = TORNADO_MODIFIER * (float)cos(torn[i].r) * (float)cos(torn[i].th);// * (1 + cos(torn[i].h));
		torn[i].pos.y = TORNADO_MODIFIER * (float)cos(torn[i].r) * (float)sin(torn[i].th);// * (1 + cos(torn[i].h));
		torn[i].pos.z = TORNADO_MODIFIERV * (1 + (float)cos(torn[i].h));

		torn[i].h += torn[i].dh;
		torn[i].r += torn[i].dr;
		torn[i].th += torn[i].dth;
		torn[i].count--;
		if (torn[i].count < 0)
			torn[i].scl -= torn[i].dscl;
		else
			torn[i].scl += torn[i].dscl;

		if (torn[i].r > M_PI)
			torn[i].r = (float)M_PI;
		if (torn[i].h > M_PI)
		{
			if (frameon < TORNADO_DURATION * 2)
			{
				InitTornadoParticle(i);
			}
			else
			{
				torn[i].h = (float)M_PI;
			}
		}
		else
			done = FALSE;
		if (torn[i].scl < 0)
		{
			if (frameon < TORNADO_DURATION * 2)
			{
				InitTornadoParticle(i);
			}
			else
			{
				torn[i].scl = 0;
			}
		}
		else
			done = FALSE;
		if (torn[i].th > M_2PI)
			torn[i].th -= (float)M_2PI;
	}

	for (i = 0; i < TORNADO_MAXICECHUNKS; i += 6) // chunks, not splashes
	{
		switch (ice[i].stage)
		{
		case 0:// falling stage
			if (ice[i].time)
				ice[i].time--;
			else
			{
				ice[i].pos.x += ice[i].vel.x;
				ice[i].pos.y += ice[i].vel.y;
				ice[i].pos.z += ice[i].vel.z;

				for (k = 0; k < TORNADO_FLAMEMULTIPLIER; k++)
				{
					InitFlameParticle(ice[i].pos.x, ice[i].pos.y, ice[i].pos.z,
						(float)(ice[i].vel.x * random(1, 9) / 10.0),
						(float)(ice[i].vel.y * random(1, 9) / 10.0),
						(float)(ice[i].vel.z * random(1, 9) / 10.0 + random(1, 4)), 1);
				}
					
				ice[i].th.x += ice[i].w.x;
				if (ice[i].th.x > M_2PI)
					ice[i].th.x -= (float)M_2PI;
				ice[i].th.y += ice[i].w.y;
				if (ice[i].th.y > M_2PI)
					ice[i].th.y -= (float)M_2PI;
				ice[i].th.z += ice[i].w.z;
				if (ice[i].th.z > M_2PI)
					ice[i].th.z -= (float)M_2PI;

				ice[i].vel.z -= (float)TORNADO_ICEGRAVITY;
				done = FALSE;
			}
			if (ice[i].pos.z < 40) // hit ground, explode, flame
			{
				ice[i].time = 10;
				ice[i].stage = 1;
				for (j = 1; j < 6; j++)
				{
					ice[i + j].pos.x = (float)ice[i].pos.x;
					ice[i + j].pos.y = (float)ice[i].pos.y;
					ice[i + j].pos.z = (float)24;
					ice[i + j].vel.x = (float)(random(-TORNADO_MODIFIER, TORNADO_MODIFIER) / 50.0);
					ice[i + j].vel.y = (float)(random(-TORNADO_MODIFIER, TORNADO_MODIFIER) / 50.0);
					ice[i + j].vel.z = (float)(random(0, TORNADO_MODIFIERV) / 15.0);
					ice[i + j].th.x = (float)(random(0, 6));
					ice[i + j].th.y = (float)(random(0, 6));
					ice[i + j].th.z = (float)(random(0, 6));
					ice[i + j].w.x = (float)(random(1, 5) / 100.0);
					ice[i + j].w.y = (float)(random(1, 5) / 100.0);
					ice[i + j].w.z = (float)(random(1, 5) / 100.0);
					ice[i + j].scl.x = (float)(random(15, 35) / 100.0);
					ice[i + j].scl.y = (float)(random(15, 35) / 100.0);
					ice[i + j].scl.z = (float)(random(15, 35) / 100.0);
					ice[i + j].time = 0;
				}
				/*PTObjectInstance invoker = ((PTEffect)inst)->GetSpell()->GetInvoker();
				S3DPoint pos;
				((PTEffect)inst)->GetPos(pos);
				pos.x += (float)ice[i].vel.x;
				pos.y += (float)ice[i].vel.y;
				pos.z += (float)ice[i].vel.z;
				DamageCharactersInRange(invoker, pos, 50, 15, 25, DAMAGE_ICE);*/
			}
		break;
		case 1:// shattering, flaming stage
			if (ice[i].time)
			{
				done = FALSE;
				ice[i].time--;
				if (ice[i].time > 5)
				{
					for (k = 0; k < TORNADO_FLAMEMULTIPLIER; k++)
					{
						// flame on explosion!
						InitFlameParticle((float)(random(-10, 10) + ice[i].pos.x),
							(float)(random(-10, 10) + ice[i].pos.y),
							(float)(random(-10, 10) + ice[i].pos.z),
							(float)(ice[i].vel.x * random(1, 9) / 10.0),
							(float)(ice[i].vel.y * random(1, 9) / 10.0),
							(float)(random(4, 10)), 1);
					}
				}
			}
			else
			{
				ice[i].stage = 2;
				ice[i].time = 1;
			}
		break;
		case 2:
			// dead, reboot me stage
			if (frameon < TORNADO_DURATION * 2 - 20)
			{
				InitIceParticle(i);
				/*for (k = 0; k < TORNADO_FLAMEMULTIPLIER * 3; k++)
				{
					InitFlameParticle(ice[i].pos.x, ice[i].pos.y, ice[i].pos.z,
						(float)(ice[i].vel.x * random(1, 9) / 10.0),
						(float)(ice[i].vel.y * random(1, 9) / 10.0),
						(float)(ice[i].vel.z * random(1, 9) / 10.0), 1);
				}*/
			}
			else
			{
				ice[i].time = 1;
				ice[i].stage = 3;
			}
		break;
		}
	}

	for (i = 0; i < TORNADO_MAXICECHUNKS; i++) // skip chunks, rest splash
	{
		if (i % 6 == 0)
			continue;
		if (!ice[i].time)
		{
			ice[i].pos.x += ice[i].vel.x;
			ice[i].pos.y += ice[i].vel.y;
			ice[i].pos.z += ice[i].vel.z;
			
			ice[i].th.x += ice[i].w.x;
			if (ice[i].th.x > M_2PI)
				ice[i].th.x -= (float)M_2PI;
			ice[i].th.y += ice[i].w.y;
			if (ice[i].th.y > M_2PI)
				ice[i].th.y -= (float)M_2PI;
			ice[i].th.z += ice[i].w.z;
			if (ice[i].th.z > M_2PI)
				ice[i].th.z -= (float)M_2PI;

			ice[i].vel.z -= (float)TORNADO_ICEGRAVITY;

			if (ice[i].pos.z < 20)
				ice[i].time = TORNADO_DURATION * 2;
			else
				done = FALSE;
		}
	}

	for (i = 0; i < TORNADO_MAXFLAMES; i++)
	{
		flame[i].scl -= flame[i].dscl;
		if (flame[i].scl <= 0)
			continue;
		flame[i].pos.x += flame[i].vel.x;
		flame[i].pos.y += flame[i].vel.y;
		flame[i].pos.z += (float)(flame[i].vel.z + TORNADO_FLAMEUP);
	}

	if (frameon >= TORNADO_DURATION * 3 && done)
	{
		if (torn != NULL)
		{
			delete torn;
			torn = NULL;
		}
		if (ice != NULL)
		{
			delete ice;
			ice = NULL;
		}
		if (flame != NULL)
		{
			delete flame;
			flame = NULL;
		}
		inst->SetCommandDone(TRUE);
		((PTEffect)inst)->KillThisEffect();
	}
}

//==============================================================================
//    Function : Render.
//------------------------------------------------------------------------------
// Description : Renders tornado
//
//==============================================================================

BOOL TTornadoAnimator::Render()
{
	if (torn == NULL || ice == NULL || flame == NULL)
		return FALSE;

	SaveBlendState();
    SetAddBlendState();

	PS3DAnimObj obj;
	int i;
	
//	int num = TORNADO_MAXPARTICLES;
//	if (frameon < TORNADO_DURATION)
		//num = (int)(frameon * TORNADO_MAXPARTICLES / TORNADO_DURATION);
//	if (frameon > TORNADO_DURATION * 2)
		//num = (int)((TORNADO_DURATION * 3 - frameon) * TORNADO_MAXPARTICLES / TORNADO_DURATION);

	ResetExtents();
	obj = GetObject(0);
	for (i = 0; i < TORNADO_MAXFLAMES; i++)
	{
		if (flame[i].scl <= 0)
			continue;

		obj->flags = OBJ3D_MATRIX;
		D3DMATRIXClear(&obj->matrix);		
				
		obj->scl.x = (D3DVALUE)(flame[i].scl);
		obj->scl.y = (D3DVALUE)(flame[i].scl);
		obj->scl.z = (D3DVALUE)(flame[i].scl);
		D3DMATRIXScale(&obj->matrix, &obj->scl);
		// rotate to face screen
		D3DMATRIXRotateX(&obj->matrix, -(float)(M_PI / 2.0));
		D3DMATRIXRotateX(&obj->matrix, -(float)(M_PI / 6.0));
		D3DMATRIXRotateZ(&obj->matrix, -(float)(M_PI / 4.0));
		D3DMATRIXRotateZ(&obj->matrix, D3DVAL(-((inst->GetFace() * 360) / 256) * TORADIAN));
		// translate to place should be
		obj->pos.x = (D3DVALUE)flame[i].pos.x;
		obj->pos.y = (D3DVALUE)flame[i].pos.y;
		obj->pos.z = (D3DVALUE)flame[i].pos.z;
		D3DMATRIXTranslate(&obj->matrix, &obj->pos);

		RenderObject(obj);
	}
	UpdateExtents();

	SetBlendState();

	obj = GetObject(2);
	for (i = 0; i < TORNADO_MAXPARTICLES; i++)
	{
		obj->flags = OBJ3D_MATRIX;
		D3DMATRIXClear(&obj->matrix);		
				
		obj->scl.x = (D3DVALUE)(torn[i].scl);
		obj->scl.y = (D3DVALUE)(torn[i].scl);
		obj->scl.z = (D3DVALUE)(torn[i].scl);
		D3DMATRIXScale(&obj->matrix, &obj->scl);
		// rotate to face screen
		D3DMATRIXRotateX(&obj->matrix, -(float)(M_PI / 2.0));
		D3DMATRIXRotateX(&obj->matrix, -(float)(M_PI / 6.0));
		D3DMATRIXRotateZ(&obj->matrix, -(float)(M_PI / 4.0));
		D3DMATRIXRotateZ(&obj->matrix, D3DVAL(-((inst->GetFace() * 360) / 256) * TORADIAN));
		// translate to place should be
		obj->pos.x = (D3DVALUE)torn[i].pos.x;
		obj->pos.y = (D3DVALUE)torn[i].pos.y;
		obj->pos.z = (D3DVALUE)torn[i].pos.z;
		D3DMATRIXTranslate(&obj->matrix, &obj->pos);

		ResetExtents();
		RenderObject(obj);
		UpdateExtents();
	}

	for (i = 0; i < TORNADO_MAXICECHUNKS; i++)
	{
		if (ice[i].time || ice[i].stage)
			continue;
		if (i % 6 == 0)
			obj = GetObject(3);
		else
			obj = GetObject(1);

		obj->flags = OBJ3D_MATRIX;
		D3DMATRIXClear(&obj->matrix);		
				
		obj->scl.x = (D3DVALUE)(ice[i].scl.x);
		obj->scl.y = (D3DVALUE)(ice[i].scl.y);
		obj->scl.z = (D3DVALUE)(ice[i].scl.z);
		D3DMATRIXScale(&obj->matrix, &obj->scl);
		// rotate to face screen
		D3DMATRIXRotateX(&obj->matrix, ice[i].th.x);
		D3DMATRIXRotateY(&obj->matrix, ice[i].th.y);
		D3DMATRIXRotateZ(&obj->matrix, ice[i].th.z);
		// translate to place should be
		obj->pos.x = (D3DVALUE)ice[i].pos.x;
		obj->pos.y = (D3DVALUE)ice[i].pos.y;
		obj->pos.z = (D3DVALUE)ice[i].pos.z;
		D3DMATRIXTranslate(&obj->matrix, &obj->pos);

		ResetExtents();
		RenderObject(obj);
		UpdateExtents();
	}

	RestoreBlendState();

	return TRUE;
}

void TTornadoAnimator::RefreshZBuffer()
{
	int size_x = 640,
		size_y = 480;
	S3DPoint effect, screen;

	((PTEffect)inst)->GetPos(effect);

	WorldToScreen(effect, screen);

	RestoreZ(screen.x - (size_x / 2), screen.y - (size_y / 2), size_x, size_y);
	/*for (i = 0; i < TORNADO_MAXFLAMES; i++)
	{
		if (flame[i].scl <= 0)
			continue;
	}*/
}

// ******************
// * Streamer Effect *
// ******************

DEFINE_BUILDER("Streamer", TStreamerEffect)
REGISTER_BUILDER(TStreamerEffect)

void TStreamerEffect::Initialize()
{
}

void TStreamerEffect::Pulse()
{
	TEffect::Pulse();
}

// ********************
// * Streamer Animator *
// ********************

#define STREAMER_MAXPARTICLES	80
#define STREAMER_SECONDS		30
#define STREAMER_DURATION		(24 * STREAMER_SECONDS)
#define STREAMER_MODIFIER		40
#define STREAMER_MODIFIERV		40
#define STREAMER_SKIP			1

REGISTER_3DANIMATOR("Streamer", TStreamerAnimator)

//==============================================================================
//    Function : Initialize.
//------------------------------------------------------------------------------
// Description : This will setup the initial state for the Tornado
//==============================================================================

/*
if (h <= M_PI)
	modif = (float)(sqrt((M_PI * M_PI) - ((2.0 * h - M_PI) * (2.0 * h - M_PI))) / M_PI);
else
	modif = (float)(sqrt((M_PI * M_PI) - ((2.0 * (h - M_PI) - M_PI) * (2.0 * (h - M_PI) - M_PI))) / M_PI);

// good sphere
float modif = (float)0.5 * (1 + cos(2.0 * h + M_PI));\
*/

void TStreamerAnimator::InitStreamer(int x)
{
	D3DVECTOR pos;
	float modif = (float)(0.5 * (1 + cos(2.0 * h[x] + M_PI)));
	pos.x = (float)(STREAMER_MODIFIER * cos(th[x]) * modif * (x + 1) / STREAMER_MAXSTREAMS);
	pos.y = (float)(STREAMER_MODIFIER * sin(th[x]) * modif * (x + 1) / STREAMER_MAXSTREAMS);
	pos.z = (float)(STREAMER_MODIFIERV * (cos(h[x]) + 1));
	h[x] += dh[x];
	if (h[x] > M_PI)
	{
		h[x] -= (float)M_PI;
		if (frameon > STREAMER_DURATION)
			done++;
	}
	th[x] += dth[x];
	if (th[x] > M_2PI)
		th[x] -= (float)M_2PI;
	AddStreamer(x, pos, (float)(scl[x] * (0.0 + 1.0 * modif)));

	h[x] += (float)(M_PI / 2.0);
	if (h[x] > M_PI)
		h[x] -= (float)M_PI;

	modif = (float)(0.5 * (1 + cos(2.0 * h[x] + M_PI)));
	pos.x = (float)(STREAMER_MODIFIER * cos(th[x]) * modif * (x + 1) / STREAMER_MAXSTREAMS);
	pos.y = (float)(STREAMER_MODIFIER * sin(th[x]) * modif * (x + 1) / STREAMER_MAXSTREAMS);
	pos.z = (float)(STREAMER_MODIFIERV * (cos(h[x]) + 1));
	AddStreamer(x, pos, (float)(scl[x] * (0.0 + 1.0 * modif)));

	h[x] += (float)(M_PI / 2.0);
	if (h[x] > M_PI)
		h[x] -= (float)M_PI;
}

void TStreamerAnimator::Initialize()
{
	int i, j;
	T3DAnimator::Initialize();
	frameon = 0;

	done = FALSE;
	
	PTObjectInstance caster = ((PTEffect)inst)->GetSpell()->GetInvoker();
	caster->GetPos(origpos);
		
	for (j = 0; j < STREAMER_MAXSTREAMS; j++)
	{
		scl[j] = (float)0.5 * (j + 1);
		dscl[j] = (float)(scl[j] / STREAMER_MAXPARTICLES);
		h[j] = (float)0;//(M_PI * j / STREAMER_MAXSTREAMS);
		dh[j] = (float)0.03 / (4 - j);
		th[j] = (float)0;//(M_2PI * j / STREAMER_MAXSTREAMS);
		dth[j] = (float)0.3;
		stream[j] = new SStreamerParticle[STREAMER_MAXPARTICLES];
		for (i = 0; i < STREAMER_MAXPARTICLES; i++)
		{
			stream[j][i].count = 0;
		}

		/*for (i = 0; i < STREAMER_MAXPARTICLES; i++)
		{
			InitStreamer(j);
		}*/
	}
}

void TStreamerAnimator::AddStreamer(int num, D3DVECTOR pos, D3DVALUE scl)
{
	if (stream[num] == NULL)
		return;

	int p = -1, i;
	if (!done)
	{
		for (i = 0; i < STREAMER_MAXPARTICLES; i++)
		{
			if (stream[num][i].count <= 0)
				p = i;
		}
		if (p > -1)
		{
			stream[num][p].pos.x = pos.x;
			stream[num][p].pos.y = pos.y;
			stream[num][p].pos.z = pos.z;
			stream[num][p].scl = scl;
			stream[num][p].count = STREAMER_MAXPARTICLES;
		}
	}
	for (i = 0; i < STREAMER_MAXPARTICLES; i++)
	{
		stream[num][i].count--;
		stream[num][i].scl -= dscl[num];
	}
}

//==============================================================================
//    Function : Animate.
//------------------------------------------------------------------------------
// Description : This updates the 
//
//==============================================================================

void TStreamerAnimator::Animate(BOOL draw)
{
	T3DAnimator::Animate(draw);
	inst->SetCommandDone(FALSE);
	
	frameon++;

	int i, j;
	for (j = 0; j < STREAMER_MAXSTREAMS; j++)
	{
		for (i = 0; i < STREAMER_SKIP * (4 - j); i++)
		{
			InitStreamer(j);
		}
	}

	if (done)
		done++;
	if (frameon > STREAMER_DURATION && done >= (STREAMER_MAXPARTICLES * STREAMER_MAXPARTICLES * STREAMER_MAXSTREAMS))
	{
		for (j = 0; j < STREAMER_MAXSTREAMS; j++)
		{
			delete stream[j];
			stream[j] = NULL;
		}
		inst->SetCommandDone(TRUE);
	}
}

//==============================================================================
//    Function : Render.
//------------------------------------------------------------------------------
// Description : Renders streamers
//
//==============================================================================

BOOL TStreamerAnimator::Render()
{
	if (stream[0] == NULL || stream[1] == NULL || stream[2] == NULL || stream[3] == NULL)
		return FALSE;

	SaveBlendState();
    SetAddBlendState();

	PS3DAnimObj obj;
	int i, j;

	S3DPoint invokepos, movetopos;
	PTObjectInstance caster = ((PTEffect)inst)->GetSpell()->GetInvoker();
	caster->GetPos(invokepos);

	movetopos.x = invokepos.x - origpos.x;
	movetopos.y = invokepos.y - origpos.y;
	movetopos.z = invokepos.z - origpos.z;
	
	for (j = 0; j < STREAMER_MAXSTREAMS; j++)
	{
		obj = GetObject(j);
		for (i = 0; i < STREAMER_MAXPARTICLES; i++)
		{
			if (stream[j][i].count <= 0 || stream[j][i].scl <= 0)
				continue;
			obj->flags = OBJ3D_MATRIX;
			D3DMATRIXClear(&obj->matrix);		
					
			obj->scl.x = (D3DVALUE)(stream[j][i].scl);
			obj->scl.y = (D3DVALUE)(stream[j][i].scl);
			obj->scl.z = (D3DVALUE)(stream[j][i].scl);
			D3DMATRIXScale(&obj->matrix, &obj->scl);
			// rotate to face screen
			D3DMATRIXRotateX(&obj->matrix, -(float)(M_PI / 2.0));
			D3DMATRIXRotateX(&obj->matrix, -(float)(M_PI / 6.0));
			D3DMATRIXRotateZ(&obj->matrix, -(float)(M_PI / 4.0));
			D3DMATRIXRotateZ(&obj->matrix, D3DVAL(-((inst->GetFace() * 360) / 256) * TORADIAN));
			// translate to place should be
			obj->pos.x = (D3DVALUE)stream[j][i].pos.x + movetopos.x;
			obj->pos.y = (D3DVALUE)stream[j][i].pos.y + movetopos.y;
			obj->pos.z = (D3DVALUE)stream[j][i].pos.z + movetopos.z;
			D3DMATRIXTranslate(&obj->matrix, &obj->pos);

			ResetExtents();
			RenderObject(obj);
			UpdateExtents();
		}
	}
	RestoreBlendState();

	return TRUE;
}

void TStreamerAnimator::RefreshZBuffer()
{
	int size_x = STREAMER_MODIFIER * 2 * STREAMER_MAXSTREAMS,
		size_y = STREAMER_MODIFIERV * 2 * STREAMER_MAXSTREAMS;
	S3DPoint effect, screen;
	S3DPoint invokepos, movetopos;
	PTObjectInstance caster = ((PTEffect)inst)->GetSpell()->GetInvoker();
	caster->GetPos(invokepos);

	movetopos.x = invokepos.x - origpos.x;
	movetopos.y = invokepos.y - origpos.y;
	movetopos.z = invokepos.z - origpos.z;

	((PTEffect)inst)->GetPos(effect);

	effect.x += movetopos.x;
	effect.y += movetopos.y;
	effect.z += movetopos.z;

	WorldToScreen(effect, screen);

	RestoreZ(screen.x - (size_x / 2), screen.y + 20 - (size_y / 2), size_x, size_y);
}

// ******************
// * FireSwarm Effect *
// ******************

DEFINE_BUILDER("FireSwarm", TFireSwarmEffect)
REGISTER_BUILDER(TFireSwarmEffect)

void TFireSwarmEffect::Initialize()
{
}

void TFireSwarmEffect::Pulse()
{
	TEffect::Pulse();
}

// ********************
// * FireSwarm Animator *
// ********************

#define FIRESWARM_DURATION		75
#define FIRESWARM_CYLHSCLSTEP	0.4
#define FIRESWARM_CYLTHSTEP		0.5
#define FIRESWARM_CYLVSCLINIT	30
#define FIRESWARM_CYLVSCLSTEP	0.4

REGISTER_3DANIMATOR("FireSwarm", TFireSwarmAnimator)

//==============================================================================
//    Function : Initialize.
//------------------------------------------------------------------------------
// Description : This will setup the initial state for the FireSwarm
//==============================================================================

void TFireSwarmAnimator::Initialize()
{
	T3DAnimator::Initialize();
	frameon = 0;
	cylth = (float)0;
	cylhscl = (float)FIRESWARM_CYLHSCLSTEP;
	cylvscl = (float)FIRESWARM_CYLVSCLINIT;
}

//==============================================================================
//    Function : Animate.
//------------------------------------------------------------------------------
// Description : This updates the FireSwarm
//
//==============================================================================

void TFireSwarmAnimator::Animate(BOOL draw)
{
	T3DAnimator::Animate(draw);
	inst->SetCommandDone(FALSE);
	
	frameon++;

	cylth += (float)FIRESWARM_CYLTHSTEP;
	if (cylth > M_2PI)
		cylth -= (float)M_2PI;
	cylhscl += (float)FIRESWARM_CYLHSCLSTEP;
	cylvscl -= (float)FIRESWARM_CYLVSCLSTEP;
	if (frameon > FIRESWARM_DURATION)
	{

		inst->SetCommandDone(TRUE);
	}
}

//==============================================================================
//    Function : Render.
//------------------------------------------------------------------------------
// Description : Renders FireSwarm
//
//==============================================================================

BOOL TFireSwarmAnimator::Render()
{
	SaveBlendState();
    SetBlendState();

	PS3DAnimObj obj;
		
	obj = GetObject(1);
	obj->flags = OBJ3D_MATRIX;
			D3DMATRIXClear(&obj->matrix);		
					
	obj->scl.x = (D3DVALUE)(cylhscl);
	obj->scl.y = (D3DVALUE)(cylhscl);
	obj->scl.z = (D3DVALUE)(cylvscl);
	D3DMATRIXScale(&obj->matrix, &obj->scl);
	// rotate to face screen
	D3DMATRIXRotateZ(&obj->matrix, cylth);

	ResetExtents();
	RenderObject(obj);
	UpdateExtents();
		
	RestoreBlendState();

	return TRUE;
}

void TFireSwarmAnimator::RefreshZBuffer()
{
	int size_x = 50,
		size_y = 50;
	S3DPoint effect, screen;

	((PTEffect)inst)->GetPos(effect);

	WorldToScreen(effect, screen);

	//RestoreZ(screen.x - (size_x / 2), screen.y + 20 - (size_y / 2), size_x, size_y);
}

// ******************
// * Halo Effect *
// ******************

DEFINE_BUILDER("Halo", THaloEffect)
REGISTER_BUILDER(THaloEffect)

void THaloEffect::Initialize()
{
}

void THaloEffect::Pulse()
{
	TEffect::Pulse();
}

// ********************
// * Halo Animator *
// ********************

REGISTER_3DANIMATOR("Halo", THaloAnimator)

//==============================================================================
//    Function : Initialize.
//------------------------------------------------------------------------------
// Description : This will setup the initial state for the Halo
//==============================================================================

void THaloAnimator::Initialize()
{
	T3DAnimator::Initialize();
	haloscale = (float)0;
}

//==============================================================================
//    Function : Animate.
//------------------------------------------------------------------------------
// Description : This updates the FireSwarm
//
//==============================================================================

void THaloAnimator::Animate(BOOL draw)
{
	int totframes = ((PTHaloEffect)inst)->GetTotalFrames();
	float halostep = ((PTHaloEffect)inst)->GetHaloStep();
	T3DAnimator::Animate(draw);
	inst->SetCommandDone(FALSE);
	
	if (frameon < totframes / 2)
		haloscale += halostep;
	else
		haloscale -= halostep;
	frameon++;

	if (frameon > totframes)
	{

		inst->SetCommandDone(TRUE);
	}
}

//==============================================================================
//    Function : Render.
//------------------------------------------------------------------------------
// Description : Renders FireSwarm
//
//==============================================================================

BOOL THaloAnimator::Render()
{
	SaveBlendState();
    SetAddBlendState();

	PS3DAnimObj obj = GetObject(0);

	if (haloscale > 0)
	{
		ResetExtents();
		// clear matrix and get ready to transform and render
		D3DMATRIXClear(&obj->matrix);
		obj->flags = OBJ3D_MATRIX;
		// scale to size of spark
		obj->scl.x = obj->scl.y = obj->scl.z = (D3DVALUE)haloscale;
		D3DMATRIXScale(&obj->matrix, &obj->scl);
		// rotate to face screen
		D3DMATRIXRotateX(&obj->matrix, -(float)(M_PI / 2.0));
		//D3DMATRIXRotateX(&obj->matrix, -(float)(M_PI / 6.0));
		D3DMATRIXRotateZ(&obj->matrix, -(float)(M_PI / 4.0));
		// translate to place should be
		obj->pos.x = (D3DVALUE)-5.0f;
		obj->pos.y = (D3DVALUE)-5.0f;
		obj->pos.z = (D3DVALUE)5.0f;
		D3DMATRIXTranslate(&obj->matrix, &obj->pos);
		// fix for direction
		D3DMATRIXRotateZ(&obj->matrix, D3DVAL(-((inst->GetFace() * 360) / 256) * TORADIAN));
		//D3DMATRIXRotateY(&obj->matrix, (float)(M_PI / 8.0));
		RenderObject(obj);
		UpdateExtents();
	}
		
	RestoreBlendState();

	return TRUE;
}

void THaloAnimator::RefreshZBuffer()
{
	int size_x = (int)(haloscale * 20),
		size_y = (int)(haloscale * 20);
	S3DPoint effect, screen;

	((PTEffect)inst)->GetPos(effect);

	WorldToScreen(effect, screen);

	RestoreZ(screen.x - (size_x / 2), screen.y + 20 - (size_y / 2), size_x, size_y);
}

// *****************
// * Ripple Effect *
// *****************

DEFINE_BUILDER("Ripple", TRippleEffect)
REGISTER_BUILDER(TRippleEffect)

void TRippleEffect::Initialize()
{
}

void TRippleEffect::Pulse()
{
	TEffect::Pulse();
}

// *******************
// * Ripple Animator *
// *******************

#define RIPPLE_SMALLDURATION	36
#define RIPPLE_GRAVITY			0.37

REGISTER_3DANIMATOR("Ripple", TRippleAnimator)

//==============================================================================
//    Function : Initialize.
//------------------------------------------------------------------------------
// Description : This will setup the initial state for the Ripple Effect
//==============================================================================

void TRippleAnimator::Initialize()
{
	T3DAnimator::Initialize();
	frameon = 0;
	ripframe = 0;
	scale = (float)0.5;
	length = ((PTRippleEffect)inst)->GetLength();
	
	PS3DAnimObj o = GetObject(0);
    GetVerts(o, D3DVT_LVERTEX);

	hassplashed = FALSE;
	numdrops = 0;
}

//==============================================================================
//    Function : Animate.
//------------------------------------------------------------------------------
// Description : This updates the Ripple
//
//==============================================================================

void TRippleAnimator::AddNewRipple(int x, int y, int z, int len)
{
	SObjectDef def;
	memset(&def, 0, sizeof(SObjectDef));
	def.objclass = OBJCLASS_EFFECT;
	def.objtype = -1;
	def.level = MapPane.GetMapLevel();

	PTEffect effect;
	def.pos.x = x;
	def.pos.y = y;
	def.pos.z = z;
	def.objtype = EffectClass.FindObjType("ripple");
	def.facing = 0;

	effect = (PTEffect)MapPane.GetInstance(MapPane.NewObject(&def));
	effect->SetSpell(((PTEffect)inst)->GetSpell());
	if (effect)
		((PTRippleEffect)effect)->SetLength(len);
}

void TRippleAnimator::Animate(BOOL draw)
{
	T3DAnimator::Animate(draw);
	inst->SetCommandDone(FALSE);
	S3DPoint pos;
	((PTEffect)inst)->GetPos(pos);
	int i;

	frameon++;
	if (frameon % 4 == 0)
	{
		if (frameon <= length - 48)
		{
			ripframe++;
			if (ripframe == 4)
				ripframe = 0;
		}
		else
		{
			if (frameon > length - 48 && ripframe < 4)
			{
				ripframe = 4;
			}
			else
			{
				ripframe++;
				if (ripframe > 15)
					ripframe = 15;
			}
		}
	}
	scale += (float)(1.0 / 16.0);
	
	if (frameon > length)
	{
		inst->SetFlags(OF_KILL);  // Causes object to commit suicide
	}

	if (!hassplashed && length > RIPPLE_SMALLDURATION)
	{
		hassplashed = TRUE;
		numdrops = random(2, 3);
		drops = new SDropParticle[numdrops];

		for (i = 0; i < numdrops; i++)
		{
			drops[i].vel.x = (float)(random(-length, length) / 32.0);
			drops[i].vel.y = (float)(random(-length, length) / 32.0);
			drops[i].vel.z = (float)(random(length / 2, length) / 20.0);
			drops[i].pos.x = 0;
			drops[i].pos.y = 0;
			drops[i].pos.z = 5;
			drops[i].dead = FALSE;
		}
	}
	if (hassplashed)
	{
		for (i = 0; i < numdrops; i++)
		{
			if (drops[i].dead)
				continue;
			drops[i].pos.x += drops[i].vel.x;
			drops[i].pos.y += drops[i].vel.y;
			drops[i].pos.z += drops[i].vel.z;
			drops[i].vel.z -= (float)RIPPLE_GRAVITY;
			if (drops[i].pos.z <= 0)
			{
				AddNewRipple(int(drops[i].pos.x + pos.x), int(drops[i].pos.y + pos.y),
					int(pos.z), (int)(3 * length / 4));
				drops[i].dead = TRUE;
			}
		}
	}
}

//==============================================================================
//    Function : Render.
//------------------------------------------------------------------------------
// Description : Renders quicksand
//
//==============================================================================

void TRippleAnimator::SetAnimFrame(int frame_num, PS3DAnimObj obj)
{
	if (!obj->lverts)
		return;
	float u = (float)(frame_num % 4) * .25f;
	float v = (float)(frame_num / 4) * .25f;

	obj->flags |= OBJ3D_VERTS;

	obj->lverts[0].tu = u;
	obj->lverts[0].tv = v;
	
	obj->lverts[2].tu = u + .25f;
	obj->lverts[2].tv = v;


	obj->lverts[1].tu = u;
	obj->lverts[1].tv = v + .25f;

	obj->lverts[3].tu = u + .25f;
	obj->lverts[3].tv = v + .25f;
}

char rippleframeof[16] = {3, 2, 1, 0, 7, 6, 5, 4, 11, 10, 9, 8, 15, 14, 13, 12 };

BOOL TRippleAnimator::Render()
{
	SaveBlendState();
    SetBlendState();

	PS3DAnimObj obj;
	// render ripple
	obj = GetObject(0);

	if (scale > 0)
	{
		// clear matrix and get ready to transform and render
		obj->flags = OBJ3D_MATRIX;
		D3DMATRIXClear(&obj->matrix);		
		// set frame
		SetAnimFrame(rippleframeof[15 - ripframe], obj);
		
		obj->scl.x = (D3DVALUE)(scale);
		obj->scl.y = (D3DVALUE)(scale);
		obj->scl.z = 1.0;
		D3DMATRIXScale(&obj->matrix, &obj->scl);
		// rotate to face correct way
		
		// translate to place should be
		obj->pos.x = (D3DVALUE)0;
		obj->pos.y = (D3DVALUE)0;
		obj->pos.z = (D3DVALUE)0;
		D3DMATRIXTranslate(&obj->matrix, &obj->pos);

		ResetExtents();
		RenderObject(obj);
		UpdateExtents();
	}

	if (hassplashed)
	{
		obj = GetObject(1);
		for (int i = 0; i < numdrops; i++)
		{
			if (drops[i].dead)
				continue;
			// clear matrix and get ready to transform and render
			obj->flags = OBJ3D_MATRIX;
			D3DMATRIXClear(&obj->matrix);		
						
			obj->scl.x = (D3DVALUE)(0.3);
			obj->scl.y = (D3DVALUE)(0.3);
			obj->scl.z = (D3DVALUE)(0.3);
			D3DMATRIXScale(&obj->matrix, &obj->scl);
			// rotate to face correct way
			
			// translate to place should be
			obj->pos.x = (D3DVALUE)drops[i].pos.x;
			obj->pos.y = (D3DVALUE)drops[i].pos.y;
			obj->pos.z = (D3DVALUE)drops[i].pos.z;
			D3DMATRIXTranslate(&obj->matrix, &obj->pos);

			ResetExtents();
			RenderObject(obj);
			UpdateExtents();			
		}
	}

    RestoreBlendState();

	return TRUE;
}

void TRippleAnimator::RefreshZBuffer()
{
	int size_x = int(50 * scale),
		size_y = int(25 * scale);
	S3DPoint effect, screen;

	((PTEffect)inst)->GetPos(effect);

	WorldToScreen(effect, screen);

	RestoreZ(screen.x - (size_x / 2), screen.y - (size_y / 2), size_x, size_y);
}

// ***************
// * Drip Effect *
// ***************

DEFINE_BUILDER("Drip", TDripEffect)
REGISTER_BUILDER(TDripEffect)

void TDripEffect::Initialize()
{
}

void TDripEffect::Pulse()
{
	TEffect::Pulse();
}

// *****************
// * Drip Animator *
// *****************

#define DRIP_FREQUENCY	48
#define DRIP_HEIGHT		128

REGISTER_3DANIMATOR("Drip", TDripAnimator)

//==============================================================================
//    Function : Initialize.
//------------------------------------------------------------------------------
// Description : This will setup the initial state for the Drip Effect
//==============================================================================

void TDripAnimator::Initialize()
{
	T3DAnimator::Initialize();
	dead = TRUE;
}

//==============================================================================
//    Function : Animate.
//------------------------------------------------------------------------------
// Description : This updates the Ripple
//
//==============================================================================

void TDripAnimator::AddNewRipple(int x, int y, int z, int len)
{
	SObjectDef def;
	memset(&def, 0, sizeof(SObjectDef));
	def.objclass = OBJCLASS_EFFECT;
	def.objtype = -1;
	def.level = MapPane.GetMapLevel();

	PTEffect effect;
	def.pos.x = x;
	def.pos.y = y;
	def.pos.z = z;
	def.objtype = EffectClass.FindObjType("ripple");
	def.facing = 0;

	effect = (PTEffect)MapPane.GetInstance(MapPane.NewObject(&def));
	//effect->SetSpell(((PTEffect)inst)->GetSpell());
	if (effect)
		((PTRippleEffect)effect)->SetLength(len);
}

void TDripAnimator::Animate(BOOL draw)
{
	T3DAnimator::Animate(draw);
	inst->SetCommandDone(FALSE);
	S3DPoint effectpos;
	((PTEffect)inst)->GetPos(effectpos);
	
	if (dead)
	{
		if (!random(0, DRIP_FREQUENCY))
		{
			vel.x = 0.0f;
			vel.y = 0.0f;
			vel.z = -(float)(RIPPLE_GRAVITY * 5);
			pos.x = 0;
			pos.y = 0;
			pos.z = DRIP_HEIGHT;
			dead = FALSE;
		}
	}
	if (!dead)
	{
		pos.x += vel.x;
		pos.y += vel.y;
		pos.z += vel.z;
		vel.z -= (float)RIPPLE_GRAVITY;
		if (pos.z <= 0)
		{
			AddNewRipple(int(pos.x + effectpos.x), int(pos.y + effectpos.y),
				int(effectpos.z), 64);
			dead = TRUE;
		}
	}
}

//==============================================================================
//    Function : Render.
//------------------------------------------------------------------------------
// Description : Renders Drip
//
//==============================================================================

BOOL TDripAnimator::Render()
{
	SaveBlendState();
    SetBlendState();

	PS3DAnimObj obj;
	
	if (!dead)
	{
		obj = GetObject(0);
		// clear matrix and get ready to transform and render
		obj->flags = OBJ3D_MATRIX;
		D3DMATRIXClear(&obj->matrix);		
					
		obj->scl.x = (D3DVALUE)(0.3);
		obj->scl.y = (D3DVALUE)(0.3);
		obj->scl.z = (D3DVALUE)(0.3);
		D3DMATRIXScale(&obj->matrix, &obj->scl);
		// rotate to face correct way
		
		// translate to place should be
		obj->pos.x = (D3DVALUE)pos.x;
		obj->pos.y = (D3DVALUE)pos.y;
		obj->pos.z = (D3DVALUE)pos.z;
		D3DMATRIXTranslate(&obj->matrix, &obj->pos);

		ResetExtents();
		RenderObject(obj);
		UpdateExtents();
	}

    RestoreBlendState();

	return TRUE;
}

void TDripAnimator::RefreshZBuffer()
{
	int size_x = 10,
		size_y = DRIP_HEIGHT + 10;
	S3DPoint effect, screen;

	((PTEffect)inst)->GetPos(effect);

	WorldToScreen(effect, screen);

	RestoreZ(screen.x - (size_x / 2), screen.y - size_y, size_x, size_y);
}// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *             effectcomp.cpp - Effect components module                 *
// *************************************************************************

#include <ddraw.h>
#include <d3d.h>
#include <d3drmwin.h>
#include <math.h>
#include "d3dmacs.h"
#include "d3dmath.h"

#include "revenant.h"
#include "effect.h"
#include "mappane.h"	   
#include "character.h"
#include "statusbar.h"
#include "MissileEffect.H"
#include "StripEffect.H"
#include "effectcomp.h"

// ******************
// * Storm Animator *
// ******************

void TStormAnimator::Init(PT3DAnimator anim, PS3DAnimObj o)
{
	// animation vars
	animator = anim;
	obj = o;
	animator->GetVerts(o, D3DVT_LVERTEX);

	for(int i = 0; i < size; ++i)
		storm_instance[i].used = FALSE;

	// init it!
	memset(&params, 0, sizeof(params));
}

// count up the existing particles
int TStormAnimator::GetCount()
{
	int count = 0;
	for(int i = 0; i < size; ++i)
	{
		if(storm_instance[i].used)
			++count;
	}
	return count;
}

// set the parameters
void TStormAnimator::Set(PSStormParams nparams)
{
	if(nparams->particles > size)
		nparams->particles = size;
	// do the copy!, kinna like the hustle but better
	memcpy(&params, nparams, sizeof(params));
}

// get the parameters
void TStormAnimator::Get(PSStormParams nparams)
{
	memcpy(nparams, &params, sizeof(params));
}

// create new instances
void TStormAnimator::Create()
{
	int i=0;
	// create all necessary particles
	while(GetCount() < params.particles)
	{
		if(storm_instance[i].used)
		{
			i++;
			continue;
		}
		// found a instance to be created
		storm_instance[i].used = TRUE;
		storm_instance[i].pos.x = params.pos.x + random(-(int)params.pos_spread.x, (int)params.pos_spread.x);
		storm_instance[i].pos.y = params.pos.y + random(-(int)params.pos_spread.y, (int)params.pos_spread.y);
		storm_instance[i].pos.z = params.pos.z + random(-(int)params.pos_spread.z, (int)params.pos_spread.z);
		storm_instance[i].is_particle = TRUE;
		storm_instance[i].velocity.x = params.velocity.x;
		storm_instance[i].velocity.y = params.velocity.y;
		storm_instance[i].velocity.z = params.velocity.z * ((float)random(100,150) / 100.0f);
		storm_instance[i].gravity = params.gravity;
		storm_instance[i].frame = (float)params.particle_begin;
		storm_instance[i].particle_frame_inc = params.particle_frame_inc;
		storm_instance[i].impact_frame_inc = params.impact_frame_inc;
		storm_instance[i].part_scl.x = params.particle_scale.x * ((float)random(50,150) / 100.0f);
		storm_instance[i].part_scl.y = params.particle_scale.y;
		storm_instance[i].part_scl.z = params.particle_scale.z;
		storm_instance[i].expl_scl.x = params.impact_scale.x * ((float)random(50,150) / 100.0f);
		storm_instance[i].expl_scl.y = params.impact_scale.y;
		storm_instance[i].expl_scl.z = params.impact_scale.z;
		storm_instance[i].explosion_sounded = FALSE;
		//PLAY("meteor fall");
		i++;
	}
}

void TStormAnimator::Animate()
{	
	D3DVECTOR new_pos;
	S3DPoint point;

	// run through existing particles
	for(int i = 0; i < size; ++i)
	{
		if(!storm_instance[i].used)
			continue;

		if(storm_instance[i].is_particle)
		{
			new_pos.x = storm_instance[i].pos.x + storm_instance[i].velocity.x;
			new_pos.y = storm_instance[i].pos.y + storm_instance[i].velocity.y;
			new_pos.z = storm_instance[i].pos.z + storm_instance[i].velocity.z;

			point.x = (int)new_pos.x;
			point.y = (int)new_pos.y;
			point.z = (int)new_pos.z; 
			int height = MapPane.GetWalkHeight(point);

			if(height >= (int)new_pos.z)
			{
				storm_instance[i].frame = (float)params.impact_begin;
				storm_instance[i].is_particle = FALSE;
			}
			else
			{
				storm_instance[i].pos.x = new_pos.x;
				storm_instance[i].pos.y = new_pos.y;
				storm_instance[i].pos.z = new_pos.z;
				storm_instance[i].velocity.z -= storm_instance[i].gravity;
				storm_instance[i].frame += storm_instance[i].particle_frame_inc;
				if(storm_instance[i].frame >= params.particle_end)
					storm_instance[i].frame -= (params.particle_end - params.particle_begin);
			}
		}
		else
		{
			if((int)storm_instance[i].frame >= params.impact_end)
				storm_instance[i].used = FALSE;
			else
				storm_instance[i].frame += storm_instance[i].impact_frame_inc;
		}
	}
	// create new particles
	Create();
}

void TStormAnimator::Render()
{
	for(int i = 0; i < size; ++i)
	{
		if(!storm_instance[i].used)
			continue;

		animator->ResetExtents();

		// start it out!
		obj->flags = OBJ3D_MATRIX | OBJ3D_ABSPOS | OBJ3D_VERTS;
		D3DMATRIXClear(&obj->matrix);

		// facing offset rotation
		if(storm_instance[i].is_particle)
		{
			
			D3DMATRIXRotateZ(&obj->matrix, D3DVAL(-45 * TORADIAN));		//-45
			D3DMATRIXRotateX(&obj->matrix, D3DVAL(0 * TORADIAN));		//0
			D3DMATRIXRotateY(&obj->matrix, D3DVAL(-90 * TORADIAN));		//-45
			
		}
		else
		{
			D3DMATRIXRotateZ(&obj->matrix, D3DVAL(0 * TORADIAN));		//0
			D3DMATRIXRotateX(&obj->matrix, D3DVAL(90 * TORADIAN));		//120
			D3DMATRIXRotateY(&obj->matrix, D3DVAL(0 * TORADIAN));		//0
		}

		// scaling
		if(storm_instance[i].is_particle)
		{
			obj->scl.x = storm_instance[i].part_scl.x;
			obj->scl.y = storm_instance[i].part_scl.y;
			obj->scl.z = storm_instance[i].part_scl.z;
		}
		else
		{
			obj->scl.x = storm_instance[i].expl_scl.x;
			obj->scl.y = storm_instance[i].expl_scl.x;
			obj->scl.z = storm_instance[i].expl_scl.x;
		}
		D3DMATRIXScale(&obj->matrix, &obj->scl);

		// position
		if(storm_instance[i].is_particle)
		{
			obj->pos.x = storm_instance[i].pos.x;
			obj->pos.y = storm_instance[i].pos.y;
			obj->pos.z = FIX_Z_VALUE(storm_instance[i].pos.z);
			D3DMATRIXTranslate(&obj->matrix, &obj->pos);
		}
		else
		{
			obj->pos.x = storm_instance[i].pos.x + 25;
			obj->pos.y = storm_instance[i].pos.y + 35;
			obj->pos.z = FIX_Z_VALUE(storm_instance[i].pos.z);
			D3DMATRIXTranslate(&obj->matrix, &obj->pos);
		}


		if(!(storm_instance[i].is_particle) && (storm_instance[i].explosion_sounded == FALSE))
		{
			S3DPoint pos;
			pos.x = (int)storm_instance[i].pos.x + 25;
			pos.y = (int)storm_instance[i].pos.y + 35;
			pos.z = MapPane.GetWalkHeight(pos);
		    DamageCharactersInRange(((PTEffect)animator->GetObjInst())->GetSpell()->GetInvoker(), pos, 50, METEOR_DAMAGE_MIN, METEOR_DAMAGE_MAX, DAMAGE_FIRE);
			PLAY("meteor explode");
			storm_instance[i].explosion_sounded = TRUE;
		}


		// all the following code is to set the frame
		int frame = (int)storm_instance[i].frame;
		float u;
		float u_size;
		float v=0;
		float v_size;
		if(storm_instance[i].is_particle)
		{
			u_size = (1.0f / (float)params.particle_u);
			u = u_size * (float)(frame % params.particle_u);
			
			v_size = (1.0f / (float)params.particle_v);
			v = 0;
		}
		else
		{
			u_size = (1.0f / (float)params.impact_u);
			u = u_size * (float)(frame % params.impact_u);
			
			v_size = (1.0f / (float)params.impact_v);
			v = v_size * (float)(frame / params.impact_v);
		}

		
		obj->lverts[0].tu = u; 
		obj->lverts[0].tv = v;

		obj->lverts[1].tu = u; 
		obj->lverts[1].tv = v + v_size;

		obj->lverts[2].tu = u + u_size;
		obj->lverts[2].tv = v;

		obj->lverts[3].tu = u + u_size;
		obj->lverts[3].tv = v + v_size;
		
/*		obj->lverts[3].tu = u; 
		obj->lverts[3].tv = v;

		obj->lverts[2].tu = u; 
		obj->lverts[2].tv = v + v_size;

		obj->lverts[1].tu = u + u_size;
		obj->lverts[1].tv = v;

		obj->lverts[0].tu = u + u_size;
		obj->lverts[0].tv = v + v_size;*/
		// yep it sure is alot just to do a simple thing

		animator->RenderObject(obj);
		animator->UpdateExtents();
	}
}

void TStormAnimator::RefreshZBuffer()
{
	S3DPoint map_pos, screen_pos;
	D3DVECTOR scale;

	if(params.particle_scale.x > params.impact_scale.x)
		scale.x = params.particle_scale.x;
	else
		scale.x = params.impact_scale.x;
	if(params.particle_scale.y > params.impact_scale.y)
		scale.y = params.particle_scale.y;
	else
		scale.y = params.impact_scale.y;

	// figure out the size
	int rect_u = (int)((float)params.tex_u * scale.x * 1.5f);
	int rect_v = (int)((float)params.tex_v * scale.y * 1.5f);

	for(int i = 0; i < size; ++i)
	{
		// skip unused particles
		if(!storm_instance[i].used)
			continue;

		// get the map position
		map_pos.x = (int)storm_instance[i].pos.x;
		map_pos.y = (int)storm_instance[i].pos.y;
		map_pos.z = (int)storm_instance[i].pos.z;

		// convert it to screen position
		WorldToScreen(map_pos, screen_pos);
		RestoreZ(screen_pos.x - (rect_u / 2), screen_pos.y - (rect_v / 2), rect_u, rect_v);
		//Display->Box(screen_pos.x - (rect_u / 2), screen_pos.y - (rect_v / 2), rect_u, rect_v);
	}
}

// ****************************
// * The SubParticle Animator *
// ****************************

void TSubParticleAnimator::Set(PSSubParticleParams nparams)
{
	// copy the new parameters in
	memcpy(&params, nparams, sizeof(SSubParticleParams));
}

void TSubParticleAnimator::Get(PSSubParticleParams nparams)
{
	// copy the new parameters in
	memcpy(nparams, &params, sizeof(SSubParticleParams));
}

int TSubParticleAnimator::GetCount()
{
	// get the total number of active particles
	int count = 0;

	for(int i = 0; i < max_particles; ++i)
	{
		if(particle[i].used)
			++count;
	}

	return count;
}

void TSubParticleAnimator::Animate()
{
	// add new particles if necessary
	int p;
	if(params.particles > max_particles)
		p = max_particles;
	else
		p = params.particles;

	int size = p - GetCount();
	for(int i = 0; i < size; ++i)
		Create();

	for(i = 0; i < max_particles; ++i)
	{
		// skip unused particles
		if(!particle[i].used)
			continue;

		// do animation!

		// change flicker status
		particle[i].flicker_status = random(0, 1);

		// change the life
		--particle[i].life;
		if(particle[i].life < 0)
			particle[i].used = FALSE;

		// change the scale
		particle[i].scale.x *= particle[i].scale_dec.x;
		particle[i].scale.y *= particle[i].scale_dec.y;
		particle[i].scale.z *= particle[i].scale_dec.z;

		// change the position
		particle[i].pos.x += particle[i].velocity.x;
		particle[i].pos.y += particle[i].velocity.y;
		particle[i].pos.z += particle[i].velocity.z;

		// change the velocity
		particle[i].velocity.z -= particle[i].gravity;
	}
}

void TSubParticleAnimator::Init(PT3DAnimator anim, PS3DAnimObj o)
{
	// initialize the particle parameters

	animator = anim;
	obj = o;

	params.particles = SUBPARTICLE_MAX_PARTICLE;

	params.pos.x = 0.0f;
	params.pos.y = 0.0f;
	params.pos.z = 0.0f;

	params.pos_spread.x = 0.0f;
	params.pos_spread.y = 0.0f;
	params.pos_spread.z = 0.0f;

	params.scale.x = 1.0f;
	params.scale.y = 1.0f;
	params.scale.z = 1.0f;

	params.scale_dec.x = 0.0f;
	params.scale_dec.y = 0.0f;
	params.scale_dec.z = 0.0f;

	params.scale_spread.x = 0.0f;
	params.scale_spread.y = 0.0f;
	params.scale_spread.z = 0.0f;

	params.velocity.x = 0.0f;
	params.velocity.y = 0.0f;
	params.velocity.z = 0.0f;

	params.velocity_dir.x = 0.0f;
	params.velocity_dir.y = 0.0f;
	params.velocity_dir.z = 0.0f;

	params.velocity_spread.x = 1.0f;
	params.velocity_spread.y = 1.0f;
	params.velocity_spread.z = 1.0f;

	params.gravity = 1.0f;

	params.min_life = 10;
	params.max_life = 20;

	params.flicker = FALSE;
	params.flicker_size = 1.0f;
}

void TSubParticleAnimator::Create()
{
	// check for creation
	int roll = random(1, 100);
	if(roll > params.chance)
		return;
		
	for(int i = 0; i < max_particles; ++i)
	{
		// skip existing particles
		if(particle[i].used)
			continue;

		// mark it as used
		particle[i].used = TRUE;

		// get the position
		particle[i].pos.x = params.pos.x + random((int)-params.pos_spread.x, (int)params.pos_spread.x);
		particle[i].pos.y = params.pos.y + random((int)-params.pos_spread.y, (int)params.pos_spread.y);
		particle[i].pos.z = params.pos.z + random((int)-params.pos_spread.z, (int)params.pos_spread.z);

		// get the scale
		particle[i].scale_dec = params.scale_dec;
		particle[i].scale.x = params.scale.x + random((int)-params.scale_spread.x, (int)params.scale_spread.x);
		particle[i].scale.y = params.scale.y + random((int)-params.scale_spread.y, (int)params.scale_spread.y);
		particle[i].scale.z = params.scale.z + random((int)-params.scale_spread.z, (int)params.scale_spread.z);

		// get the velocity
		float vx, vy, vz;

		if(params.velocity_dir.x < 0)
			vx = (float)random((int)-params.velocity_spread.x, 0);
		else if(params.velocity_dir.x == 0)
			vx = (float)random((int)-params.velocity_spread.x, (int)params.velocity_spread.x);
		else
			vx = (float)random(0, (int)params.velocity_spread.x);

		if(params.velocity_dir.y < 0)
			vy = (float)random((int)-params.velocity_spread.y, 0);
		else if(params.velocity_dir.y == 0)
			vy = (float)random((int)-params.velocity_spread.y, (int)params.velocity_spread.y);
		else
			vy = (float)random(0, (int)params.velocity_spread.y);

		if(params.velocity_dir.z < 0)
			vz = (float)random((int)-params.velocity_spread.z, 0);
		else if(params.velocity_dir.x == 0)
			vz = (float)random((int)-params.velocity_spread.z, (int)params.velocity_spread.z);
		else
			vz = (float)random(0, (int)params.velocity_spread.z);

		particle[i].velocity.x = params.velocity.x + vx;
		particle[i].velocity.y = params.velocity.y + vy;
		particle[i].velocity.z = params.velocity.z + vz;

		// get the gravity
		particle[i].gravity = params.gravity;

		// get the life
		particle[i].life = random(params.min_life, params.max_life);

		// get the flicker
		particle[i].flicker = params.flicker;
		particle[i].flicker_status = random(0, 1);
		particle[i].flicker_size = params.flicker_size;

		// done!
		break;
	}
}

void TSubParticleAnimator::Render()
{
	for(int i = 0; i < max_particles; ++i)
	{
		if(!particle[i].used)
			continue;

		animator->ResetExtents();
		
		// rotate, scale, position, and use absolute position
		obj->flags = OBJ3D_MATRIX | OBJ3D_ABSPOS;

		D3DMATRIXClear(&obj->matrix);

		// rotate the to face user
		D3DMATRIXRotateZ(&obj->matrix, (float)(-M_PI / 3.0f));
		D3DMATRIXRotateX(&obj->matrix, (float)(-M_PI / 4.0f));
		D3DMATRIXRotateY(&obj->matrix, 0);

		// scale the thing
		if(particle[i].flicker && particle[i].flicker_status)
		{
			obj->scl.x = particle[i].scale.x * particle[i].flicker_size;
			obj->scl.y = particle[i].scale.y * particle[i].flicker_size;
			obj->scl.z = particle[i].scale.z * particle[i].flicker_size;
		}
		else
		{
			obj->scl.x = particle[i].scale.x;
			obj->scl.y = particle[i].scale.y;
			obj->scl.z = particle[i].scale.z;
		}
		D3DMATRIXScale(&obj->matrix, &obj->scl);

		// position the thing
		obj->pos.x = particle[i].pos.x;
		obj->pos.y = particle[i].pos.y;
		obj->pos.z = FIX_Z_VALUE(particle[i].pos.z);
		D3DMATRIXTranslate(&obj->matrix, &obj->pos);

		animator->RenderObject( obj);

		animator->UpdateExtents();
	}
}

void TSubParticleAnimator::RefreshZBuffer(int tex_u, int tex_v)
{
	S3DPoint map_pos, screen_pos;
	int rect_u, rect_v;

	for(int i = 0; i < max_particles; ++i)
	{
		// skip unused particles
		if(!particle[i].used)
			continue;

		// figure the size out
		rect_u = (int)((float)tex_u * particle[i].scale.x * 1.5f);
		rect_v = (int)((float)tex_v * particle[i].scale.y * 1.5f);
		if(particle[i].flicker && particle[i].flicker_status)
		{
			rect_u = (int)((float)rect_u * particle[i].flicker_size);
			rect_v = (int)((float)rect_v * particle[i].flicker_size);
		}

		// get the map position
		map_pos.x = (int)particle[i].pos.x;
		map_pos.y = (int)particle[i].pos.y;
		map_pos.z = (int)particle[i].pos.z;

		// convert it to screen position
		WorldToScreen(map_pos, screen_pos);

		// refresh the zbuffer
		RestoreZ(screen_pos.x - (rect_u / 2), screen_pos.y - (rect_v / 2), rect_u, rect_v);
	}
}

// **********************
// * Shockwave Animator *
// **********************

void TShockAnimator::Set(PSShockParam nparams)
{
	// copy the new parameters in
	memcpy(&params, nparams, sizeof(SShockParam));

	init_scale = params.scale;

	if(!(params.flags & SHOCKWAVE_FLAG_SHRINK))
		grow = SHOCKWAVE_GROW;
}

void TShockAnimator::Init(PT3DAnimator anim, PS3DAnimObj o, int rings, int vertices)
{
	// get the animator stuff
	animator = anim;
	obj = o;
	animator->GetVerts(o, D3DVT_LVERTEX);

	// init done to false - duh!
	done = FALSE;

	// ring info
	ring_count = rings;
	vertex_count = vertices;
	ring = new D3DCOLOR[ring_count];
}

void TShockAnimator::Animate()
{
	if(done == TRUE)
		return;

	// scaling
	params.scale.x *= params.scale_factor.x;
	params.scale.y *= params.scale_factor.y;
	params.scale.z *= params.scale_factor.z;

	// check growth, and shrinking
	if((params.scale.x > params.max_size.x || params.scale.y > params.max_size.y || params.scale.z > params.max_size.z) && grow == SHOCKWAVE_GROW)
	{
		if(params.flags & SHOCKWAVE_FLAG_SHRINK)
		{
			grow = SHOCKWAVE_SHRINK;
			params.scale_factor.x = params.shrink_factor.x;
			params.scale_factor.y = params.shrink_factor.y;
			params.scale_factor.z = params.shrink_factor.z;
		}
		else
			done = TRUE;
	}
	else if((params.scale.x < params.min_size.x || params.scale.y < params.min_size.y || params.scale.z < params.min_size.z) && grow == SHOCKWAVE_SHRINK)
	{
		done = TRUE;
	}
}

void TShockAnimator::RefreshZBuffer(int tex_u, int tex_v)
{
	// z buffer refreshing
	int rect_u, rect_v;
	S3DPoint map, screen;

	float max = params.scale.x;
	if(params.scale.y > max)
		max = params.scale.y;
	if(params.scale.z > max)
		max = params.scale.z;

	rect_u = (int)(tex_u * max); 
	rect_v = (int)(tex_v * max);

	map.x = (int)params.pos.x;
	map.y = (int)params.pos.y;
	map.z = (int)params.pos.z;

	WorldToScreen(map, screen);

	RestoreZ(screen.x - (rect_u / 2), screen.y - (rect_v / 2), rect_u, rect_v);
}

void TShockAnimator::Render()
{
	if(done == TRUE)
		return;

	// vars for rendering
	DWORD oldcullmode;
	DWORD oldsrcmode;
	DWORD olddestmode;
	DWORD oldblendstate;

	// save the render state
	Device2->GetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, &oldblendstate);
	Device2->GetRenderState(D3DRENDERSTATE_CULLMODE, &oldcullmode);
	Device2->GetRenderState(D3DRENDERSTATE_SRCBLEND, &oldsrcmode);
	Device2->GetRenderState(D3DRENDERSTATE_DESTBLEND, &olddestmode);

	animator->ResetExtents();

	obj->flags = OBJ3D_MATRIX | OBJ3D_ABSPOS | OBJ3D_VERTS;

	D3DMATRIXClear(&obj->matrix);

	// rotation
	D3DMATRIXRotateX(&obj->matrix, params.rot.x);
	D3DMATRIXRotateY(&obj->matrix, params.rot.y);
	D3DMATRIXRotateZ(&obj->matrix, params.rot.z);

	// scaling
	D3DVECTOR scl;
	scl.x = params.scale.x;
	scl.y = params.scale.y;
	scl.z = params.scale.z;
	D3DMATRIXScale(&obj->matrix, &scl);
	
	// translation
	D3DVECTOR pos;
	pos.z = FIX_Z_VALUE(params.pos.z);
	pos.x = params.pos.x;
	pos.y = params.pos.y;
	D3DMATRIXTranslate(&obj->matrix, &pos);

	float alpha_blend_factor;
	if(params.flags & SHOCKWAVE_FLAG_FADE)
		alpha_blend_factor =  (params.max_size.x - params.scale.x) / (params.max_size.x - init_scale.x);
	
	for(int i = 0; i < ring_count; ++i)
	{
		float r = (RGBA_GETRED(ring[i])   / 255.0f);
		float g = (RGBA_GETGREEN(ring[i]) / 255.0f);
		float b = (RGBA_GETBLUE(ring[i])  / 255.0f);
		float a = (RGBA_GETALPHA(ring[i]) / 255.0f);

		if(params.flags & SHOCKWAVE_FLAG_FADE)
		{
			//r *= alpha_blend_factor;
			//g *= alpha_blend_factor;
			//b *= alpha_blend_factor;
			a *= alpha_blend_factor;
		}
		for(int j = 0; j < vertex_count; ++j)
		{
			obj->lverts[(i * vertex_count) + j].color = D3DRGBA(r, g, b, a);
		}
	}
	
	// set the new render flags
	Device2->SetRenderState(D3DRENDERSTATE_CULLMODE, D3DCULL_NONE);
	Device2->SetRenderState(D3DRENDERSTATE_SRCBLEND, D3DBLEND_SRCALPHA);
	Device2->SetRenderState(D3DRENDERSTATE_DESTBLEND, D3DBLEND_INVSRCALPHA);
	Device2->SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, TRUE);

	animator->RenderObject(obj);

	animator->UpdateExtents();

	// restore the old render flags
	Device2->SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, oldblendstate);
	Device2->SetRenderState(D3DRENDERSTATE_CULLMODE, oldcullmode);
	Device2->SetRenderState(D3DRENDERSTATE_SRCBLEND, oldsrcmode);
	Device2->SetRenderState(D3DRENDERSTATE_DESTBLEND, olddestmode);
}

// **********************
// * The Strip Animator *
// **********************

TStripAnimator::TStripAnimator( PS3DAnimObj myobj, int maxp)
{
	int v, foff;
	float rangle;

	pbeg = pend = curpoints = 0;

	float zrot[8] = { -60, -60, 0, 60, 60, 60, 0, -60 };
	for (v = 0; v < 8; v++)
	{
		rangle = D3DVAL( zrot[v] * TORADIAN);
		myx[v] = D3DVAL( cos( rangle));
		myz[v] = D3DVAL( sin( rangle));
	}

	obj = myobj;

	maxpoints = maxp;
	SetWidth( 10, 5);

	uoff = 0;
	SetTextureRange( 0, 1);

	points = new D3DVECTOR[maxpoints];

	// Paraphrased GetVerts
	obj->numverts = (maxpoints * 2);	// Updated in AddPoint
	obj->lverts = new D3DLVERTEX[obj->numverts];
	obj->verttype = D3DVT_LVERTEX;

	// Paraphrased GetFaces
	obj->numfaces = ((maxpoints - 1) * 2);
	if (!obj->faces)
		obj->faces = new S3DFace[obj->numfaces];
	obj->texfaces[0] = 0;
	obj->texfaces[1] = 0;
	obj->numtexfaces[0] = 0;
	obj->numtexfaces[1] = obj->numfaces;

	// Build Vertex index for each Face
	for (v = 0; v < obj->numfaces; v++)
	{
		switch (v % 4)
		{
			case 0:
				obj->faces[v].v1 = 2;
				obj->faces[v].v2 = 0;
				obj->faces[v].v3 = 3;
				break;
			case 1:
				obj->faces[v].v1 = 1;
				obj->faces[v].v2 = 3;
				obj->faces[v].v3 = 0;
				break;
			case 2:
				obj->faces[v].v1 = 2;
				obj->faces[v].v2 = 4;
				obj->faces[v].v3 = 3;
				break;
			case 3:
				obj->faces[v].v1 = 5;
				obj->faces[v].v2 = 3;
				obj->faces[v].v3 = 4;
				break;
		}

		// Offset index every two Faces
		if (foff = (4 * (v / 4)))
		{
			obj->faces[v].v1 += foff;
			obj->faces[v].v2 += foff;
			obj->faces[v].v3 += foff;
		}
	}
};

void TStripAnimator::SetTextureRange( D3DVALUE startu, D3DVALUE endu)
{
	ubeg = startu;
	uend = endu;
	ufrequency = (float)((uend - ubeg) / maxpoints);
	if (uoff < ubeg)
		uoff = ubeg;
	if (uoff > uend)
		uoff = uend;
}

void TStripAnimator::ScrollTexture( float deltau)
{
	uoff += deltau;

	if (uoff < ubeg)
		uoff = uend - (ubeg - uoff);
	if (uoff > uend)
		uoff = ubeg + (uoff - uend);
}

void TStripAnimator::GenerateStrip( int angle)
{
	int pnt, v1, v2, w, z;
	float rx, rz;

	angle = (angle + 224) % 256; // 16

	int ang = (angle / 32);
	float sz, tfreq;

	if (startsize != endsize)
		sz = (float)(((float)(startsize - endsize) / maxpoints) * curpoints) / (maxpoints - 1);

	for (pnt = 0; pnt < curpoints; pnt++)
	{
		z = (startsize + (int)((curpoints - pnt) * sz)) / 2;
		if (pnt)
			w = (pnt + pbeg) % curpoints;
		else
			w = 0;

		v1 = (pnt * 2);
		v2 = v1 + 1;

		rx = (z * myx[ang]); 
		rz = (z * myz[ang]);

		obj->verts[v1].y = points[pnt].y;
		obj->verts[v1].x = points[w].x - rx;
		obj->verts[v1].z = points[w].z - rz;

		obj->verts[v2].y = points[pnt].y;
		obj->verts[v2].x = points[w].x + rx;
		obj->verts[v2].z = points[w].z + rz;

		tfreq = D3DVALUE( (pnt * ufrequency) + uoff);
		if (tfreq < ubeg)
			tfreq = uend - (ubeg - tfreq);
		if (tfreq > uend)
			tfreq = ubeg + (tfreq - uend);
			
		obj->verts[v1].tu = tfreq;
		obj->verts[v2].tu = tfreq;
	}

	obj->flags = OBJ3D_MATRIX | OBJ3D_ROT1 | OBJ3D_VERTS | OBJ3D_FACES | OBJ3D_OWNSVERTS | OBJ3D_OWNSFACES;
    D3DMATRIXClear( &obj->matrix);
}

void TStripAnimator::AddPoint( D3DVECTOR *p)
{
	if (curpoints >= maxpoints)
		return;

    points[curpoints].x = p->x;
    points[curpoints].y = p->y;
    points[curpoints].z = p->z;

	obj->verts[(curpoints * 2)].z = D3DVAL( startsize / 2);
	obj->verts[(curpoints * 2)].tv = 0;	
	obj->verts[(curpoints * 2)].tu = 1;

	obj->verts[(curpoints * 2) + 1].z = D3DVAL( startsize / -2);
	obj->verts[(curpoints * 2) + 1].tv = 1;	
	obj->verts[(curpoints * 2) + 1].tu = 1;

	curpoints++;
	if (pend >= pbeg)
		pend++;

	// Update our verts and faces
	obj->numverts = (curpoints * 2);
	obj->numfaces = ((curpoints - 1) * 2);
	obj->numtexfaces[1] = obj->numfaces;
}

// Deletes point from the end of the point array
void TStripAnimator::DelEndPoint()
{
	if (curpoints < 3)	// Don't kill last segment
		return;

	curpoints--;
	if (pbeg == curpoints)
		pbeg--;
	if (pend == curpoints)
		pend--;

	// Update our verts and faces
	obj->numverts = (curpoints * 2);	// Updated in AddPoint
	obj->numfaces = ((curpoints - 1) * 2);
	obj->numtexfaces[1] = obj->numfaces;
}

// Deletes point from the start of the point array
void TStripAnimator::DelStartPoint()
{
	int i;

	if (curpoints < 1)	// Don't kill last segment
		return;

	curpoints--;
	if (pbeg == curpoints)
		pbeg--;
	if (pend == curpoints)
		pend--;

	obj->numverts = (curpoints * 2);	// Updated in AddPoint
	obj->numfaces = ((curpoints - 1) * 2);
	obj->numtexfaces[1] = obj->numfaces;

	for (i = 0; i < curpoints; i++)
	    points[i] = points[(i + 1)];
}

void TStripAnimator::AdvanceStrip()
{
	if (!pbeg)
		pbeg = curpoints;
	pbeg--;
	if (!pend)
		pend = curpoints;
	pend--;
}

void TStripAnimator::ReverseStrip()
{
	pbeg++;
	if (pbeg == curpoints)
		pbeg = 0;
	pend++;
	if (pend == curpoints)
		pend = 0;
}

void TStripAnimator::SetWidth( int start, int end) {
	startsize = start;
	endsize = end;
}

void TStripAnimator::AddUpdateRects( LPD3DRECT drawextents) {
	SRect r;

	r.left = -5;
	r.top = -10;
	r.right = 15 * 16;
	r.bottom = 10;

//	drawextents->x1 += r.left;
//	drawextents->y1 += r.top;
//	drawextents->x2 += r.right;
//	drawextents->y2 += r.bottom;

	// WorldToScreen( RS3DPoint pos, int &x, int &y);
	// WorldToScreen( RS3DPoint pos, RS3DPoint spos);
}

void TParticleSystem::Init(PT3DAnimator a, PS3DAnimObj o, S3DPoint s, BOOL move, float facing_angle)
{
	// set up the basic info
	animator = a;
	object = o;
	size = s;
	check_move = move;
	facing = facing_angle;
}

void TParticleSystem::Animate()
{
	// cycle through and do life checking, and moving if necessary
	// don't run this if you don't want to use lifespans
	for(int i = 0; i < count; ++i)
	{
		if(!particle[i].used)
			continue;

		if(particle[i].life >= particle[i].life_span)
		{
			particle[i].used = FALSE;
			continue;
		}
		++particle[i].life;

		if(check_move)
		{
			particle[i].pos.x += particle[i].vel.x;
			particle[i].pos.y += particle[i].vel.y;
			particle[i].pos.z += particle[i].vel.z;

			particle[i].vel.x *= particle[i].acc.x;
			particle[i].vel.y *= particle[i].acc.y;
			particle[i].vel.z *= particle[i].acc.z;
		}
	}
}

void TParticleSystem::Render()
{
	// basically cycle through the particles and render them...duh!
	for(int i = 0; i < count; ++i)
	{
		if(!particle[i].used)
			continue;

		animator->ResetExtents();

		object->flags = OBJ3D_MATRIX;
		D3DMATRIXClear(&object->matrix);

		D3DMATRIXRotateX(&object->matrix, (float)(particle[i].rot.x * TORADIAN));
		D3DMATRIXRotateY(&object->matrix, (float)(particle[i].rot.y * TORADIAN));
		D3DMATRIXRotateZ(&object->matrix, (float)(particle[i].rot.z * TORADIAN));
		D3DMATRIXRotateX(&object->matrix, -(float)(M_PI / 2.0));
		D3DMATRIXRotateZ(&object->matrix, -(float)(M_PI / 4.0));
		D3DMATRIXRotateZ(&object->matrix, facing);

		object->scl = particle[i].scl;
		D3DMATRIXScale(&object->matrix, &object->scl);

		object->pos.x = particle[i].pos.x;
		object->pos.y = particle[i].pos.y;
		object->pos.z = FIX_Z_VALUE(particle[i].pos.z);
		D3DMATRIXTranslate(&object->matrix, &object->pos);

		animator->RenderObject(object);
		animator->UpdateExtents();
	}
}

void TParticleSystem::RefreshZBuffer()
{
	S3DPoint effect, pos, screen;

	// get the effect position
	((PTEffect)animator->GetObjInst())->GetPos(effect);

	// again cycle through the particles and update their zbuffers
	for(int i = 0; i < count; ++i)
	{
		if(!particle[i].used)
			continue;
		pos.x = effect.x + (int)particle[i].pos.x;
		pos.y = effect.y + (int)particle[i].pos.y;
		pos.z = effect.z + (int)particle[i].pos.z;

		WorldToScreen(pos, screen);

		RestoreZ(screen.x - (int)(size.x * particle[i].scl.x / 2), screen.y - (int)(size.y * particle[i].scl.y / 2), (int)(size.x * particle[i].scl.x), (int)(size.y * particle[i].scl.y));
	}
}

void TParticleSystem::Add(PSParticleSystemInfo p)
{
	// look for an unused particle
	for(int i = 0; i < count; ++i)
	{
		if(particle[i].used)
			continue;

		// add in a particle where possible
		particle[i].used = TRUE;
		particle[i].life = 0;

		particle[i].life_span = p->life_span;

		particle[i].temp = p->temp;

		particle[i].vel = p->vel;
		particle[i].pos = p->pos;
		particle[i].scl = p->scl;
		particle[i].rot = p->rot;
		particle[i].acc = p->acc;

		return;
	}
}

// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                     equip.cpp - Equipment Pane                        *
// *************************************************************************

#include "revenant.h"
#include "equip.h"
#include "bitmap.h"
#include "display.h"
#include "playscreen.h"
#include "inventory.h"
#include "mappane.h"
#include "player.h"
#include "cursor.h"
#include "multi.h"

// Location of equipment slots on eq pane
struct { int x, y; } EquipLoc[NUM_SECTS][NUM_EQ_SLOTS] =
{ { { 64, 24 }, { 64, 66 }, { 22, 83 }, { 106, 83 }, { -1, -1 }, { -1, -1 }, { 106, 5 }, { 22, 5 }, { -1, -1 } },
  { { -1, -1 }, { -1, -1 }, { 22, 5 }, { 106, 5 }, { 106, 47 }, { 22, 47 }, { -1, -1 }, { -1, -1 }, { 64, 83 } }
};

void BtnEquipDown()
{
	EquipPane.Scroll(1);
}

void BtnEquipUp()
{
	EquipPane.Scroll(-1);
}

BOOL TEquipPane::Initialize()
{
	TButtonPane::Initialize();

	NewButton("\\/", 64, 108, 40, 15, -1, BtnEquipDown, GameData->Bitmap("equipdowndown"), GameData->Bitmap("equipdownup"));
	NewButton("/\\", 64, 5, 40, 15, -1, BtnEquipUp, GameData->Bitmap("equipupdown"), GameData->Bitmap("equipupup"));

	equipdata = TMulti::LoadMulti("equipscr.dat");

	top = equipdata->Bitmap("equipscrtop");
	bottom = equipdata->Bitmap("equipscrbottom");
	section = SECT_TOP;

	heldslot = grabslot = -1;
	SetDirty(TRUE);

	return (top != NULL) && (bottom != NULL);
}

void TEquipPane::MouseClick(int button, int x, int y)
{
	TButtonPane::MouseClick(button, x, y);

	if (!Player)
		return;

	if (button == MB_LEFTDOWN)
	{
		int slot = OnSlot(x, y);
		if (slot >= 0)
		{
			if (Player->GetEquip(slot) && Player->GetEquip(slot)->InventoryImage())
			{
				heldslot = grabslot = slot;
				SetDragBitmap(Player->GetEquip(slot)->InventoryImage(),
								x - EquipLoc[section][slot].x, y - EquipLoc[section][slot].y);
				SetDragObj(Player->GetEquip(slot));
				Update();
			}
		}
	}
	else if (button == MB_LEFTUP)
	{
		if (grabslot >= 0)
		{
			// dragging from the equipment pane to someplace else
			grabslot = -1;
			SetDragBitmap(NULL);
			SetDragObj(NULL);
			Update();
		}
		else if (InPane(x, y))
		{
			// dragging from the inventory pane to here
			PTObjectInstance inst = Inventory.GetContainer()->GetInventorySlot(Inventory.GetHeldSlot());
			if (inst)
			{
				int slot = inst->GetStat("eqslot");
				if ((DWORD)slot < NUM_EQ_SLOTS)
				{
					if (Player->GetEquip(slot))
					{
						// special case: accessories can go in either left or right slot
						if (slot == EQ_R_ACCESSORY && Player->GetEquip(EQ_L_ACCESSORY) == NULL)
							slot = EQ_L_ACCESSORY;
						else if (slot == EQ_L_ACCESSORY && Player->GetEquip(EQ_R_ACCESSORY) == NULL)
								slot = EQ_R_ACCESSORY;
					}

					if (inst->GetOwner() == Player)
					{
						// something already in that slot?
						if (Player->GetEquip(slot))
							Player->GetEquip(slot)->SetInventNum(inst->InventNum());

						inst->SetInventNum(256 + slot);
					}
					else
					{
						// it's a container, so can't just swap inventory positions
						inst->RemoveFromInventory();

						if (Player->GetEquip(slot))
						{
							Player->GetEquip(slot)->RemoveFromInventory();
							Inventory.GetContainer()->AddToInventory(Player->GetEquip(slot), Inventory.GetHeldSlot());
						}

						Player->AddToInventory(inst, 256 + slot);
					}

					Player->Equip(inst, slot);
					SetDirty(TRUE);
					Inventory.SetDirty(TRUE);
				}
			}
		}
	}
}

void TEquipPane::DrawBackground()
{
	if (!IsDirty())
		TButtonPane::DrawBackground();
	else
	{
		Display->Put(0, 0, section == SECT_TOP ? top : bottom, DM_BACKGROUND);

		if (Player)
		{
			for (int i = 0; i < NUM_EQ_SLOTS; i++)
				if (grabslot != i && Player->GetEquip(i))
					if (EquipLoc[section][i].x >= 0)
						Player->GetEquip(i)->DrawInvItem(EquipLoc[section][i].x, EquipLoc[section][i].y);

			if (grabslot < 0)
				heldslot = -1;
		}

		if (section == SECT_TOP)
		{
			Button(0)->Show();
			Button(1)->Hide();
		}
		else
		{
			Button(1)->Show();
			Button(0)->Hide();
		}

		TButtonPane::DrawBackground();

		PlayScreen.MultiUpdate();
		SetDirty(FALSE);
	}
}

void TEquipPane::Animate(BOOL draw)
{
	if (draw && !mousebutton && Player)
	{
		PTObjectInstance inst = Player->GetInventorySlot(OnSlot(cursorx - GetPosX(), cursory - GetPosY()));
		CursorOverObject(inst);
	}
}

void TEquipPane::Scroll(int amount)
{
	if (amount > 0)
		section = SECT_BOTTOM;
	else if (amount < 0)
		section = SECT_TOP;
	else
		return;

	SetDirty(TRUE);
}
 
void TEquipPane::DrawAnim(PTObjectInstance inst, PTBitmap bm)
{
	if (inst->InventNum() < 256)
		return;

	if (EquipLoc[section][inst->InventNum() - 256].x >= 0)
		Display->Put(EquipLoc[section][inst->InventNum() - 256].x, EquipLoc[section][inst->InventNum() - 256].y, bm);
}

int TEquipPane::OnSlot(int x, int y)
{
	for (int slot = 0; slot < NUM_EQ_SLOTS; slot++)
		if (EquipLoc[section][slot].x >= 0 && EquipLoc[section][slot].y >= 0 &&
			x >= EquipLoc[section][slot].x && x < (EquipLoc[section][slot].x + INVITEMREALWIDTH) &&
			y >= EquipLoc[section][slot].y && y < (EquipLoc[section][slot].y + INVITEMREALHEIGHT))
		return slot;

	return -1;
}
// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                       Exit.cpp - TExit object                         *
// *************************************************************************

#include <windows.h>

#include "revenant.h"
#include "exit.h"
#include "savegame.h"
#include "mappane.h"
#include "playscreen.h"
#include "player.h"
#include "file.h"
#include "dls.h"
#include "textbar.h"
#include "3dimage.h"
#include "parse.h"
#include "sound.h"
#include "script.h"

REGISTER_BUILDER(TExit)
TObjectClass ExitClass("EXIT", OBJCLASS_EXIT, 0);

// Hard coded class stats
DEFSTAT(Exit, Openable,				OPEN, 0, 0, 0, 1)
DEFSTAT(Exit, Facing,				FACE, 1, 0, 0, 255)
DEFSTAT(Exit, UseCenter,			USE,  2, 0, 0, 2)
DEFSTAT(Exit, StopMoving,			STMV, 3, 0, 1, 1)
DEFSTAT(Exit, Delay,				DLY,  4, 0, 0, 1000)

// Hard coded object stats
DEFOBJSTAT(Exit, Locked,			LOCK, 0, 0, 0, 1)
DEFOBJSTAT(Exit, KeyId,				KEY,  1, 0, 0, 100000)
DEFOBJSTAT(Exit, PickDifficulty,	PICK, 2, 0, 0, 100000)


// these should be static members of TExit, but it doesn't seem to recognize
// their existance when I do it that way, so here they are
PSExitRef exitlist;		// master list of exits
BOOL exitlistdirty;		// if we need to save out the exit list

BOOL TExit::Initialize()
{
	exitlistdirty = FALSE;
	return ReadExitList();
}

void TExit::Close()
{
	WriteExitList();
	DestroyExitList();
}

BOOL TExit::ReadExitList(BOOL reload)
{
	if (!reload)
		exitlist = NULL;

	char fname[MAX_PATH];
	sprintf(fname, "%sexit.def", ClassDefPath);
	
	FILE *fp = TryOpen(fname, "rb");
	if (!fp)
		return FALSE;

	TFileParseStream s(fp, fname);
	TToken t(s);

	t.Get();

	PSExitRef ref;
	char name[128];

	do
	{
		if (t.Type() == TKN_RETURN || t.Type() == TKN_WHITESPACE)
			t.LineGet();

		if (t.Type() == TKN_EOF)
			break;

		ref = new SExitRef;

		if (!Parse(t, "%t (%d, %d, %d) level %d mapindex %d ambient %d (%d, %d, %d)",
					name, &ref->target.x, &ref->target.y, &ref->target.z, &ref->level, &ref->mapindex,
					&ref->ambient, &ref->ambcolor.red, &ref->ambcolor.green, &ref->ambcolor.blue))
			return FALSE;

		if (reload)
		{
			// don't overwrite any that already exist in the loaded version
			if (FindExit(name))
			{
				delete ref;
				ref = NULL;
			}
		}

		if (ref)
		{
			ref->name = strdup(name);
			ref->next = exitlist;
			exitlist = ref;
		}

		t.SkipLine();		// skip past any other garbage on the line, including the newline

	} while (t.Type() != TKN_EOF);

	fclose(fp);

	exitlistdirty = FALSE;
	return TRUE;
}

BOOL TExit::WriteExitList()
{
	if (!exitlistdirty)
		return TRUE;		// nothing to do, no changes have been made since last load/save

	if (!ReadExitList(TRUE))	// get any exits that have been added since last load
		return FALSE;

	char fname[MAX_PATH];
	sprintf(fname, "%sexit.def", ClassDefPath);
	
	FILE *fp = TryOpen(fname, "wb");
	if (!fp)
		return FALSE;

	for (PSExitRef ref = exitlist; ref; ref = ref->next)
		if (!fprintf(fp, "%s (%d, %d, %d) level %d mapindex 0x%x ambient %d (%d, %d, %d)\r\n",
						ref->name, ref->target.x, ref->target.y, ref->target.z, ref->level, ref->mapindex,
						ref->ambient, ref->ambcolor.red, ref->ambcolor.green, ref->ambcolor.blue))
		{
			fclose(fp);
			return FALSE;
		}

	fclose(fp);
	exitlistdirty = FALSE;
	return TRUE;
}

void TExit::DestroyExitList()
{
	PSExitRef next;

	for (PSExitRef ref = exitlist; ref; ref = next)
	{
		next = ref->next;

		delete ref->name;
		delete ref;
	}

	exitlist = NULL;
	exitlistdirty = FALSE;
}

void TExit::GetExitStrip(int &regx, int &regy, int &regz, int &width, int &length, int &height)
{
	// get all the bounding box data
	GetFacingBoundBox(regx, regy, width, length);

	int dummy;
	GetImagery()->GetWorldBoundBox(state, dummy, dummy, height);

	height = max(1, height);

	if (UseCenter())
	{
		// special case for objects that use the center as the activation area
		if (UseCenter() == 2)
		{
			// rotating walls
			regx = (regx / 4) * 3;
			regy = (regy + 1) / 2;
			width = (width / 4) * 3;
			length = (length + 1) / 2;
		}
		else
		{
			// elevators and teleporters
			regx = (regx / 2);
			regy = (regy / 2);
			width /= 2;
			length /= 2;
		}

		return;
	}

	// get the facing data
	int dir = Facing();
	if (dir < 0)
		dir = GetFace();

	// find the strip based on the direction the exit is facing
	if (dir >= 0xE0 || dir < 0x20)
	{
		// north-facing exit
		//regy += 1;
		length = 1;
	}
	else if (dir < 0x60)
	{
		// east-facing exit
		regx -= width - 1;
		width = 1;
	}
	else if (dir < 0xA0)
	{
		// south-facing exit
		regy -= length - 1;
		length = 1;
	}
	else if (dir < 0xE0)
	{
		// west-facing exit
		//regx += 1;
		width = 1;
	}
}

BOOL TExit::AddExit(char *name, PTObjectInstance inst, BOOL getamb)
{
	if (!name || !*name || !inst)
		return FALSE;

	PSExitRef ref = FindExit(name);

	// if it already exists we can skip some stuff
	if (!ref)
	{
		ref = new SExitRef;
		ref->name = strdup(name);

		ref->next = exitlist;
		exitlist = ref;
	}

	if (inst->ObjClass() != OBJCLASS_EXIT)
	{
		inst->GetPos(ref->target);
		ref->mapindex = -1;
	}
	else
	{
		if (inst->GetImagery() == NULL)
			memset(&ref->target, 0, sizeof(S3DPoint));
		else
		{
			int regx, regy, regz, width, length, height;
			((PTExit)inst)->GetExitStrip(regx, regy, regz, width, length, height);
			S3DPoint start(0, 0, 0);
			start.x -= regx * GRIDSIZE;
			start.y -= regy * GRIDSIZE;
			S3DPoint end = start;
			end.x += width * GRIDSIZE;
			end.y += length * GRIDSIZE;

			ref->target.x = (start.x + end.x) / 2;
			ref->target.y = (start.y + end.y) / 2;
			ref->target.z = (start.z + end.z) / 2;
		}

		S3DPoint pos;
		inst->GetPos(pos);
		ref->target += pos;

		// remember to close the door on the way out...
		ref->mapindex = inst->GetMapIndex();

		if (getamb)
		{
			ref->ambient = MapPane.GetAmbientLight();
			GetAmbientColor(ref->ambcolor);
		}
		else
		{
			ref->ambcolor.red = ref->ambcolor.green = ref->ambcolor.blue = 255;
			ref->ambient = -1;
		}
	}

	ref->level = MapPane.GetMapLevel();		// hrm...no level on objects...is that bad?

	exitlistdirty = TRUE;

	return TRUE;
}

PSExitRef TExit::FindExit(char *exitname)
{
	for (PSExitRef ref = exitlist; ref; ref = ref->next)
		if (stricmp(ref->name, exitname) == 0)
			return ref;

	return NULL;
}

BOOL TExit::Use(PTObjectInstance user, int with)
{
	TObjectInstance::Use(user, with);

	if (Openable())
	{
		if (CheckKeyUse(user, MapPane.GetInstance(with)))
			return TRUE;

		if (Locked())
		{
			TextBar.Print("It seems to be locked.");
			return FALSE;
		}

		if (state == EXIT_OPEN || state == EXIT_OPENING)
			SetState(EXIT_CLOSING);
		else if (state == EXIT_CLOSED || state == EXIT_CLOSING)
			SetState(EXIT_OPENING);

		return TRUE;
	}

	return FALSE;
}

int TExit::CursorType(PTObjectInstance with)
{
	if (Openable())
	{
		if (with)
			return CURSOR_HAND;

		return CURSOR_DOOR;
	}

	return CURSOR_NONE;
}

BOOL TExit::Activate()
{
	if (GetScript())
		GetScript()->Trigger(TRIGGER_ACTIVATE);

	if (exitflags & EX_FROMEXIT)		// if we just came from an exit, don't reflect back
		return FALSE;

	PSExitRef ref = FindExit(name);		// find this exit in the master list
	if (!ref)
		return FALSE;

	S3DPoint targ = ref->target;

	// minor hack, for now
	if (stricmp(GetTypeName(), "Door") == 0 && Player)
	{
		S3DPoint vect;
		ConvertToVector(Player->GetFace(), 24, vect);
		targ += vect;
	}

	// Set new position
	Player->SetPos(targ, ref->level);

	return TRUE;
}

void TExit::Unactivate()
{
	if (Openable())
		SetState(EXIT_CLOSING);
}

void TExit::Pulse()
{
	TContainer::Pulse();

	if (!Editor && CommandDone() && Openable())
	{
		if (state == EXIT_CLOSING)
			SetState(EXIT_CLOSED);
		else if (state == EXIT_OPENING)
			SetState(EXIT_OPEN);
	}

	if (Player && !Editor && GetImagery())
	{
		int regx, regy, regz, width, length, height;
		GetExitStrip(regx, regy, regz, width, length, height);

		// get the player's relative position to the exit
		S3DPoint delta;
		Player->GetPos(delta);
		delta -= pos;
		delta.x = (delta.x + (regx * GRIDSIZE)) / GRIDSIZE;
		delta.y = (delta.y + (regy * GRIDSIZE)) / GRIDSIZE;
		delta.z = (delta.z + (GetImagery()->GetWorldRegZ(state) * GRIDSIZE)) / GRIDSIZE;

		BOOL activate = TRUE;
//		if (StopMoving())
//		{
//			// for usecenter exits, wait until the character stops moving
//			S3DPoint lnextmove;
//			Player->GetNextMove(lnextmove);
//			if (lnextmove.x != 0 || lnextmove.y != 0 || lnextmove.z != 0)
//				activate = FALSE;
//		}

		// check if the player is over the strip of walkmap immediately past
		// the bounding box in the given direction
		if (delta.x >= 0 && delta.y >= 0 && /*delta.z >= 0 &&*/
			delta.x < width && delta.y < length/* && delta.z < height*/)
		{
			if (Player->IsOnExit() && !(exitflags & EX_ON))
				exitflags |= EX_FROMEXIT; // Looks like we just poped here from another exit

			Player->SetOnExit(); // Indicate we're on an exit
			exitflags |= EX_ON;

			if (activate &&						// Activation enabled
				!(exitflags & EX_ACTIVATED))	// Hasn't already been activated
			{
				if (wait++ > Delay())
				{
					wait = 0;
					if (Activate())
						exitflags |= EX_ACTIVATED;
				}
			}
		}
		else
		{
			if (exitflags & EX_ACTIVATED)
				Unactivate();

			exitflags &= ~(EX_ON | EX_ACTIVATED | EX_FROMEXIT);
		}
	}
}

void TExit::UseRange(int &mindist, int &maxdist, int &minang, int &maxang)
{
}

void TExit::Load(RTInputStream is, int version, int objversion)
{
	TContainer::Load(is, version, objversion);
	is >> exitflags;
}

void TExit::Save(RTOutputStream os)
{
	TContainer::Save(os);
	os << exitflags;
}

// *************
// * TElevator *
// *************

#if 0

#define ELEV_INACTIVE	0
#define ELEV_ACTIVE		1
#define ELEV_GLOW		2
#define ELEV_FLASH		3

#define TOP				1102
#define BOTTOM			222
#define MIDDLE			(((TOP - BOTTOM) / 2) + BOTTOM)

#define SPEED			8

_CLASSDEF(TElevator)
class TElevator : public TExit
{
  public:
	TElevator(PTObjectImagery newim) : TExit(newim) { speed = 0; glow = NULL; }
	TElevator(PSObjectDef def, PTObjectImagery newim) : TExit(def, newim) { speed = 0; glow = NULL; }

	virtual BOOL Activate();
		// Take the player through the exit

	virtual void Pulse();

  protected:
	int speed;					// speed and direction (negative or positive)
	int accel;					// level of acceleration

	PTObjectInstance glow;		// attached glow effect
};

DEFINE_BUILDER("ELEVATOR", TElevator)
REGISTER_BUILDER(TElevator)

int OldElevScrollLock;

BOOL TElevator::Activate()
{
	TExit::Activate();

	if (state == ELEV_INACTIVE)
	{
		SetState(ELEV_ACTIVE);
		speed = 1;
		OldElevScrollLock = ScrollLock;
		ScrollLock = TRUE;
		return TRUE;
	}

	return FALSE;
}

void TElevator::Pulse()
{
	extern TObjectClass EffectClass;

	TExit::Pulse();

	if (Editor)
		return;

	if (speed == 0 && !(exitflags & EX_ON))
	{
		// make sure elevator is at the same level as the player
		if (Player)
		{
			S3DPoint lpos;
			Player->GetPos(lpos);
			if (lpos.z < (MIDDLE - 32) && pos.z >= (MIDDLE + 32))
				speed--;
			else if (lpos.z >= (MIDDLE + 32) && pos.z < (MIDDLE - 32))
				speed++;

			if (speed && state == ELEV_INACTIVE)
				SetState(ELEV_ACTIVE);
		}
	}

	if (speed != 0)
	{
		S3DPoint newpos = pos;
		newpos.z += speed;
		SetPos(newpos);

		if (glow)
		{
			glow->GetPos(newpos);
			newpos.z += speed;
			glow->SetPos(newpos);
		}

		if (state == ELEV_ACTIVE)
		{
			if (!(exitflags & EX_ON))
			{
				// make sure elevator is at the same level as the player
				if (Player)
				{
					S3DPoint lpos;
					Player->GetPos(lpos);
					if (lpos.z < MIDDLE && speed >= 0)
						speed--;
					else if (lpos.z >= MIDDLE && speed <= 0)
						speed++;
				}
			}

			BOOL addglow = FALSE;

			if (pos.z == (TOP + 24))
			{
				speed = -1;
				addglow = TRUE;
			}

			if (pos.z == (BOTTOM + 24))
			{
				speed = 1;
				addglow = TRUE;
			}

			if (addglow)
			{
				PTObjectInstance inst = MapPane.FindClosestObject("ElevGlow", pos, FALSE);
				if (inst)
				{
					glow = inst;
					glow->ResetFlags(glow->GetFlags() & ~(OF_INVISIBLE));
					newpos = pos;
					newpos.x -= 24;
					newpos.y -= 24;
					newpos.z -= 10;
					glow->SetPos(newpos);
				}

				SetState(ELEV_GLOW);
				accel = 0;
			}
		}
		else if (state == ELEV_GLOW)
		{
			if (speed < 0 && pos.z <= (BOTTOM + 64))
			{
				if (accel++ >= 2)
				{
					accel = 0;
					speed++;
					if (speed > -1)
						speed = -1;
				}
			}
			else if (speed > 0 && pos.z >= (TOP - 64))
			{
				if (accel++ >= 2)
				{
					accel = 0;
					speed--;
					if (speed < 1)
						speed = 1;
				}
			}
			else if (abs(speed) < SPEED)
			{
				if (accel++ >= 2)
				{
					accel = 0;

					if (speed > 0)
						speed++;
					else
						speed--;
				}
			}
			else
				accel = 0;

			if ((speed < 0 && pos.z <= BOTTOM) || (speed > 0 && pos.z >= TOP))
			{
				newpos = pos;

				if (speed < 0)
					newpos.z = BOTTOM;
				else
					newpos.z = TOP;

				SetPos(newpos);

				speed = 0;
				SetState(ELEV_INACTIVE);
				ScrollLock = OldElevScrollLock;

				if (glow)
				{
					glow->SetFlags(OF_INVISIBLE);
					glow = NULL;
				}
			}
		}
	}
}

#endif

// ***************
// * TPressPlate *
// ***************

#define PLATE_UP		0
#define PLATE_DOWN		1

_CLASSDEF(TPressPlate)
class TPressPlate : public TExit
{
  public:
	TPressPlate(PTObjectImagery newim) : TExit(newim) { }
	TPressPlate(PSObjectDef def, PTObjectImagery newim) : TExit(def, newim) { }

	virtual BOOL Use(PTObjectInstance user, int with = -1) { return FALSE; }
	virtual int CursorType(PTObjectInstance with = NULL) { return CURSOR_NONE; }

	virtual BOOL Activate();
	virtual void Unactivate();
};

DEFINE_BUILDER("PressPlate", TPressPlate)
REGISTER_BUILDER(TPressPlate)

BOOL TPressPlate::Activate()
{
	TExit::Activate();

	SetState(PLATE_DOWN);

	return TRUE;
}

void TPressPlate::Unactivate()
{
	SetState(PLATE_UP);
}

// ************
// * TUpBlock *
// ************

_CLASSDEF(TUpBlock)
class TUpBlock : public TExit
{
  public:
	TUpBlock(PTObjectImagery newim) : TExit(newim) { }
	TUpBlock(PSObjectDef def, PTObjectImagery newim) : TExit(def, newim) { }

	virtual BOOL Use(PTObjectInstance user, int with = -1);
	virtual int CursorType(PTObjectInstance with = NULL) { return CURSOR_NONE; }

	virtual void Pulse();
};

DEFINE_BUILDER("UpBlock", TUpBlock)
REGISTER_BUILDER(TUpBlock)

void TUpBlock::Pulse()
{
	if (!Editor && CommandDone())
	{
		if (state == EXIT_CLOSING)
			SetState(EXIT_CLOSED);
		else if (state == EXIT_OPENING)
			SetState(EXIT_OPEN);
	}

	TExit::Pulse();
}

BOOL TUpBlock::Use(PTObjectInstance user, int with)
{
	if (with == -1)
	{
		if (state == EXIT_CLOSING || state == EXIT_CLOSED)
			SetState(EXIT_OPENING);
		else if (state == EXIT_OPENING || state == EXIT_OPEN)
			SetState(EXIT_CLOSING);

		PLAY("grind rock");

		return TRUE;
	}

	return FALSE;
}

// **********************
// * TDragonEntAnimator *
// **********************

_CLASSDEF(TDragonEntAnimator)
class TDragonEntAnimator : public T3DAnimator
{
  public:
	TDragonEntAnimator(PTObjectInstance oi) : T3DAnimator(oi) { }
	virtual ~TDragonEntAnimator() { Close(); }

	virtual void Animate(BOOL draw);
	virtual BOOL Render();
	virtual void GetExitStrip(int &regx, int &regy, int &regz, int &width, int &length, int &height);
};

REGISTER_3DANIMATOR("DragonEnt", TDragonEntAnimator)

void TDragonEntAnimator::GetExitStrip(int &regx, int &regy, int &regz, int &width, int &length, int &height)
{
	regx = 2;
	regy = 2;
	width = 4;
	length = 4;
}

void TDragonEntAnimator::Animate(BOOL draw)
{
	T3DAnimator::Animate(draw);
}

BOOL TDragonEntAnimator::Render()
{
	/*
	DWORD savedcull;
	TRY_D3D(Device2->GetRenderState(D3DRENDERSTATE_CULLMODE, &savedcull));

	TRY_D3D(Device2->SetRenderState(D3DRENDERSTATE_CULLMODE, D3DCULL_NONE));

	TRY_D3D(Device2->SetRenderState(D3DRENDERSTATE_CULLMODE, savedcull));
	*/

	T3DAnimator::Render();

	return TRUE;
}

// **************
// * TSpikeWall *
// **************

_CLASSDEF(TSpikeWall)
class TSpikeWall : public TExit
{
  public:
	TSpikeWall(PTObjectImagery newim) : TExit(newim) { }
	TSpikeWall(PSObjectDef def, PTObjectImagery newim) : TExit(def, newim) { }

	virtual BOOL Use(PTObjectInstance user, int with = -1) { return FALSE; }
	virtual int CursorType(PTObjectInstance with = NULL) { return CURSOR_NONE; }

	virtual BOOL Activate();
	virtual void Unactivate();
};

DEFINE_BUILDER("SpikeWall", TSpikeWall)
REGISTER_BUILDER(TSpikeWall)

BOOL TSpikeWall::Activate()
{
	TExit::Activate();
	
	if (Player)
	{
		Player->Force("impale");
		Player->Damage(10000, DAMAGE_PIERCING);		// make sure he's good n' dead
	}

	SetState(EXIT_OPENING);

	PLAY("spike");

	return TRUE;
}

void TSpikeWall::Unactivate()
{
	SetState(EXIT_CLOSING);

	PLAY("spike");
}

// ***************
// * TLever      *
// ***************

REGISTER_BUILDER(TLever)

BOOL TLever::Use(PTObjectInstance user, int with)
{
	TExit::Use(user, with);

	return TRUE;
}											   

void TLever::Pulse()
{
	TExit::Pulse();

	if (Editor)
		return;

/*	if (AtActivatePos() == ACTIVATE_IMTHERE)
	{
		S3DPoint newpos;

		Player->Face( (usedir * 64));	// 0 = NE, SE, SW, NW
		Player->GetPos( newpos);
		newpos.x = targetpos.x;
		newpos.y = targetpos.y;
		Player->SetPos( newpos);
		((PTCharacter)Player)->Pull( this);
		return;
	}
*/
}

// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                      file.cpp - Common File IO                        *
// *************************************************************************

#include <windows.h>

#include "revenant.h"

#include <io.h>
#include <fcntl.h>
#include <errno.h>
#include <sys\stat.h>

#include "file.h"


//==============================================================================
//    Function : LoadFile.
//------------------------------------------------------------------------------
// Description : This will load the file specified by FileName into memory.
//               If the filebuf specified is NULL, the memory to store the file
//               will be allocated here, otherwise the file will be loaded
//               into the buffer provided.
//
//  Parameters : filepath = Path to the file to load.
//
//               filebuf  = Pointer to a buffer to recieve the file or NULL if
//                          LoadFile is to allocate the memory
//
//               filesize = Pointer to a long to recieve the size of the file.
//
//     Returns : If successful, returns a pointer to the newly loaded file.
//               If the load fails, returns NULL.
//
//==============================================================================

void *LoadFile(const char *filepath, void *filebuf, long *filesize)
{
  int datafile;
  long size;
  BOOL allocmem = TRUE;

  // Initialize the size of the file read to 0 incase we encounter an error
  if (filesize != NULL)
    *filesize = 0;

  // Open the File
  if ((datafile = open(filepath, O_BINARY|O_RDONLY)) == -1)
    return NULL;

  // Get the size
  size = filelength(datafile);
  if (size == -1)
  {
    close(datafile);
    return NULL;
  }

  // See if we need to allocate memory here or use the provided buffer
  if (filebuf == NULL)
  {
    // Allocate memory to load the file into
    if ((filebuf = (void *)malloc(size)) == NULL)
    {
      close(datafile);
      return NULL;
    }
  }
  else
    allocmem = FALSE;

  // Make sure that we read the entire file
  if (read(datafile, filebuf, size) != size)
  {
    if (allocmem)
      free(filebuf);
    close(datafile);
    return NULL;
  }

  close(datafile);

  // If the filesize is requested, set it now
  if (filesize != NULL)
    *filesize = size;

  return filebuf;
}



//==============================================================================
//    Function : FileExists.
//------------------------------------------------------------------------------
// Description : This will tell if the file specified by filename exists or not.
//
//  Parameters : filepath = Specifies the file to check for.
//
//     Returns : If the file exists, returns TRUE, otherwise returns FALSE.
//
//==============================================================================

BOOL FileExists(const char *filepath)
{
	if (!access(filepath, 0))
		return TRUE;
	else
		return FALSE;
}



//==============================================================================
//    Function : FileSize.
//------------------------------------------------------------------------------
// Description : This will return the size of the file specified.
//
//  Parameters : filepath = Path to the file to check.
//
//     Returns : If the file exists, it returns the size of the file.
//               If the file doesn't exist, it returns 0.
//
//==============================================================================

long FileSize(const char *filepath)
{
  int datafile;
  long size;

  if ((datafile = open(filepath, O_RDONLY|O_BINARY)) == -1)
    return 0;

  size = filelength(datafile);

  close(datafile);

  return size;
}



//==============================================================================
//    Function : TryOpen.
//------------------------------------------------------------------------------
// Description : This will attempt to open the file specified.
//
//  Parameters : name = Path to the file to try to open.
//
//               mode = How to open the file.
//
//     Returns : Returns the FILE * if it succeeds, NULL if it fails.
//
//==============================================================================

FILE *TryOpen(const char *name, const char *mode)
{
	FILE *fp;
	int n;

	// Try to open the file, it may already be open by someone else so we need to
	// try more than once before we exit out
	for (n = 0; n < 300; n++)
	{
		if ((fp = popen((char *)name, (char *)mode)) != NULL)
			break;

		// check error - if we're out of disk space or trying to access
		// a non-existant file, just jump out right away
		if (errno == ENOENT || errno == ENOSPC)
			break;

		// Wait 100 milliseconds inbetween trys
		while (GetTickCount() % 100);
	}

	return fp;
}



//==============================================================================
//    Function : TryDelete.
//------------------------------------------------------------------------------
// Description : This will attempt to delete the file specified.
//
//  Parameters : name = Path to the file to try to delete.
//
//     Returns : If successful, returns TRUE, otherwise, returns FALSE.
//
//==============================================================================

BOOL TryDelete(const char *name)
{
	int n;
	BOOL success = TRUE;

	// Remove the file (if it exists)
	if (FileExists(name))
	{
		for (n = 0; n < 1000; n++)
		{
			if (remove(name) == 0)
				break;
			// Wait 100 milliseconds inbetween trys
			while (GetTickCount() % 100);
		}
		if (n == 1000)
			success = FALSE;
	}

	return success;
}



//==============================================================================
//    Function : TryRename.
//------------------------------------------------------------------------------
// Description : This will attempt to rename the file oldname to newname.
//
//  Parameters : oldname = Path specifying the current name.
//
//               newname = Path specifying the new name.
//
//     Returns : If successful, returns TRUE, otherwise, returns FALSE.
//
//==============================================================================

BOOL TryRename(const char *oldname, const char *newname)
{
	int n;
	BOOL success = TRUE;

	for (n = 0; n < 1000; n++)
	{
		if (rename(oldname, newname) == 0)
			break;
		// Wait 100 milliseconds inbetween trys
		while (GetTickCount() % 100);
	}
	if (n == 1000)
		success = FALSE;

	return success;
}
// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                 font.cpp - EXILE Font Objects File                    *
// *************************************************************************

#include "revenant.h"
#include "bitmap.h"
#include "font.h"
#include "graphics.h"

PTBitmap TFont::GetChar(unsigned char ch)
{
	if (ch < firstchar || ch > (firstchar + numchars))
		return NULL;

	PTBitmap character = (PTBitmap)chars[ch - firstchar].ptr();
	return character;
}

int TFont::FindNumLinesInText(char *text, int wrapwidth, int justify)
{
	SDrawBlock db;
	SDrawParam dp;
	STextParam tp;
	dp.func = TextDraw;
	dp.dx = dp.dy = 0;
	dp.data = (void *)&tp;

	tp.text = text;
	tp.numlines = 100000;
	tp.startline = 0;
	tp.wrapwidth = wrapwidth;
	tp.font = this;
	tp.justify = justify;
	tp.draw = FALSE;
	tp.length = 0;

	TextDraw(&db, &dp);
	return tp.length;
}
// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                       food.cpp - TFood module                         *
// *************************************************************************

#include "revenant.h"
#include "food.h"

REGISTER_BUILDER(TFood)

TObjectClass FoodClass("FOOD", OBJCLASS_FOOD, 0);

// Food hard coded stats
DEFSTAT(Food, Value, VAL, 0, 0, 0, 1000000)

BOOL TFood::Use(PTObjectInstance user, int with)
{
	if (GetState() == 0)
	{
		SetState(1);
		return TRUE;
	}

	return FALSE;
}
// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *               graphics.cpp - Graphics objects module                  *
// *************************************************************************

#include <stdio.h>
#include <string.h>

#include "revenant.h"
#include "bitmap.h"
#include "chunkcache.h"
#include "decompdata.h"
#include "display.h"
#include "font.h"
#include "graphics.h"

extern BYTE  ColorTable[32 * 256];
extern BYTE  ColorTable16[32 * 256];
extern BYTE  ColorTableUpperHi[32 * 256];
extern BYTE  ColorTableUpperLo[32 * 256];
extern BYTE  ColorTableLower[32 * 256];
extern DWORD Conv16to32Upper[256];
extern DWORD Conv16to32Lower[256];
extern BYTE  IntensityTableUpper[256];
extern BYTE  IntensityTableLower[256];

// ***************************************
// * Entry Function to graphics routines *
// ***************************************

BOOL Draw(PSDrawBlock db, PSDrawParam dp)
{
	int numrects = 0;    
	SDrawParam  dparray[4];

    if (dp->drawmode & DM_NOCLIP)
	{
		dparray[0] = *dp;
		numrects = 1;
	}
    else
    {
		if (dp->drawmode & DM_STRETCH)
		{  
			if (!StretchClip(db, dp, dparray, numrects))
				return FALSE;
		}
        else
		{
			if (!Clip(db, dp, dparray, numrects))
				return FALSE;
		}
	}

	BOOL drawok = FALSE;

	DRAWFUNCTION func = dp->func;
	if (!func)
		func = GetPutFunction(db, dp);
	if (!func)
		return FALSE; // Unable to find an appropriate draw function

    for (int loop = 0; loop < numrects; loop++)
    {
		PSDrawParam dpa = &dparray[loop];

		drawok |= func(db, dpa);

	  // Add update rectangles (or whatever else a callback might be used for)
		if (dpa->callback && !(dpa->drawmode & DM_DOESCALLBACK))
			dpa->callback(db, dpa);
	}

	return drawok;
}

DRAWFUNCTION GetPutFunction(PSDrawBlock db, PSDrawParam dp)
{
	DRAWFUNCTION drawfunc = NULL;

	if (db->srcbitmapflags & BM_CHUNKED)
		drawfunc = PutChunk8;
	
	else if (dp->drawmode & DM_SELECTED)
	{
		if (db->srcbitmapflags & BM_8BIT)
			drawfunc = DrawSelected8;
	
		else
			drawfunc = DrawSelected;
	}
	
	else if ((dp->drawmode & DM_ZBUFFER) || (dp->drawmode & DM_NORMALS)) // ZBuffer or Normal Buffer draws
	{
		if (dp->drawmode & DM_STRETCH)
		{
			if (dp->drawmode & DM_ZMASK)
				drawfunc = ZMaskStretch;

			else
				drawfunc = ZStretch;
		}

		else if (dp->drawmode & DM_ALPHA)
		{
			if (db->srcbitmapflags & BM_NOBITMAP && db->dstbitmapflags & (BM_16BIT | BM_15BIT))
				drawfunc = AlphaDimZNoBitmap;
		}
		else
		{
			if (db->srcbitmapflags & BM_8BIT && db->dstbitmapflags & BM_32BIT)
			{
				if (dp->drawmode & DM_SHUTTER)	
					drawfunc = ShutterZPut8;
				else
					drawfunc = ZPut8;
			}

			else if (db->srcbitmapflags & BM_8BIT && db->dstbitmapflags & (BM_16BIT | BM_15BIT))
			{
				if (dp->drawmode & DM_SHUTTER)	
					drawfunc = ShutterZPut816;
				else
					drawfunc = ZPut816;
			}
			
			else if (db->dstbitmapflags & (BM_32BIT | BM_24BIT))
			{
				if (dp->drawmode & DM_SHUTTER)	
					drawfunc = ShutterZPut32;
				else
					drawfunc = ZPut32;
			}

			else
			{
				if (dp->drawmode & DM_SHUTTER)	
					drawfunc = ShutterZPut;
				else
					drawfunc = ZPut;
			}
		}
	}

	else	// No ZBuffer or Normal buffer
	{
		if (dp->drawmode & DM_STRETCH)
		{
			if (dp->drawmode & DM_ZMASK)
				drawfunc = MaskStretch;
			
			else if (dp->drawmode & DM_TRANSLUCENT)
				drawfunc = TranslucentStretch;
			
			else if (dp->drawmode & DM_TRANSPARENT)
				drawfunc = TransStretch;
			
			else
				drawfunc = Stretch;
		}

		else if (dp->drawmode & DM_ALPHA && dp->drawmode & DM_ZSTATIC)
		{
			if (dp->intensity < 31)
				drawfunc = AlphaDimZ;
			
			else
			{
				if (db->srcbitmapflags & BM_8BIT)
					drawfunc = AlphaZ8;

				else
					drawfunc = AlphaZ;
			}
		}

		else if (dp->drawmode & DM_ALPHA)
		{
			if (db->dstbitmapflags & BM_32BIT)
				drawfunc = Alpha32;

			else
			{
				if (dp->intensity < 31)
					drawfunc = AlphaDim;
			
				else
				{
					if (db->srcbitmapflags & BM_8BIT)
						drawfunc = Alpha8;

					else
						drawfunc = Alpha;
				}
			}
		}

		else if (dp->drawmode & DM_ALPHALIGHTEN)
			drawfunc = AlphaLighten;

		else if (dp->drawmode & DM_TRANSLUCENT)
		{
			if (dp->drawmode & DM_TRANSPARENT)
				drawfunc = TransTranslucent;
			
			else
				drawfunc = Translucent;
		}    

		else
		{
			if (dp->drawmode & DM_TRANSPARENT)
			{                
				if (db->srcbitmapflags & BM_8BIT)
				{
					if (db->dstbitmapflags & BM_32BIT)
					{
						if (dp->drawmode & DM_ZSTATIC)
							drawfunc = TransZStaticPut8;
						else
							drawfunc = TransPut8;
					}
					else if (db->dstbitmapflags & BM_8BIT)
						drawfunc = TransPut88;
					else if (db->dstbitmapflags & (BM_16BIT | BM_15BIT))
					{
						if (dp->drawmode & DM_ZSTATIC)
							drawfunc = TransZStaticPut816;
						else
							drawfunc = TransPut816;
					}
				}
				else if (db->dstbitmapflags & (BM_32BIT | BM_24BIT))
					drawfunc = TransPut32;
	
				else
				{
					if (dp->drawmode & DM_ALIAS)
					{
						if (dp->drawmode & DM_CHANGECOLOR)
							drawfunc = AliasColor;
						else
							drawfunc = Alias;
					}
					else if (dp->drawmode & DM_CHANGECOLOR)
						drawfunc = TransPutColor;
				
					else if (dp->drawmode & DM_CHANGEHUE)
						drawfunc = PutHueChange;		// make a TransPut version someday

					else if (dp->drawmode & DM_CHANGESV)
						drawfunc = TransPutSVChange;

					else if (db->keycolor)
						drawfunc = TransPutKey;

					else
						drawfunc = TransPut;
				}
			}

			else
			{                
				if (db->srcbitmapflags & BM_8BIT && db->dstbitmapflags & BM_32BIT)
				{
					if (dp->drawmode & DM_SHUTTER)	
						drawfunc = ShutterPut8;
						
					else
						drawfunc = Put8;
				}

				else if (db->srcbitmapflags & BM_8BIT && db->dstbitmapflags & (BM_16BIT | BM_15BIT))
				{
					if (dp->drawmode & DM_SHUTTER)	
						drawfunc = ShutterPut816;
						
					else
						drawfunc = Put816;
				}
				else if (db->srcbitmapflags & BM_8BIT && db->dstbitmapflags & BM_8BIT)
				{
					drawfunc = Put88;
				}
				else if (db->dstbitmapflags & (BM_32BIT | BM_24BIT))
				{
					if (dp->drawmode & DM_SHUTTER)	
						drawfunc = ShutterPut32;
						
					else
						drawfunc = Put32;
				}

				else
				{
					if (dp->drawmode & DM_SHUTTER)	
						drawfunc = ShutterPut8;
					else if (dp->drawmode & DM_CHANGEHUE)
						drawfunc = PutHueChange;
					else
						drawfunc = Put;
				}
			}					
		}

	} // End of no Zbuffer/Normal Buffer

	return drawfunc;
}

// ****************************************************
// * General purpose bitmap buffer clipping functions *
// ****************************************************

// Returns the intersection of two rectangles (always a single rectangle)
BOOL ClipRect(RSRect dst, RSRect src, RSRect result)
{
	if (src.left > dst.right || src.top > dst.bottom ||
		src.right < dst.left || src.bottom < dst.top)
			return FALSE;

	if (src.left < dst.left)
		result.left = dst.left;
	else
		result.left = src.left;

	if (src.right > dst.right)
		result.right = dst.right; 
	else
		result.right = src.right;

	if (src.top < dst.top)
		result.top = dst.top;
	else
		result.top = src.top;

	if (src.bottom > dst.bottom)
		result.bottom = dst.bottom;
	else
		result.bottom = src.bottom;

	return TRUE;
}

// Returns the inverse of the intersection of two rectangles (subtraction) returns up to 4 rects
BOOL SubtractRect(RSRect dst, RSRect src, PSRect rects, int &numrects)
{
	numrects = 0;

	if (src.left > dst.right || src.top > dst.bottom ||
		src.right < dst.left || src.bottom < dst.top)
			return FALSE;

	PSRect r = rects;

	if (src.left > dst.left)
	{
		r->left = dst.left;
		r->top = dst.top;
		r->right = src.left - 1;
		r->bottom = dst.bottom;
		r++;
		numrects++;
	}
	
	if (src.right < dst.right)
	{
		r->left = src.right + 1;
		r->top = dst.top;
		r->right = dst.right;
		r->bottom = dst.bottom;
		r++;
		numrects++;
	}		

	if (src.top > dst.top)
	{
		r->left = max(dst.left, src.left);
		r->top = dst.top;
		r->right = min(dst.right, src.right);
		r->bottom = src.top - 1;
		r++;
		numrects++;
	}		

	if (src.bottom < dst.bottom)
	{
		r->left = max(dst.left, src.left);
		r->top = src.bottom + 1;
		r->right = min(dst.right, src.right);
		r->bottom = dst.bottom;
		r++;
		numrects++;
	}		

	return numrects > 0;
}

BOOL Clip(PSDrawBlock db, PSDrawParam dp, PSDrawParam dparray, int &numrects)
{
	numrects = 0;
    dparray[0] = *dp;

    SDrawBlock dbval = *db;
    SDrawParam dpval = *dp;

	// ********* Clip source to source buffer!! **********
	// Note: source rect doesn not use origins or clipping rectangle, just clips
	// to source surface size

	// There actually is a source buffer
	if (dbval.sbufwidth != 0 && dbval.sbufheight != 0)
	{

		if (!(dpval.drawmode & (DM_WRAPCLIPSRC | DM_WRAPCLIP)))			// Not wrap clipping
		{
			if (dpval.sx >= dbval.sbufwidth || dpval.sy >= dbval.sbufheight ||
				dpval.sx + dpval.swidth < 0 || dpval.sy + dpval.sheight < 0)
					return FALSE;

			if (dpval.sx < 0)
			{
				dpval.dwidth -= -dpval.sx;
				dpval.swidth -= -dpval.sx;
				dpval.dx += -dpval.sx;
				dpval.sx = 0;
			}
			if (dpval.sy < 0)
			{
				dpval.dheight -= -dpval.sy;
				dpval.sheight -= -dpval.sy;
				dpval.dy += -dpval.sy;
				dpval.sy = 0;
			}
			if (dpval.sx + dpval.swidth > dbval.sbufwidth)
			{
				dpval.dwidth -= dpval.swidth + dpval.sx - dbval.sbufwidth; 
				dpval.swidth = dbval.sbufwidth - dpval.sx;
			}
			if (dpval.sy + dpval.sheight > dbval.sbufheight)
			{
				dpval.dheight -= dpval.sheight + dpval.sy - dbval.sbufheight; 
				dpval.sheight = dbval.sbufheight - dpval.sy;
			}
		}
		else // Make sure buf width/height not to large for wrapping
		{
			if (dpval.swidth > dbval.sbufwidth)
			{
				dpval.dwidth -= dpval.swidth - dbval.sbufwidth;
				dpval.swidth = dbval.sbufwidth;
			}
			if (dpval.sheight > dbval.sbufheight)
			{
				dpval.dheight -= dpval.sheight - dbval.sbufheight;
				dpval.sheight = dbval.sbufheight;
			}
			if (dpval.swidth <= 0 || dpval.sheight <= 0)
				return FALSE;
		}
	}

	// ********* Clip the dest clipping rectange !! **********
	int cx, cy, cw, ch;
    cx = dpval.clipx;
    cy = dpval.clipy;
    cw = dpval.clipwidth;
    ch = dpval.clipheight;

	if (!(dpval.drawmode & (DM_WRAPCLIP | DM_WRAPCLIPSRC)))
	{
		if (cx >= dbval.dbufwidth || cy >= dbval.dbufheight ||
			cx + cw <= 0 || cy + ch <= 0) 
			return FALSE;

		if (cx < 0)
		{
			cw += cx;
			cx = 0;
		}

		if (cy < 0)
		{
			ch += cy;
			cy = 0;
		}
		
		if (cx + cw > dbval.dbufwidth)
		   cw = dbval.dbufwidth - cx;

		if (cy + ch > dbval.dbufheight)
		   ch = dbval.dbufheight - cy;

	}

	// ********* Do Edge Clipping **********

    int destx = dpval.dx + dpval.originx;
    int desty = dpval.dy + dpval.originy;

	if ((destx >= cx + cw) || (destx + dpval.dwidth <= cx) ||
		(desty >= cy + ch) || (desty + dpval.dheight <= cy))
	   return FALSE;

	if (destx < cx)
	{
		dpval.sx    += cx - destx;
		dpval.dwidth -= cx - destx;
		dpval.swidth = dpval.dwidth;
		dpval.dx     = cx - dpval.originx;
		destx = cx;
	}
	    
	if (desty < cy)
	{
		dpval.sy     += cy - desty;
		dpval.dheight -= cy - desty;
		dpval.sheight = dpval.dheight;
		dpval.dy      = cy - dpval.originy;
		desty = cy;
	}

	if ((destx + dpval.dwidth) > (cx + cw))
		dpval.dwidth = dpval.swidth = (cx + cw) - destx;	

	if ((desty + dpval.dheight) > (cy + ch))
		dpval.dheight = dpval.sheight = (cy + ch) - desty;

	PSDrawParam dpa = dparray;

	if (!(dpval.drawmode & DM_WRAPCLIP) && !(dpval.drawmode & DM_WRAPCLIPSRC))
	{
	// ********* No Wrap Clip **********

        dpa->dx      = dpval.dx;
        dpa->dy      = dpval.dy;
        dpa->sx      = dpval.sx;
        dpa->sy      = dpval.sy;
        dpa->dwidth  = dpa->swidth  = dpval.dwidth;
        dpa->dheight = dpa->sheight = dpval.dheight;
		dpa->originx = dpval.originx;
		dpa->originy = dpval.originy;
       
		numrects = 1;
	}

    else if (dpval.drawmode & DM_WRAPCLIP)
    {
	// ********* Do Dest Wrap Clipping **********

        int srcx = dpval.sx;
        int srcy = dpval.sy;

        destx = dpval.dx + dpval.originx;
        desty = dpval.dy + dpval.originy;

		int dstx1, dsty1, srcx1, srcy1, srcwidth1, srcheight1;
        int dstx2, dsty2, srcx2, srcy2, srcwidth2, srcheight2;

        dparray[1] = *dp;
        dparray[2] = *dp;
        dparray[3] = *dp;

        destx = destx % max(dbval.dbufwidth, 1);
		if (destx < 0) 
			destx += dbval.dbufwidth;
        
		desty = desty % max(dbval.dbufheight, 1);
	    if (desty < 0) 
			desty += dbval.dbufheight;

		if (dpval.drawmode & DM_WRAPCLIPSRC) // Allow ONLY if buffers same size
		{
			if (dbval.sbufwidth != dbval.dbufwidth || dbval.sbufheight != dbval.dbufheight ||
				dp->sx != dp->dx || dp->sy != dp->dy || dp->swidth != dp->dwidth || dp->sheight != dp->dheight)
				FatalError("Can't use DM_WRAPCLIP and DM_WRAPCLIPSRC together unless buffers and coords match!");

			srcx = srcx % max(dbval.sbufwidth, 1);
			if (srcx < 0) 
				srcx += dbval.sbufwidth;
        
			srcy = srcy % max(dbval.sbufheight, 1);
			if (srcy < 0) 
				srcy += dbval.sbufheight;
		}

      // Do wrapping stuff
        if (destx + dpval.dwidth > dbval.dbufwidth)
        {
            dstx1     = destx - dpval.originx;
            srcx1     = srcx;
            srcwidth1 = dbval.dbufwidth - destx;
            dstx2     = 0 - dpval.originx;
			if (dpval.drawmode & DM_WRAPCLIPSRC)
				srcx2  = 0;
			else 
				srcx2  = srcx1 + srcwidth1;
            srcwidth2 = dpval.dwidth - srcwidth1;
        }

        else
        {
            dstx1     = destx - dpval.originx;
            srcx1     = srcx;
            srcwidth1 = dpval.dwidth;
            dstx2     = 0 - dpval.originx;
			srcx2	  = srcwidth2 = 0;
        }

        if (desty + dpval.dheight > dbval.dbufheight)
        {
            dsty1      = desty - dpval.originy;
            srcy1      = srcy;
            srcheight1 = dbval.dbufheight - desty;
            dsty2      = 0 - dpval.originy;
			if (dpval.drawmode & DM_WRAPCLIPSRC)
				srcy2  = 0;
			else 
				srcy2  = srcy1 + srcheight1; 
            srcheight2 = dpval.dheight - srcheight1;
        }

        else
        {
	        dsty1      = desty - dpval.originy;
		    srcy1      = srcy;
			srcheight1 = dpval.dheight;
			dsty2      = 0 - dpval.originy;
			srcy2	   = srcheight2 = 0;
        }
    
      // Upper left corner
		dpa->dx      = dstx1;
        dpa->dy      = dsty1;
        dpa->sx      = srcx1;
        dpa->sy      = srcy1;
        dpa->dwidth  = dpa->swidth = srcwidth1;
        dpa->dheight = dpa->sheight = srcheight1;
       
	    numrects = 1;

      // Lower left corner
        if (srcheight2)
        {
			dpa++;
            dpa->dx      = dstx1;
            dpa->dy      = dsty2;
            dpa->sx      = srcx1;
            dpa->sy      = srcy2;
            dpa->dwidth  = dpa->swidth = srcwidth1;
            dpa->dheight = dpa->sheight = srcheight2;
       
            numrects++;
        }
    
      // Upper right corner
        if (srcwidth2)
        {
			dpa++;
            dpa->dx      = dstx2;
            dpa->dy      = dsty1;
            dpa->sx      = srcx2;
            dpa->sy      = srcy1;
            dpa->dwidth  = dpa->swidth = srcwidth2;
            dpa->dheight = dpa->sheight = srcheight1;
       
            numrects++;

	      // Lower right corner
	        if (srcheight2)
	        {
				dpa++;
				dpa->dx      = dstx2;
				dpa->dy      = dsty2;
				dpa->sx      = srcx2;
				dpa->sy      = srcy2;
				dpa->dwidth  = dpa->swidth = srcwidth2;
				dpa->dheight = dpa->sheight = srcheight2;
       
				numrects++;
			}
        }
    }

    else if (dpval.drawmode & DM_WRAPCLIPSRC)
    {
	// ********* Do Source Wrap Clipping **********

        int srcx = dpval.sx;
        int srcy = dpval.sy;

		int dstx1, dsty1, srcx1, srcy1, srcwidth1, srcheight1;
        int dstx2, dsty2, srcx2, srcy2, srcwidth2, srcheight2;

        dparray[1] = *dp;
        dparray[2] = *dp;
        dparray[3] = *dp;

        srcx = srcx % max(dbval.sbufwidth, 1);
		if (srcx < 0) 
			srcx += dbval.sbufwidth;
        
		srcy = srcy % max(dbval.sbufheight, 1);
	    if (srcy < 0) 
			srcy += dbval.sbufheight;

      // Do wrapping stuff
        if (srcx + dpval.dwidth > dbval.sbufwidth)
        {
            dstx1     = dpval.dx;
            srcx1     = srcx;
            srcwidth1 = dbval.sbufwidth - srcx;
            dstx2     = dstx1 + srcwidth1;
            srcx2     = 0;
            srcwidth2 = dpval.dwidth - srcwidth1;
        }

        else
        {
            dstx1     = dpval.dx;
            srcx1     = srcx;
            srcwidth1 = dpval.dwidth;
            dstx2     = srcx2 = srcwidth2 = 0;
        }

        if (srcy + dpval.dheight > dbval.sbufheight)
        {
            dsty1      = dpval.dy;
            srcy1      = srcy;
            srcheight1 = dbval.sbufheight - srcy;
            dsty2      = dsty1 + srcheight1;
            srcy2      = 0; 
            srcheight2 = dpval.dheight - srcheight1;
        }

        else
        {
	        dsty1      = dpval.dy;
		    srcy1      = srcy;
			srcheight1 = dpval.dheight;
			dsty2      = srcy2 = srcheight2 = 0;
        }
    
      // Upper left corner
		dpa->dx      = dstx1;
        dpa->dy      = dsty1;
        dpa->sx      = srcx1;
        dpa->sy      = srcy1;
        dpa->dwidth  = dpa->swidth  = srcwidth1;
        dpa->dheight = dpa->sheight = srcheight1;
       
	    numrects = 1;

      // Lower left corner
        if (srcheight2)
        {
			dpa++;
            dpa->dx      = dstx1;
            dpa->dy      = dsty2;
            dpa->sx      = srcx1;
            dpa->sy      = srcy2;
            dpa->dwidth  = dpa->swidth = srcwidth1;
            dpa->dheight = dpa->sheight = srcheight2;
       
            numrects++;
        }
    
      // Upper right corner
        if (srcwidth2)
        {
			dpa++;
            dpa->dx      = dstx2;
            dpa->dy      = dsty1;
            dpa->sx      = srcx2;
            dpa->sy      = srcy1;
            dpa->dwidth  = dpa->swidth = srcwidth2;
            dpa->dheight = dpa->sheight = srcheight1;
       
            numrects++;

	      // Lower right corner
	        if (srcheight2)
	        {
				dpa++;
	            dpa->dx      = dstx2;
	            dpa->dy      = dsty2;
	            dpa->sx      = srcx2;
	            dpa->sy      = srcy2;
	            dpa->dwidth  = dpa->swidth = srcwidth2;
	            dpa->dheight = dpa->sheight = srcheight2;
       
				numrects++;
			}
        }
    }

    return TRUE;
}

BOOL StretchClip(PSDrawBlock db, PSDrawParam dp, PSDrawParam dparray, 
				 int &numrects)
{
	numrects = 0;
    return FALSE;
}

// ***************************************************
// * General purpose bitmap buffer drawing functions *
// ***************************************************

BOOL Put(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 1 || dp->dheight < 1) 
		return FALSE;

    if (db->srcbitmapflags & BM_COMPRESSED)
	{
		return FALSE; // No longer supported
//		if (dp->sx || dp->sy || db->sbufwidth != dp->swidth || db->sbufheight != dp->sheight)
//			return ClipDecompress(db, dp, FALSE);
//		else
//			return Decompress(db, dp, FALSE);
	}

    SDrawBlock dbval = *db;
    SDrawParam dpval = *dp;

    SETUP_DRAW

    __asm
    {
        cld

  // Load source
        mov  esi, [dbval.source]
        add  esi, srcoff

  // Load destination
        mov  edi, [dbval.dest]
        add  edi, dstoff

  // Load lines
        mov  edx, [dpval.sheight]
        mov  ebx, [dpval.drawmode]

        and  ebx, DM_REVERSEHORZ
        jne  reverse

	forward:
        mov  ecx, [dpval.swidth]     ; Do two pixels at a time

        test ecx, 1
        je   notodd

        mov  ax, [esi]
        add  esi, 2
        mov  [edi], ax
        add  edi, 2

	notodd:
        shr  ecx, 1
		or   ecx, ecx
		je   newline

	floop:
        mov  eax, [esi]
        add  esi, 4

        mov  [edi], eax
        add  edi, 4

        dec  ecx
        jne  floop

	newline:
        add  esi, srcadd
        add  edi, dstadd
        dec  edx
        jne  forward
        jmp  done

	reverse:
        add  esi, [bmwidth]
		mov  eax, [bmwidth]
		shl  eax, 1
		add	 eax, srcadd
		mov  srcadd, eax

	revloop:
        mov  ecx, [dpval.swidth]     ; Do two pixels at a time backwords

        test ecx, 1
        je   revnotodd

        mov  ax, [esi]
        sub  esi, 2
        mov  [edi], ax
        add  edi, 2
        
	revnotodd:
		shr  ecx, 1
		or   ecx, ecx
		je   revnewline

	revmoveloop:
        mov  eax, [esi]
        sub  esi, 4
        rol  eax, 16
        mov  [edi], eax
        add  edi, 4
        dec  ecx
        jne  revmoveloop

	revnewline:
        add  esi, srcadd
        add  edi, dstadd
        dec  edx
        jne  revloop

	done:
    }

    return TRUE;
}

BOOL Put8(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 1 || dp->dheight < 1) 
		return FALSE;

	DWORD *palette = (DWORD *)((BYTE *)db->palette + sizeof(WORD) * 256);

    if (db->srcbitmapflags & BM_COMPRESSED)
	{
		return FALSE;
//		if (dp->sx || dp->sy || db->sbufwidth != dp->swidth || db->sbufheight != dp->sheight)
//			return FALSE; //ClipDecompress(db, dp, FALSE);
//
//		else
//			return FALSE; //Decompress(db, dp, FALSE);
	}

    SDrawBlock dbval = *db;
    SDrawParam dpval = *dp;

    SETUP_DRAW

    __asm
    {
        cld

  // Load source
        mov  esi, [dbval.source]
        add  esi, srcoff

  // Load destination
        mov  edi, [dbval.dest]
        add  edi, dstoff

  // Load lines
        mov  edx, [dpval.sheight]
        mov  ebx, [dpval.drawmode]

        and  ebx, DM_REVERSEHORZ
        jne  reverse

	forward:
        mov  ecx, [dpval.swidth]

	floop:
		xor  eax, eax
		mov  al, [esi]
		shl  eax, 2
		add  eax, [palette]
		mov  eax, [eax]

		mov  [edi], eax

        inc  esi
		add  edi, 4

		dec  ecx
        jne  floop

        add  esi, srcadd
        add  edi, dstadd

        dec  edx
        jne  forward
        jmp  done

	reverse:
        add  esi, [bmwidth]
		mov  eax, [bmwidth]
		add	 eax, srcadd
		mov  srcadd, eax

	revloop:
        mov  ecx, [dpval.swidth]

	revmoveloop:
		xor  eax, eax
		mov  al, [esi]
		shl  eax, 2
		add  eax, [palette]
		mov  eax, [eax]

		mov  [edi], eax

		dec  esi
		add  edi, 4

        dec  ecx
        jne  revmoveloop

        add  esi, srcadd
        add  edi, dstadd

        dec  edx
        jne  revloop

	done:
    }

    return TRUE;
}

BOOL Put88(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 1 || dp->dheight < 1) 
		return FALSE;

    if (db->srcbitmapflags & BM_COMPRESSED)
	{
		return FALSE;
//		if (dp->sx || dp->sy || db->sbufwidth != dp->swidth || db->sbufheight != dp->sheight)
//			ClipDecompress(db, dp, TRUE);
//		else
//			Decompress(db, dp, TRUE);
	}

	SDrawBlock dbval = *db;
    SDrawParam dpval = *dp;

	SETUP_DRAW

	int width = bmwidth >> 2;
	int odd = bmwidth & 3;

    __asm
    {
        cld

  // Load source
        mov  esi, [dbval.source]
        add  esi, [srcoff]

  // Load destination
        mov  edi, [dbval.dest]
        add  edi, [dstoff]

  // Load lines
        mov  edx, [dpval.sheight]
        mov  ebx, [dpval.drawmode]

        and  ebx, DM_REVERSEHORZ
        jne  reverse

	forloop:
		mov  ecx, [odd]
		or   ecx, ecx
		jz   notodd
	oddloop:
		mov  al, [esi]
		mov  [edi], al
		inc  esi
		inc  edi
		dec  ecx
		jne  oddloop

	notodd:
        mov  ecx, [width]
		or   ecx, ecx
		jz   nextline

	floop:
		mov  eax, [esi]
		mov  [edi], eax
        add  esi, 4
		add  edi, 4

		dec  ecx
        jne  floop

	nextline:
        add  edi, [dstadd]
        add  esi, [srcadd]

		dec  edx
		jne  forloop

		jmp	 done

	reverse:
		mov  eax, [width]
        add  esi, eax
			 
		shl  eax, 1
		add	 eax, [srcadd]
		mov  [srcadd], eax

	revloop:
        mov  ecx, [width]

	rloop:
		mov  eax, [esi]
		mov  [edi], eax
        sub  esi, 4
		add  edi, 4

		dec  ecx
        jne  rloop

        add  esi, srcadd
        add  edi, dstadd

		dec  edx
		jne  revloop

	done:
    }
    return TRUE;
}

BOOL Put816(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 1 || dp->dheight < 1) 
		return FALSE;

	DWORD *palette = (DWORD *)(db->palette);

    if (db->srcbitmapflags & BM_COMPRESSED)
	{
		return FALSE;
//		if (dp->sx || dp->sy || db->sbufwidth != dp->swidth || db->sbufheight != dp->sheight)
//			ClipDecompress(db, dp, FALSE);
//		else
//			Decompress(db, dp, FALSE);
	}

    SDrawBlock dbval = *db;
    SDrawParam dpval = *dp;

	SETUP_DRAW

    __asm
    {
        cld

  // Load source
        mov  esi, [dbval.source]
        add  esi, srcoff

  // Load destination
        mov  edi, [dbval.dest]
        add  edi, dstoff

  // Load lines
        mov  edx, [dpval.sheight]
        mov  ebx, [dpval.drawmode]

        and  ebx, DM_REVERSEHORZ
        jne  reverse

	forward:
        mov  ecx, [dpval.swidth]

	floop:
		xor  eax, eax
		mov  al, [esi]
		shl  eax, 1
		add  eax, [palette]
		mov  ax, [eax]

		mov  [edi], ax

        inc  esi
		add  edi, 2

		dec  ecx
        jne  floop

        add  esi, srcadd
        add  edi, dstadd

        dec  edx
        jne  forward
        jmp  done

	reverse:
		mov  eax, [dbval.sstride]
        add  esi, eax
		shl  eax, 1
		add  srcadd, eax

	revloop:
        mov  ecx, [dpval.swidth]

	revmoveloop:
		xor  eax, eax
		mov  al, [esi]
		shl  eax, 1
		add  eax, [palette]
		mov  ax, [eax]

		mov  [edi], ax

		dec  esi
		add  edi, 2

        dec  ecx
        jne  revmoveloop

        add  esi, srcadd
        add  edi, dstadd

        dec  edx
        jne  revloop

	done:
    }

    return TRUE;
}

// *********** 32 bit Bitmap Transfer Routine *********

BOOL Put32(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 1 || dp->dheight < 1) 
		return FALSE;

    if (db->srcbitmapflags & BM_COMPRESSED)
	{
		if (dp->sx || dp->sy || db->sbufwidth != dp->swidth || 
			db->sbufheight != dp->sheight)
			return FALSE;

		else 
			return FALSE;
	}

	if (db->dstbitmapflags & BM_32BIT)
	{
		SDrawBlock dbval = *db;
	    SDrawParam dpval = *dp;

		SETUP_DRAW

		__asm
		{
			mov  esi, [dbval.source]	; Point ESI to source
			add  esi, [srcoff]			; Adjusts ESI for offset

			mov	 edi, [dbval.dest]		; Point EDI to destination
			add  edi, [dstoff]			; Adjusts EDI for offset
 
			mov  edx, [dpval.sheight]
	        mov  ebx, [dpval.drawmode]

			and  ebx, DM_REVERSEHORZ
			jne  Reverse32

			xor  ebx, ebx

		OuterLoop32:
			mov  ecx, [dpval.swidth]

		InnerLoop32:
			mov  bl, [esi]
			mov  eax, [Conv16to32Lower + ebx * 4]
			mov  bl, [esi + 1]
			add  eax, [Conv16to32Upper + ebx * 4]

			mov  [edi], eax

			add  esi, 2
			add  edi, 4
			
			dec  ecx
			jne  InnerLoop32
			
			add  esi, srcadd
			add  edi, dstadd

			dec  edx
			jne  OuterLoop32
			
			jmp  Done32

		Reverse32:
			xor  ebx, ebx

			add  esi, [bmwidth]
			mov  eax, [bmwidth]
			shl  eax, 1
			add	 eax, srcadd
			mov  srcadd, eax
	
		RevOuterLoop32:
			mov     ecx, [dpval.swidth]     ; Do two pixels at a time backwords

		RevInnerLoop32:
			mov  bl, [esi]
			mov  eax, [Conv16to32Lower + ebx * 4]
			mov  bl, [esi + 1]
			add  eax, [Conv16to32Upper + ebx * 4]

			mov  [edi], eax

			sub  esi, 2
			add  edi, 4
			
			dec  ecx
			jne  RevInnerLoop32
			
			add  esi, srcadd
			add  edi, dstadd
			dec  edx
			jne  RevOuterLoop32

		Done32:
		}
	}

	if (db->dstbitmapflags & BM_24BIT)
	{
		SDrawBlock dbval = *db;
	    SDrawParam dpval = *dp;

		SETUP_DRAW

		__asm
		{
			mov  esi, [dbval.source]	; Point ESI to source
			add  esi, [srcoff]			; Adjusts ESI for offset

			mov	 edi, [dbval.dest]		; Point EDI to destination
			add  edi, [dstoff]			; Adjusts EDI for offset
 
			mov  edx, [dpval.sheight]
	        mov  ebx, [dpval.drawmode]

			and  ebx, DM_REVERSEHORZ
			jne  Reverse24

			xor  ebx, ebx

		OuterLoop24:
			mov  ecx, [dpval.swidth]
			shr  ecx, 1
		
		InnerLoop24:
			mov  bl, [esi]
			mov  eax, [Conv16to32Lower + ebx * 4]
			mov  bl, [esi + 1]
			add  eax, [Conv16to32Upper + ebx * 4]

			add  esi, 2
			add  edi, 3
			
			dec  ecx
			jne  InnerLoop24
			
			add  esi, srcadd
			add  edi, dstadd

			dec  edx
			jne  OuterLoop24
			
			jmp  Done24

		Reverse24:
			xor  ebx, ebx

			add  esi, [bmwidth]
			mov  eax, [bmwidth]
			shl  eax, 1
			add	 eax, srcadd
			mov  srcadd, eax
	
		RevOuterLoop24:
			mov  ecx, [dpval.swidth]     ; Do two pixels at a time backwords

		RevInnerLoop24:
			mov  bl, [esi]
			mov  eax, [Conv16to32Lower + ebx * 4]
			mov  bl, [esi + 1]
			add  eax, [Conv16to32Upper + ebx * 4]

			sub  esi, 2
			add  edi, 3
			
			dec  ecx
			jne  RevInnerLoop24
			
			add  esi, srcadd
			add  edi, dstadd

			dec  edx
			jne  RevOuterLoop24

		Done24:
		}
	}

	return TRUE;
}

BOOL ShutterPut(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 1 || dp->dheight < 1) 
		return FALSE;

    if (db->srcbitmapflags & BM_COMPRESSED)
	{
		return FALSE;
//		if (dp->sx || dp->sy || db->sbufwidth != dp->swidth || db->sbufheight != dp->sheight)
//			return ClipDecompress(db, dp, FALSE);
//		else
//			return Decompress(db, dp, FALSE);
	}

    SDrawBlock dbval = *db;
    SDrawParam dpval = *dp;

	SETUP_DRAW

	DWORD pixelx;	// Current pixel screen pos
	DWORD pixely;

    __asm
    {
        cld

  // Load source
        mov  esi, [dbval.source]
        add  esi, srcoff

  // Load destination
        mov  edi, [dbval.dest]
        add  edi, dstoff

  // Load lines
        mov  edx, [dpval.sheight]
        mov  ebx, [dpval.drawmode]
		
		mov  eax, [dpval.dy]
		mov  [pixely], eax

        and  ebx, DM_REVERSEHORZ
        jne  reverse

	forward:
		mov  eax, [dpval.dx]
		mov  [pixelx], eax

        mov  ecx, [dpval.swidth]     ; Do two pixels at a time

	floop:
		test [pixely], 1
		jne  line0
		
		test [pixelx], 1
		je	 skipraw
	
		jmp  draw	

	line0:
		test [pixelx], 1
		jne	 skipraw
	
	draw:
        mov  ax, [esi]
        add  esi, 2

        mov  [edi], ax
        add  edi, 2

        inc  [pixelx]
        dec  ecx

        jne  floop

	skipraw:
        add  esi, srcadd
        add  edi, dstadd

        inc  [pixely]
		dec  edx

        jne  forward

        jmp  done

	reverse:
        add  esi, [bmwidth]
		mov  eax, [bmwidth]

		shl  eax, 1
		add	 eax, srcadd

		mov  srcadd, eax

	revloop:
		mov  eax, [dpval.dx]
		mov  [pixelx], eax

        mov  ecx, [dpval.swidth]     ; Do two pixels at a time backwords

	revmoveloop:
		test [pixely], 1
		jne  revline0
		
		test [pixelx], 1
		je	 revskipraw
	
		jmp  revdraw	

	revline0:
		test [pixelx], 1
		jne	 revskipraw
	
	revdraw:
        mov  ax, [esi]
        sub  esi, 2
     
	    mov  [edi], ax
        add  edi, 2

        inc  [pixelx]
		dec  ecx

        jne  revmoveloop

	revskipraw:
        add  esi, srcadd
        add  edi, dstadd

        inc  [pixely]
        dec  edx

        jne  revloop

	done:
    }

    return TRUE;
}

BOOL ShutterPut8(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 1 || dp->dheight < 1) 
		return FALSE;

	DWORD *palette = (DWORD *)((BYTE *)db->palette + sizeof(WORD) * 256);

    if (db->srcbitmapflags & BM_COMPRESSED)
	{
		return FALSE;
//		if (dp->sx || dp->sy || db->sbufwidth != dp->swidth || db->sbufheight != dp->sheight)
//			return FALSE; //ClipDecompress(db, dp, FALSE);
//
//		else
//			return FALSE; //Decompress(db, dp, FALSE);
	}

    SDrawBlock dbval = *db;
    SDrawParam dpval = *dp;

	SETUP_DRAW

    DWORD pixelx;	// Screen pos of current pixel
    DWORD pixely;

	__asm
    {
        cld

  // Load source
        mov  esi, [dbval.source]
        add  esi, srcoff

  // Load destination
        mov  edi, [dbval.dest]
        add  edi, dstoff

  // Load lines
        mov  edx, [dpval.sheight]
        mov  ebx, [dpval.drawmode]
        
		mov  eax, [dpval.dy]
		mov  [pixely], eax

		and  ebx, DM_REVERSEHORZ
        jne  reverse

	forward:
		mov  eax, [dpval.dx]
		mov  [pixelx], eax

        mov  ecx, [dpval.swidth]

	floop:
		test [pixely], 1
		jne  line0
		
		test [pixelx], 1
		je	 SkipRaw
	
		jmp  draw	

	line0:
		test [pixelx], 1
		jne	 SkipRaw
	
	draw:
		xor  eax, eax
		mov  al, [esi]
		shl  eax, 2
		add  eax, [palette]
		mov  eax, [eax]

		mov  [edi], eax

	SkipRaw:
		inc  esi
		add  edi, 4

		inc  [pixelx]
		dec  ecx

        jne  floop

        add  esi, srcadd
        add  edi, dstadd

		inc  [pixely]
        dec  edx

        jne  forward
        jmp  done

	reverse:
        add  esi, [bmwidth]
		mov  eax, [bmwidth]

		add	 eax, srcadd
		mov  srcadd, eax

	revloop:
		mov  eax, [dpval.dx]
		mov  [pixelx], eax

        mov  ecx, [dpval.swidth]

	revmoveloop:
		test [pixely], 1
		jne  Revline0
		
		test [pixelx], 1
		je	 revskipraw
	
		jmp  Revdraw	

	Revline0:
		test [pixelx], 1
		jne	 revskipraw
	
	Revdraw:
		xor  eax, eax
		mov  al, [esi]
	
		shl  eax, 2
		add  eax, [palette]
	
		mov  eax, [eax]
		mov  [edi], eax

	revskipraw:
		dec  esi
		add  edi, 4

		inc  [pixelx]
        dec  ecx

        jne  revmoveloop

        add  esi, srcadd
        add  edi, dstadd

		inc  [pixely]
        dec  edx

        jne  revloop

	done:
    }

    return TRUE;
}

BOOL ShutterPut816(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 1 || dp->dheight < 1) 
		return FALSE;

	DWORD *palette = (DWORD *)((BYTE *)db->palette);

    if (db->srcbitmapflags & BM_COMPRESSED)
	{
		return FALSE;
//		if (dp->sx || dp->sy || db->sbufwidth != dp->swidth || db->sbufheight != dp->sheight)
//			return FALSE; //ClipDecompress(db, dp, FALSE);
//		else
//			return FALSE; //Decompress(db, dp, FALSE);
	}

    SDrawBlock dbval = *db;
    SDrawParam dpval = *dp;

	SETUP_DRAW

    DWORD pixelx;	// Screen pos of current pixel
    DWORD pixely;

    __asm
    {
        cld

  // Load source
        mov  esi, [dbval.source]
        add  esi, srcoff

  // Load destination
        mov  edi, [dbval.dest]
        add  edi, dstoff

  // Load lines
        mov  edx, [dpval.sheight]
        mov  ebx, [dpval.drawmode]

		mov  eax, [dpval.dy]
		mov  [pixely], eax

        and  ebx, DM_REVERSEHORZ
        jne  reverse

	forward:
		mov  eax, [dpval.dx]
		mov  [pixelx], eax

        mov  ecx, [dpval.swidth]

	floop:
		test [pixely], 1
		jne  line0
		
		test [pixelx], 1
		je	 SkipRaw
	
		jmp  draw	

	line0:
		test [pixelx], 1
		jne	 SkipRaw
	
	draw:
		xor  eax, eax
		mov  al, [esi]
		shl  eax, 1
		add  eax, [palette]
		mov  ax, [eax]

		mov  [edi], ax

   SkipRaw:
        inc  esi
		add  edi, 2

		inc  [pixelx]
		dec  ecx

        jne  floop

        add  esi, srcadd
        add  edi, dstadd

		inc  [pixely]
        dec  edx

        jne  forward

        jmp  done

	reverse:
        add  esi, [dbval.sstride]
		mov  eax, [dbval.sstride]

		shl  eax, 1
		add  srcadd, eax

	revloop:
		mov  eax, [dpval.dx]
		mov  [pixelx], eax

        mov  ecx, [dpval.swidth]

	revmoveloop:
		test [pixely], 1
		jne  Revline0
		
		test [pixelx], 1
		je	 RevSkipRaw
	
		jmp  Revdraw	

	Revline0:
		test [pixelx], 1
		jne	 RevSkipRaw
	
	Revdraw:
		xor  eax, eax
		mov  al, [esi]

		shl  eax, 1
		add  eax, [palette]

		mov  ax, [eax]
		mov  [edi], ax

	RevSkipRaw:
		dec  esi
		add  edi, 2

		inc  [pixelx]
        dec  ecx

        jne  revmoveloop

        add  esi, srcadd
        add  edi, dstadd

		inc  [pixely]
        dec  edx

        jne  revloop

	done:
    }

    return TRUE;
}

// *********** 32 bit Bitmap Transfer Routine *********

BOOL ShutterPut32(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 1 || dp->dheight < 1) 
		return FALSE;

    if (db->srcbitmapflags & BM_COMPRESSED)
	{
		if (dp->sx || dp->sy || db->sbufwidth != dp->swidth || 
			db->sbufheight != dp->sheight)
			return FALSE;

		else 
			return FALSE;
	}

	if (db->dstbitmapflags & BM_32BIT)
	{
		SDrawBlock dbval = *db;
	    SDrawParam dpval = *dp;

		SETUP_DRAW

	    DWORD pixelx;	// Screen pos of current pixel
		DWORD pixely;

		__asm
		{
			mov  esi, [dbval.source]	; Point ESI to source
			add  esi, [srcoff]			; Adjusts ESI for offset

			mov	 edi, [dbval.dest]		; Point EDI to destination
			add  edi, [dstoff]			; Adjusts EDI for offset
 
			mov  eax, [dpval.dy]
			mov  [pixely], eax

			mov  edx, [dpval.sheight]
	        mov  ebx, [dpval.drawmode]

			and  ebx, DM_REVERSEHORZ
			jne  Reverse32

			xor  ebx, ebx

		OuterLoop32:
			mov  eax, [dpval.dx]
			mov  [pixelx], eax

			mov  ecx, [dpval.swidth]

		InnerLoop32:
			test [pixely], 1
			jne  line32
		
			test [pixelx], 1
			je	 SkipRaw32
	
			jmp  draw32	

		line32:
			test [pixelx], 1
			jne	 SkipRaw32
	
		draw32:
			mov  bl, [esi]
			mov  eax, [Conv16to32Lower + ebx * 4]
	
			mov  bl, [esi + 1]
			add  eax, [Conv16to32Upper + ebx * 4]

			mov  [edi], eax

		SkipRaw32:
			add  esi, 2
			add  edi, 4
			
			inc  [pixelx]
			dec  ecx

			jne  InnerLoop32
			
			add  esi, srcadd
			add  edi, dstadd

			inc  [pixely]
			dec  edx

			jne  OuterLoop32
			
			jmp  Done32

		Reverse32:
			xor  ebx, ebx
			add  esi, [bmwidth]
			
			mov  eax, [bmwidth]
			shl  eax, 1

			add	 eax, srcadd
			mov  srcadd, eax
	
		RevOuterLoop32:
			mov  eax, [dpval.dx]
			mov  [pixelx], eax

			mov  ecx, [dpval.swidth]     ; Do two pixels at a time backwords

		RevInnerLoop32:
			test [pixely], 1
			jne  Revline32
		
			test [pixelx], 1
			je	 RevSkipRaw32
	
			jmp  Revdraw32

		Revline32:
			test [pixelx], 1
			jne	 SkipRaw32
	
		Revdraw32:
			mov  bl, [esi]
			mov  eax, [Conv16to32Lower + ebx * 4]

			mov  bl, [esi + 1]
			add  eax, [Conv16to32Upper + ebx * 4]

			mov  [edi], eax

		RevSkipRaw32:
			sub  esi, 2
			add  edi, 4
			
			inc  [pixelx]
			dec  ecx

			jne  RevInnerLoop32
			
			add  esi, srcadd
			add  edi, dstadd

			inc  [pixely]
			dec  edx

			jne  RevOuterLoop32

		Done32:
		}
	}

	if (db->dstbitmapflags & BM_24BIT)
	{
		SDrawBlock dbval = *db;
	    SDrawParam dpval = *dp;

		SETUP_DRAW

		DWORD pixelx;	// Screen pos of current pixel
		DWORD pixely;

		__asm
		{
			mov  esi, [dbval.source]	; Point ESI to source
			add  esi, [srcoff]			; Adjusts ESI for offset

			mov	 edi, [dbval.dest]		; Point EDI to destination
			add  edi, [dstoff]			; Adjusts EDI for offset
 
			mov  edx, [dpval.sheight]
	        mov  ebx, [dpval.drawmode]

			mov  eax, [dpval.dy]
			mov  [pixely], eax

			and  ebx, DM_REVERSEHORZ
			jne  Reverse24

			xor  ebx, ebx

		OuterLoop24:
			mov  eax, [dpval.dx]
			mov  [pixelx], eax

			mov  ecx, [dpval.swidth]
		
		InnerLoop24:
			test [pixely], 1
			jne  line24
		
			test [pixelx], 1
			je	 SkipRaw24
	
			jmp  draw24

		line24:
			test [pixelx], 1
			jne	 SkipRaw24
	
		draw24:
			mov  bl, [esi]
			mov  eax, [Conv16to32Lower + ebx * 4]
			mov  bl, [esi + 1]
			add  eax, [Conv16to32Upper + ebx * 4]

		SkipRaw24:
			add  esi, 2
			add  edi, 3
			
			inc  [pixelx]
			dec  ecx

			jne  InnerLoop24
			
			add  esi, srcadd
			add  edi, dstadd

			inc  [pixely]
			dec  edx

			jne  OuterLoop24
			
			jmp  Done24

		Reverse24:
			xor  ebx, ebx
			add  esi, [bmwidth]

			mov  eax, [bmwidth]
			shl  eax, 1

			add	 eax, srcadd
			mov  srcadd, eax
	
		RevOuterLoop24:
			mov  eax, [dpval.dx]
			mov  [pixelx], eax

			mov  ecx, [dpval.swidth]     ; Do two pixels at a time backwords

		RevInnerLoop24:
			test [pixely], 1
			jne  Revline24
		
			test [pixelx], 1
			je	 RevSkipRaw24
	
			jmp  Revdraw24

		Revline24:
			test [pixelx], 1
			jne	 RevSkipRaw24
	
		Revdraw24:
			mov  bl, [esi]
			mov  eax, [Conv16to32Lower + ebx * 4]
		
			mov  bl, [esi + 1]
			add  eax, [Conv16to32Upper + ebx * 4]

		RevSkipRaw24:
			sub  esi, 2
			add  edi, 3
			
			inc  [pixelx]
			dec  ecx

			jne  RevInnerLoop24
			
			add  esi, srcadd
			add  edi, dstadd

			inc  [pixelx]
			dec  edx

			jne  RevOuterLoop24

		Done24:
		}
	}

	return TRUE;
}

// *********** Chunk Bitmap Transfer Routines *********
BOOL PutChunk8(PSDrawBlock db, PSDrawParam dp)
{
	SDrawBlock dbval = *db;	
	SDrawParam dpval = *dp;	

	SDrawBlock dbval2 = *db;	
	SDrawParam dpval2 = *dp;	
	dpval2.func = NULL;

	SETUP_DRAW

	PSChunkHeader hdr  = (PSChunkHeader)dbval.source;
	PSChunkHeader zhdr = (PSChunkHeader)dbval.szbuffer;
	PSChunkHeader nhdr = (PSChunkHeader)dbval.snormals;

	int type   = hdr->type;
	int width  = hdr->width;
	int height = hdr->height;

	int ULx = dpval.sx / CHUNKWIDTH;
	int ULy = dpval.sy / CHUNKHEIGHT;
	int LRx = (dpval.sx + dpval.swidth) / CHUNKWIDTH;
	int LRy = (dpval.sy + dpval.sheight) / CHUNKHEIGHT;
	
	if ((dpval.sx + dpval.swidth) % CHUNKWIDTH)
		LRx++;
	
	if ((dpval.sy + dpval.sheight) % CHUNKHEIGHT)
		LRy++;

	dbval2.srcbitmapflags = dbval.srcbitmapflags & ~BM_COMPRESSED;
	dbval2.srcbitmapflags &= ~BM_CHUNKED;
	dbval2.dstbitmapflags = dbval.dstbitmapflags & ~BM_COMPRESSED;
	dbval2.dstbitmapflags &= ~BM_CHUNKED;
	dbval2.sbufwidth      = CHUNKWIDTH;
	dbval2.sbufheight     = CHUNKHEIGHT;
	dbval2.sstride        = CHUNKWIDTH;
	dbval2.szstride		  = CHUNKWIDTH;

	dpval.sx %= CHUNKWIDTH;
	dpval.sy %= CHUNKHEIGHT;

	for (int outerloop = ULy; outerloop < LRy; outerloop++)
	{
		for (int innerloop = ULx; innerloop < LRx; innerloop++)
		{
			dpval2.sx = 0;
			dpval2.swidth = CHUNKWIDTH;

			dpval2.sy = 0;
			dpval2.sheight = CHUNKHEIGHT;

			if (innerloop == ULx && (dpval.sx % CHUNKWIDTH))
			{
				dpval2.sx = dpval.sx;
				dpval2.swidth -= dpval.sx;
			}

			if (innerloop == (LRx - 1) && ((dpval.sx + dpval.swidth) % CHUNKWIDTH))
				dpval2.swidth = ((dpval.sx + dpval.swidth) % CHUNKWIDTH) - dpval2.sx;

			if (outerloop == ULy && (dpval.sy % CHUNKHEIGHT))
			{
				dpval2.sy = dpval.sy;
				dpval2.sheight -= dpval.sy;
			}

			if (outerloop == (LRy - 1) && ((dpval.sy + dpval.sheight) % CHUNKHEIGHT))
				dpval2.sheight = ((dpval.sy + dpval.sheight) % CHUNKHEIGHT) - dpval2.sy;

			dpval2.dwidth  = dpval2.swidth;
			dpval2.dheight = dpval2.sheight;

			dbval2.source = ChunkCache.AddChunk(hdr->block[outerloop * width + innerloop].ptr(), 1);
			
			if (dbval2.source == NULL)
				goto endloop;

			if (dpval2.drawmode & DM_ZBUFFER)
			{
				if (dbval.szbuffer && dbval.dzbuffer)
					dbval2.szbuffer = (WORD *)ChunkCache.AddChunkZ(zhdr->block[outerloop * width + innerloop].ptr(), 2);

				if (dbval2.szbuffer == NULL) 
					goto endloop;

				if (dbval2.szbuffer == NULL || dbval2.dzbuffer == NULL)
					dpval2.drawmode &= ~DM_ZBUFFER;
			}

			if (dpval2.drawmode & DM_NORMALS)
			{
				if (dbval.snormals && dbval.dnormals)
					dbval2.snormals = (WORD *)ChunkCache.AddChunk16(nhdr->block[outerloop * width + innerloop].ptr(), 1);

				if (dbval2.snormals == NULL || dbval2.dnormals == NULL)
					dpval2.drawmode &= ~DM_NORMALS;
			}

			dpval2.drawmode |= DM_NOCLIP;

			Draw(&dbval2, &dpval2);

		endloop:
			dpval2.dx += dpval2.dwidth;
		}

		dpval2.dx = dpval.dx;
		dpval2.dy += dpval2.dheight;
	}

	return TRUE;
}

// *********** Normal Transparent Bitmap Transfer Routine *********
BOOL TransPut(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 1 || dp->dheight < 1) 
		return FALSE;

    if (db->srcbitmapflags & BM_COMPRESSED)
	{
		return FALSE;
//		if (dp->sx || dp->sy || db->sbufwidth != dp->swidth || db->sbufheight != dp->sheight)
//			return ClipDecompress(db, dp, TRUE);
//
//		else
//			return Decompress(db, dp, TRUE);
	}

	SDrawBlock dbval = *db;
    SDrawParam dpval = *dp;

	SETUP_DRAW

    __asm
    {
        cld

  // Load source
        mov  esi, [dbval.source]
        add  esi, srcoff

  // Load destination
        mov  edi, [dbval.dest]
        add  edi, dstoff

  // Load lines
        mov  edx, [dpval.sheight]
        mov  ebx, [dpval.drawmode]

        and  ebx, DM_REVERSEHORZ
        jne  reverse

	forloop:
        mov  ecx, [dpval.swidth]

        test ecx, 1
        je   notodd

        mov  ax, [esi]
        add  esi, 2
        or   ax, ax
        je   nopixel
        mov  [edi], ax
			 
	nopixel:
        add  edi, 2

	notodd:
        shr  ecx, 1
		or   ecx, ecx
		je   newline

	floop:
        mov  eax, [esi]      
        add  esi, 4
        or   eax, eax                ; Skips both pixels if both transparent
        je   skip

        cmp  eax, 0000ffffh          ; Checks to see if upper pixel
        jbe  drawbottom              ; transparent

        or   ax, ax                  ; Check if lower pixel needs to be
        jne  drawboth                ; retrieved from screen

        mov  ax, [edi]

        mov  [edi], eax              ; Moves both pixels
        add  edi, 4
        dec  ecx
        jne  floop
        jmp  newline

	drawbottom:
        __emit 66h
	drawboth:
        mov  [edi], eax              ; Moves both pixels
	skip:
        add  edi, 4
        dec  ecx
        jne  floop

	newline:
        add  esi, srcadd
        add  edi, dstadd
        dec  edx
        jne  forloop
        jmp  done

	reverse:
        add  esi, [bmwidth]
			 
		mov  eax, [bmwidth]
		shl  eax, 1
		add	 eax, srcadd
		mov  srcadd, eax

	revloop:
        mov  ecx, [dpval.swidth]

        test ecx, 1
        je   revnotodd

        mov  ax,[esi]
        sub  esi, 2
        or   ax, ax
        je   revnopixel

        mov  [edi], ax

	revnopixel:
        add  edi, 2

	revnotodd:
        shr  ecx, 1

	rloop:
        mov  eax, [esi]      
        sub  esi, 4
        rol  eax,16
		or   eax, eax                ; Skips both pixels if both transparent
        je   revskip
        
		cmp  eax, 0000ffffh          ; Checks to see if upper pixel
        jbe  revdrawbottom           ; transparent
        or   ax, ax                  ; Check if lower pixel needs to be
        jne  revdrawboth             ; retrieved from screen

        mov  ax, [edi]

        mov  [edi], eax              ; Moves both pixels
        add  edi, 4
        dec  ecx
        jne  rloop

        jmp  revnewline

	revdrawbottom:
        _emit 66h                    ; Cause instruction to be changed to
	revdrawboth:                     ; mov [edi], ax
        mov  [edi], eax              ; Moves both pixels
	revskip:
        add  edi, 4

        dec  ecx
        jne  rloop

	revnewline:
        add  esi, srcadd
        add  edi, dstadd
        dec  edx
        jne  revloop
     
	done:
    }
    return TRUE;
}

BOOL TransPut8(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 1 || dp->dheight < 1) 
		return FALSE;

	DWORD *palette = (DWORD *)((BYTE *)db->palette + sizeof(WORD) * 256);

    if (db->srcbitmapflags & BM_COMPRESSED)
	{
		return FALSE;
//		if (dp->sx || dp->sy || db->sbufwidth != dp->swidth || db->sbufheight != dp->sheight)
//			return FALSE; //ClipDecompress(db, dp, TRUE);
//
//		else
//			return FALSE; //Decompress(db, dp, TRUE);
	}

	SDrawBlock dbval = *db;
    SDrawParam dpval = *dp;

	SETUP_DRAW

    __asm
    {
        cld

  // Load source
        mov  esi, [dbval.source]
        add  esi, [srcoff]

  // Load destination
        mov  edi, [dbval.dest]
        add  edi, [dstoff]

  // Load lines
        mov  edx, [dpval.sheight]
        mov  ebx, [dpval.drawmode]

        and  ebx, DM_REVERSEHORZ
        jne  reverse

	forloop:
        mov  ecx, [dpval.swidth]

	floop:
		mov  al, [esi]
		and  eax, 0ffh

		or   al, al
		je   skip

		shl  eax, 2
		add  eax, [palette]
		mov  eax, [eax]

		mov  [edi], eax

	skip:
        inc  esi
		add  edi, 4

		dec  ecx
        jne  floop

        add  edi, [dstadd]
        add  esi, [srcadd]

		dec  edx
		jne  forloop

		jmp	 done

	reverse:
		mov  eax, [bmwidth]
        add  esi, eax
			 
		shl  eax, 1
		add	 eax, [srcadd]
		mov  [srcadd], eax

	revloop:
        mov  ecx, [dpval.swidth]

	rloop:
		mov  al, [esi]
		and  eax, 0ffh

		or   al, al
		je   revskip

		shl  eax, 2
		add  eax, [palette]
		mov  eax, [eax]

		mov  [edi], eax

	revskip:
        dec  esi
		add  edi, 4

		dec  ecx
        jne  rloop

        add  esi, srcadd
        add  edi, dstadd

		dec  edx
		jne  revloop

	done:
    }
    return TRUE;
}

BOOL TransZStaticPut8(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 1 || dp->dheight < 1) 
		return FALSE;

    if (db->dzbuffer == NULL)
		return FALSE;

	DWORD *palette = (DWORD *)((BYTE *)db->palette + sizeof(WORD) * 256);

	if (db->srcbitmapflags & BM_COMPRESSED)
	{
		return FALSE;
//		if (dp->sx || dp->sy || db->sbufwidth != dp->swidth || 
//			db->sbufheight != dp->sheight)
//			return FALSE;//ClipZBufferDecompress832(db, dp, palette);
//		
//		else
//			return FALSE;//ZBufferDecompress832(db, dp, palette);
	}

	SDrawBlock dbval = *db;
    SDrawParam dpval = *dp;

	SETUP_Z_DRAW

	DWORD tmpesp;	// Stores Temp ESP

	__asm
	{
		mov  [tmpesp], esp

		mov  esi, [dbval.source]	; Point ESI to source
		add  esi, [srcoff]			; Adjusts ESI for offset

		mov	 edi, [dbval.dest]		; Point EDI to destination
		add  edi, [dstoff]			; Adjusts EDI for offset
 
		mov  edx, [dbval.dzbuffer]  ; Points EDX to	Dest zbuffer
		add  edx, [dstzoff]			; Adjusts EDX for offset

		cld							; Forward direction
		mov  eax, [dpval.drawmode]

		and  eax, DM_REVERSEHORZ
		jne  Reverse

		mov  ebx, [bmheight]

	OuterLoop:
		mov  ecx, [dpval.swidth]	; ECX contains number of rows to do.

	InnerLoop:
		mov  ax, [dpval.zpos]

		cmp  [edx], ax
		jb   SkipRaw

		xor  eax, eax
		mov  al, [esi]

		or   eax, eax
		jz   SkipRaw

		shl  eax, 2
		add  eax, [palette]
		
		mov  eax, [eax]
		shr	 eax, 3
		mov  [edi], eax

		mov  ax, [dpval.zpos]
		mov  [edx], ax

	SkipRaw:
		inc  esi
		add  edi, 4
		add  edx, 2

		dec  ecx
        jne  InnerLoop

        add  esi, srcadd
        add  edi, dstadd
		add  edx, dstzadd

		dec  ebx

		jne  OuterLoop
		jmp  Done

	Reverse:
		add  esi, [bmwidth]

		mov  eax, [bmwidth]
		shl  eax, 1
		add	 eax, srcadd
		mov  srcadd, eax
		mov  ebx, [bmheight]

	RevOuterLoop:
		mov  ecx, [dpval.swidth]	; ECX contains number of rows to do.

	RevInnerLoop:
		mov  ax, [dpval.zpos]

		cmp  [edx], ax
		jb   RevSkipRaw

		xor  eax, eax
		mov  al, [esi]

		or   eax, eax
		jz   RevSkipRaw

		shl  eax, 2
		add  eax, [palette]

		mov  eax, [eax]
		mov  [edi], eax

		mov  ax, [dpval.zpos]
		mov  [edx], ax

	RevSkipRaw:
		dec  esi
		add  edi, 4
		dec  ebx
		add  edx, 2

		dec  ecx
		jne  RevInnerLoop

		add  esi, srcadd
		add  edi, dstadd
		add  edx, dstzadd

		dec  ebx
		jne  RevOuterLoop

	Done:
		mov esp, [tmpesp]
	}

	return TRUE;
}

BOOL TransZStaticPut816(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 1 || dp->dheight < 1) 
		return FALSE;

    if (db->dzbuffer == NULL)
		return FALSE;

	DWORD *palette = (DWORD *)((BYTE *)db->palette);

	if (db->srcbitmapflags & BM_COMPRESSED)
	{
		return FALSE;
//		if (dp->sx || dp->sy || db->sbufwidth != dp->swidth || 
//			db->sbufheight != dp->sheight)
//			return FALSE;//ClipZBufferDecompress832(db, dp, palette);
//		
//		else
//			return FALSE;//ZBufferDecompress832(db, dp, palette);
	}

	SDrawBlock dbval = *db;
    SDrawParam dpval = *dp;

	SETUP_Z_DRAW

	DWORD tmpesp;	// Stores Temp ESP

	__asm
	{
		mov  [tmpesp], esp

		mov  esi, [dbval.source]	; Point ESI to source
		add  esi, [srcoff]			; Adjusts ESI for offset

		mov	 edi, [dbval.dest]		; Point EDI to destination
		add  edi, [dstoff]			; Adjusts EDI for offset
 
		mov  edx, [dbval.dzbuffer]  ; Points EDX to	Dest zbuffer
		add  edx, [dstzoff]		; Adjusts EDX for offset

		cld							; Forward direction
		mov  eax, [dpval.drawmode]

		and  eax, DM_REVERSEHORZ
		jne  Reverse

		mov  ebx, [bmheight]

	OuterLoop:
		mov  ecx, [dpval.swidth]	; ECX contains number of rows to do.

	InnerLoop:
		mov  ax, [dpval.zpos]

		cmp  [edx], ax
		jb   SkipRaw

		xor  eax, eax
		mov  al, [esi]

		or   eax, eax
		jz   SkipRaw

		shl  eax, 1
		add  eax, [palette]

		mov  ax, [eax]
		mov  [edi], ax

		mov  ax, [dpval.zpos]
		mov  [edx], ax

	SkipRaw:
		inc  esi
		add  edi, 2
		add  edx, 2

		dec  ecx
        jne  InnerLoop

        add  esi, srcadd
        add  edi, dstadd
		add  edx, dstzadd

		dec  ebx

		jne  OuterLoop
		jmp  Done

	Reverse:
		add  esi, [bmwidth]

		mov  eax, [bmwidth]
		shl  eax, 1
		add	 eax, srcadd
		mov  srcadd, eax
		mov  ebx, [bmheight]

	RevOuterLoop:
		mov  ecx, [dpval.swidth]	; ECX contains number of rows to do.

	RevInnerLoop:
		mov  ax, [dpval.zpos]

		cmp  [edx], ax
		jb   RevSkipRaw

		xor  eax, eax
		mov  al, [esi]

		or   eax, eax
		jz   RevSkipRaw

		shl  eax, 1
		add  eax, [palette]

		mov  ax, [eax]
		mov  [edi], ax

		mov  ax, [dpval.zpos]
		mov  [edx], ax

	RevSkipRaw:
		dec  esi
		add  edi, 2
		dec  ebx
		add  edx, 2

		dec  ecx
		jne  RevInnerLoop

		add  esi, srcadd
		add  edi, dstadd
		add  edx, dstzadd

		dec  ebx
		jne  RevOuterLoop

	Done:
		mov esp, [tmpesp]
	}

	return TRUE;
}

BOOL TransPut816(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 1 || dp->dheight < 1) 
		return FALSE;

	DWORD *palette = (DWORD *)((BYTE *)db->palette);

    if (db->srcbitmapflags & BM_COMPRESSED)
	{
		return FALSE;
//		if (dp->sx || dp->sy || db->sbufwidth != dp->swidth || db->sbufheight != dp->sheight)
//			return FALSE; //ClipDecompress(db, dp, TRUE);
//
//		else
//			return FALSE; //Decompress(db, dp, TRUE);
	}

	SDrawBlock dbval = *db;
    SDrawParam dpval = *dp;

	SETUP_DRAW

    __asm
    {
        cld

  // Load source
        mov  esi, [dbval.source]
        add  esi, srcoff

  // Load destination
        mov  edi, [dbval.dest]
        add  edi, dstoff

  // Load lines
        mov  edx, [dpval.sheight]
        mov  ebx, [dpval.drawmode]

        and  ebx, DM_REVERSEHORZ
        jne  reverse

	forloop:
        mov  ecx, [dpval.swidth]

	floop:
		xor  eax, eax
		mov  al, [esi]
		or   al, al
		je   skip

		shl  eax, 1
		add  eax, [palette]
		mov  ax, [eax]

		mov  [edi], ax

	skip:
        inc  esi
		add  edi, 2

		dec  ecx
        jne  floop

        add  esi, srcadd
        add  edi, dstadd
		dec  edx
		jne  forloop
		jmp	 done

	reverse:
        add  esi, [bmwidth]
			 
		mov  eax, [bmwidth]
		shl  eax, 1
		add	 eax, srcadd
		mov  srcadd, eax

	revloop:
        mov  ecx, [dpval.swidth]

	rloop:
		xor  eax, eax
		mov  al, [esi]
		shl  eax, 1
		add  eax, [palette]
		mov  ax, [eax]

		or   ax, ax
		je   revskip

		mov  [edi], ax

	revskip:
        dec  esi
		add  edi, 2

		dec  ecx
        jne  rloop

        add  esi, srcadd
        add  edi, dstadd
		dec  edx
		jne  revloop

	done:
    }
    return TRUE;
}

BOOL TransPut88(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 1 || dp->dheight < 1) 
		return FALSE;

    if (db->srcbitmapflags & BM_COMPRESSED)
	{
		return FALSE;
//		if (dp->sx || dp->sy || db->sbufwidth != dp->swidth || db->sbufheight != dp->sheight)
//			return FALSE; //ClipDecompress(db, dp, TRUE);
//
//		else
//			return FALSE; //Decompress(db, dp, TRUE);
	}

	SDrawBlock dbval = *db;
    SDrawParam dpval = *dp;

	SETUP_DRAW

    __asm
    {
        cld

  // Load source
        mov  esi, [dbval.source]
        add  esi, srcoff

  // Load destination
        mov  edi, [dbval.dest]
        add  edi, dstoff

  // Load lines
        mov  edx, [dpval.sheight]
        mov  ebx, [dpval.drawmode]

        and  ebx, DM_REVERSEHORZ
        jne  reverse

	forloop:
        mov  ecx, [dpval.swidth]

	floop:
		mov  al, [esi]
		or   al, al
		je   skip

		mov  [edi], al

	skip:
        inc  esi
		inc  edi

		dec  ecx
        jne  floop

        add  esi, srcadd
        add  edi, dstadd
		dec  edx
		jne  forloop
		jmp	 done

	reverse:
        add  esi, [bmwidth]
			 
		mov  eax, [bmwidth]
		shl  eax, 1
		add	 eax, srcadd
		mov  srcadd, eax

	revloop:
        mov  ecx, [dpval.swidth]

	rloop:
		mov  al, [esi]
		or   al, al
		je   revskip

		mov  [edi], al

	revskip:
        dec  esi
		dec  edi

		dec  ecx
        jne  rloop

        add  esi, srcadd
        add  edi, dstadd
		dec  edx
		jne  revloop

	done:
    }
    return TRUE;
}

BOOL TransPutColor(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 1 || dp->dheight < 1) 
		return FALSE;

    if (db->srcbitmapflags & BM_COMPRESSED)
	{
		return FALSE;
//		if (dp->sx || dp->sy || db->sbufwidth != dp->swidth || db->sbufheight != dp->sheight)
//			return ClipDecompress(db, dp, TRUE);
//
//		else
//			return Decompress(db, dp, TRUE);
	}

	SDrawBlock dbval = *db;
    SDrawParam dpval = *dp;

	SETUP_DRAW

	WORD color = (WORD)dp->color;

    __asm
    {
        cld

  // Load source
        mov  esi, [dbval.source]
        add  esi, srcoff

  // Load destination
        mov  edi, [dbval.dest]
        add  edi, dstoff

  // Load lines
        mov  edx, [dpval.sheight]
        mov  ebx, [dpval.drawmode]

        and  ebx, DM_REVERSEHORZ
        jne  reverse

	forloop:
        mov  ecx, [dpval.swidth]

	floop:
        mov  ax, [esi]
        add  esi, 2
        or   ax, ax
        je   skip

		mov  ax, color
        mov  [edi], ax

	skip:
        add  edi, 2
        dec  ecx
        jne  floop

        add  esi, srcadd
        add  edi, dstadd
        dec  edx
        jne  forloop
        jmp  done

	reverse:
        add  esi, [bmwidth]
			 
		mov  eax, [bmwidth]
		shl  eax, 1
		add	 eax, srcadd
		mov  srcadd, eax

	revloop:
        mov  ecx, [dpval.swidth]

	rloop:
        mov  ax, [esi]
        sub  esi, 2
		or   ax, ax
        je   revskip
        
		mov  ax, color
        mov  [edi], ax

	revskip:
        add  edi, 2
        dec  ecx
        jne  rloop

        add  esi, srcadd
        add  edi, dstadd
        dec  edx
        jne  revloop
     
	done:
    }
    return TRUE;
}

BOOL TransPutSVChange(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 1 || dp->dheight < 1) 
		return FALSE;

    if (db->srcbitmapflags & BM_COMPRESSED)
	{
		return FALSE;
//		if (dp->sx || dp->sy || db->sbufwidth != dp->swidth || db->sbufheight != dp->sheight)
//			return ClipDecompress(db, dp, TRUE);
//
//		else
//			return Decompress(db, dp, TRUE);
	}

	SDrawBlock dbval = *db;
    SDrawParam dpval = *dp;

	SETUP_DRAW

	int saturation = (dp->color >> 8) & 0xFF;
	int brightness = dp->color & 0xFF;
	WORD pixel;

	srcoff >>= 1;
	dstoff >>= 1;
	srcadd >>= 1;
	dstadd >>= 1;
	WORD *src = (WORD *)dbval.source + srcoff;
	WORD *dst = (WORD *)dbval.dest + dstoff;
	for (int h = 0; h < dpval.sheight; h++)
	{
		for (int w = 0; w < dpval.swidth; w++)
		{
			pixel = *src++;

			if (pixel == db->keycolor)
			{
				pixel = *dst;
				*dst++ = pixel;
			}
			else if (pixel == 0)
				*dst++ = 0;
			else
			{
				int r, g, b;
				if (Display->BitsPerPixel() == 15)
				{
					r = (pixel >> 10) & 0x1F;
					g = (pixel >> 5) & 0x1F;
					b = pixel & 0x1F;
				}
				else
				{
					r = (pixel >> 11) & 0x1F;
					g = (pixel >> 6) & 0x1F;
					b = pixel & 0x1F;
				}

 				int upper = 255 - (brightness / 8);
				int lower = brightness / 8;
				if (upper > lower)
				{
					r = (r * (upper - lower)) / 255 + lower;
					b = (b * (upper - lower)) / 255 + lower;
					g = (g * (upper - lower)) / 255 + lower;
				}

				r <<= 3;
				g <<= 3;
				b <<= 3;

				int minval = min(r, min(g, b));
				int maxval = max(r, max(g, b));
				double hue;

				int delta = maxval - minval;
				if (delta <= 0)
				{
					// for right now, ignore any grey pixels
				/*
					// all three are equal - no saturation or hue
					r -= brightness;
					if (r < 0)
						r = 0;
					g = b = r;*/
				}
				else
				{
					if (r == maxval)
						hue = ((double)g - (double)b) / (double)delta;
					else if (g == maxval)
						hue = 2.0 + (((double)b - (double)r) / (double)delta);
					else
						hue = 4.0 + (((double)r - (double)g) / (double)delta);

					hue *= 60.0;
					if (hue < 0)
						hue = hue + 360.0;

					double s = (double)((((double)maxval - (double)minval) / (double)maxval) - ((double)saturation / 255.0));
					if (s < 0.0)
						s = 0.0;
					double v = (double)(((double)maxval / 255.0) - ((double)brightness / 255.0));
					if (v < 0.0)
						v = 0.0;

					int range = (int)(hue / 60.0);
					double h = hue / 60.0;
					double f = h - (double)range;
					int p = (int)((v * (1 - s)) * 255.0);
					int q = (int)((v * (1 - (s * f))) * 255.0);
					int t = (int)((v * (1 - (s * (1 - f)))) * 255.0);
					int v0 = (int)(v * 255.0);

					switch (range)
					{
						case 0:
							r = v0;
							g = t;
							b = p;
							break;
						case 1:
							r = q;
							g = v0;
							b = p;
							break;
						case 2:
							r = p;
							g = v0;
							b = t;
							break;
						case 3:
							r = p;
							g = q;
							b = v0;
							break;
						case 4:
							r = t;
							g = p;
							b = v0;
							break;
						case 5:
							r = v0;
							g = p;
							b = q;
							break;
					}
				}

				r >>= 3;
				g >>= 3;
				b >>= 3;

				if (Display->BitsPerPixel() == 15)
					pixel = (r << 10) | (g << 5) | b;
				else
					pixel = (r << 11) | (g << 6) | b;

				*dst++ = pixel;
			}
		}

		src += srcadd;
		dst += dstadd;
	}

    return TRUE;
}

BOOL PutHueChange(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 1 || dp->dheight < 1) 
		return FALSE;

    if (db->srcbitmapflags & BM_COMPRESSED)
	{
		return FALSE;
//		if (dp->sx || dp->sy || db->sbufwidth != dp->swidth || db->sbufheight != dp->sheight)
//			return ClipDecompress(db, dp, TRUE);
//
//		else
//			return Decompress(db, dp, TRUE);
	}

	SDrawBlock dbval = *db;
    SDrawParam dpval = *dp;

	SETUP_DRAW

	WORD hue = (WORD)dp->color;
	WORD pixel;

	srcoff >>= 1;
	dstoff >>= 1;
	srcadd >>= 1;
	dstadd >>= 1;
	WORD *src = (WORD *)dbval.source + srcoff;
	WORD *dst = (WORD *)dbval.dest + dstoff;
	for (int h = 0; h < dpval.sheight; h++)
	{
	for (int w = 0; w < dpval.swidth; w++)
	{
	pixel = *src++;

	if (pixel != 0)
	{
		int r, g, b;
		if (Display->BitsPerPixel() == 15)
		{
			r = (pixel >> 10) & 0x1F;
			g = (pixel >> 5) & 0x1F;
			b = pixel & 0x1F;
		}
		else
		{
			r = (pixel >> 11) & 0x1F;
			g = (pixel >> 6) & 0x1F;
			b = pixel & 0x1F;
		}

		r <<= 3;
		g <<= 3;
		b <<= 3;

		if (g > r && g > b)
		{
			double v = (double)g / 255.0;
			double s = ((double)g - (double)(min(r, b))) / (double)g;

			int range = hue / 60;
			double h = (double)hue / 60.0;
			double f = h - (double)range;
			int p = (int)((v * (1 - s)) * 255.0);
			int q = (int)((v * (1 - (s * f))) * 255.0);
			int t = (int)((v * (1 - (s * (1 - f)))) * 255.0);
			int v0 = (int)(v * 255.0);

			switch (range)
			{
				case 0:
					r = v0;
					g = t;
					b = p;
					break;
				case 1:
					r = q;
					g = v0;
					b = p;
					break;
				case 2:
					r = p;
					g = v0;
					b = t;
					break;
				case 3:
					r = p;
					g = q;
					b = v0;
					break;
				case 4:
					r = t;
					g = p;
					b = v0;
					break;
				case 5:
					r = v0;
					g = p;
					b = q;
					break;
			}

			r >>= 3;
			g >>= 3;
			b >>= 3;

			if (Display->BitsPerPixel() == 15)
				pixel = (r << 10) | (g << 5) | b;
			else
				pixel = (r << 11) | (g << 6) | b;
		}
	}

	if (pixel == 0 && dpval.drawmode & DM_TRANSPARENT)
		dst++;
	else
		*dst++ = pixel;
	}

	src += srcadd;
	dst += dstadd;
	}

    return TRUE;
}

// Non-zero keycolor transparent put
BOOL TransPutKey(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 1 || dp->dheight < 1) 
		return FALSE;

    if (db->srcbitmapflags & BM_COMPRESSED)
	{
		return FALSE;
//		if (dp->sx || dp->sy || db->sbufwidth != dp->swidth || db->sbufheight != dp->sheight)
//			return ClipDecompress(db, dp, TRUE);
//
//		else
//			return Decompress(db, dp, TRUE);
	}

	SDrawBlock dbval = *db;
    SDrawParam dpval = *dp;

	SETUP_DRAW

	WORD keycolor = (WORD) dbval.keycolor;
	DWORD dblkeycolor = (keycolor << 16) | keycolor;

    __asm
    {
        cld

  // Load source
        mov  esi, [dbval.source]
        add  esi, srcoff

  // Load destination
        mov  edi, [dbval.dest]
        add  edi, dstoff

  // Load lines
		mov  edx, [dpval.sheight]
        mov  ebx, [dpval.drawmode]

        and  ebx, DM_REVERSEHORZ
        jne  reverse

	forloop:
        mov  ecx, [dpval.swidth]

        test ecx, 1
        je   notodd

        mov  ax, [esi]
        add  esi, 2
        cmp  ax, keycolor
        je   nopixel
        mov  [edi], ax
			 
	nopixel:
        add  edi, 2

	notodd:
        shr  ecx, 1
		or   ecx, ecx
		je   newline

	floop:
        mov  eax, [esi]      
        add  esi, 4
		cmp  eax, dblkeycolor        ; Skips both pixels if both transparent
        je   skip

		mov  ebx, eax
		shr  ebx, 16
        cmp  bx, keycolor			 ; Checks to see if upper pixel
        je   drawbottom              ; transparent

        cmp  ax, keycolor            ; Check if lower pixel needs to be
        jne  drawboth                ; retrieved from screen

        mov  ax, [edi]

        mov  [edi], eax              ; Moves both pixels
        add  edi, 4
        dec  ecx
        jne  floop
        jmp  newline

	drawbottom:
        mov  bx, [edi+2]
		shl  ebx, 16
		and  eax, 0000ffffh
		add  eax, ebx
        mov  [edi], eax              ; Moves both pixels

        add  edi, 4
        dec  ecx
        jne  floop
        jmp  newline

	drawboth:
        mov  [edi], eax              ; Moves both pixels
	skip:
        add  edi, 4
        dec  ecx
        jne  floop

	newline:
        add  esi, srcadd
        add  edi, dstadd
        dec  edx
        jne  forloop
        jmp  done

	reverse:
        add  esi, [bmwidth]

		mov  eax, [bmwidth]
		shl  eax, 1
		add	 eax, srcadd
		mov  srcadd, eax

	revloop:
        mov  ecx, [dpval.swidth]

        test ecx, 1
        je   revnotodd

        mov  ax,[esi]
        sub  esi, 2
        cmp  ax, keycolor
        je   revnopixel

        mov  [edi], ax

	revnopixel:
        add  edi, 2

	revnotodd:
        shr  ecx, 1

	rloop:
        mov  eax, [esi]      
        sub  esi, 4
        rol  eax,16
		cmp  eax, dblkeycolor        ; Skips both pixels if both transparent
        je   revskip
        
		mov  ebx, eax
		shr  ebx, 16
        cmp  bx, keycolor			 ; Checks to see if upper pixel
        je   revdrawbottom           ; transparent
        cmp  ax, keycolor            ; Check if lower pixel needs to be
        jne  revdrawboth             ; retrieved from screen

        mov  ax, [edi]

        mov  [edi], eax              ; Moves both pixels
        add  edi, 4
        dec  ecx
        jne  rloop

        jmp  revnewline

	revdrawbottom:
        mov  bx, [edi+2]
		shl  ebx, 16
		add  eax, ebx
		mov  [edi], eax

        add  edi, 4
        dec  ecx
        jne  rloop

		jmp  revnewline

	revdrawboth:
        mov  [edi], eax              ; Moves both pixels
	revskip:
        add  edi, 4

        dec  ecx
        jne  rloop

	revnewline:
        add  esi, srcadd
        add  edi, dstadd
        dec  edx
        jne  revloop
     
	done:
    }
    return TRUE;
}

// *********** 32-bit Transparent Bitmap Transfer Routine *********
BOOL TransPut32(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 1 || dp->dheight < 1) 
		return FALSE;

    if (db->srcbitmapflags & BM_COMPRESSED)
	{
		if (dp->sx || dp->sy || db->sbufwidth != dp->swidth || 
			db->sbufheight != dp->sheight)
			return FALSE;

		else 
			return FALSE;
	}

	if (db->dstbitmapflags & BM_32BIT)
	{
		SDrawBlock dbval = *db;
	    SDrawParam dpval = *dp;

		SETUP_DRAW
	
		__asm
		{
			mov  esi, [dbval.source]	; Point ESI to source
			add  esi, [srcoff]			; Adjusts ESI for offset

			mov	 edi, [dbval.dest]		; Point EDI to destination
			add  edi, [dstoff]			; Adjusts EDI for offset
 
			mov  edx, [dpval.sheight]
	        mov  ebx, [dpval.drawmode]

			and  ebx, DM_REVERSEHORZ
			jne  Reverse32

			xor  ebx, ebx

		OuterLoop32:
			mov  ecx, [dpval.swidth]
		
		InnerLoop32:
			cmp  WORD ptr [esi], 0 
			je   SkipPixel32

			mov  bl, [esi]
			mov  eax, [Conv16to32Lower + ebx * 4]
			mov  bl, [esi + 1]
			add  eax, [Conv16to32Upper + ebx * 4]

			mov  [edi], eax

		SkipPixel32:
			add  esi, 2
			add  edi, 4
			
			dec  ecx
			jne  InnerLoop32
			
			add  esi, srcadd
			add  edi, dstadd

			dec  edx
			jne  OuterLoop32
			
			jmp  Done32

		Reverse32:
			xor  ebx, ebx

			add  esi, [bmwidth]
			mov  eax, [bmwidth]
			shl  eax, 1
			add	 eax, srcadd
			mov  srcadd, eax
	
		RevOuterLoop32:
			mov     ecx, [dpval.swidth]     ; Do two pixels at a time backwords

		RevInnerLoop32:
			cmp  WORD ptr [esi], 0
			je   RevSkipPixel32

			mov  bl, [esi]
			mov  eax, [Conv16to32Lower + ebx * 4]
			mov  bl, [esi]
			add  eax, [Conv16to32Upper + ebx * 4]

			mov  [edi], eax

		RevSkipPixel32:
			sub  esi, 2
			add  edi, 4
			
			dec  ecx
			jne  RevInnerLoop32
			
			add  esi, srcadd
			add  edi, dstadd
			dec  edx
			jne  RevOuterLoop32

		Done32:
		}
	}

	if (db->dstbitmapflags & BM_24BIT)
	{
		SDrawBlock dbval = *db;
	    SDrawParam dpval = *dp;

	    SETUP_DRAW
	
		__asm
		{
			mov  esi, [dbval.source]	; Point ESI to source
			add  esi, [srcoff]			; Adjusts ESI for offset

			mov	 edi, [dbval.dest]		; Point EDI to destination
			add  edi, [dstoff]			; Adjusts EDI for offset
 
			mov  edx, [dpval.sheight]
	        mov  ebx, [dpval.drawmode]

			and  ebx, DM_REVERSEHORZ
			jne  Reverse24

			xor  ebx, ebx

		OuterLoop24:
			mov  ecx, [dpval.swidth]
		
		InnerLoop24:
			cmp  WORD ptr [esi], 0
			je   SkipPixel24

			mov  bl, [esi]
			mov  eax, [Conv16to32Lower + ebx * 4]
			mov  bl, [esi + 1]
			add  eax, [Conv16to32Upper + ebx * 4]

		SkipPixel24:			
			add  esi, 2
			add  edi, 3
			
			dec  ecx
			jne  InnerLoop24
			
			add  esi, srcadd
			add  edi, dstadd

			dec  edx
			jne  OuterLoop24
			
			jmp  Done24

		Reverse24:
			xor  ebx, ebx

			add  esi, [bmwidth]
			mov  eax, [bmwidth]
			shl  eax, 1
			add	 eax, srcadd
			mov  srcadd, eax
	
		RevOuterLoop24:
			mov     ecx, [dpval.swidth]     ; Do two pixels at a time backwords

		RevInnerLoop24:
			cmp  WORD ptr [esi], 0
			je   RevSkipPixel24

			mov  bl, [esi]
			mov  eax, [Conv16to32Lower + ebx * 4]
			mov  bl, [esi + 1]
			add  eax, [Conv16to32Upper + ebx * 4]

		RevSkipPixel24:
			sub  esi, 2
			add  edi, 3
			
			dec  ecx
			jne  RevInnerLoop24
			
			add  esi, srcadd
			add  edi, dstadd
			dec  edx
			jne  RevOuterLoop24

		Done24:
		}
	}

	return TRUE;
}

BOOL Stretch(PSDrawBlock db, PSDrawParam dp)
{
    return FALSE;
}

BOOL TransStretch(PSDrawBlock db, PSDrawParam dp)
{
    return FALSE;
}

// ********** Masked Bitmap Transfer Routines ***********

BOOL Mask(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 1 || dp->dheight < 1) 
		return FALSE;

    SDrawBlock dbval = *db;
    SDrawParam dpval = *dp;

	SETUP_DRAW

	DWORD tmpecx;
    __asm
    {
        cld

  // Load source
        mov  esi, [dbval.source]
        add  esi, srcoff

  // Load destination
        mov  edi, [dbval.dest]
        add  edi, dstoff

  // Load lines
        mov  edx, [dpval.sheight]
        mov  ebx, [dbval.szbuffer]   ; Set ebx to point to Source Z-Buffer

        mov  eax, [dpval.drawmode]

        and  eax, DM_REVERSEHORZ
        jne  reverse

	forloop:
        mov  ecx, [dpval.swidth]
        shr  ecx, 1
	floop:
        mov  [tmpecx], ecx

        mov  ecx, [tmpecx]
		dec  ecx
		jne  floop

		jne  forloop

		dec  edx
		jne  forloop

        jmp  done

	reverse:
        add  esi, bmwidth            ; since were now going backwards
        dec  esi                     ; Start 1 pixel to left
        mov  eax, [dpval.swidth]     ; Add two srcwidths from srcadd
        add  eax, eax
        add  srcadd, eax

	revloop:
        mov  edx, [dpval.swidth]
        mov  [tmpecx], ecx
	rloop:
        mov  ecx, [tmpecx]
		dec  ecx
		jne  rloop

		dec  edx
		jne  revloop

	done:
    }
    return TRUE;
}

BOOL MaskStretch(PSDrawBlock db, PSDrawParam dp)
{
    return FALSE;
}

BOOL Translucent(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 1 || dp->dheight < 1) 
		return FALSE;

    SDrawBlock dbval = *db;
    SDrawParam dpval = *dp;

	SETUP_DRAW

    DWORD tmpebx;
	__asm
    {
        cld

  // Load source
        mov  esi, [dbval.source]
        add  esi, srcoff

  // Load destination
        mov  edi, [dbval.dest]
        add  edi, dstoff

  // Load lines

		xor	 edx, edx
		xor	 ecx, ecx

		mov	 ch, BYTE PTR [dpval.intensity]
		mov	 dh, 31
		sub	 dh, BYTE PTR [dpval.intensity]
        mov  ebx, [dpval.drawmode]

        and  ebx, DM_REVERSEHORZ
        jne  reverse

        mov  ebx, [dpval.sheight]

	forloop:
        mov  [tmpebx], ebx
		mov  ebx, [dpval.swidth]
	
	floop:
		or   dh, dh
		jne  NotZero
		mov  WORD ptr [edi], 0
		jmp	 ZeroIntensity
	
	NotZero:
		mov	 dl, BYTE PTR [edi + 1] 
        mov	 ah, [ColorTableUpperHi + edx]
		mov	 al, [ColorTableUpperLo + edx]
		mov	 dl, BYTE PTR [edi]     
		add	 al, [ColorTableLower + edx]
		adc  ah, 0
		mov	 [edi], ax
		
	ZeroIntensity:
		or   ch, ch
		je	 ZeroIntensity2
		mov	 cl, BYTE PTR [esi + 1]
        mov	 ah, [ColorTableUpperHi + ecx]
		mov	 al, [ColorTableUpperLo + ecx]
		mov	 cl, BYTE PTR [esi]
		add	 al, [ColorTableLower + ecx]
		adc  ah, 0
		add	 [edi], ax

	ZeroIntensity2:
		add	 edi, 2
		add	 esi, 2
							
		dec  ebx
		jne  floop

        add  esi, srcadd
        add  edi, dstadd

        mov  ebx, [tmpebx]
		dec  ebx
		jne  forloop
		jmp  done	

	reverse:
        mov  ebx, [dpval.sheight]
		add  esi, [bmwidth]

		mov  eax, [bmwidth]
		shl  eax, 1
		add	 eax, srcadd
		mov  srcadd, eax

	revloop:
        mov  [tmpebx], ebx
		mov  ebx, [dpval.swidth]

	rloop:
		mov	 dl, BYTE PTR [edi + 1] 
        mov	 ah, [ColorTableUpperHi + edx]
		mov	 al, [ColorTableUpperLo + edx]
		mov	 dl, BYTE PTR [edi]     
		add	 al, [ColorTableLower + edx]
		adc  ah, 0
		mov	 [edi], ax
		
		mov	 cl, BYTE PTR [esi + 1]
        mov	 ah, [ColorTableUpperHi + ecx]
		mov	 al, [ColorTableUpperLo + ecx]
		mov	 cl, BYTE PTR [esi]
		add	 al, [ColorTableLower + ecx]
		adc  ah, 0
		add	 [edi], ax

		add	 edi, 2
		sub	 esi, 2
							
		dec  ebx
		jne  rloop

        add  esi, srcadd
        add  edi, dstadd
		mov  ebx, [tmpebx]
		dec  ebx
		jne  revloop

	done:
	}
    return TRUE;
}

BOOL TransTranslucent(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 1 || dp->dheight < 1) 
		return FALSE;

    SDrawBlock dbval = *db;
    SDrawParam dpval = *dp;

	SETUP_DRAW

    DWORD tmpebx;
	__asm
    {
        cld

  // Load source
        mov  esi, [dbval.source]
        add  esi, srcoff

  // Load destination
        mov  edi, [dbval.dest]
        add  edi, dstoff

  // Load lines

		xor	 edx, edx
		xor	 ecx, ecx

		mov	 ch, BYTE PTR [dpval.intensity]
		mov	 dh, 31
		sub	 dh, BYTE PTR [dpval.intensity]

        mov  ebx, [dpval.drawmode]

        and  ebx, DM_REVERSEHORZ
        jne  reverse

        mov  ebx, [dpval.sheight]

	forloop:
        mov  [tmpebx], ebx
		mov  ebx, [dpval.swidth]
	
	floop:
		cmp  WORD ptr [esi], 0
		je	 ZeroIntensity2

		or   dh, dh
		jne  NotZero
		mov  WORD ptr [edi], 0
		jmp	 ZeroIntensity
	
	NotZero:
		mov	 dl, BYTE PTR [edi + 1] 
        mov	 ah, [ColorTableUpperHi + edx]
		mov	 al, [ColorTableUpperLo + edx]
		mov	 dl, BYTE PTR [edi]     
		add	 al, [ColorTableLower + edx]
		adc  ah, 0
		mov	 [edi], ax
		
	ZeroIntensity:
		or   ch, ch
		je	 ZeroIntensity2
		mov	 cl, BYTE PTR [esi + 1]
        mov	 ah, [ColorTableUpperHi + ecx]
		mov	 al, [ColorTableUpperLo + ecx]
		mov	 cl, BYTE PTR [esi]
		add	 al, [ColorTableLower + ecx]
		adc  ah, 0
		add	 [edi], ax

	ZeroIntensity2:
		add	 edi, 2
		add	 esi, 2
							
		dec  ebx
		jne  floop

        add  esi, srcadd
        add  edi, dstadd

        mov  ebx, [tmpebx]
		dec  ebx
		jne  forloop
		jmp  done	

	reverse:
        mov  ebx, [dpval.sheight]
        add  esi, [bmwidth]

		mov  eax, [bmwidth]
		shl  eax, 1
		add	 eax, srcadd
		mov  srcadd, eax

	revloop:
        mov  [tmpebx], ebx
		mov  ebx, [dpval.swidth]
	rloop:
		mov	 dl, BYTE PTR [edi + 1] 
        mov	 ah, [ColorTableUpperHi + edx]
		mov	 al, [ColorTableUpperLo + edx]
		mov	 dl, BYTE PTR [edi]     
		add	 al, [ColorTableLower + edx]
		adc  ah, 0
		mov	 [edi], ax
		
		mov	 cl, BYTE PTR [esi + 1]
        mov	 ah, [ColorTableUpperHi + ecx]
		mov	 al, [ColorTableUpperLo + ecx]
		mov	 cl, BYTE PTR [esi]
		add	 al, [ColorTableLower + ecx]
		adc  ah, 0
		add	 [edi], ax

		sub	 esi, 2
		add	 edi, 2
							
		dec  ebx
		jne  rloop

        add  esi, srcadd
        add  edi, dstadd

		mov  ebx, [tmpebx]
		dec  ebx
		jne  revloop

	done:
	}
    return TRUE;
}

BOOL TranslucentStretch(PSDrawBlock db, PSDrawParam dp)
{
    return FALSE;
}

BOOL AlphaLighten(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 4 || dp->dheight < 1) 
		return FALSE;

    if (db->srcbitmapflags & BM_COMPRESSED)
	{
		return FALSE;
//		if (dp->sx || dp->sy || db->sbufwidth != dp->swidth || db->sbufheight != dp->sheight)
//			return FALSE;
//	
//		else
//			return AlphaDecompress(db, dp);
	}

	SDrawBlock dbval = *db;
    SDrawParam dpval = *dp;

	SETUP_DRAW
	
	int alphasrcoff = srcoff >> 1;
	int alphasrcadd = srcadd >> 1;

    DWORD tmpecx;
    DWORD tmpesp;
    DWORD outercounter;
    DWORD innercounter;

	__asm
    {
        mov [tmpesp], esp
		cld
        xor  edx, edx

  // Load source
        mov  esi, [dbval.source]
        add  esi, srcoff

  // Load destination
        mov  edi, [dbval.dest]
		add  edi, dstoff

  // Load lines

		mov	 esp, [dbval.alpha]
        add  esp, alphasrcoff

        mov  ecx, [dpval.drawmode]

        and  ecx, DM_REVERSEHORZ
        jne  reverse

		xor  ecx, ecx
		mov  eax, [dpval.sheight]
		mov  [outercounter], eax

	forloop:
		mov  eax, [dpval.swidth]
		mov  [innercounter], eax

	floop:
		xor	 eax, eax
		mov  dh, [esp]
		or   dh, dh
		je   NoDraw

		mov	 dl, BYTE PTR [esi + 1]
		mov	 al, [ColorTableUpperLo + edx]
        mov	 ah, [ColorTableUpperHi + edx]
		mov	 dl, BYTE PTR [esi]
		add	 al, [ColorTableLower + edx]
		adc  ah, 0

		neg	 dh
		add	 dh, 31
		je	 PutIt

		mov	 cl, BYTE PTR [edi + 1] 
		mov	 bl, [IntensityTableUpper + ecx]
		mov  dl, cl
		add	 al, [ColorTableUpperLo + edx]
        adc	 ah, [ColorTableUpperHi + edx]
		mov	 cl, BYTE PTR [edi]     
		add	 bl, [IntensityTableLower + ecx]
		mov	 dl, cl
		add	 al, [ColorTableLower + edx]
		adc  ah, 0
		mov	 cl, ah
		mov	 dh, [IntensityTableUpper + ecx]
		mov  cl, al
		add  dh, [IntensityTableLower + ecx]

		cmp	 dh, bl
		jb	 NoDraw		

	PutIt:
		mov	 [edi], ax

	NoDraw:
		add	 edi, 2
		add	 esi, 2
		inc  esp
							
		dec  [innercounter]
		jne	 floop

        add  esi, srcadd
        add  edi, dstadd
        add  esp, alphasrcadd

		dec  [outercounter]
		jne  forloop

		jmp  done	

	reverse:
        mov  ecx, [dpval.sheight]

        add  esi, [bmwidth]

		mov  eax, [bmwidth]
		shl  eax, 1
		add	 eax, srcadd
		mov  srcadd, eax

		mov  eax, srcadd
		shr  eax, 1
		mov  alphasrcadd, eax

	revloop:
		mov  [tmpecx], ecx
		mov  ecx, [dpval.swidth]

	rloop:
		mov  dh, 31
		sub  dh, [ebx]
		mov	 dl, BYTE PTR [edi + 1] 
        mov	 ah, [ColorTableUpperHi + edx]
		mov	 al, [ColorTableUpperLo + edx]
		mov	 dl, BYTE PTR [edi]     
		add	 al, [ColorTableLower + edx]
		adc  ah, 0
		mov	 [edi], ax
		
		mov  dh, [ebx]
		mov	 dl, BYTE PTR [esi + 1]
        mov	 ah, [ColorTableUpperHi + edx]
		mov	 al, [ColorTableUpperLo + edx]
		mov	 dl, BYTE PTR [esi]
		add	 al, [ColorTableLower + edx]
		adc  ah, 0
		add	 [edi], ax

		add	 edi, 2
		sub	 esi, 2
		dec  ebx					

		dec  ecx
		jne  rloop

        add  esi, srcadd
        add  edi, dstadd
		add  ebx, alphasrcadd

		mov  ecx, [tmpecx]
		dec  ecx
		jne  revloop

	done:
        mov esp, [tmpesp]
	}
    return TRUE;
}

BOOL Alpha(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 4 || dp->dheight < 1) 
		return FALSE;

    if (db->srcbitmapflags & BM_COMPRESSED)
	{
		return FALSE;
//		if (dp->sx || dp->sy || db->sbufwidth != dp->swidth || db->sbufheight != dp->sheight)
//			return FALSE;
//	
//		else
//			return AlphaDecompress(db, dp);
	}

	SDrawBlock dbval = *db;
    SDrawParam dpval = *dp;

	SETUP_DRAW
	
	int alphasrcoff = srcoff >> 1;
	int alphasrcadd = srcadd >> 1;

    DWORD tmpecx;

	__asm
    {
        cld
        xor  edx, edx

  // Load source
        mov  esi, [dbval.source]
        add  esi, srcoff

  // Load destination
        mov  edi, [dbval.dest]
		add  edi, dstoff

  // Load lines

		mov	 ebx, [dbval.alpha]
        add  ebx, alphasrcoff

        mov  ecx, [dpval.drawmode]

        and  ecx, DM_REVERSEHORZ
        jne  reverse

		mov  ecx, [dpval.sheight]

	forloop:
		mov  [tmpecx], ecx
		mov  ecx, [dpval.swidth]

	floop:
		mov  dh, 31
		sub  dh, [ebx]
		jnz  NotZero

		mov  WORD ptr [edi], 0
		jmp  ZeroIntensity1

	NotZero:
		mov	 dl, BYTE PTR [edi + 1] 
        mov	 ah, [ColorTableUpperHi + edx]
		mov	 al, [ColorTableUpperLo + edx]
		mov	 dl, BYTE PTR [edi]     
		add	 al, [ColorTableLower + edx]
		adc  ah, 0
		mov	 [edi], ax

	ZeroIntensity1:
		mov  dh, [ebx]
		or   dh, dh
		je   ZeroIntensity2

		mov	 dl, BYTE PTR [esi + 1]
        mov	 ah, [ColorTableUpperHi + edx]
		mov	 al, [ColorTableUpperLo + edx]
		mov	 dl, BYTE PTR [esi]
		add	 al, [ColorTableLower + edx]
		adc  ah, 0
		add	 [edi], ax

	ZeroIntensity2:
		add	 edi, 2
		add	 esi, 2
		inc  ebx
							
		dec  ecx
		jne  floop

        add  esi, srcadd
        add  edi, dstadd
        add  ebx, alphasrcadd

		mov  ecx, [tmpecx]
		dec  ecx
		jne  forloop

		jmp  done	

	reverse:
        mov  ecx, [dpval.sheight]

        add  esi, [bmwidth]

		mov  eax, [bmwidth]
		shl  eax, 1
		add	 eax, srcadd
		mov  srcadd, eax

		mov  eax, srcadd
		shr  eax, 1
		mov  alphasrcadd, eax

	revloop:
		mov  [tmpecx], ecx
		mov  ecx, [dpval.swidth]

	rloop:
		mov  dh, 31
		sub  dh, [ebx]
		mov	 dl, BYTE PTR [edi + 1] 
        mov	 ah, [ColorTableUpperHi + edx]
		mov	 al, [ColorTableUpperLo + edx]
		mov	 dl, BYTE PTR [edi]     
		add	 al, [ColorTableLower + edx]
		adc  ah, 0
		mov	 [edi], ax
		
		mov  dh, [ebx]
		mov	 dl, BYTE PTR [esi + 1]
        mov	 ah, [ColorTableUpperHi + edx]
		mov	 al, [ColorTableUpperLo + edx]
		mov	 dl, BYTE PTR [esi]
		add	 al, [ColorTableLower + edx]
		adc  ah, 0
		add	 [edi], ax

		add	 edi, 2
		sub	 esi, 2
		dec  ebx					

		dec  ecx
		jne  rloop

        add  esi, srcadd
        add  edi, dstadd
		add  ebx, alphasrcadd

		mov  ecx, [tmpecx]
		dec  ecx
		jne  revloop

	done:
	}
    return TRUE;
}

BOOL Alpha8(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 4 || dp->dheight < 1) 
		return FALSE;

	DWORD *palette = (DWORD *)((BYTE *)db->palette);

    if (db->srcbitmapflags & BM_COMPRESSED)
	{
		return FALSE;
//		if (dp->sx || dp->sy || db->sbufwidth != dp->swidth || db->sbufheight != dp->sheight)
//			return FALSE;
//	
//		else
//			return AlphaDecompress8(db, dp, palette);
	}

	SDrawBlock dbval = *db;
    SDrawParam dpval = *dp;

	SETUP_DRAW
	
	int alphasrcoff = srcoff >> 1;
	int alphasrcadd = srcadd >> 1;

    DWORD tmpecx;
	WORD  pixel16;

	__asm
    {
        cld
        xor  edx, edx

  // Load source
        mov  esi, [dbval.source]
        add  esi, srcoff

  // Load destination
        mov  edi, [dbval.dest]
		add  edi, dstoff

  // Load lines

		mov	 ebx, [dbval.alpha]
        add  ebx, alphasrcoff

        mov  ecx, [dpval.drawmode]

        and  ecx, DM_REVERSEHORZ
        jne  reverse

		mov  ecx, [dpval.sheight]

	forloop:
		mov  [tmpecx], ecx
		mov  ecx, [dpval.swidth]

	floop:
		mov  dh, 31
		sub  dh, [ebx]
		jnz  NotZero

		mov  WORD ptr [edi], 0
		jmp  ZeroIntensity1

	NotZero:
		mov	 dl, BYTE PTR [edi + 1] 
        mov	 ah, [ColorTableUpperHi + edx]
		mov	 al, [ColorTableUpperLo + edx]
		mov	 dl, BYTE PTR [edi]     
		add	 al, [ColorTableLower + edx]
		adc  ah, 0
		mov	 [edi], ax

	ZeroIntensity1:
		mov  al, [esi]
		inc  esi

		and  eax, 000000ffh
		shl  eax, 1

		add  eax, [dbval.palette]
		mov	 ax, [eax]
		mov  [pixel16], ax

		mov  dh, [ebx]
		or   dh, dh
		je   ZeroIntensity2

		mov	 dl, BYTE PTR [pixel16 + 1]
        mov	 ah, [ColorTableUpperHi + edx]

		mov	 al, [ColorTableUpperLo + edx]
		mov	 dl, BYTE PTR [pixel16]

		add	 al, [ColorTableLower + edx]
		adc  ah, 0

		add	 [edi], ax

	ZeroIntensity2:
		add	 edi, 2
		inc  ebx
							
		dec  ecx
		jne  floop

        add  esi, srcadd
        add  edi, dstadd
        add  ebx, alphasrcadd

		mov  ecx, [tmpecx]
		dec  ecx
		jne  forloop

		jmp  done	

	reverse:
        mov  ecx, [dpval.sheight]

        add  esi, [bmwidth]

		mov  eax, [bmwidth]
		shl  eax, 1
		add	 eax, srcadd
		mov  srcadd, eax

		mov  eax, srcadd
		shr  eax, 1
		mov  alphasrcadd, eax

	revloop:
		mov  [tmpecx], ecx
		mov  ecx, [dpval.swidth]

	rloop:
		mov  dh, 31
		sub  dh, [ebx]
		jnz  revNotZero

		mov  WORD ptr [edi], 0
		jmp  revZeroIntensity1

	revNotZero:
		mov	 dl, BYTE PTR [edi + 1] 
        mov	 ah, [ColorTableUpperHi + edx]
		mov	 al, [ColorTableUpperLo + edx]
		mov	 dl, BYTE PTR [edi]     
		add	 al, [ColorTableLower + edx]
		adc  ah, 0
		mov	 [edi], ax

	revZeroIntensity1:
		mov  al, [esi]
		dec  esi

		and  eax, 000000ffh
		shl  eax, 1

		add  eax, [dbval.palette]
		mov	 ax, [eax]
		mov  [pixel16], ax

		mov  dh, [ebx]
		or   dh, dh
		je   revZeroIntensity2

		mov	 dl, BYTE PTR [pixel16 + 1]
        mov	 ah, [ColorTableUpperHi + edx]

		mov	 al, [ColorTableUpperLo + edx]
		mov	 dl, BYTE PTR [pixel16]

		add	 al, [ColorTableLower + edx]
		adc  ah, 0

		add	 [edi], ax

	revZeroIntensity2:
		add	 edi, 2
		dec  ebx
							
		dec  ecx
		jne  rloop

        add  esi, [srcadd]
        add  edi, [dstadd]

        add  ebx, [alphasrcadd]
		mov  ecx, [tmpecx]

		dec  ecx
		jne  revloop

	done:
	}
    return TRUE;
}

BOOL AlphaZ(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 4 || 
		dp->dheight < 1 || db->dzbuffer == NULL) 
		return FALSE;

    if (db->srcbitmapflags & BM_COMPRESSED)
	{
		return FALSE;
//		if (dp->sx || dp->sy || db->sbufwidth != dp->swidth || db->sbufheight != dp->sheight)
//			return FALSE;
//	
//		else
//			return AlphaStaticZDecompress(db, dp);
	}

	SDrawBlock dbval = *db;
    SDrawParam dpval = *dp;

	SETUP_Z_DRAW
	
	int alphasrcoff = srcoff >> 1;
	int alphasrcadd = srcadd >> 1;

    DWORD tmpecx;
    DWORD tmpecx2;

	__asm
    {
        cld
        xor  edx, edx

  // Load source
        mov  esi, [dbval.source]
        add  esi, srcoff

  // Load destination
        mov  edi, [dbval.dest]
		add  edi, dstoff

		mov  ecx, [dbval.dzbuffer]
		add  ecx, dstzoff

  // Load lines

		mov	 ebx, [dbval.alpha]
        add  ebx, alphasrcoff

        mov  eax, [dpval.drawmode]

		and  eax, DM_REVERSEHORZ
        jne  reverse

		mov  eax, [dpval.sheight]
		mov  [tmpecx], eax

	forloop:
		mov  eax, [dpval.swidth]
		mov  [tmpecx2], eax

	floop:
		mov  eax, [ecx]
		cmp  ax, [dpval.zpos]
		jb   ZeroIntensity2 
		
		mov  dh, 31
		sub  dh, [ebx]
		jnz  NotZero

		mov  WORD ptr [edi], 0
		jmp  ZeroIntensity1

	NotZero:
		mov	 dl, BYTE PTR [edi + 1] 
        mov	 ah, [ColorTableUpperHi + edx]
		mov	 al, [ColorTableUpperLo + edx]
		mov	 dl, BYTE PTR [edi]     
		add	 al, [ColorTableLower + edx]
		adc  ah, 0
		mov	 [edi], ax

	ZeroIntensity1:
		mov  dh, [ebx]
		or   dh, dh
		je   ZeroIntensity2

		mov	 dl, BYTE PTR [esi + 1]
        mov	 ah, [ColorTableUpperHi + edx]
		mov	 al, [ColorTableUpperLo + edx]
		mov	 dl, BYTE PTR [esi]
		add	 al, [ColorTableLower + edx]
		adc  ah, 0
		add	 [edi], ax

	ZeroIntensity2:
		add	 edi, 2
		add	 esi, 2
		
		add  ecx, 2
		inc  ebx
							
		dec  [tmpecx2]
		jne  floop

        add  esi, srcadd
        add  edi, dstadd

        add  ecx,  dstzadd
		add  ebx, alphasrcadd
		dec [tmpecx]

		jne  forloop

		jmp  done	

	reverse:
        add  esi, [bmwidth]

		mov  eax, [bmwidth]
		shl  eax, 1
		add	 eax, srcadd
		mov  srcadd, eax

		mov  eax, srcadd
		shr  eax, 1
		mov  alphasrcadd, eax

        mov  eax, [dpval.sheight]
		mov  [tmpecx2], eax

	revloop:
		mov  eax, [dpval.swidth]
		mov  [tmpecx2], eax

	rloop:
		mov  eax, [ecx]
		cmp  ax, [dpval.zpos]
		jb   RevZeroIntensity2 
		
		mov  dh, 31
		sub  dh, [ebx]
		jnz  RevNotZero

		mov  WORD ptr [edi], 0
		jmp  RevZeroIntensity1

	RevNotZero:
		mov	 dl, BYTE PTR [edi + 1] 
        mov	 ah, [ColorTableUpperHi + edx]
		mov	 al, [ColorTableUpperLo + edx]
		mov	 dl, BYTE PTR [edi]     
		add	 al, [ColorTableLower + edx]
		adc  ah, 0
		mov	 [edi], ax
		
	RevZeroIntensity1:
		mov  dh, [ebx]
		or   dh, dh
		je   RevZeroIntensity2

		mov	 dl, BYTE PTR [esi + 1]
        mov	 ah, [ColorTableUpperHi + edx]
		mov	 al, [ColorTableUpperLo + edx]
		mov	 dl, BYTE PTR [esi]
		add	 al, [ColorTableLower + edx]
		adc  ah, 0
		add	 [edi], ax

	RevZeroIntensity2:
		add	 edi, 2
		sub	 esi, 2
		dec  ebx					

		dec  ecx
		jne  rloop

        add  esi, srcadd
        add  edi, dstadd
		add  ebx, alphasrcadd

		mov  ecx, [tmpecx]
		dec  ecx
		jne  revloop

	done:
	}
    return TRUE;
}

BOOL AlphaZ8(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 4 || 
		dp->dheight < 1 || db->dzbuffer == NULL) 
		return FALSE;

	DWORD *palette = (DWORD *)((BYTE *)db->palette);

    if (db->srcbitmapflags & BM_COMPRESSED)
	{
		return FALSE;
//		if (dp->sx || dp->sy || db->sbufwidth != dp->swidth || db->sbufheight != dp->sheight)
//			return FALSE;
//	
//		else
//			return AlphaStaticZDecompress8(db, dp, palette);
	}

	SDrawBlock dbval = *db;
    SDrawParam dpval = *dp;

	SETUP_Z_DRAW
	
	int alphasrcoff = srcoff >> 1;
	int alphasrcadd = srcadd >> 1;

    DWORD tmpecx;
    DWORD tmpecx2;
	WORD  pixel16;

	__asm
    {
        cld
        xor  edx, edx

  // Load source
        mov  esi, [dbval.source]
        add  esi, srcoff

  // Load destination
        mov  edi, [dbval.dest]
		add  edi, dstoff

		mov  ecx, [dbval.dzbuffer]
		add  ecx, dstzoff

  // Load lines

		mov	 ebx, [dbval.alpha]
        add  ebx, alphasrcoff

        mov  eax, [dpval.drawmode]

		and  eax, DM_REVERSEHORZ
        jne  reverse

		mov  eax, [dpval.sheight]
		mov  [tmpecx], eax

	forloop:
		mov  eax, [dpval.swidth]
		mov  [tmpecx2], eax

	floop:
		mov  eax, [ecx]
		cmp  ax, [dpval.zpos]
		jb   ZeroIntensity2 
		
		mov  dh, 31
		sub  dh, [ebx]
		jnz  NotZero

		mov  WORD ptr [edi], 0
		jmp  ZeroIntensity1

	NotZero:
		mov	 dl, BYTE PTR [edi + 1] 
        mov	 ah, [ColorTableUpperHi + edx]
		mov	 al, [ColorTableUpperLo + edx]
		mov	 dl, BYTE PTR [edi]     
		add	 al, [ColorTableLower + edx]
		adc  ah, 0
		mov	 [edi], ax

	ZeroIntensity1:
		mov  al, [esi]
		inc  esi

		and  eax, 000000ffh
		shl  eax, 1

		add  eax, [dbval.palette]
		mov	 ax, [eax]

		mov  [pixel16], ax
		mov  dh, [ebx]

		or   dh, dh
		je   ZeroIntensity2

		mov	 dl, BYTE PTR [pixel16 + 1]
        mov	 ah, [ColorTableUpperHi + edx]
		mov	 al, [ColorTableUpperLo + edx]
		mov	 dl, BYTE PTR [pixel16]
		add	 al, [ColorTableLower + edx]
		adc  ah, 0
		add	 [edi], ax

	ZeroIntensity2:
		add	 edi, 2
		add  ecx, 2

		inc  ebx
		dec  [tmpecx2]

		jne  floop

        add  esi, srcadd
        add  edi, dstadd
		add  ecx, dstzadd

        add  ebx, alphasrcadd
		dec [tmpecx]

		jne  forloop

		jmp  done	

	reverse:
        add  esi, [bmwidth]

		mov  eax, [bmwidth]
		shl  eax, 1
		add	 eax, srcadd
		mov  srcadd, eax

		mov  eax, srcadd
		shr  eax, 1
		mov  alphasrcadd, eax

        mov  eax, [dpval.sheight]
		mov  [tmpecx2], eax

	revloop:
		mov  eax, [dpval.swidth]
		mov  [tmpecx2], eax

	rloop:
		mov  eax, [ecx]
		cmp  ax, [dpval.zpos]
		jb   RevZeroIntensity2 
		
		mov  dh, 31
		sub  dh, [ebx]
		jnz  RevNotZero

		mov  WORD ptr [edi], 0
		jmp  RevZeroIntensity1

	RevNotZero:
		mov	 dl, BYTE PTR [edi + 1] 
        mov	 ah, [ColorTableUpperHi + edx]
		mov	 al, [ColorTableUpperLo + edx]
		mov	 dl, BYTE PTR [edi]     
		add	 al, [ColorTableLower + edx]
		adc  ah, 0
		mov	 [edi], ax
		
	RevZeroIntensity1:
		mov  al, [esi]
		dec  esi

		and  eax, 000000ffh
		shl  eax, 1

		add  eax, [dbval.palette]
		mov	 ax, [eax]

		mov  [pixel16], ax
		mov  dh, [ebx]

		or   dh, dh
		je   RevZeroIntensity2

		mov	 dl, BYTE PTR [pixel16 + 1]
        mov	 ah, [ColorTableUpperHi + edx]
		mov	 al, [ColorTableUpperLo + edx]
		mov	 dl, BYTE PTR [pixel16]
		add	 al, [ColorTableLower + edx]
		adc  ah, 0
		add	 [edi], ax

	RevZeroIntensity2:
		add	 edi, 2
		dec  ebx					

		dec  ecx
		jne  rloop

        add  esi, srcadd
        add  edi, dstadd
		add  ebx, alphasrcadd
		add  ecx, dstzadd

		dec  [tmpecx]
		jne  revloop

	done:
	}
    return TRUE;
}

BOOL AlphaDim(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 4 || dp->dheight < 1) 
		return FALSE;

    if (db->srcbitmapflags & BM_COMPRESSED)
	{
		return FALSE;
//		if (dp->sx || dp->sy || db->sbufwidth != dp->swidth || db->sbufheight != dp->sheight)
//			return FALSE;
//	
//		else
//			return AlphaDecompress(db, dp);
	}

	SDrawBlock dbval = *db;
    SDrawParam dpval = *dp;

	SETUP_DRAW
	
	int alphasrcoff = srcoff >> 1;
	int alphasrcadd = srcadd >> 1;

	BYTE modifier = (BYTE)(31 - min(dp->intensity, 31));

    DWORD tmpecx;
	__asm
    {
        cld
        xor  edx, edx

  // Load source
        mov  esi, [dbval.source]
        add  esi, srcoff

  // Load destination
        mov  edi, [dbval.dest]
		add  edi, dstoff

  // Load lines

		mov	 ebx, [dbval.alpha]
        add  ebx, alphasrcoff

        mov  ecx, [dpval.drawmode]

        and  ecx, DM_REVERSEHORZ
        jne  reverse

		mov  ecx, [dpval.sheight]

	forloop:
		mov  [tmpecx], ecx
		mov  ecx, [dpval.swidth]

	floop:
		mov  dh, 31
		add  dh, [modifier]
		sub  dh, [ebx]
		cmp  dh, 31
		jle  nowrap
		mov  dh, 31				; wrapped around, set to 31

	nowrap:
		or   dh, dh
		jnz  NotZero

		mov  WORD ptr [edi], 0
		jmp  ZeroIntensity1

	NotZero:
		mov	 dl, BYTE PTR [edi + 1] 
        mov	 ah, [ColorTableUpperHi + edx]
		mov	 al, [ColorTableUpperLo + edx]
		mov	 dl, BYTE PTR [edi]     
		add	 al, [ColorTableLower + edx]
		adc  ah, 0
		mov	 [edi], ax

	ZeroIntensity1:
		mov  dh, [ebx]
		sub  dh, [modifier]
		jnc  nowrap2
		mov  dh, 0				; wrapped around

	nowrap2:
		or   dh, dh
		je   ZeroIntensity2

		mov	 dl, BYTE PTR [esi + 1]
        mov	 ah, [ColorTableUpperHi + edx]
		mov	 al, [ColorTableUpperLo + edx]
		mov	 dl, BYTE PTR [esi]
		add	 al, [ColorTableLower + edx]
		adc  ah, 0
		add	 [edi], ax

	ZeroIntensity2:
		add	 edi, 2
		add	 esi, 2
		inc  ebx
							
		dec  ecx
		jne  floop

        add  esi, srcadd
        add  edi, dstadd
        add  ebx, alphasrcadd

		mov  ecx, [tmpecx]
		dec  ecx
		jne  forloop

		jmp  done	

	reverse:
        mov  ecx, [dpval.sheight]

        add  esi, [bmwidth]

		mov  eax, [bmwidth]
		shl  eax, 1
		add	 eax, srcadd
		mov  srcadd, eax

		mov  eax, srcadd
		shr  eax, 1
		mov  alphasrcadd, eax

	revloop:
		mov  [tmpecx], ecx
		mov  ecx, [dpval.swidth]

	rloop:
		mov  dh, 31
		add  dh, [modifier]
		sub  dh, [ebx]
		cmp  dh, 31
		jle  rnowrap
		mov  dh, 31				; wrapped around, set to 31

	rnowrap:
		mov	 dl, BYTE PTR [edi + 1] 
        mov	 ah, [ColorTableUpperHi + edx]
		mov	 al, [ColorTableUpperLo + edx]
		mov	 dl, BYTE PTR [edi]     
		add	 al, [ColorTableLower + edx]
		adc  ah, 0
		mov	 [edi], ax
		
		mov  dh, [ebx]
		sub  dh, [modifier]
		jnc  rnowrap2
		mov  dh, 0				; wrapped around

	rnowrap2:
		mov	 dl, BYTE PTR [esi + 1]
        mov	 ah, [ColorTableUpperHi + edx]
		mov	 al, [ColorTableUpperLo + edx]
		mov	 dl, BYTE PTR [esi]
		add	 al, [ColorTableLower + edx]
		adc  ah, 0
		add	 [edi], ax

		add	 edi, 2
		sub	 esi, 2
		dec  ebx					

		dec  ecx
		jne  rloop

        add  esi, srcadd
        add  edi, dstadd
		add  ebx, alphasrcadd

		mov  ecx, [tmpecx]
		dec  ecx
		jne  revloop

	done:
	}
    return TRUE;
}

BOOL AlphaDimZ(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 4 || dp->dheight < 1
		|| db->dzbuffer == NULL) 
		return FALSE;

    if (db->srcbitmapflags & BM_COMPRESSED)
	{
		return FALSE;
//		if (dp->sx || dp->sy || db->sbufwidth != dp->swidth || db->sbufheight != dp->sheight)
//			return FALSE;
//	
//		else
//			return AlphaDecompress(db, dp);
	}

	SDrawBlock dbval = *db;
    SDrawParam dpval = *dp;

	SETUP_Z_DRAW
	
	int alphasrcoff = srcoff >> 1;
	int alphasrcadd = srcadd >> 1;

	BYTE modifier = (BYTE)(31 - min(dp->intensity, 31));

    DWORD tmpecx;
    DWORD tmpecx2;

	__asm
    {
        cld
        xor  edx, edx

  // Load source
        mov  esi, [dbval.source]
        add  esi, srcoff

  // Load destination
        mov  edi, [dbval.dest]
		add  edi, dstoff

        mov  ecx, [dbval.dzbuffer]
		add  ecx, dstzoff

  // Load lines

		mov	 ebx, [dbval.alpha]
        add  ebx, alphasrcoff

        mov  eax, [dpval.drawmode]

        and  eax, DM_REVERSEHORZ
        jne  reverse

		mov  eax, [dpval.sheight]
		mov  [tmpecx], eax

	forloop:
		mov  eax, [dpval.swidth]
		mov  [tmpecx2], eax

	floop:
		mov  eax, [ecx]
		cmp  ax, [dpval.zpos]
		jg   ZeroIntensity2

		mov  dh, 31
		add  dh, [modifier]
		sub  dh, [ebx]
		cmp  dh, 31
		jle  nowrap
		mov  dh, 31				; wrapped around, set to 31

	nowrap:
		or   dh, dh
		jnz  NotZero

		mov  WORD ptr [edi], 0
		jmp  ZeroIntensity1

	NotZero:
		mov	 dl, BYTE PTR [edi + 1] 
        mov	 ah, [ColorTableUpperHi + edx]
		mov	 al, [ColorTableUpperLo + edx]
		mov	 dl, BYTE PTR [edi]     
		add	 al, [ColorTableLower + edx]
		adc  ah, 0
		mov	 [edi], ax

	ZeroIntensity1:
		mov  dh, [ebx]
		sub  dh, [modifier]
		jnc  nowrap2
		mov  dh, 0				; wrapped around

	nowrap2:
		or   dh, dh
		je   ZeroIntensity2

		mov	 dl, BYTE PTR [esi + 1]
        mov	 ah, [ColorTableUpperHi + edx]
		mov	 al, [ColorTableUpperLo + edx]
		mov	 dl, BYTE PTR [esi]
		add	 al, [ColorTableLower + edx]
		adc  ah, 0
		add	 [edi], ax

	ZeroIntensity2:
		add	 edi, 2
		add	 esi, 2
		add	 ecx, 2
		inc  ebx
							
		dec  [tmpecx2]
		jne  floop

        add  esi, srcadd
        add  edi, dstadd
        add  ebx, alphasrcadd
		add  ecx, dstzadd

		dec [tmpecx]
		jne  forloop

		jmp  done	

	reverse:
        add  esi, [bmwidth]

		mov  eax, [bmwidth]
		shl  eax, 1
		add	 eax, srcadd
		mov  srcadd, eax

		mov  eax, srcadd
		shr  eax, 1
		mov  alphasrcadd, eax

        mov  eax, [dpval.sheight]
		mov  [tmpecx], eax

	revloop:
		mov  eax, [dpval.swidth]
		mov  [tmpecx2], eax

	rloop:
		mov  eax, [ecx]
		cmp  ax, [dpval.zpos]
		jg   RevZeroIntensity2

		mov  dh, 31
		add  dh, [modifier]
		sub  dh, [ebx]
		cmp  dh, 31
		jle  rnowrap
		mov  dh, 31				; wrapped around, set to 31

	rnowrap:
		or   dh, dh
		jnz  RevNotZero

		mov  WORD ptr [edi], 0
		jmp  RevZeroIntensity1

	RevNotZero:
		mov	 dl, BYTE PTR [edi + 1] 
        mov	 ah, [ColorTableUpperHi + edx]
		mov	 al, [ColorTableUpperLo + edx]
		mov	 dl, BYTE PTR [edi]     
		add	 al, [ColorTableLower + edx]
		adc  ah, 0
		mov	 [edi], ax
		
	
	RevZeroIntensity1:
		mov  dh, [ebx]
		sub  dh, [modifier]
		jnc  rnowrap2
		mov  dh, 0				; wrapped around

	rnowrap2:
		or   dh, dh
		je   RevZeroIntensity2

		mov	 dl, BYTE PTR [esi + 1]
        mov	 ah, [ColorTableUpperHi + edx]
		mov	 al, [ColorTableUpperLo + edx]
		mov	 dl, BYTE PTR [esi]
		add	 al, [ColorTableLower + edx]
		adc  ah, 0
		add	 [edi], ax

	RevZeroIntensity2:
		add	 edi, 2
		sub	 esi, 2
		dec  ebx					

		dec  [tmpecx2]
		jne  rloop

        add  esi, srcadd
        add  edi, dstadd
		add  ebx, alphasrcadd
		add  ecx, dstzadd

		dec  [tmpecx]
		jne  revloop

	done:
	}
    return TRUE;
}

// This routine is designed for doing spider webs and glows: it draws an image with
// z and alpha info, but no bitmap (it just uses solid color for the pixel color).
BOOL AlphaDimZNoBitmap(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 4 || dp->dheight < 1 || db->dzbuffer == NULL) 
		return FALSE;

    if (db->srcbitmapflags & BM_COMPRESSED)
		return FALSE;

	SDrawBlock dbval = *db;
    SDrawParam dpval = *dp;

	SETUP_Z_DRAW
	
	int alphasrcoff = srcoff >> 1;
	int alphasrcadd = srcadd >> 1;
	int alphawidth = bmwidth >> 1;

	BYTE modifier = (BYTE)(31 - min(dp->intensity, 31));

    DWORD tmpecx;
    DWORD tmpecx2;

	BYTE highbyte = (BYTE)((dp->color >> 8) & 0xff);
	BYTE lowbyte = (BYTE)(dp->color & 0xff);

	__asm
    {
        cld
        xor  edx, edx

  // Load source zbf
        mov  esi, [dbval.szbuffer]
        add  esi, srczoff

  // Load destination
        mov  edi, [dbval.dest]
		add  edi, dstoff

        mov  ecx, [dbval.dzbuffer]
		add  ecx, dstzoff

  // Load lines

		mov	 ebx, [dbval.alpha]
        add  ebx, alphasrcoff

        mov  eax, [dpval.drawmode]

        and  eax, DM_REVERSEHORZ
        jne  reverse

		mov  eax, [dpval.sheight]
		mov  [tmpecx], eax

	forloop:
		mov  eax, [dpval.swidth]
		mov  [tmpecx2], eax

	floop:
		mov  ax, [esi]
		cmp  ax, 0x7f7f				; check keycolor
		je   ZeroIntensity2

		add  ax, [dpval.zpos]		; check against dest zbuf
		cmp  [ecx], ax
		jb   ZeroIntensity2

		mov  [ecx], ax				; set it into the zbuffer

		mov  dh, 31
		add  dh, [modifier]
		sub  dh, [ebx]
		cmp  dh, 31
		jle  nowrap
		mov  dh, 31				; wrapped around, set to 31

	nowrap:
		or   dh, dh
		jnz  NotZero

		mov  WORD ptr [edi], 0
		jmp  ZeroIntensity1

	NotZero:
		mov	 dl, BYTE PTR [edi + 1] 
        mov	 ah, [ColorTableUpperHi + edx]
		mov	 al, [ColorTableUpperLo + edx]
		mov	 dl, BYTE PTR [edi]     
		add	 al, [ColorTableLower + edx]
		adc  ah, 0
		mov	 [edi], ax

	ZeroIntensity1:
		mov  dh, [ebx]
		sub  dh, [modifier]
		jnc  nowrap2
		mov  dh, 0				; wrapped around

	nowrap2:
		or   dh, dh
		je   ZeroIntensity2

		mov	 dl, highbyte
        mov	 ah, [ColorTableUpperHi + edx]
		mov	 al, [ColorTableUpperLo + edx]
		mov	 dl, lowbyte
		add	 al, [ColorTableLower + edx]
		adc  ah, 0
		add	 [edi], ax

	ZeroIntensity2:
		add	 edi, 2
		add	 esi, 2
		add  ecx, 2
		inc  ebx
							
		dec  [tmpecx2]
		jne  floop

        add  esi, srczadd
        add  edi, dstadd
		add  ecx, dstzadd
        add  ebx, alphasrcadd

		dec [tmpecx]
		jne  forloop

		jmp  done	

	reverse:
		add  esi, [bmwidth]
		add  ebx, [alphawidth]

		mov  eax, [dpval.sheight]
		mov  [tmpecx], eax

	revforloop:
		mov  eax, [dpval.swidth]
		mov  [tmpecx2], eax

	revfloop:
		sub  esi, 2
		dec  ebx

		mov  ax, [esi]
		cmp  ax, 0x7f7f				; check keycolor
		je   revZeroIntensity2

		add  ax, [dpval.zpos]		; check against dest zbuf
		cmp  [ecx], ax
		jb   revZeroIntensity2

		mov  [ecx], ax				; set it into the zbuffer

		mov  dh, 31
		add  dh, [modifier]
		sub  dh, [ebx]
		cmp  dh, 31
		jle  revnowrap
		mov  dh, 31				; wrapped around, set to 31

	revnowrap:
		or   dh, dh
		jnz  revNotZero

		mov  WORD ptr [edi], 0
		jmp  revZeroIntensity1

	revNotZero:
		mov	 dl, BYTE PTR [edi + 1] 
        mov	 ah, [ColorTableUpperHi + edx]
		mov	 al, [ColorTableUpperLo + edx]
		mov	 dl, BYTE PTR [edi]     
		add	 al, [ColorTableLower + edx]
		adc  ah, 0
		mov	 [edi], ax

	revZeroIntensity1:
		mov  dh, [ebx]
		sub  dh, [modifier]
		jnc  revnowrap2
		mov  dh, 0				; wrapped around

	revnowrap2:
		or   dh, dh
		je   revZeroIntensity2

		mov	 dl, highbyte
        mov	 ah, [ColorTableUpperHi + edx]
		mov	 al, [ColorTableUpperLo + edx]
		mov	 dl, lowbyte
		add	 al, [ColorTableLower + edx]
		adc  ah, 0
		add	 [edi], ax

	revZeroIntensity2:
		add	 edi, 2
		add  ecx, 2
							
		dec  [tmpecx2]
		jne  revfloop

		add  esi, bmwidth
		add  esi, bmwidth
        add  esi, srczadd

		add  ebx, alphawidth
		add  ebx, alphawidth
        add  ebx, alphasrcadd

        add  edi, dstadd
		add  ecx, dstzadd

		dec [tmpecx]
		jne  revforloop

	done:
	}
    return TRUE;
}

BOOL Alpha32(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 4 || dp->dheight < 1) 
		return FALSE;

    if (db->srcbitmapflags & BM_COMPRESSED)
	{
		if (dp->sx || dp->sy || db->sbufwidth != dp->swidth || db->sbufheight != dp->sheight)
			return FALSE;
	
		else
			return FALSE;
	}

	SDrawBlock dbval = *db;
    SDrawParam dpval = *dp;

	SETUP_DRAW
	
	int alphasrcoff = srcoff >> 1;
	int alphasrcadd = srcadd >> 1;

	DWORD tmpecx;
	DWORD tmpecx2;
	DWORD color;

	__asm
    {
        cld
        xor  edx, edx

  // Load source
        mov  esi, [dbval.source]
        add  esi, srcoff

  // Load destination
        mov  edi, [dbval.dest]
		add  edi, dstoff

  // Load lines

		mov	 ebx, [dbval.alpha]
        add  ebx, alphasrcoff

        mov  ecx, [dpval.drawmode]

        and  ecx, DM_REVERSEHORZ
        jne  reverse

		mov  eax, [dpval.sheight]
		mov  [tmpecx], eax

	forloop:
		mov  eax, [dpval.swidth]
		mov  [tmpecx2], eax

	floop:
		mov  dh, 31
		sub  dh, [ebx]
		jnz  NotZero

		mov  DWORD ptr[edi], DWORD ptr 0x00000000
		jmp  ZeroIntensity1

	NotZero:
		mov  eax, [edi]
		shr  eax, 16

		mov	 dl, al						// Do Blue
        mov	 cl, [ColorTable + edx]

		mov  ch, ah
		shl  ecx, 16
        
		mov  eax, [edi]
		mov	 dl, al						// Do Green

		mov	 cl, [ColorTable + edx]
		mov	 dl, ah						// Do Red

        mov	 ch, [ColorTable + edx]
		mov  [edi], ecx

	ZeroIntensity1:
		mov  dh, [ebx]
		or   dh, dh

		je   ZeroIntensity2

		xor  ecx, ecx
		mov  cl, [esi]

		mov  eax, Conv16to32Lower[ecx]
		mov  cl, [esi + 1]

		add  eax, Conv16to32Upper[ecx]
		mov  [color], eax

		shr  eax, 16

		mov	 dl, al						// Do Green
        mov	 cl, [ColorTable + edx]

		xor  ch, ch
		shl  ecx, 16

		mov  eax, [color] 
		mov	 dl, al						// Do Red

        mov	 cl, [ColorTable + edx]
		mov	 dl, ah						// Do Blue

        mov	 ch, [ColorTable + edx]
		add  [edi], ecx

	ZeroIntensity2:
		add  esi, 2
		add  edi, 4

		inc  ebx
		dec  [tmpecx2]

		jne  floop
        add  esi, srcadd

        add  edi, dstadd
        add  ebx, alphasrcadd

		dec  [tmpecx]
		jne  forloop

		jmp  done	

	reverse:
        add  esi, [bmwidth]

		mov  eax, [bmwidth]
		shl  eax, 1

		add	 eax, srcadd
		mov  srcadd, eax

		mov  eax, srcadd
		shr  eax, 1

		mov  alphasrcadd, eax

        mov  eax, [dpval.sheight]
		mov  [tmpecx], eax

	revloop:
		mov  eax, [dpval.swidth]
		mov  [tmpecx2], eax

	rloop:
		mov  dh, 31
		sub  dh, [ebx]
		jnz  revNotZero

		mov  DWORD ptr [edi], DWORD ptr 0x00000000
		jmp  revZeroIntensity1

	revNotZero:
		mov  eax, [edi]
		shr  eax, 16

		mov	 dl, al						// Do Blue
        mov	 cl, [ColorTable + edx]

		mov  ch, ah
		shl  ecx, 16

		mov  eax, [edi]
		mov	 dl, BYTE PTR [edi + 2]		// Do Green

        mov	 cl, [ColorTable + edx]

		mov	 dl, ah						// Do Red
        mov	 cl, [ColorTable + edx]

		mov  [edi], ecx

	revZeroIntensity1:
		mov  dh, [ebx]
		or   dh, dh

		je   revZeroIntensity2

		xor  ecx, ecx
		mov  cl, [esi]

		mov  eax, Conv16to32Lower[ecx]
		mov  cl, [esi + 1]

		add  eax, Conv16to32Upper[ecx]

		mov  [color], eax

		shr  eax, 16

		mov	 dl, al						// Do Blue
        mov	 cl, [ColorTable + edx]

		xor  ch, ch
		shl  ecx, 16

		mov  eax, [color]
		mov	 dl, al						// Do Red

        mov	 cl, [ColorTable + edx]
		mov	 dl, ah						// Do Blue

        mov	 ch, [ColorTable + edx]

		add  [edi], ecx

	revZeroIntensity2:
		sub	 esi, 2
		add	 edi, 4
		dec  ebx					

		dec  ecx
		jne  rloop

        add  esi, srcadd
        add  edi, dstadd
		add  ebx, alphasrcadd

		mov  ecx, [tmpecx]
		dec  ecx
		jne  revloop

	done:
	}
    
	return TRUE;
}

BOOL Alias(PSDrawBlock db, PSDrawParam dp)
// put alias data, which is stored in RLE with end of line codes
{
	if (!TransPut(db, dp))
		return FALSE;

    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 1 || dp->dheight < 1) 
		return FALSE;

    if (!db->alias || dp->swidth < 1 || dp->sheight < 1 ||
					  dp->dwidth < 1 || dp->dheight < 1)
		return FALSE;
	
    SDrawBlock dbval = *db;
    SDrawParam dpval = *dp;

	SETUP_DRAW

	// orient dstadd for byte maneuvering
	dstadd = db->dstride << 1;

	// endptr tells where to end the drawing for clipping bottom edge
	BYTE *endptr = ((BYTE *)db->dest) + dstoff + (dp->sheight * dstadd);
	// the next two are for left and right clipping
	BYTE *leftptr = ((BYTE *)db->dest) + dstoff;
	BYTE *rightptr = leftptr + (dp->swidth << 1);

	DWORD nextdestrow;

	__asm
	{
		mov	 esi, [dbval.alias]				// load source alias data
		mov	 edi, [dbval.dest]				// load destination
		add	 edi, dstoff					// skip to start location in dest buf
		sub	 edi, [dpval.sx]				// handle left clipping internally
		sub	 edi, [dpval.sx]				// do it twice for 2 byte pixels
		mov	 nextdestrow, edi				// hang on to the start of the row
		mov	 edx, 0							// clear dx

		mov	 eax, [dpval.drawmode]
		and	 eax, DM_NOCLIP					// do we need to bother with clipping?
		jnz	 setuprun						// if so, jump straight in

		// do top clipping
		mov	 ecx, [dpval.sy]				// how many lines to clip from top
	topclip:
		or	 ecx, ecx
		jz	 setuprun
		dec	 ecx

	topskiprun:
		mov	 al, [esi]						// load alias code
		inc	 esi

		cmp	 al, AL_EOL						// only interested in EOLs
		je	 topclip

	//topdatarun:
		and	 eax, eax
		mov	 al, [esi]

		inc	 esi

		add	 esi, eax
		add	 esi, eax
		add	 esi, eax						// add (al * 3) to esi
		jmp	 topskiprun	  

		// do the aliasing for non-clipped portion	
	setuprun:
		mov	 cl, [esi]						// load up run code
		inc	 esi

		cmp	 cl, AL_EOL						// check for end of line
		je	 nextline
		
	skiprun:
		or	 cl, cl							// once skip complete, do data run
		jz	 setupdatarun
		
		add	 edi, 2							// skip the pixel in the dest buf
		dec	 cl								// decrement run counter
		jmp	 skiprun

	setupdatarun:
		mov	 cl, [esi]						// get run code
		inc	 esi

	datarun:
		or 	 cl, cl							// check for remaining pixels
		jz	 setuprun

		mov	 bx, [esi]						// word pixel (color)
		add	 esi, 2
		mov	 ch, [esi]						// byte alias (intensity)
		inc  esi

		cmp	 edi, leftptr					// check for left clipping
		jl	 clipedge
		cmp	 edi, rightptr					// check for right clipping
		jge	 clipedge

		// pixel lookup and transfer
		mov  dh, 31
		sub  dh, ch							// reverse intensity (0 = 100%, 31 = 0%)
		mov	 dl, BYTE PTR [edi + 1]			// get background pixel
        mov	 ah, [ColorTableUpperHi + edx]	// color table lookup
		mov	 al, [ColorTableUpperLo + edx]
		mov	 dl, BYTE PTR [edi]				// other byte (two byte pixels)
		add	 al, [ColorTableLower + edx]
		adc  ah, 0
		mov	 [edi], ax
		
		mov  dh, ch							// load intensity
		mov	 dl, bh							// source pixel value
        mov	 ah, [ColorTableUpperHi + edx]	// lookup
		mov	 al, [ColorTableUpperLo + edx]
		mov	 dl, bl							// do other byte
		add	 al, [ColorTableLower + edx]
		adc  ah, 0
		add	 [edi], ax						// put the pixel

	clipedge:
		add	 edi, 2							// increment the background pointer
		dec	 cl								// decrement run counter
		jmp	 datarun

	nextline:
		mov	 edi, leftptr					// borrow edi for a sec
		add	 edi, dstadd
		mov	 leftptr, edi

		mov	 edi, rightptr					// borrow edi for a sec
		add	 edi, dstadd
		mov	 rightptr, edi

		mov	 edi, nextdestrow				// reset to start of line
		add	 edi, dstadd					// now jump to new line
		mov	 nextdestrow, edi				// and save that for next time
			  		
		cmp	 edi, endptr					// check for bottom clip
		jge	 done

		mov	 cl, [esi]						// load up run code
		inc	 esi
			 
		cmp	 cl, AL_EOL						// blank line..
		je	 nextline

		cmp	 cl, AL_EOD						// check for end of data
		jne	 skiprun						// do the line

	done:
		// if we get to here, EOD was reached...we're done
	}

    return TRUE;
}

BOOL AliasColor(PSDrawBlock db, PSDrawParam dp)
// put alias data, which is stored in RLE with end of line codes
{
	if (!TransPutColor(db, dp))
		return FALSE;

    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 1 || dp->dheight < 1) 
		return FALSE;

    if (!db->alias || dp->swidth < 1 || dp->sheight < 1 ||
					  dp->dwidth < 1 || dp->dheight < 1)
		return FALSE;
	
    SDrawBlock dbval = *db;
    SDrawParam dpval = *dp;

	SETUP_DRAW

	// orient dstadd for byte maneuvering
	dstadd = db->dstride << 1;

	// endptr tells where to end the drawing for clipping bottom edge
	BYTE *endptr = ((BYTE *)db->dest) + dstoff + (dp->sheight * dstadd);
	// the next two are for left and right clipping
	BYTE *leftptr = ((BYTE *)db->dest) + dstoff;
	BYTE *rightptr = leftptr + (dp->swidth << 1);

	DWORD nextdestrow;
	WORD color = (WORD)dp->color;
	BYTE colorhi = color >> 8;
	BYTE colorlo = color & 0xff;

	__asm
	{
		mov	 esi, [dbval.alias]				// load source alias data
		mov	 edi, [dbval.dest]				// load destination
		add	 edi, dstoff					// skip to start location in dest buf
		sub	 edi, [dpval.sx]				// handle left clipping internally
		sub	 edi, [dpval.sx]				// do it twice for 2 byte pixels
		mov	 nextdestrow, edi				// hang on to the start of the row
		mov	 edx, 0							// clear dx

		mov	 eax, [dpval.drawmode]
		and	 eax, DM_NOCLIP					// do we need to bother with clipping?
		jnz	 setuprun						// if so, jump straight in

		// do top clipping
		mov	 ecx, [dpval.sy]				// how many lines to clip from top
	topclip:
		or	 ecx, ecx
		jz	 setuprun
		dec	 ecx

	topskiprun:
		mov	 al, [esi]						// load alias code
		inc	 esi

		cmp	 al, AL_EOL						// only interested in EOLs
		je	 topclip

	//topdatarun:
		and	 eax, eax
		mov	 al, [esi]

		inc	 esi

		add	 esi, eax
		add	 esi, eax
		add	 esi, eax						// add (al * 3) to esi
		jmp	 topskiprun	  

		// do the aliasing for non-clipped portion	
	setuprun:
		mov	 cl, [esi]						// load up run code
		inc	 esi

		cmp	 cl, AL_EOL						// check for end of line
		je	 nextline
		
	skiprun:
		or	 cl, cl							// once skip complete, do data run
		jz	 setupdatarun
		
		add	 edi, 2							// skip the pixel in the dest buf
		dec	 cl								// decrement run counter
		jmp	 skiprun

	setupdatarun:
		mov	 cl, [esi]						// get run code
		inc	 esi

	datarun:
		or 	 cl, cl							// check for remaining pixels
		jz	 setuprun

		mov	 bx, [esi]						// word pixel (color)
		add	 esi, 2
		mov	 ch, [esi]						// byte alias (intensity)
		inc  esi

		cmp	 edi, leftptr					// check for left clipping
		jl	 clipedge
		cmp	 edi, rightptr					// check for right clipping
		jge	 clipedge

		// pixel lookup and transfer
		mov  dh, 31
		sub  dh, ch							// reverse intensity (0 = 100%, 31 = 0%)
		mov	 dl, BYTE PTR [edi + 1]			// get background pixel
        mov	 ah, [ColorTableUpperHi + edx]	// color table lookup
		mov	 al, [ColorTableUpperLo + edx]
		mov	 dl, BYTE PTR [edi]				// other byte (two byte pixels)
		add	 al, [ColorTableLower + edx]
		adc  ah, 0
		mov	 [edi], ax
		
		mov  dh, ch							// load intensity
		mov	 dl, colorhi
        mov	 ah, [ColorTableUpperHi + edx]	// lookup
		mov	 al, [ColorTableUpperLo + edx]
		mov	 dl, colorlo					// do other byte
		add	 al, [ColorTableLower + edx]
		adc  ah, 0
		add	 [edi], ax						// put the pixel

	clipedge:
		add	 edi, 2							// increment the background pointer
		dec	 cl								// decrement run counter
		jmp	 datarun

	nextline:
		mov	 edi, leftptr					// borrow edi for a sec
		add	 edi, dstadd
		mov	 leftptr, edi

		mov	 edi, rightptr					// borrow edi for a sec
		add	 edi, dstadd
		mov	 rightptr, edi

		mov	 edi, nextdestrow				// reset to start of line
		add	 edi, dstadd					// now jump to new line
		mov	 nextdestrow, edi				// and save that for next time
			  		
		cmp	 edi, endptr					// check for bottom clip
		jge	 done

		mov	 cl, [esi]						// load up run code
		inc	 esi
			 
		cmp	 cl, AL_EOL						// blank line..
		je	 nextline

		cmp	 cl, AL_EOD						// check for end of data
		jne	 skiprun						// do the line

	done:
		// if we get to here, EOD was reached...we're done
	}

    return TRUE;
}

BOOL Alias32(PSDrawBlock db, PSDrawParam dp)
// Alias for 32 bit buffers.
{
	return FALSE;
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 1 || dp->dheight < 1) 
		return FALSE;

    if (!db->alias || dp->swidth < 1 || dp->sheight < 1 ||
					  dp->dwidth < 1 || dp->dheight < 1)
		return FALSE;
	
    SDrawBlock dbval = *db;
    SDrawParam dpval = *dp;

	SETUP_DRAW

	// orient dstadd for byte maneuvering
	dstadd = db->dstride << 2;
	int smalldstoff = dstoff >> 1;
	int smalldstadd = dstadd >> 1;

	// endptr tells where to end the drawing for clipping bottom edge
	BYTE *endptr = ((BYTE *)db->dest) + dstoff + (dp->sheight * dstadd);
	// the next two are for left and right clipping
	BYTE *leftptr = ((BYTE *)db->dest) + dstoff;
	BYTE *rightptr = leftptr + (dp->swidth << 2);

	DWORD nextdestrow, nextzbufrow, nextnormrow;
	DWORD tmpesp;

	__asm
	{
		mov  [tmpesp], esp					// Save esp
		mov	 esi, [dbval.alias]				// load source alias data
		mov	 edi, [dbval.dest]				// load destination
		add	 edi, dstoff					// skip to start location in dest buf
		sub	 edi, [dpval.sx]				// handle left clipping internally
		sub	 edi, [dpval.sx]				// do it twice for 2 byte pixels
		sub	 edi, [dpval.sx]				// do it twice for 2 byte pixels
		sub	 edi, [dpval.sx]				// do it twice for 2 byte pixels
		mov	 nextdestrow, edi				// hang on to the start of the row

		mov  esp, [dbval.dzbuffer]			// esp is dest zbuffer
		add  esp, [smalldstoff]				// go to start in zbuffer
		sub	 esp, [dpval.sx]				// handle left clipping internally
		sub	 esp, [dpval.sx]				// do it twice for 2 byte pixels
		mov	 nextzbufrow, esp				// hang on to the start of the row

		mov  edx, 0							// we'll need high word of dx clear

		mov	 eax, [dpval.drawmode]
		and	 eax, DM_NOCLIP					// do we need to bother with clipping?
		jnz	 startdraw						// if so, jump straight in

		// do top clipping
		mov	 ecx, [dpval.sy]				// how many lines to clip from top
	topclip:
		or	 ecx, ecx
		jz	 setuprun
		dec	 ecx

	topskiprun:
		mov	 al, [esi]						// load alias code
		inc	 esi

		cmp	 al, AL_EOL						// only interested in EOLs
		je	 topclip

	//topdatarun:
		mov	 al, [esi]
		inc	 esi

		add	 esi, eax
		add	 esi, eax
		add	 esi, eax
		add	 esi, eax
		add	 esi, eax
		add	 esi, eax
		add	 esi, eax						// add (al * 7) to esi
		jmp	 topskiprun	  

	startdraw:
		mov  ecx, [dbval.dnormals]
		add  ecx, [smalldstoff]				// go to start in normal buffer
		sub	 ecx, [dpval.sx]				// handle left clipping internally
		sub	 ecx, [dpval.sx]
		mov	 nextnormrow, ecx				// hang on to the start of the row

		// do the aliasing for non-clipped portion	
	setuprun:
		mov	 ah, [esi]						// load up run code
		inc	 esi

		cmp	 ah, AL_EOL						// check for end of line
		je	 nextline
		
	skiprun:
		or	 ah, ah							// once skip complete, do data run
		jz	 setupdatarun
		
		add	 edi, 4							// skip the pixel in the dest buf
		add  esp, 2							// skip the pixel in the dest zbuffer
		add  ecx, 2							// skip the pixel in the dest normals
		dec	 ah								// decrement run counter
		jmp	 skiprun

	setupdatarun:
		mov	 ah, [esi]						// get run code
		inc	 esi

	datarun:
		or 	 ah, ah							// check for remaining pixels
		jz	 setuprun

		cmp	 edi, leftptr					// check for left clipping
		jl	 clipedge
		cmp	 edi, rightptr					// check for right clipping
		jge	 clipedge

		// check zbuffer
		mov  bx, WORD PTR [esi + 3]
		add  bx, [dpval.zpos]
		cmp  [esp], bx
		jb  clipedge

		mov  [esp], bx

//		mov  ax, [esp]
//		mov	 ecx, DWORD PTR [dstnormal]
//		mov  WORD PTR [ecx], ax

		// pixel lookup and transfer
		mov  dh, 31
		sub  dh, [esi + 2]
		jnz  NotZero

		mov  DWORD ptr [edi], 0
		jmp  ZeroIntensity1

	NotZero:
		// Translucent pixel transfer
		mov	 dl, BYTE PTR [edi + 1]		// Do Blue
        mov	 al, [ColorTable + edx]
		mov  [edi + 1], al

		mov	 dl, BYTE PTR [edi + 2]		// Do Green
        mov	 al, [ColorTable + edx]
		mov  [edi + 2], al

		mov	 dl, BYTE PTR [edi + 3]		// Do Red
        mov	 al, [ColorTable + edx]
		mov  [edi + 3], al

	ZeroIntensity1:
		mov  dh, [esi + 2]
		or   dh, dh
		je   ZeroIntensity2

		// Convert 16 bit to 32 bit
		mov  dl, [esi]
		mov  ebx, [Conv16to32Lower + edx * 4]

		mov  dl, [esi + 1]
		add  ebx, [Conv16to32Upper + edx * 4]

		// Translucent pixel transfer
		mov	 dl, bh						// Blue
        mov	 al, [ColorTable + edx]
		add  [edi + 1], al

		shr  ebx, 16					// get at the upper word of ebx
		mov	 dl, bl						// Green
        mov	 al, [ColorTable + edx]
		add  [edi + 2], al

		mov	 dl, bh						// Red
        mov	 al, [ColorTable + edx]
		add  [edi + 3], al

	ZeroIntensity2:
	clipedge:
		add  esi, 7							// increment alias buffer
		add	 edi, 4							// increment the background pointer
		add  esp, 2							// increment zbuffer
		add  ecx, 2							// increment normal buffer
		dec	 ah								// decrement run counter
		jmp	 datarun

	nextline:
		mov	 edi, leftptr					// borrow edi for a sec
		add	 edi, dstadd
		mov	 leftptr, edi

		mov	 edi, rightptr					// borrow edi for a sec
		add	 edi, dstadd
		mov	 rightptr, edi

		mov	 esp, nextzbufrow				// reset to start of line
		add	 esp, smalldstadd				// now jump to new line
		mov	 nextzbufrow, esp				// and save that for next time

		mov	 ecx, nextnormrow				// reset to start of line
		add	 ecx, smalldstadd				// now jump to new line
		mov	 nextnormrow, ecx				// and save that for next time

		mov	 edi, nextdestrow				// reset to start of line
		add	 edi, dstadd					// now jump to new line
		mov	 nextdestrow, edi				// and save that for next time
			  		
		cmp	 edi, endptr					// check for bottom clip
		jge	 done

		mov	 ah, [esi]						// load up run code
		inc	 esi
			 
		cmp	 ah, AL_EOL						// blank line..
		je	 nextline

		cmp	 ah, AL_EOD						// check for end of data
		jne	 skiprun						// do the line

	done:
		// if we get to here, EOD was reached...we're done
		mov esp, [tmpesp]
	}

    return TRUE;
}

BOOL DrawSelected8(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 1 || dp->dheight < 1) 
		return FALSE;

    if (db->szbuffer == NULL || db->dzbuffer == NULL)
		return FALSE;

	DWORD *palette = (DWORD *)((BYTE *)db->palette);

	if (db->srcbitmapflags & BM_COMPRESSED)
	{
		return FALSE;
//		if (dp->sx || dp->sy || db->sbufwidth != dp->swidth || 
//			db->sbufheight != dp->sheight)
//			return ClipZBufferDecompress8(db, dp, palette);
//		
//		else
//			return ZBufferDecompress8(db, dp, palette);
	}

	SDrawBlock dbval = *db;
    SDrawParam dpval = *dp;

	SETUP_Z_DRAW

	DWORD lastpixel;

	__asm
	{
		mov	 edi, [dbval.dest]		; Point EDI to destination
		add  edi, [dstoff]			; Adjusts EDI for offset
 
		mov  ebx, [dbval.szbuffer]	; Points EBX to Src zbuffer
		add  ebx, [srczoff]			; Adjusts EDX for offset

		mov  edx, [dbval.dzbuffer]  ; Points EDX to	Dest zbuffer
		add  edx, [dstzoff]			; Adjusts EDX for offset

		cld							; Forward direction

		mov  esi, [dpval.sheight]

	OuterLoop:
		mov  ecx, [dpval.swidth]	; ECX contains number of rows to do.
		mov  [lastpixel], 0

	InnerLoop:
		mov  ax, [ebx]
		cmp  ax, 7f7fh
		je   RightSide

		add  ax, [dpval.zpos]
		cmp  [edx], ax
		jb   RightSide

		cmp  [lastpixel], 0
		jne  SkipRaw

		mov  [lastpixel], 1
		cmp  ecx, [dpval.swidth]
		je   SkipRaw				; when we're the left edge don't draw

		mov  eax, [dpval.color]
		mov  [edi], ax
		jmp  SkipRaw

	RightSide:
		cmp  [lastpixel], 0
		je   Skip

		cmp  ecx, 1
		je   Skip					; when we're on the right edge don't draw

		mov  eax, [dpval.color]
		mov  [edi-2], ax

	Skip:
		mov [lastpixel], 0

	SkipRaw:
		add	 edi, 2
		add  ebx, 2
		add  edx, 2

		dec  ecx
		jne  InnerLoop

		add  edi, dstadd
		add  ebx, srczadd
		add  edx, dstzadd

		dec  esi
		jne  OuterLoop
	}

	return TRUE;
}

BOOL DrawSelected(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 1 || dp->dheight < 1) 
		return FALSE;

    if (db->szbuffer == NULL || db->dzbuffer == NULL)
		return FALSE;

	if (db->srcbitmapflags & BM_COMPRESSED)
	{
		return FALSE;
//		if (dp->sx || dp->sy || db->sbufwidth != dp->swidth || 
//			db->sbufheight != dp->sheight)
//			return ClipZBufferDecompress(db, dp);
//		
//		else
//			return ZBufferDecompress(db, dp);
	}

	SDrawBlock dbval = *db;
    SDrawParam dpval = *dp;

	SETUP_Z_DRAW

	DWORD tmpecx;	// Stores Temp ECX value in OuterLoop
	DWORD lastpixel;

	__asm
	{
		mov	 edi, [dbval.dest]		; Point EDI to destination
		add  edi, [dstoff]			; Adjusts EDI for offset
 
		mov  ebx, [dbval.szbuffer]	; Points EBX to Src zbuffer
		add  ebx, [srczoff]			; Adjusts EDX for offset

		mov  edx, [dbval.dzbuffer]  ; Points EDX to	Dest zbuffer
		add  edx, [dstzoff]			; Adjusts EDX for offset

		cld							; Forward direction

		mov  eax, [dpval.drawmode]

		and  eax, DM_REVERSEHORZ
		jne  Reverse

		mov  ecx, [bmheight]

	OuterLoop:
		mov  [tmpecx], ecx
		mov  ecx, [dpval.swidth]	; ECX contains number of rows to do.
		mov  [lastpixel], 0

	InnerLoop:
		mov  ax, [ebx]
		add  ax, [dpval.zpos]
		cmp  [edx], ax
		jb   RightSide

		cmp  [lastpixel], 0
		jne  SkipRaw

		mov  [lastpixel], 1
		cmp  ecx, [dpval.swidth]
		je   SkipRaw				; when we're the left edge don't draw

		mov  eax, [dpval.color]
		mov  [edi], ax
		jmp  SkipRaw

	RightSide:
		cmp  [lastpixel], 0
		je   Skip

		cmp  ecx, 1
		je   Skip					; when we're on the right edge don't draw

		mov  eax, [dpval.color]
		mov  [edi-2], ax

	Skip:
		mov [lastpixel], 0

	SkipRaw:
		add	 edi, 2 
		add  ebx, 2
		add  edx, 2

		dec  ecx
		jne  InnerLoop

		add  edi, dstadd
		add  ebx, srczadd
		add  edx, dstzadd

		mov  ecx, [tmpecx]
		dec  ecx
		jne  OuterLoop
		jmp  Done

	Reverse:
		mov  ecx, [bmheight]
		add  ebx, [bmwidth]

	RevOuterLoop:
		mov  [tmpecx], ecx
		mov  ecx, [dpval.swidth]	; ECX contains number of rows to do.
		mov  [lastpixel], 0

	RevInnerLoop:
		sub  ebx, 2

		mov  ax, [ebx]
		add  ax, [dpval.zpos]
		cmp  [edx], ax
		jb   RevRightSide

		cmp  [lastpixel], 0
		jne  RevSkipRaw

		mov  [lastpixel], 1
		cmp  ecx, 1
		je   RevSkipRaw				; when we're the left edge don't draw

		mov  eax, [dpval.color]
		mov  [edi], ax
		jmp  RevSkipRaw

	RevRightSide:
		cmp  [lastpixel], 0
		je   RevSkip

		cmp  ecx, [dpval.swidth]
		je   RevSkip					; when we're on the right edge don't draw

		mov  eax, [dpval.color]
		mov  [edi-2], ax

	RevSkip:
		mov [lastpixel], 0

	RevSkipRaw:
		add	 edi, 2 
		add  edx, 2

		dec  ecx
		jne  RevInnerLoop

		add  edi, dstadd
		add  edx, dstzadd

		add  ebx, bmwidth
		add  ebx, bmwidth
		add  ebx, srczadd

		mov  ecx, [tmpecx]
		dec  ecx
		jne  RevOuterLoop

	Done:
	}

	return TRUE;
}

BOOL ZPut(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 1 || dp->dheight < 1) 
		return FALSE;

    if (db->szbuffer == NULL || db->dzbuffer == NULL)
		return FALSE;

	if (db->srcbitmapflags & BM_COMPRESSED)
	{
		return FALSE;
//		if (dp->sx || dp->sy || db->sbufwidth != dp->swidth || 
//			db->sbufheight != dp->sheight)
//			return ClipZBufferDecompress(db, dp);
//		
//		else
//			return ZBufferDecompress(db, dp);
	}

	SDrawBlock dbval = *db;
    SDrawParam dpval = *dp;

	SETUP_Z_DRAW

	DWORD tmpecx;	// Stores Temp ECX value in OuterLoop

	__asm
	{
		mov  esi, [dbval.source]	; Point ESI to source
		add  esi, [srcoff]			; Adjusts EDI for offset

		mov	 edi, [dbval.dest]		; Point EDI to destination
		add  edi, [dstoff]			; Adjusts EDI for offset
 
		mov  ebx, [dbval.szbuffer]	; Points EBX to Src zbuffer
		add  ebx, [srczoff]			; Adjusts EDX for offset

		mov  edx, [dbval.dzbuffer]  ; Points EDX to	Dest zbuffer
		add  edx, [dstzoff]			; Adjusts EDX for offset

		cld							; Forward direction

		mov  eax, [dpval.drawmode]

		and  eax, DM_REVERSEHORZ
		jne  Reverse

		mov  ecx, [bmheight]

	OuterLoop:
		mov  [tmpecx], ecx
		mov  ecx, [dpval.swidth]	; ECX contains number of rows to do.

	InnerLoop:
		mov  ax, [ebx]
		cmp  ax, 0x7f7f				; check keycolor
		je   SkipRaw

		add  ax, [dpval.zpos]		; check against dest zbuf
		cmp  [edx], ax
		jb   SkipRaw

		mov  [edx], ax
		
		inc  ax
		and  ax, 0fffeh
		mov  ax, [esi]
		mov	 [edi], ax

	SkipRaw:
		add  esi, 2 
		add	 edi, 2 
		add  ebx, 2
		add  edx, 2

		dec  ecx
		jne  InnerLoop

		add  esi, srcadd
		add  edi, dstadd
		add  ebx, srczadd
		add  edx, dstzadd

		mov  ecx, [tmpecx]
		dec  ecx
		jne  OuterLoop
		jmp  Done

	Reverse:
		xor  eax, eax

		add  esi, [bmwidth]
		add  ebx, [bmwidth]

		mov  eax, [bmwidth]
		shl  eax, 1
		add	 eax, srcadd
		mov  srcadd, eax
		mov  ecx, [bmheight]

	RevOuterLoop:
		mov  [tmpecx], ecx
		mov  ecx, [dpval.swidth]	; ECX contains number of rows to do.

	RevInnerLoop:
		mov  ax, [ebx]
		cmp  [edx], ax
		add  ax, [dpval.zpos]
		jb   RevSkipRaw

		mov  [edx], ax
		
		inc  ax
		and  ax, 0fffeh
		mov  ax, [esi]
		mov	 [edi], ax

	RevSkipRaw:
		sub  esi, 2 
		add	 edi, 2 
		sub  ebx, 2
		add  edx, 2

		dec  ecx
		jne  RevInnerLoop

		add  esi, srcadd
		add  edi, dstadd
		add  ebx, srczadd
		add  edx, dstzadd

		mov  ecx, [tmpecx]
		dec  ecx
		jne  RevOuterLoop

	Done:
	}

	return TRUE;
}

BOOL ZPut8(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 1 || dp->dheight < 1) 
		return FALSE;

    if (db->szbuffer == NULL || db->dzbuffer == NULL)
		return FALSE;

	DWORD *palette = (DWORD *)((BYTE *)db->palette + sizeof(WORD) * 256);

	if (db->srcbitmapflags & BM_COMPRESSED)
	{
		return FALSE;
//		if (dp->sx || dp->sy || db->sbufwidth != dp->swidth || 
//			db->sbufheight != dp->sheight)
//			return ClipZBufferDecompress832(db, dp, palette);
//		
//		else
//			return ZBufferDecompress832(db, dp, palette);
	}

	SDrawBlock dbval = *db;
    SDrawParam dpval = *dp;

	SETUP_Z_DRAW

	DWORD tmpecx;	// Stores Temp ECX value in OuterLoop
	DWORD tmpedx;	// Stores Temp ECX value in OuterLoop
	DWORD tmpesp;	// Stores Temp ECX value in OuterLoop

	DWORD xloop = dpval.dwidth;
	DWORD yloop = dpval.dheight;

	DWORD srcstride = dbval.sstride;
	DWORD srczstride = dbval.sstride << 1;
	DWORD dststride = dbval.dstride << 2;
	DWORD dstzstride = dbval.dstride << 1;

	DWORD zval = dpval.zpos;

	__asm
	{
		mov	 [tmpesp], esp			; Save esp value

		mov  esi, [dbval.source]	; Point ESI to source
		add  esi, [srcoff]			; Adjusts ESI for offset

		mov	 edi, [dbval.dest]		; Point EDI to destination
		add  edi, [dstoff]			; Adjusts EDI for offset
 
		mov  ebx, [dbval.szbuffer]	; Points EBX to Src zbuffer
		add  ebx, [srczoff]		; Adjusts EBX for offset

		mov  esp, [dbval.dzbuffer]  ; Points ESP to	Dest zbuffer
		add  esp, [dstzoff]		; Adjusts ESP for offset

		mov  edx, [palette]			; Points EDX to	palette

		cld							; Forward direction

		mov  eax, [dpval.drawmode]

		and  eax, DM_REVERSEHORZ
		jne  Reverse

		xor  eax, eax

	OuterLoop:
		xor	 ecx, ecx

	InnerLoop:
		mov  al, [ebx + ecx * 2]
		mov  ah, [ebx + ecx * 2 + 1] 

		cmp  eax, 7f7fh
		je   SkipRaw

		add  eax, zval
		cmp  [esp + ecx * 2], ax
		jb   SkipRaw

		mov  [esp + ecx * 2], ax

	    xor  eax, eax
		mov  al, [esi + ecx]
		mov  eax, [edx + eax * 4]
		shr  eax, 3
		mov  [edi + ecx * 4], eax
		xor  eax, eax

	SkipRaw:
		inc	 ecx

		cmp	 ecx, xloop
		jne	 InnerLoop

        add  esi, srcstride
        add  edi, dststride
        add  ebx, srczstride
		add  esp, dstzstride

		dec  yloop
		jne  OuterLoop

		jmp  Done

	Reverse:
		add  esi, [bmwidth]

		mov  eax, [bmwidth]
		shl  eax, 1

		add  ebx, eax

		add	 eax, srcadd

		mov  srcadd, eax
		mov  eax, [bmheight]
		mov  [tmpedx], eax

	RevOuterLoop:
		mov  eax, [dpval.swidth]	; ECX contains number of rows to do.
		mov  [tmpecx], eax

	RevInnerLoop:
		mov  ax, [ebx]
		cmp  ax, 7f7fh

		je   RevSkipRaw
		add  ax, [dpval.zpos]

		cmp  [edx], ax
		jb   RevSkipRaw

		mov  [edx], ax

		xor  eax, eax
		mov  al, [esi]
		shl  eax, 2
		add  eax, [palette]
		mov  ax, [eax]

		mov  [edi], eax

	RevSkipRaw:
		dec  esi
		add  edi, 4
		sub  ebx, 2
		add  edx, 2

		dec  [tmpecx]
		jne  RevInnerLoop

		add  esi, [srcadd]
		add  ebx, [srczadd]
		add  edi, [dstadd]
		add  edx, [dstzadd]

		dec  [tmpedx]
		jne  RevOuterLoop

	Done:
		mov	 esp, [tmpesp]
	
	}

	return TRUE;
}

BOOL ZPut816(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 1 || dp->dheight < 1) 
		return FALSE;

    if (db->szbuffer == NULL || db->dzbuffer == NULL)
		return FALSE;

	DWORD *palette = (DWORD *)((BYTE *)db->palette);

	if (db->srcbitmapflags & BM_COMPRESSED)
	{
		return FALSE;
//		if (dp->sx || dp->sy || db->sbufwidth != dp->swidth || 
//			db->sbufheight != dp->sheight)
//			return ClipZBufferDecompress8(db, dp, palette);
//		
//		else
//			return ZBufferDecompress8(db, dp, palette);
	}

	SDrawBlock dbval = *db;
    SDrawParam dpval = *dp;

	SETUP_Z_DRAW

	DWORD tmpedx;	// Stores Temp ECX value in OuterLoop
	DWORD tmpecx;	// Stores Temp ECX value in InnerLoop

	__asm
	{
		mov  esi, [dbval.source]	; Point ESI to source
		add  esi, [srcoff]			; Adjusts ESI for offset

		mov	 edi, [dbval.dest]		; Point EDI to destination
		add  edi, [dstoff]			; Adjusts EDI for offset

		mov  ebx, [dbval.szbuffer]	; Points EBX to Src zbuffer
		add  ebx, [srczoff]		; Adjusts EBX for offset

		mov  edx, [dbval.dzbuffer]  ; Points EDX to	Dest zbuffer
		add  edx, [dstzoff]			; Adjusts EDX for offset

		cld							; Forward direction

		mov  eax, [dpval.drawmode]

		and  eax, DM_REVERSEHORZ
		jne  Reverse

		mov  eax, [bmheight]
		mov  [tmpedx], eax

	OuterLoop:
		mov  eax, [dpval.swidth]	; ECX contains number of rows to do.
		mov  [tmpecx], eax

	InnerLoop:
		mov  ax, [ebx]

		cmp  ax, 7f7fh
		je   SkipRaw

		add  ax, [dpval.zpos]

		cmp  [edx], ax
		jb   SkipRaw

		mov  [edx], ax
		xor  eax, eax

		mov  al, [esi]
		shl  eax, 1

		add  eax, [palette]
		mov  ax, [eax]

		mov  [edi], ax

	SkipRaw:
		inc  esi
		add  ebx, 2

		add  edi, 2
		add  edx, 2

		dec  [tmpecx]
        jne  InnerLoop

        add  esi, [srcadd]
        add  ebx, [srczadd]
				  
        add  edi, [dstadd]
		add  edx, [dstzadd]

		dec  [tmpedx]
		jne  OuterLoop

		jmp  Done

	Reverse:
		add  esi, [bmwidth]

		mov  eax, [bmwidth]
		shl  eax, 1

		add  ebx, eax

		add	 eax, srcadd
		mov  srcadd, eax
		mov  eax, [bmheight]
		mov  [tmpedx], eax

	RevOuterLoop:
		mov  eax, [dpval.swidth]	; ECX contains number of rows to do.
 		mov  [tmpecx], eax

	RevInnerLoop:
		mov  ax, [ebx]

		cmp  ax, 7f7fh
		je   RevSkipRaw

		add  ax, [dpval.zpos]
		cmp  [edx], ax
		jb   RevSkipRaw

		mov  [edx], ax

		xor  eax, eax
		mov  al, [esi]
		shl  eax, 1
		add  eax, [palette]
		mov  ax, [eax]

		mov  [edi], ax

	RevSkipRaw:
		dec  esi
		add  edi, 2
		sub  ebx, 2
		add  edx, 2

		dec  [tmpecx]
		jne  RevInnerLoop

		add  esi, [srcadd]
		add  ebx, [srczadd]
		add  edi, [dstadd]
		add  edx, [dstzadd]

		dec  [tmpedx]
		jne  RevOuterLoop

	Done:
	}

	return TRUE;
}

BOOL ZPut32(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 1 || dp->dheight < 1) 
		return FALSE;

    if (db->szbuffer == NULL || db->dzbuffer == NULL)
		return FALSE;

    if (db->srcbitmapflags & BM_COMPRESSED)
	{
		return FALSE;
//		if (dp->sx || dp->sy || db->sbufwidth != dp->swidth || 
//			db->sbufheight != dp->sheight)
//			return ClipZBufferDecompress32(db, dp);
//
//		else 
//			return ZBufferDecompress32(db, dp);
	}

	if (db->dstbitmapflags & BM_32BIT)
	{
		SDrawBlock dbval = *db;
	    SDrawParam dpval = *dp;

		SETUP_Z_DRAW

		DWORD tmpecx;	// Stores Temp ECX value in OuterLoop
		DWORD tmpesp;	// Stores Temp ECX value in InnerLoop
	
		DWORD xloop = dpval.dwidth << 1;
		DWORD yloop = dpval.dheight;

		DWORD srcwidth = dbval.sstride << 1;
		DWORD dstwidth = dbval.dstride << 2;
		DWORD srczwidth = dbval.sstride << 1;
		DWORD dstzwidth = dbval.dstride << 1;

		__asm
		{
			mov  [tmpesp], esp

			mov  esi, [dbval.source]	; Point ESI to source
			add  esi, [srcoff]			; Adjusts EDI for offset

			mov	 edi, [dbval.dest]		; Point EDI to destination
			add  edi, [dstoff]			; Adjusts EDI for offset
 
			mov  ebx, [dbval.szbuffer]	; Points EBX to Src zbuffer
			add  ebx, [srczoff]			; Adjusts EDX for offset

			mov  esp, [dbval.dzbuffer]  ; Points EDX to	Dest zbuffer
			add  esp, [dstzoff]			; Adjusts EDX for offset

			cld							; Forward direction
		
			xor  edx, edx

			mov  eax, [dpval.drawmode]

			and  eax, DM_REVERSEHORZ
			jne  Reverse32

			mov  ecx, [bmheight]

		OuterLoop32:
			xor  ecx, ecx			; ECX contains number of rows to do.

		InnerLoop32:
			mov  al, [ebx + ecx]
			mov	 ah, [ebx + ecx + 1]
			add  al, BYTE PTR [dpval.zpos]
			adc  ah, BYTE PTR [dpval.zpos + 1]
			cmp  [esp + ecx], ax
			jb   SkipRaw32

//			inc  ax
//			and  ax, 0fffeh
			mov  [esp + ecx], ax

			mov  dl, [esi + ecx]
			mov  eax, [Conv16to32Lower + edx * 4]

			mov  dl, [esi + ecx + 1]
			add  eax, [Conv16to32Upper + edx * 4]

			mov  [edi + ecx * 2], eax

		SkipRaw32:
			add	 ecx, 2

			cmp  ecx, xloop
			jne  InnerLoop32

			add  esi, srcwidth  ; Src
			add  edi, dstwidth  ; Dst
			add  ebx, srczwidth ; Src Z
			add  esp, dstzwidth ; Dst Z

			dec  yloop
			jne  OuterLoop32
			jmp  Done32

		Reverse32:
			add  esi, [bmwidth]
			add  ebx, [bmwidth]

			mov  eax, [bmwidth]
			shl  eax, 1
			add	 eax, srcadd
			mov  srcadd, eax
	
			mov  ecx, [bmheight]

		RevOuterLoop32:
			xor  ecx, ecx				; ECX contains number of rows to do.

		RevInnerLoop32:
			mov  ax, [ebx]
			add  ax, [dpval.zpos]
			cmp  [esp], ax
			jb   RevSkipRaw32

			inc  ax
			and  ax, 0fffeh
			mov  [esp], ax

			mov  dl, [esi]
			mov  eax, [Conv16to32Lower + edx * 4]

			mov  dl, [esi + 1]
			add  eax, [Conv16to32Upper + edx * 4]

			mov  [edi], eax

		RevSkipRaw32:
			sub  esi, 2 
			add	 edi, 4 
			sub  ebx, 2
			add  esp, 2

			dec  ecx
			jne  RevInnerLoop32

			add  esi, srcadd
			add  edi, dstadd
			add  ebx, srczadd
			add  esp, dstzadd

			mov  ecx, [tmpecx]
			dec  ecx
			jne  RevOuterLoop32

		Done32:
			mov  esp, [tmpesp]
		}
	}

	if (db->dstbitmapflags & BM_24BIT)
	{
		SDrawBlock dbval = *db;
	    SDrawParam dpval = *dp;

		SETUP_Z_DRAW
	
		DWORD tmpecx;	// Stores Temp ECX value in OuterLoop
		DWORD tmpesp;   // Stores Temp ESP value;

		__asm
		{
			mov  [tmpesp], esp

			mov  esi, [dbval.source]	; Point ESI to source
			add  esi, [srcoff]			; Adjusts EDI for offset

			mov	 edi, [dbval.dest]		; Point EDI to destination
			add  edi, [dstoff]			; Adjusts EDI for offset
 
			mov  ebx, [dbval.szbuffer]	; Points EBX to Src zbuffer
			add  ebx, [srczoff]			; Adjusts EDX for offset

			mov  esp, [dbval.dzbuffer]  ; Points EDX to	Dest zbuffer
			add  esp, [dstzoff]			; Adjusts EDX for offset

			cld							; Forward direction

			xor  edx, edx

			mov  eax, [dpval.drawmode]

			and  eax, DM_REVERSEHORZ
			jne  Reverse24

			mov  ecx, [bmheight]

		OuterLoop24:
			mov  [tmpecx], ecx
			mov  ecx, [dpval.swidth]			; ECX contains number of rows to do.

		InnerLoop24:
			mov  ax, [ebx]
			add  ax, [dpval.zpos]
			cmp  [esp], ax
			jb   SkipRaw24

			inc  ax
			and  ax, 0fffeh
			mov  [esp], ax

			mov  dl, [esi]
			mov  eax, [Conv16to32Lower + edx * 4]

			mov  dl, [esi + 1]
			add  eax, [Conv16to32Upper + edx * 4]

			mov  [edi], eax

		SkipRaw24:
			add  esi, 2 
			add	 edi, 3 
			add  ebx, 2
			add  esp, 2

			dec  ecx
			jne  InnerLoop24

			add  esi, srcadd
			add  edi, dstadd
			add  ebx, srczadd
			add  esp, dstzadd


			mov  ecx, [tmpecx]
			dec  ecx
			jne  OuterLoop24
			jmp  Done24

		Reverse24:
			add  esi, [bmwidth]
			add  ebx, [bmwidth]

			mov  eax, [bmwidth]
			shl  eax, 1
			add	 eax, srcadd
			mov  srcadd, eax
	
			mov  ecx, [bmheight]

		RevOuterLoop24:
			mov  [tmpecx], ecx
			mov  ecx, [dpval.swidth]			; ECX contains number of rows to do.

		RevInnerLoop24:

			mov  ax, [ebx]
			add  ax, [dpval.zpos]
			cmp  [esp], ax
			jb   RevSkipRaw24

			inc  ax
			and  ax, 0fffeh
			mov  [esp], ax

			mov  dl, [esi]
			mov  eax, [Conv16to32Lower + edx * 4]

			mov  dl, [esi + 1]
			add  eax, [Conv16to32Upper + edx * 4]

			mov  [edi], eax

		RevSkipRaw24:
			sub  esi, 2 
			add	 edi, 3 
			sub  ebx, 2
			add  esp, 2

			dec  ecx
			jne  RevInnerLoop24

			add  esi, srcadd
			add  edi, dstadd
			add  ebx, srczadd
			add  esp, dstzadd

			mov  ecx, [tmpecx]
			dec  ecx
			jne  RevOuterLoop24

		Done24:
			mov  esp, [tmpesp]
		}
	}

	return TRUE;
}

BOOL ShutterZPut(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 1 || dp->dheight < 1) 
		return FALSE;

    if (db->szbuffer == NULL || db->dzbuffer == NULL)
		return FALSE;

	if (db->srcbitmapflags & BM_COMPRESSED)
	{
		return FALSE;
//		if (dp->sx || dp->sy || db->sbufwidth != dp->swidth || 
//			db->sbufheight != dp->sheight)
//			return ClipZBufferDecompress(db, dp);
//		
//		else
//			return ZBufferDecompress(db, dp);
	}

	SDrawBlock dbval = *db;
    SDrawParam dpval = *dp;

	SETUP_Z_DRAW

	DWORD tmpecx;	// Stores Temp ECX value in OuterLoop
	DWORD tmpedx;	// Stores Temp EDX value in OuterLoop

	__asm
	{
		mov  esi, [dbval.source]	; Point ESI to source
		add  esi, [srcoff]			; Adjusts EDI for offset

		mov	 edi, [dbval.dest]		; Point EDI to destination
		add  edi, [dstoff]			; Adjusts EDI for offset
 
		mov  ebx, [dbval.szbuffer]	; Points EBX to Src zbuffer
		add  ebx, [srczoff]			; Adjusts EDX for offset

		mov  edx, [dbval.dzbuffer]  ; Points EDX to	Dest zbuffer
		add  edx, [dstzoff]			; Adjusts EDX for offset

		cld							; Forward direction

		mov  eax, [dpval.drawmode]

		and  eax, DM_REVERSEHORZ
		jne  Reverse

		mov  eax, [bmheight]
		mov  [tmpedx], eax

	OuterLoop:
		mov  eax, [dpval.swidth]	; ECX contains number of rows to do.
		mov  [tmpecx], eax

	InnerLoop:
		mov  eax, [dpval.dy]
		add  eax, [tmpedx]

		test eax, 1
		jne  line0
		
		mov  eax, [dpval.dx]
		add  eax, [tmpecx]

		test eax, 1
		je	 SkipRaw
	
		jmp  draw	

	line0:
		mov  eax, [dpval.dx]
		add  eax, [tmpecx]

		test eax, 1
		jne	 SkipRaw
	
	draw:
		mov  ax, [ebx]
		add  ax, [dpval.zpos]

		cmp  [edx], ax
		jb   SkipRaw

		mov  [edx], ax
		
		inc  ax
		and  ax, 0fffeh

		mov  ax, [esi]
		mov	 [edi], ax

	SkipRaw:
		add  esi, 2 
		add	 edi, 2 

		add  ebx, 2
		add  edx, 2

		dec  [tmpecx]
		jne  InnerLoop

		add  esi, srcadd
		add  edi, dstadd

		add  ebx, srczadd
		add  edx, dstzadd

		dec  [tmpedx]
		jne  OuterLoop

		jmp  Done

	Reverse:
		add  esi, [bmwidth]
		add  ebx, [bmwidth]

		mov  eax, [bmwidth]
		shl  eax, 1

		add	 eax, srcadd
		mov  srcadd, eax

		mov  eax, [bmheight]
		mov  [tmpedx], eax

	RevOuterLoop:
		mov  eax, [dpval.swidth]	; ECX contains number of rows to do.
		mov  [tmpecx], eax

	RevInnerLoop:
		test [tmpedx], 1
		jne  Revline0
		
		test [tmpecx], 1
		je	 RevSkipRaw
	
		jmp  Revdraw	

	Revline0:
		test [tmpecx], 1
		jne	 RevSkipRaw
	
	Revdraw:
		mov  ax, [ebx]
		add  ax, [dpval.zpos]

		cmp  [edx], ax
		jb   RevSkipRaw

		mov  [edx], ax
		inc  ax

		and  ax, 0fffeh
		mov  ax, [esi]

		mov	 [edi], ax

	RevSkipRaw:
		sub  esi, 2 
		add	 edi, 2 
		sub  ebx, 2
		add  edx, 2

		dec  [tmpecx]
		jne  RevInnerLoop

		add  esi, srcadd
		add  edi, dstadd

		add  ebx, srczadd
		add  edx, dstzadd

		dec  [tmpedx]
		jne  RevOuterLoop

	Done:
	}

	return TRUE;
}

BOOL ShutterZPut8(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 1 || dp->dheight < 1) 
		return FALSE;

    if (db->szbuffer == NULL || db->dzbuffer == NULL)
		return FALSE;

	DWORD *palette = (DWORD *)((BYTE *)db->palette + sizeof(WORD) * 256);

	if (db->srcbitmapflags & BM_COMPRESSED)
	{
		return FALSE;
//		if (dp->sx || dp->sy || db->sbufwidth != dp->swidth || 
//			db->sbufheight != dp->sheight)
//			return ClipZBufferDecompress832(db, dp, palette);
//		
//		else
//			return ZBufferDecompress832(db, dp, palette);
	}

	SDrawBlock dbval = *db;
    SDrawParam dpval = *dp;

	SETUP_Z_DRAW

	DWORD pixelx;	// Stores Temp ECX value in OuterLoop
	DWORD pixely;	// Stores Temp ECX value in OuterLoop
	DWORD tmpecx;	// Stores Temp ECX value in OuterLoop
	DWORD tmpedx;	// Stores Temp ECX value in OuterLoop

	__asm
	{
		mov  esi, [dbval.source]	; Point ESI to source
		add  esi, [srcoff]			; Adjusts ESI for offset

		mov	 edi, [dbval.dest]		; Point EDI to destination
		add  edi, [dstoff]			; Adjusts EDI for offset
 
		mov  ebx, [dbval.szbuffer]	; Points EBX to Src zbuffer
		add  ebx, [srczoff]		; Adjusts EBX for offset

		mov  edx, [dbval.dzbuffer]  ; Points EDX to	Dest zbuffer
		add  edx, [dstzoff]		; Adjusts EDX for offset

		cld							; Forward direction

		mov  eax, [dpval.drawmode]

		and  eax, DM_REVERSEHORZ
		jne  Reverse

		mov  eax, [bmheight]
		mov [tmpedx], eax

		mov  eax, [dpval.dy]
		mov [pixely], eax

	OuterLoop:
		mov  eax, [dpval.swidth]	; ECX contains number of rows to do.
		mov  [tmpecx], eax

		mov  eax, [dpval.dx]
		mov [pixelx], eax

	InnerLoop:
		test [pixely], 1
		jne  line0
		
		test [pixelx], 1
		je	 SkipRaw
	
		jmp  draw	

	line0:
		test [pixelx], 1
		jne	 SkipRaw
	
	draw:
		mov  ax, [ebx]

		cmp  ax, 7f7fh
		je   SkipRaw

		add  ax, [dpval.zpos]

		cmp  [edx], ax
		jb   SkipRaw

		mov  [edx], ax

		xor  eax, eax
		mov  al, [esi]

		shl  eax, 2
		add  eax, [palette]

		mov  eax, [eax]
		mov  [edi], eax

	SkipRaw:
		inc  esi
		add  ebx, 2

		add  edi, 4
		add  edx, 2

		inc  [pixelx]
		dec  [tmpecx]

        jne  InnerLoop

        add  esi, [srcadd]
        add  ebx, [srczadd]

		add  edx, [dstzadd]
        add  edi, [dstadd]

		inc  [pixely]
		dec  [tmpedx]

		jne  OuterLoop

		jmp  Done

	Reverse:
		add  esi, [bmwidth]

		mov  eax, [bmwidth]
		shl  eax, 1

		add  ebx, eax

		add	 eax, [srcadd]
		mov  [srcadd], eax

		mov  eax, [bmheight]
		mov  [tmpedx], eax

		mov  eax, [dpval.dy]
		mov  [pixely], eax

	RevOuterLoop:
		mov  eax, [dpval.swidth]	; ECX contains number of rows to do.
		mov  [tmpecx], eax

		mov  eax, [dpval.dx]
		mov  [pixelx], eax

	RevInnerLoop:
		test [pixely], 1
		jne  Revline0
		
		test [pixelx], 1
		je	 RevSkipRaw
	
		jmp  Revdraw	

	Revline0:
		test [pixelx], 1
		jne	 RevSkipRaw
	
	Revdraw:
		mov  ax, [ebx]

		cmp  ax, 7f7fh
		je   RevSkipRaw

		add  ax, [dpval.zpos]
		cmp  [edx], ax
		jb   RevSkipRaw

		mov  [edx], ax
		xor  eax, eax

		mov  al, [esi]
		shl  eax, 1

		add  eax, [palette]
		mov  ax, [eax]

		mov  [edi], ax

	RevSkipRaw:
		dec  esi
		sub  ebx, 2

		add  edi, 2
		add  edx, 2

		inc  [pixelx]
		dec  [tmpecx]

		jne  RevInnerLoop

		add  esi, [srcadd]
		add  ebx, [srczadd]

		add  edi, [dstadd]
		add  edx, [dstzadd]

		inc  [pixely]
		dec  [tmpedx]

		jne  RevOuterLoop

	Done:
	}

	return TRUE;
}

BOOL ShutterZPut816(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 1 || dp->dheight < 1) 
		return FALSE;

    if (db->szbuffer == NULL || db->dzbuffer == NULL)
		return FALSE;

	DWORD *palette = (DWORD *)((BYTE *)db->palette);

	if (db->srcbitmapflags & BM_COMPRESSED)
	{
		return FALSE;
//		if (dp->sx || dp->sy || db->sbufwidth != dp->swidth || 
//			db->sbufheight != dp->sheight)
//			return ClipZBufferDecompress8(db, dp, palette);
//		
//		else
//			return ZBufferDecompress8(db, dp, palette);
	}

	SDrawBlock dbval = *db;
    SDrawParam dpval = *dp;

	SETUP_Z_DRAW

	DWORD tmpecx;	// Stores Temp ECX value in OuterLoop
	DWORD tmpedx;	// Stores Temp ECX value in OuterLoop
	DWORD pixelx;	// Stores current pixel position on screen
	DWORD pixely;	// Stores Temp ECX value in OuterLoop

	__asm
	{
		cld							; Forward direction
				   
		mov  esi, [dbval.source]	; Point ESI to source
		add  esi, [srcoff]			; Adjusts ESI for offset

		mov	 edi, [dbval.dest]		; Point EDI to destination
		add  edi, [dstoff]			; Adjusts EDI for offset
 
		mov  ebx, [dbval.szbuffer]	; Points EBX to Src zbuffer
		add  ebx, [srczoff]		; Adjusts EB for offset

		mov  edx, [dbval.dzbuffer]  ; Points EDX to	Dest zbuffer
		add  edx, [dstzoff]			; Adjusts EDX for offset

		mov  eax, [dpval.drawmode]

		and  eax, DM_REVERSEHORZ
		jne  Reverse

		mov  eax, [bmheight]
		mov  [tmpedx], eax

		mov  eax, [dpval.dy]
		mov  [pixely], eax

	OuterLoop:
		mov  eax, [dpval.swidth]	; ECX contains number of rows to do.
		mov  [tmpecx], eax

		mov  eax, [dpval.dx]
		mov  [pixelx], eax

	InnerLoop:
		test [pixely], 1
		jne  line0
		
		test [pixelx], 1
		je	 SkipRaw
	
		jmp  draw	

	line0:
		test [pixelx], 1
		jne	 SkipRaw
	
	draw:
		mov  ax, [ebx]

		cmp  ax, 7f7fh
		je   SkipRaw

		add  ax, [dpval.zpos]

		cmp  [edx], ax
		jb   SkipRaw

		mov  [edx], ax
		xor  eax, eax

		mov  al, [esi]
		shl  eax, 1

		add  eax, [palette]
		mov  ax, [eax]

		mov  [edi], ax

	SkipRaw:
		inc  esi
		add  ebx, 2

		add  edi, 2
		add  edx, 2

		inc  [pixelx]
		dec  [tmpecx]

        jne  InnerLoop

        add  esi, [srcadd]
        add  ebx, [srczadd]

        add  edi, [dstadd]
		add  edx, [dstzadd]

		inc  [pixely]
		dec  [tmpedx]

		jne  OuterLoop

		jmp  Done

	Reverse:
		add  esi, [bmwidth]
		mov  eax, [bmwidth]
		shl  eax, 1

		add  ebx, eax

		add	 eax, [srcadd]
		mov  [srcadd], eax

		mov  eax, [bmheight]
		mov  [tmpedx], eax

		mov  eax, [dpval.dy]
		mov  [pixely], eax

	RevOuterLoop:
		mov  eax, [dpval.swidth]	; ECX contains number of rows to do.
		mov  [tmpecx], eax

		mov  eax, [dpval.dx]
		mov  [pixelx], eax

	RevInnerLoop:
		test [tmpedx], 1
		jne  Revline0
		
		test [tmpecx], 1
		je	 RevSkipRaw
	
		jmp  Revdraw	

	Revline0:
		test [tmpecx], 1
		jne	 RevSkipRaw
	
	Revdraw:
		mov  ax, [ebx]

		cmp  ax, 7f7fh
		je   RevSkipRaw

		add  ax, [dpval.zpos]

		cmp  [edx], ax
		jb   RevSkipRaw

		mov  [edx], ax
		xor  eax, eax

		mov  al, [esi]
		shl  eax, 1

		add  eax, [palette]
		mov  ax, [eax]

		mov  [edi], ax

	RevSkipRaw:
		dec  esi
		sub  ebx, 2

		add  edi, 2
		add  edx, 2

		inc  [pixelx]
		dec  [tmpecx]
							
		jne  RevInnerLoop

		add  esi, [srcadd]
		add  ebx, [srczadd]

		add  edi, [dstadd]
		add  edx, [dstzadd]

		inc  [pixely]
		dec  [tmpedx]

		jne  RevOuterLoop

	Done:
	}

	return TRUE;
}

BOOL ShutterZPut32(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 1 || dp->dheight < 1) 
		return FALSE;

    if (db->szbuffer == NULL || db->dzbuffer == NULL)
		return FALSE;

    if (db->srcbitmapflags & BM_COMPRESSED)
	{
		return FALSE;
//		if (dp->sx || dp->sy || db->sbufwidth != dp->swidth || 
//			db->sbufheight != dp->sheight)
//			return ClipZBufferDecompress32(db, dp);
//
//		else 
//			return ZBufferDecompress32(db, dp);
	}

	if (db->dstbitmapflags & BM_32BIT)
	{
		SDrawBlock dbval = *db;
	    SDrawParam dpval = *dp;

		SETUP_Z_DRAW

		DWORD tmpecx;	// Stores Temp ECX value in OuterLoop
		DWORD tmpecx2;	// Stores Temp ECX value in OuterLoop
		DWORD tmpesp;	// Stores Temp ECX value in InnerLoop
		
		DWORD pixelx;	// Screen Pos of currently drawn pixel
		DWORD pixely;

		__asm
		{
			cld							; Forward direction
			mov  [tmpesp], esp

			mov  esi, [dbval.source]	; Point ESI to source
			add  esi, [srcoff]			; Adjusts EDI for offset

			mov	 edi, [dbval.dest]		; Point EDI to destination
			add  edi, [dstoff]			; Adjusts EDI for offset
 
			mov  ebx, [dbval.szbuffer]	; Points EBX to Src zbuffer
			add  ebx, [srczoff]			; Adjusts EDX for offset

			mov  esp, [dbval.dzbuffer]  ; Points EDX to	Dest zbuffer
			add  esp, [dstzoff]			; Adjusts EDX for offset

			xor  edx, edx
			mov  eax, [dpval.drawmode]

			and  eax, DM_REVERSEHORZ
			jne  Reverse32

			mov  eax, [bmheight]
			mov  [tmpecx], eax

			mov  eax, [dpval.dy]
			mov  [pixely], eax

		OuterLoop32:
			mov  eax, [dpval.swidth]			; ECX contains number of rows to do.
			mov  [tmpecx2], eax

			mov  eax, [dpval.dx]
			mov  [pixelx], eax

		InnerLoop32:
			test [pixely], 1
			jne  line32
		
			test [pixelx], 1
			je	 SkipRaw32
	
			jmp  draw32

		line32:
			test [pixelx], 1
			jne	 SkipRaw32
	
		draw32:
			mov  ax, [ebx]
			add  ax, [dpval.zpos]

			cmp  [esp], ax
			jb   SkipRaw32

			inc  ax
			and  ax, 0fffeh

			mov  [esp], ax
			mov  dl, [esi]

			mov  eax, [Conv16to32Lower + edx * 4]
			mov  dl, [esi + 1]

			add  eax, [Conv16to32Upper + edx * 4]
			mov  [edi], eax

		SkipRaw32:
			add  esi, 2 
			add	 edi, 4 

			inc  [pixelx]
			add  ebx, 2

			add  esp, 2
			dec  [tmpecx2]

			jne  InnerLoop32

			add  esi, srcadd
			add  edi, dstadd

			add  ebx, srczadd
			inc  [pixely]

			add  esp, dstzadd
			dec  [tmpecx]

			jne  OuterLoop32

			jmp  Done32

		Reverse32:
			add  esi, [bmwidth]
			add  ebx, [bmwidth]

			mov  eax, [bmwidth]
			shl  eax, 1

			add	 eax, srcadd
			mov  srcadd, eax
	
			mov  eax, [bmheight]
			mov  [tmpecx], eax

			mov  eax, [dpval.dy]
			mov  [pixely], eax

		RevOuterLoop32:
			mov  eax, [dpval.swidth]			; ECX contains number of rows to do.
			mov  [tmpecx2], eax

			mov  eax, [dpval.dx]
			mov  [pixelx], eax

		RevInnerLoop32:
			test [pixely], 1
			jne  Revline32
		
			test [pixelx], 1
			je	 RevSkipRaw32
	
			jmp  Revdraw32

		Revline32:
			test [pixelx], 1
			jne	 RevSkipRaw32
	
		Revdraw32:
			mov  ax, [ebx]
			add  ax, [dpval.zpos]

			cmp  [esp], ax
			jb   RevSkipRaw32

			inc  ax
			and  ax, 0fffeh

			mov  [esp], ax
			mov  dl, [esi]

			mov  eax, [Conv16to32Lower + edx * 4]
			mov  dl, [esi + 1]

			add  eax, [Conv16to32Upper + edx * 4]
			mov  [edi], eax

		RevSkipRaw32:
			sub  esi, 2 
			add	 edi, 4 

			sub  ebx, 2
			inc  [pixelx]

			add  esp, 2
			dec  [tmpecx2]

			jne  RevInnerLoop32

			add  esi, srcadd
			add  edi, dstadd

			add  ebx, srczadd
			inc  [pixely]

			add  esp, dstzadd
			dec  [tmpecx]

			jne  RevOuterLoop32

		Done32:
			mov  esp, [tmpesp]
		}
	}

	if (db->dstbitmapflags & BM_24BIT)
	{
		SDrawBlock dbval = *db;
	    SDrawParam dpval = *dp;

		SETUP_Z_DRAW
	
		DWORD tmpecx;	// Stores Temp ECX value in OuterLoop
		DWORD tmpecx2;	// Stores Temp ECX value in OuterLoop
		DWORD tmpesp;   // Stores Temp ESP value;

		DWORD pixelx;	// Screen Pos of currently drawn pixel
		DWORD pixely;

		__asm
		{
			cld							; Forward direction
			mov  [tmpesp], esp

			mov  esi, [dbval.source]	; Point ESI to source
			add  esi, [srcoff]			; Adjusts EDI for offset

			mov	 edi, [dbval.dest]		; Point EDI to destination
			add  edi, [dstoff]			; Adjusts EDI for offset
 
			mov  ebx, [dbval.szbuffer]	; Points EBX to Src zbuffer
			add  ebx, [srczoff]			; Adjusts EDX for offset

			mov  esp, [dbval.dzbuffer]  ; Points EDX to	Dest zbuffer
			add  esp, [dstzoff]			; Adjusts EDX for offset

			xor  edx, edx
			mov  eax, [dpval.drawmode]

			and  eax, DM_REVERSEHORZ
			jne  Reverse24

			mov  eax, [bmheight]
			mov  [tmpecx], eax
			
			mov  eax, [dpval.dy]
			mov  [pixely], eax

		OuterLoop24:
			mov  eax, [dpval.swidth]			; ECX contains number of rows to do.
			mov  [tmpecx2], eax

			mov  eax, [dpval.dx]
			mov  [pixelx], eax

		InnerLoop24:
			test [pixely], 1
			jne  line24
		
			test [pixelx], 1
			je	 SkipRaw24
	
			jmp  draw24

		line24:
			test [pixelx], 1
			jne	 SkipRaw24
	
		draw24:
			mov  ax, [ebx]
			add  ax, [dpval.zpos]

			cmp  [esp], ax
			jb   SkipRaw24

			inc  ax
			and  ax, 0fffeh

			mov  [esp], ax
			mov  dl, [esi]

			mov  eax, [Conv16to32Lower + edx * 4]
			mov  dl, [esi + 1]

			add  eax, [Conv16to32Upper + edx * 4]
			mov  [edi], eax

		SkipRaw24:
			add  esi, 2 
			add	 edi, 3 

			add  ebx, 2
			inc  [pixelx]

			add  esp, 2
			dec  [tmpecx2]

			jne  InnerLoop24

			add  esi, srcadd
			add  edi, dstadd

			add  ebx, srczadd
			inc  [pixely]

			add  esp, dstzadd
			dec  [tmpecx]

			jne  OuterLoop24
			jmp  Done24

		Reverse24:
			add  esi, [bmwidth]
			add  ebx, [bmwidth]

			mov  eax, [bmwidth]
			shl  eax, 1
			add	 eax, srcadd
			mov  srcadd, eax
	
			mov  eax, [bmheight]
			mov  [tmpecx], eax
			
			mov  eax, [dpval.dy]
			mov  [pixely], eax 

		RevOuterLoop24:
			mov  eax, [dpval.swidth]			; ECX contains number of rows to do.
			mov  [tmpecx2], eax

			mov  eax, [dpval.dx]
			mov  [pixelx], eax 

		RevInnerLoop24:
			test [pixely], 1
			jne  Revline24
		
			test [pixelx], 1
			je	 RevSkipRaw24
	
			jmp  Revdraw24

		Revline24:
			test [pixelx], 1
			jne	 RevSkipRaw24
	
		Revdraw24:
			mov  ax, [ebx]
			add  ax, [dpval.zpos]

			cmp  [esp], ax
			jb   RevSkipRaw24

			inc  ax
			and  ax, 0fffeh

			mov  [esp], ax
			mov  dl, [esi]

			mov  eax, [Conv16to32Lower + edx * 4]
			mov  dl, [esi + 1]

			add  eax, [Conv16to32Upper + edx * 4]
			mov  [edi], eax

		RevSkipRaw24:
			sub  esi, 2 
			add	 edi, 3 
		
			sub  ebx, 2
			inc  [pixelx]

			add  esp, 2
			dec  [tmpecx2]

			jne  RevInnerLoop24

			add  esi, srcadd
			add  edi, dstadd

			add  ebx, srczadd
			inc  [pixely]

			add  esp, dstzadd
			dec  [tmpecx]

			jne  RevOuterLoop24

		Done24:
			mov  esp, [tmpesp]
		}
	}

	return TRUE;
}

BOOL ZFind(PSDrawBlock db, PSDrawParam dp)
{
	SDrawBlock dbval = *db;
	PSDrawParam dpa = dp;

	if (dpa->swidth < 1 || dpa->sheight < 1 || dpa->dwidth < 1 || dpa->dheight < 1) 
		return FALSE;

	if (db->srcbitmapflags & BM_COMPRESSED)
	{
		BOOL retval = FALSE;

		SETUP_Z_DRAW

		WORD zval = ZFindChunk(db, dpa);

		if (zval == 0x7f7f)
			return FALSE;

		zval += dpa->zpos;

		__asm
		{
			mov  edx, [dbval.dzbuffer]  ; Points EDX to	Dest zbuffer
			add  edx, [dstzoff]			; Adjusts EDX for offset

			mov  ax, [zval]
			cmp  [edx], ax
			jb 	 Exit

			mov  eax, TRUE
			mov  retval, eax

		Exit:
		}
		
		return retval;
	}

	if (db->dstbitmapflags & BM_32BIT)
	{
		SDrawBlock dbval = *db;
		SDrawParam dpval = *dpa;

		SETUP_Z_DRAW

		BOOL retval = FALSE;

		__asm
		{
			mov  ebx, [dbval.szbuffer]	; Points EBX to Src zbuffer
			add  ebx, [srczoff]			; Adjusts EDX for offset

			mov  edx, [dbval.dzbuffer]  ; Points EDX to	Dest zbuffer
			add  edx, [dstzoff]			; Adjusts EDX for offset

			xor	 eax, eax
			mov  ecx, [dpval.drawmode]
			and  ecx, DM_ZBUFFER
			jz  Compare32

			mov  ecx, [dbval.srcbitmapflags]
			and  ecx, BM_8BIT
			jnz  Do8Bit32

			mov  ax, [ebx]				; Get source zbuf value
			cmp  ax, 0x7f7f
			je   Done32
			jmp  Compare32

		Do8Bit32:
			mov  al, [ebx]
			cmp  al, 0ffh
			je   Done32
			shl  eax, 2

		Compare32:
			add  ax, [dpval.zpos]
			cmp  [edx], ax				; Is it the highest object displayed?
			jb   Done32					; If not, return FALSE

			mov  [retval], 1			; Otherwise TRUE

		Done32:
		}

		if (retval && dp->drawmode & DM_ZSTATIC)
		{
			// for static, check transparency on the bitmap
			BYTE *ptr = (BYTE *)db->source + srczoff;
			if (db->srcbitmapflags & BM_8BIT)
				return (*((BYTE *)ptr) != db->keycolor);
			else if (db->srcbitmapflags & (BM_15BIT | BM_16BIT))
				return (*((WORD *)ptr) != db->keycolor);
		}

		return retval;
	}

	return FALSE;
}

BOOL ZStretch(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 1 || dp->dheight < 1) 
		return FALSE;

    return FALSE;
}

BOOL ZMaskStretch(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 1 || dp->dheight < 1) 
		return FALSE;

    return FALSE;
}

BOOL Box(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->swidth < 1 || dp->sheight < 1 || dp->dwidth < 1 || dp->dheight < 1) 
		return FALSE;

	SDrawBlock dbval = *db;
	SDrawParam dpval = *dp;

	for (int c = 0; c < 3; c++) // Graphics, Z, and Normal buffers
	{
		int bmheight, bmwidth, srcoff, srcadd, dstoff, dstadd;
		int dstzoff, dstzadd;
		int oddwords = 0;
		
		DWORD color, pixeldwordshift;
		DWORD dstincr;

		void *dest;
		DWORD dstbitmapflags;
		DWORD dcolor;
		if (c == 0) // Dest buffer
		{
			dest = db->dest;
			if (!dest || (dp->drawmode & DM_NODRAW))
				continue;
			dstbitmapflags = db->dstbitmapflags;
			dcolor = dp->color;
		}
		else if (c == 1) // Z buffer
		{
			dest = db->dzbuffer;
			if (!dest || !(dp->drawmode & DM_ZBUFFER))
				continue;
			dstbitmapflags = BM_16BIT;
			dcolor = dp->zpos;
		}
		else if (c == 2) // Normal buffer
		{
			dest = db->dnormals;
			if (!dest || !(dp->drawmode & DM_NORMALS))
				continue;
			dstbitmapflags = BM_16BIT;
			dcolor = dp->normal;
		}

		if (dstbitmapflags & BM_8BIT)
		{
			color = (((dcolor & 0xff) << 24) | ((dcolor & 0xff) << 16) 
				  | ((dcolor & 0xff) << 8) | (dcolor & 0xff)); 
							  
			pixeldwordshift = 2;
			dstincr = 1;
		}

		else if (dstbitmapflags & BM_15BIT || dstbitmapflags & BM_16BIT) 
		{
			color = ((dcolor & 0xffff) << 16) | ((dcolor & 0xffff));
			pixeldwordshift = 1;
			dbval.dstbitmapflags = dstbitmapflags;
			SetupDraw(&bmwidth, &bmheight, &srcoff, &srcadd,
				&dstoff, &dstadd, &dbval, &dpval);
			
			dstzoff = dstoff;
			dstzadd = dstadd;
			dstincr = 4;

			oddwords = dpval.dwidth & 1;
		}

		else if (dstbitmapflags & BM_24BIT || dstbitmapflags & BM_32BIT) 
		{
			color = dcolor;
			pixeldwordshift = 0;
			
			if (dstbitmapflags & BM_32BIT)
			{
				dbval.dstbitmapflags = dstbitmapflags;
				SetupDraw(&bmwidth, &bmheight, &srcoff, &srcadd,
					&dstoff, &dstadd, &dbval, &dpval);
				dstzoff = dstoff >> 1;
				dstzadd = dstadd >> 1;
				dstincr = 4;
			}			

			else
			{
				dbval.dstbitmapflags = dstbitmapflags;
				SetupDraw(&bmwidth, &bmheight, &srcoff, &srcadd, 
					&dstoff, &dstadd, &dbval, &dpval); 
				dstzoff = (dstoff >> 1) / 3;
				dstzadd = (dstadd >> 1) / 3;
				dstincr = 3;
			}
		}

		DWORD dstwidth = (dpval.dwidth >> pixeldwordshift);

		if (dest)
		{
			__asm
			{
				cld 

				mov  edi, [dest]
				add  edi, [dstoff]

				mov  eax, [color]
				mov  edx, [bmheight]
				mov  ebx, [oddwords]

			OuterLoop:
				mov  ecx, [dstwidth]	;ECX contains number of rows to do.
				cmp  ecx, 0
				jz	 SingleWord			;Odd cases where only 16 bits per row

			InnerLoop:
				mov  [edi], eax
				add  edi, [dstincr]

				dec  ecx
				jne  InnerLoop

				or   ebx, ebx
				je	 NotOdd

			SingleWord:
				mov  [edi], ax
				add  edi, 2
				
			NotOdd:
				add  edi, [dstadd]

				dec  edx
				jne  OuterLoop
			}
		}
	}

	return TRUE;
}

BOOL Convert15to16(PTBitmapData bitmap)
{
    if (Display->BitsPerPixel() == 15)
		return TRUE;

	TBitmapData bmd = *bitmap;
	BYTE *data = (BYTE *)bitmap->data16;
	BYTE *tmp = (BYTE *)bitmap->zbuffer.ptr();

	if (bitmap->flags & BM_COMPRESSED)
	{
		BYTE  DLE1 = *(data++);
		BYTE  DLE2 = *(data++);
	
		BYTE  AltDLE1;
		BYTE  AltDLE2;
		BYTE  Alt1 = 0;
		BYTE  Alt2 = 0;

		switch(DLE1 & 0x03)
		{
			case 0:
				switch(DLE2 & 0x03)
				{
					case 0:
						Alt1 = 0x01;
						Alt2 = 0x02;
						break;

					case 1:
						Alt1 = 0x02;
						Alt2 = 0x03;
						break;

					case 2:
						Alt1 = 0x01;
						Alt2 = 0x03;
						break;

					case 3:
						Alt1 = 0x01;
						Alt2 = 0x02;
						break;
				}
				
			break;

			case 1:
				switch(DLE2 & 0x03)
				{
					case 0:
						Alt1 = 0x02;
						Alt2 = 0x03;
						break;

					case 1:
						Alt1 = 0x00;
						Alt2 = 0x02;
						break;

					case 2:
						Alt1 = 0x00;
						Alt2 = 0x03;
						break;

					case 3:
						Alt1 = 0x00;
						Alt2 = 0x02;
						break;
				}
				
			break;

			case 2:
				switch(DLE2 & 0x03)
				{
					case 0:
						Alt1 = 0x01;
						Alt2 = 0x03;
						break;

					case 1:
						Alt1 = 0x00;
						Alt2 = 0x03;
						break;

					case 2:
						Alt1 = 0x00;
						Alt2 = 0x01;
						break;

					case 3:
						Alt1 = 0x00;
						Alt2 = 0x01;
						break;
				}
				
			break;

			case 3:
				switch(DLE2 & 0x03)
				{
					case 0:
						Alt1 = 0x01;
						Alt2 = 0x02;
						break;

					case 1:
						Alt1 = 0x00;
						Alt2 = 0x02;
						break;

					case 2:
						Alt1 = 0x00;
						Alt2 = 0x01;
						break;

					case 3:
						Alt1 = 0x00;
						Alt2 = 0x01;
						break;
				}
			}

		AltDLE1 = DLE1 & 0xfc | Alt1;			
		AltDLE2 = DLE2 & 0xfc | Alt2;			

		int loop = (bitmap->datasize - 2) & 0xfffffffe;

		while(loop > 0)
		{
			if (*data == DLE1)
			{
				if ( *(data + 1) == 0)
				{
					data += 2;
					loop -= 2;
					continue;
				}

				else if (*(data + 1)  > 0x80)
				{
					data += 2;
					loop -= 2;
					continue;
				}

				
				else
				{
					data += 3;
					loop -= 3;
				}
			}

			else if (*data == DLE2)
			{
				if (*(data + 1) == 0)
				{
					data += 3;
					loop -= 3;
				}

				else
				{
					data += 4;
					loop -= 4;
				}
			}
			
			else
			{
				__asm
				{
					mov  esi, [data]
					mov  ax, WORD ptr [esi]
					mov  bx, ax
					and  bx, 7fe0h
					add  ax, bx

					cmp  al, DLE1
					jne  TestDLE2

					mov  al, [AltDLE1]

				TestDLE2:
					cmp  al, DLE2
					jne  EndDLECmp2

					mov  al, [AltDLE2]

				EndDLECmp2:
					mov  WORD ptr [esi], ax
				}
				
				data += 2;
				loop -= 2;		
			}
		}
	}
	
	else
	{
		__asm
		{
			cld

	  // Load source
			mov  esi, [data]

	  // Load lines
			mov  edx, [bmd.height]

		forward:
			mov  ecx, [bmd.width]     ; Do two pixels at a time

			test ecx, 1
			je   notodd

			mov  ax, [esi]
			and  ax, 7fe0h
			add  [esi], ax
			add  esi, 2

		notodd:
			shr  ecx, 1

		floop:
			mov  eax, [esi]
			and  eax, 7fe07fe0h           ; Ands out blue
			add  [esi], eax
			add  esi, 4                   ; doubles green
			dec  ecx
			jne  floop

			dec  edx
			jne  forward
		}
	}

	// transform alias data (RLE)
	if (bitmap->flags & BM_ALIAS)
	{
		DWORD *alias = (DWORD *) bitmap->alias.ptr();

		__asm
		{
			mov	 esi, [alias]					// load alias data

		setuprun:
			mov	 cl, [esi]						// load up run code
			inc	 esi
			cmp	 cl, AL_EOL						// check for end of line
			je	 nextline
			
		skiprun:
			or	 cl, cl							// once skip complete, do data run
			jz	 setupdatarun
			
			dec	 cl								// decrement run counter
			jmp	 skiprun

		setupdatarun:
			mov	 cl, [esi]						// get run code
			inc	 esi

		datarun:
			or	 cl, cl							// check for remaining pixels
			jz	 setuprun

			mov  ax, [esi]						// pixel to transform
			mov  bx, ax							// save it
			and  bx, 7fe0h						// and out the blue
			add  ax, bx							// double green
			mov  [esi], ax						// overwrite old (15-bit) pixel

			add  esi, 3							// skip pixel data and intensity
			dec	 cl								// decrement run counter
			jmp	 datarun

		nextline:
			mov	 cl, [esi]						// load up run code
			inc	 esi

			cmp	 cl, AL_EOL						// blank line..
			je	 nextline

			cmp	 cl, AL_EOD						// check for end of data
			jne	 skiprun							// do the line

			// if we get to here, EOD was reached...we're done
		}

	}
	
	data = (BYTE *)bitmap->zbuffer.ptr();

    bitmap->flags = (bitmap->flags & ~BM_15BIT) | BM_16BIT;
	int r = (bitmap->keycolor >> 10) & 0x1F;
	int g = (bitmap->keycolor >> 5) & 0x1F;
	int b = bitmap->keycolor & 0x1F;
	bitmap->keycolor = (r << 11) | (g << 6) | b;

	return TRUE;
}

BOOL ConvertPal15to16(PTBitmapData bitmap)
{
    if (Display->BitsPerPixel() == 15)
		return TRUE;

	WORD *pal = (WORD *)bitmap->palette.ptr();

	for (int i = 0; i < 256; pal++, i++)
	{
		WORD red = (*pal >> 10) & 0x1F;
		WORD green = (*pal >> 5) & 0x1F;
		WORD blue = *pal & 0x1F;
		*pal = (red << 11) | (green << 6) | blue;
	}

	return TRUE;
}

BOOL Convert16to15(PTBitmapData bitmap)
{
    if (Display->BitsPerPixel() == 15)
		return TRUE;

	TBitmapData bmd = *bitmap;
	BYTE *data = (BYTE *)bitmap->data16;
	BYTE *tmp = (BYTE *)bitmap->zbuffer.ptr();

	if (bitmap->flags & BM_COMPRESSED)
	{
		BYTE  DLE1 = *(data++);
		BYTE  DLE2 = *(data++);
	
		BYTE  AltDLE1;
		BYTE  AltDLE2;
		BYTE  Alt1 = 0;
		BYTE  Alt2 = 0;

		switch(DLE1 & 0x03)
		{
			case 0:
				switch(DLE2 & 0x03)
				{
					case 0:
						Alt1 = 0x01;
						Alt2 = 0x02;
						break;

					case 1:
						Alt1 = 0x02;
						Alt2 = 0x03;
						break;

					case 2:
						Alt1 = 0x01;
						Alt2 = 0x03;
						break;

					case 3:
						Alt1 = 0x01;
						Alt2 = 0x02;
						break;
				}
				
			break;

			case 1:
				switch(DLE2 & 0x03)
				{
					case 0:
						Alt1 = 0x02;
						Alt2 = 0x03;
						break;

					case 1:
						Alt1 = 0x00;
						Alt2 = 0x02;
						break;

					case 2:
						Alt1 = 0x00;
						Alt2 = 0x03;
						break;

					case 3:
						Alt1 = 0x00;
						Alt2 = 0x02;
						break;
				}
				
			break;

			case 2:
				switch(DLE2 & 0x03)
				{
					case 0:
						Alt1 = 0x01;
						Alt2 = 0x03;
						break;

					case 1:
						Alt1 = 0x00;
						Alt2 = 0x03;
						break;

					case 2:
						Alt1 = 0x00;
						Alt2 = 0x01;
						break;

					case 3:
						Alt1 = 0x00;
						Alt2 = 0x01;
						break;
				}
				
			break;

			case 3:
				switch(DLE2 & 0x03)
				{
					case 0:
						Alt1 = 0x01;
						Alt2 = 0x02;
						break;

					case 1:
						Alt1 = 0x00;
						Alt2 = 0x02;
						break;

					case 2:
						Alt1 = 0x00;
						Alt2 = 0x01;
						break;

					case 3:
						Alt1 = 0x00;
						Alt2 = 0x01;
						break;
				}
			}

		AltDLE1 = DLE1 & 0xfc | Alt1;			
		AltDLE2 = DLE2 & 0xfc | Alt2;			

		int loop = (bitmap->datasize - 2) & 0xfffffffe;

		while(loop > 0)
		{
			if (*data == DLE1)
			{
				if ( *(data + 1) == 0)
				{
					data += 2;
					loop -= 2;
					continue;
				}

				else if (*(data + 1)  > 0x80)
				{
					data += 2;
					loop -= 2;
					continue;
				}

				
				else
				{
					data += 3;
					loop -= 3;
				}
			}

			else if (*data == DLE2)
			{
				data += 4;
				loop -= 4;
			}
			
			else
			{
				__asm
				{
					mov  esi, [data]
					mov  ax, WORD ptr [esi]
					mov  bx, ax
					and  bx, 7fe0h
					add  ax, bx

					cmp  al, DLE1
					jne  TestDLE2

					mov  al, [AltDLE1]

				TestDLE2:
					cmp  al, DLE2
					jne  EndDLECmp2

					mov  al, [AltDLE2]

				EndDLECmp2:
					mov  WORD ptr [esi], ax
				}
				
				data += 2;
				loop -= 2;		
			}
		}
	}
	
	else
	{
		WORD *ptr = (WORD *)data;
		for (long i = 0; i < bmd.height * bmd.width; i++)
		{
			int r = (*ptr >> 11) & 0x1F;
			int g = (*ptr >> 5) & 0x3F;
			int b = *ptr & 0x1F;
			*ptr++ = (r << 10) | ((g >> 1) << 5) | b;
		}
	}

	// transform alias data (RLE)
	if (bitmap->flags & BM_ALIAS)
	{
		DWORD *alias = (DWORD *) bitmap->alias.ptr();

		__asm
		{
			mov	 esi, [alias]					// load alias data

		setuprun:
			mov	 cl, [esi]						// load up run code
			inc	 esi
			cmp	 cl, AL_EOL						// check for end of line
			je	 nextline
			
		skiprun:
			or	 cl, cl							// once skip complete, do data run
			jz	 setupdatarun
			
			dec	 cl								// decrement run counter
			jmp	 skiprun

		setupdatarun:
			mov	 cl, [esi]						// get run code
			inc	 esi

		datarun:
			or	 cl, cl							// check for remaining pixels
			jz	 setuprun

			mov  ax, [esi]						// pixel to transform
			mov  bx, ax							// save the pixel
			shr  ax, 6							// divide green by two
			and  ax, 1Fh						// and out the red
			shl  ax, 5							// realign green bits
			or   ax, bx							// add back in the red and the blue
			mov  [esi], ax						// overwrite old (15-bit) pixel

			add  esi, 3							// skip pixel data and intensity
			dec	 cl								// decrement run counter
			jmp	 datarun

		nextline:
			mov	 cl, [esi]						// load up run code
			inc	 esi

			cmp	 cl, AL_EOL						// blank line..
			je	 nextline

			cmp	 cl, AL_EOD						// check for end of data
			jne	 skiprun							// do the line

			// if we get to here, EOD was reached...we're done
		}

	}
	
	data = (BYTE *)bitmap->zbuffer.ptr();

    bitmap->flags = (bitmap->flags & ~BM_16BIT) | BM_15BIT;

	return TRUE;
}

BOOL ConvertPal16to15(PTBitmapData bitmap)
{
    if (Display->BitsPerPixel() == 15)
		return TRUE;

	WORD *pal = (WORD *)bitmap->palette.ptr();

	for (int i = 0; i < 256; pal++, i++)
	{
		WORD red = (*pal >> 10) & 0x1F;
		WORD green = (*pal >> 5) & 0x3F;
		WORD blue = *pal & 0x1F;
		*pal = (red << 10) | ((green >> 1) << 5) | blue;
	}

	return TRUE;
}

BOOL LineDraw(PSDrawBlock db, PSDrawParam dp)
{
    if (dp->dwidth < 1 || dp->dheight < 1) 
		return FALSE;

	int x1 = ((SLineParam *)dp->data)->x1;
	int y1 = ((SLineParam *)dp->data)->y1;
	int x2 = ((SLineParam *)dp->data)->x2;
	int y2 = ((SLineParam *)dp->data)->y2;
	int dx = x2 - x1 + 1;
	int dy = y2 - y1 + 1;
	DWORD color = dp->color;

  // Trivial clipping
	if (x2 < dp->dx || y2 < dp->dy ||
		x1 >= dp->dx + dp->dwidth || y1 >= dp->dy + dp->dheight)
		return FALSE;

  // Non trivial clipping (anybody every played non trivial clipping pursuit?)
	if (x1 < dp->dx)
	{
		y1 += (dp->dx - x1) * dy / dx;  // Add to y1 a proportional amount
		x1 = dp->dx;
	}
	if (y1 < dp->dy)
	{
		x1 += (dp->dy - y1) * dx / dy;  // Add to x1 a proportional amount 
		y1 = dp->dy;
	}
	if (x1 >= dp->dx + dp->dwidth)
	{
		y1 -= (x1 - dp->dx + dp->dwidth + 1) * dy / dx;  // Subtract proportion
		x1 = dp->dx + dp->dwidth - 1;
	}
	if (y1 >= dp->dy + dp->dheight)
	{
		x1 -= (y1 - dp->dy + dp->dheight + 1) * dx / dy;	// Subtract proportion
		y1 = dp->dy + dp->dheight - 1;
	}
	
	x1 += dp->originx;
	y1 += dp->originy;
	x2 += dp->originx;
	y2 += dp->originy;

    int width  = db->dstride;
    int height = db->dbufheight;
	
	SDrawBlock drawb = *db;

	if ((db->dstbitmapflags & BM_15BIT) || (db->dstbitmapflags & BM_16BIT))
    {
        DWORD newcolor = color;

        width       = width << 1;
        int start   = y1 * width + ( x1 << 1);
        int xchange = x2 - x1;
        int ychange = y2 - y1;

        if (xchange == 0)
        {
			ychange++;
            __asm
            {
                mov  ax, WORD PTR newcolor
                mov  edi, drawb.dest
                add  edi, start

                mov  ecx, ychange

            vertloop:
                mov  [edi], ax
                add  edi, width

                dec  ecx
                jne  vertloop
            }
        }

        else if (ychange == 0)
        {
			xchange++;
            __asm
            {
                mov  ax, WORD PTR newcolor
                shl  eax, 16
                mov  ax, WORD PTR newcolor

                mov  edi, drawb.dest
                add  edi, start

                mov  ecx, xchange
                test ebx, 1
                je   notodd
                mov  [edi], ax
                add  edi, 2

            notodd:
                shr  ecx, 1

            horzloop:
                mov  [edi], eax
                add  edi, 4

                dec  ecx
                jne  horzloop
            }
		}

        else if (ychange == xchange)
        {
            WORD xincr = (int)(((double)xchange / (double)ychange) * 65536.0);

            __asm
            {
                mov  ax, WORD PTR newcolor
                shl  eax, 16
                mov  ax, WORD PTR newcolor

                mov  edi, drawb.dest
                add  edi, start

                mov  ecx, ychange
            diagloop:
                mov  [edi], ax
                add  edi, width
                add  edi, 2

                dec  ecx
                jne  diagloop
            }
        }

		else if (ychange > xchange)
        {
            WORD xincr = (int)(((double)xchange / (double)ychange) * 65536.0);

            __asm
            {
                mov  ax, WORD PTR newcolor
                shl  eax, 16
                mov  ax, WORD PTR newcolor

                mov  edi, drawb.dest
                add  edi, start

                xor  ebx, ebx					; Error term

                mov  ecx, ychange
            yloop:
                mov  [edi], ax
                add  edi, width

                add  bx, xincr					; Check if error term is > 1 
                jnc  noincrement  

                add  edi, 2

            noincrement:
                dec  ecx
                jne  yloop
            }
		}

        else									
        {
            WORD yincr = (int)(((double)xchange / (double)ychange) * 65536.0);
            __asm
            {									; xchange > ychange
                mov  ax, WORD PTR newcolor
                shl  eax, 16
                mov  ax, WORD PTR newcolor

                mov  edi, drawb.dest
                add  edi, start

                xor  ebx, ebx					; Error term

                mov  ecx, xchange

            xloop:
                mov  [edi], ax
                add  edi, 2

                add  bx, yincr					; Check if error term is > 1 
                jnc  noincrementx

                add  edi, width

            noincrementx:
                dec  ecx
                jne  xloop
            }
        }
    }

	else if (db->dstbitmapflags & BM_24BIT)		
    {
        width = (width << 1) + width;
        int start = y1 * width + (x1 << 1 + x1);
        int xchange = x2 - x1;
        int ychange = y2 - y1;

        if (xchange == 0)
        {
            __asm
            {									; Draw 24 bit line
                mov  ah, color.red
                mov  al, color.green
				shl  eax, 16
				mov  ah, color.blue

                mov  edi, drawb.dest
                add  edi, start

                mov  ecx, ychange

            vertloop24:
                mov  al, [edi + 3]
				mov  [edi], eax
                add  edi, width

                dec  ecx
                jne  vertloop24
            }
        }

        else if (ychange == 0)
        {
            __asm
            {
                mov  ah, color.red
                mov  al, color.green
                shl  eax, 16
				mov  ah, color.blue
				xor  al, al

                mov  edi, drawb.dest
                add  edi, start

                mov  ecx, xchange
				dec  ecx						; Do one less write since last write 
												; must not change neighboring pixel
            horzloop24:
                mov  [edi], eax
                add  edi, 3

                dec  ecx
                jne  horzloop24
				
                mov  al, [edi + 3]				; Write out last pixel the SLOOOW way
				mov  [edi], eax
			}
		}

        else if (ychange = xchange)
        {
            WORD xincr = (int)(((double)xchange / (double)ychange) * 65536.0);

            __asm
            {
                mov  ah, color.red
                mov  al, color.green
                mov  dl, color.blue

                mov  edi, drawb.dest
                add  edi, start

                mov  ecx, ychange
            
			diagloop24:
                mov  al, [edi + 3]
				mov  [edi], eax
                add  edi, 3
				add  edi, width

                dec  ecx
                jne  diagloop24
            }
		}

        else if (ychange > xchange)
        {
            WORD xincr = (int)(((double)xchange / (double)ychange) * 65536.0);

            __asm
            {
                mov  ah, color.red
                mov  al, color.green
                mov  dl, color.blue

                mov  edi, drawb.dest
                add  edi, start

                xor  ebx, ebx					; Error term

                mov  ecx, ychange
            yloop24:
                mov  al, [edi + 3]
				mov  [edi], eax
                add  edi, width

                add  bx, xincr					; Check if error term is > 1 
                jnc  noincrementy  

                add  edi, 3

            noincrementy:
                dec  ecx
                jne  yloop24
            }
		}

        else									
        {
            WORD yincr = (int)(((double)xchange / (double)ychange) * 65536.0);
            __asm
            {									; xchange > ychange
                mov ah, color.red
                mov al, color.green
                mov dl, color.blue

                mov  edi, drawb.dest
                add  edi, start

                xor  ebx, ebx					; Error term

                mov  ecx, xchange
            xloop24:
                mov  al, [edi + 3]
				mov  [edi], eax
                add  edi, 3

                add  bx, yincr					; Check if error term is > 1 
                jnc  noincrement24x

                add  edi, width

            noincrement24x:
                dec  ecx
                jne  xloop24
            }
        }
	}

	else if (db->dstbitmapflags & BM_32BIT)		
    {
        width = (width << 2);
        int start = y1 * width + (x1 << 2);
        int xchange = x2 - x1;
        int ychange = y2 - y1;

        if (xchange == 0)
        {
            __asm
            {									; Draw 32 bit line
                mov  ah, color.red
                mov  al, color.green
                shl  eax, 16
				mov  ah, color.blue

                mov  edi, drawb.dest
                add  edi, start

                mov  ecx, ychange

            vertloop32:
                mov  [edi], eax
                add  edi, width

                dec  ecx
                jne  vertloop32 
            }
        }

        else if (ychange == 0)
        {
            __asm
            {
                mov  ah, color.red;
                mov  al, color.green;
                shl  eax, 16
				mov  ah, color.blue;

                mov  edi, drawb.dest
                add  edi, start

                mov  ecx, xchange

            horzloop32:
                mov  [edi], eax
				add  edi, 4

                dec  ecx
                jne  horzloop32
            }
		}

        else if (ychange = xchange)
        {
            WORD xincr = (int)(((double)xchange / (double)ychange) * 65536.0);

            __asm
            {
                mov  ah, color.red
                mov  al, color.green
                shl  eax, 16
				mov  ah, color.blue

                mov  edi, drawb.dest
                add  edi, start

                mov  ecx, ychange
            
			diagloop32:
                mov  [edi], eax
                add  edi, 4
				add  edi, width

                dec  ecx
                jne  diagloop32
            }
		}

        else if (ychange > xchange)
        {
            WORD xincr = (int)(((double)xchange / (double)ychange) * 65536.0);

            __asm
            {
                mov  ah, color.red
                mov  al, color.green
                shl  eax, 16
				mov  ah, color.blue

                mov  edi, drawb.dest
                add  edi, start

                xor  ebx, ebx					; Error term

                mov  ecx, ychange

            yloop32:
                mov  [edi], eax
                add  edi, width

                add  bx, xincr					; Check if error term is > 1 
                jnc  noincrementy32

                add  edi, 4

            noincrementy32:
                dec  ecx
                jne  yloop32
            }
		}

        else									
        {
            WORD yincr = (int)(((double)xchange / (double)ychange) * 65536.0);
            __asm
            {									; xchange > ychange
                mov  ah, color.red
                mov  al, color.green
                shl  eax, 16
				mov  ah, color.blue

                mov  edi, drawb.dest
                add  edi, start

                xor  ebx, ebx					; Error term

                mov  ecx, xchange
            xloop32:
                mov  [edi], eax
                add  edi, 4

                add  bx, yincr					; Check if error term is > 65535
                jnc  noincrementx32

                add  edi, width

            noincrementx32:
                dec  ecx
                jne  xloop32
            }
        }
	}

	return TRUE;
}

BOOL TextDraw(PSDrawBlock db, PSDrawParam dp)
{
	int startline = ((STextParam *)dp->data)->startline;
	int numlines = ((STextParam *)dp->data)->numlines;
	char *text = ((STextParam *)dp->data)->text;
	TFont *font = ((STextParam *)dp->data)->font;
	int wrapwidth = ((STextParam *)dp->data)->wrapwidth;
	int justify = ((STextParam *)dp->data)->justify;
	BOOL draw = ((STextParam *)dp->data)->draw;
	int linespace = ((STextParam *)dp->data)->linespace;			
	int lineheight = font->height + linespace;
					
	if (!text || !*text)
		return FALSE;

	SDrawBlock ndb;
	SDrawParam ndp;
	PTBitmap ch;
	int tmpy;

	ndb = *db;								// preserve arguments
	ndp = *dp;

	ndp.func = NULL;
	ndp.callback = NULL;
	ndp.dy += lineheight;
	if (!((STextParam *)dp->data)->noclip)
		ndp.drawmode &= ~DM_NOCLIP;		// used to skip initial clip

	SRect update(1000000, 1000000, -1000000, -1000000);		// update rectangle for callback

	BOOL needsprocessing = wrapwidth < 0 ? FALSE : TRUE;	// wordwrap processing
	BOOL wrap = FALSE;

	int width = 0;					// width of current line

	BOOL wasdrawing = draw;
	char *linestart = text;

	if (draw && justify & JUSTIFY_CLIP)
	{
		// do a single run through to determine text height after wordwrap
		((STextParam *)dp->data)->draw = FALSE;
		TextDraw(db, dp);
		((STextParam *)dp->data)->draw = draw;

		if (((STextParam *)dp->data)->length > 1)
			ndp.dy -= (((STextParam *)dp->data)->length - 1) * lineheight;
	}

	if (!(justify & JUSTIFY_LEFT))
		draw = FALSE;				// first pass just check text width

	int l = 0;

	do
	{
		if (needsprocessing || (*text == ' ' && wrapwidth >= 0))
		{
			int x = width;
			for (char *ptr = (text+1); *ptr && *ptr != ' ' && !wrap; ptr++)
			{
				x += font->DrawRight(*ptr) - font->DrawLeft(*ptr);
				if (x >= wrapwidth)
					wrap = TRUE;
			}
			needsprocessing = FALSE;
		}

		if (wrap || *text == '\n' || *text == 0)
		{
			if (wasdrawing && !draw)
			{
				// figure out alignment then draw for real
				if (justify & JUSTIFY_CENTER)
					ndp.dx = dp->dx - ((ndp.dx - dp->dx) / 2);
				else if (justify & JUSTIFY_RIGHT)
					ndp.dx = dp->dx - (ndp.dx - dp->dx);

				if (justify & JUSTIFY_CLIP)
				{
					// force it to stay within the given rect
					int left = dp->clipx - dp->originx + 16;
					if (ndp.dx < left)
						ndp.dx = left;

					int right = dp->clipx - dp->originx + dp->clipwidth - 16;
					if ((ndp.dx + width) >= right)
						ndp.dx = right - width;

					int top = dp->clipy - dp->originy + 24 + lineheight;
					if (ndp.dy < top)
						ndp.dy = top;
				}

				draw = TRUE;
				text = linestart;
			}
			else
			{
				l++;
				if (l > startline)
					ndp.dy += lineheight;
				ndp.dx = dp->dx;
				width = 0;

				if (!(justify & JUSTIFY_LEFT))
				{
					linestart = text;
					draw = FALSE;
				}
			}

			wrap = FALSE;
			width = 0;
		}

		if (*text != '\n')
		{
			ch = font->GetChar(*text);
			if (ch)
			{
				tmpy = ndp.dy;
				ndp.dy -= font->StartHeight(*text);
				ndp.dx -= font->DrawLeft(*text);

				if (draw && l >= startline && *text != ' ')
				{
					ndb.source     = ch->data16;
					ndb.sbufwidth  = ndp.swidth = ndp.dwidth = ch->width;
					ndb.sbufheight = ndp.sheight = ndp.dheight = ch->height;
					ndb.sstride    = ndb.sbufwidth;
					ndb.alias      = (BYTE *)ch->alias.ptr();

					Draw(&ndb, &ndp);

					// check bounds on update rectangle
					if (ndp.dy < update.top)
						update.top = ndp.dy;
					if ((ndp.dy + ch->height - 1) > update.bottom)
						update.bottom = ndp.dy + ch->height - 1;
					if (ndp.dx < update.left)
						update.left = ndp.dx;
					if ((ndp.dx + ch->width - 1) > update.right)
						update.right = ndp.dx + ch->width - 1;
				}

				ndp.dx += font->DrawRight(*text);
				ndp.dy = tmpy;

				width += font->DrawRight(*text) - font->DrawLeft(*text);
			}
		}
	} while (l < (startline + numlines) && *text++);

	if (dp->callback && ((STextParam *)dp->data)->draw)
	{
		ndp.dx = max(update.left, dp->clipx - dp->originx);
		ndp.dy = max(update.top, dp->clipy - dp->originy);
		ndp.dwidth = min(update.right - update.left + 1, dp->clipwidth);
		ndp.dheight = min(update.bottom - update.top + 1, dp->clipheight);
		dp->callback(&ndb, &ndp);
		dp->drawmode |= DM_DOESCALLBACK; // Tells draw function we already did callback
	}

	((STextParam *)dp->data)->length = l - startline;

	return TRUE;
}


// *********** Chunk Z Find Routine *********
WORD ZFindChunk(PSDrawBlock db, PSDrawParam dp)
{
	PSChunkHeader hdr = NULL;
	
	if (dp->drawmode & DM_ZBUFFER)
		hdr = (PSChunkHeader)db->szbuffer;
	else if (dp->drawmode & DM_ZSTATIC)
		hdr = (PSChunkHeader)db->source;

	if (hdr == NULL)
		return 0x7f7f;

	int ULx = dp->sx / CHUNKWIDTH;
	int ULy = dp->sy / CHUNKHEIGHT;

	int sx = dp->sx % CHUNKWIDTH;
	int sy = dp->sy % CHUNKHEIGHT;

	if (dp->drawmode & DM_ZBUFFER)
	{
		WORD *szbuffer = (WORD *)ChunkCache.AddChunkZ(hdr->block[ULy * hdr->width + ULx].ptr(), 2);

		if (szbuffer)
			return szbuffer[CHUNKWIDTH * sy + sx];
	}
	else if (dp->drawmode & DM_ZSTATIC)
	{
		if (db->srcbitmapflags & BM_8BIT)
		{
			BYTE *buffer = (BYTE *)ChunkCache.AddChunk(hdr->block[ULy * hdr->width + ULx].ptr(), 1);

			if (buffer && buffer[CHUNKWIDTH * sy + sx] != db->keycolor)
				return 0;

			return 0x7f7f;
		}
		else if (db->srcbitmapflags & (BM_15BIT | BM_16BIT))
		{
			WORD *buffer = (WORD *)ChunkCache.AddChunk16(hdr->block[ULy * hdr->width + ULx].ptr(), 1);

			if (buffer && buffer[CHUNKWIDTH * sy + sx] != db->keycolor)
				return 0;

			return 0x7f7f;
		}
	}

	return 0x7f7f;
}

// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                     helper.cpp - THelper module                       *
// *************************************************************************

#include <windows.h>

#include "revenant.h"
#include "helper.h"
#include "3dimage.h"
#include "mappane.h"

REGISTER_BUILDER(THelper)

TObjectClass HelperClass("HELPER", OBJCLASS_HELPER, 0);

// *******************
// * Helper Animator *
// *******************

_CLASSDEF(THelperAnimator)
class THelperAnimator : public T3DAnimator
{
  public:
	THelperAnimator(PTObjectInstance oi) : T3DAnimator(oi) {}
	  // Constructor (initialization handled by Initialize)
	virtual ~THelperAnimator() { Close(); }
	  // Call close function

	virtual void SetupObjects();
	  // Sets up objects
	virtual BOOL Render();
	  // Renders objects
};

REGISTER_3DANIMATOR("Box", THelperAnimator)

// Sets up the objects to animate (simply uses whatever objects are in the imagery)
// Override this function to set up whatever objects you need for your effect, etc.
void THelperAnimator::SetupObjects()
{
	PS3DAnimObj o = NewObject(0, OBJ3D_VERTS | OBJ3D_COPYVERTS | OBJ3D_POS1);
	AddObject(o);
}

BOOL THelperAnimator::Render()
{
	PS3DAnimObj obj = GetObject(0);

	ResetExtents();

	int width, length, height;
	image->GetWorldBoundBox(state, width, length, height);

	obj->pos.x = -(float)((((float)width / 2.0) - (float)image->GetWorldRegX(state)) * (float)GRIDSIZE);
	obj->pos.y = -(float)((((float)length / 2.0) - (float)image->GetWorldRegY(state)) * (float)GRIDSIZE);
	obj->pos.z = -(float)((((float)height / 2.0) - (float)image->GetWorldRegZ(state)) * (float)GRIDSIZE);

	for (int i = 0; i < obj->numverts; i++)
	{
		D3DVERTEX *v = &(((D3DVERTEX *)obj->verts)[i]);

		if (v->x)
		{
			v->x = (float)((float)width / 2.0 * (float)GRIDSIZE);
			if (v->x < 0)
				v->x *= -1;
		}
		if (v->y)
		{
			v->y = (float)((float)length / 2.0 * (float)GRIDSIZE);
			if (v->y < 0)
				v->y *= -1;
		}
		if (v->z)
		{
			v->z = (float)((float)height / 2.0 * (float)GRIDSIZE);
			if (v->z < 0)
				v->z *= -1;
		}
	}

	RenderObject(obj);

	UpdateExtents();
	
	return TRUE;
}
// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                      object.cpp - TObject module                      *
// *************************************************************************

#include <windows.h>
#include <process.h>
#include <sys/types.h>
#include <sys/stat.h>

#include "revenant.h"
#include "bitmap.h"
#include "imagery.h"
#include "object.h"
#include "resource.h"

// Builder array for imagery builder class
int TImageryBuilder::numimagerytypes = 0;
PTImageryBuilder TImageryBuilder::builders[MAXIMAGERYTYPES];

// Imagery loading status values
#define QE_NONE		 0
#define QE_QUEUED	 1
#define QE_LOADING	 2
#define QE_LOADED	 3
#define QE_FAILED	 4

extern DWORD ImageryMemUsage;

static TVirtualArray <SImageryEntry> EntryArray;

static char imagerypath[FILENAMELEN];

//BOOL LoaderWait = FALSE;

// *******************
// * TObjectAnimator *
// *******************

TObjectAnimator::TObjectAnimator(PTObjectInstance oi)
{
    inst = oi;
    image = oi->GetImagery();

  // These values are copied from 'inst' each frame 
  // (frame/framerate are copied back after ani)
	prevstate = state = -1;
	frame = 0;		
	framerate = 1;

	newstate = TRUE;
	complete = FALSE;
}

TObjectAnimator::~TObjectAnimator()
{
	Close();
}

void TObjectAnimator::Animate(BOOL draw)
{
	int stateflags = 0;
	int statesize = 0;

	frame = inst->GetFrame();
	framerate = inst->GetFrameRate();

	if (state != inst->GetState())
	{
		newstate = TRUE;
		complete = FALSE;
		prevstate = state;
 		state = inst->GetState();

		if (inst->IsInInventory())
		{
			stateflags = image->GetInvAniFlags(state);
			statesize = image->GetInvAniLength(state);
		}
		else
		{
			stateflags = image->GetAniFlags(state);
			statesize = image->GetAniLength(state);
		}
	}
	else
	{
		if (inst->IsInInventory())
			statesize = image->GetInvAniLength(state);
		else
			statesize = image->GetAniLength(state);
	}

	if (inst->IsInInventory())
		stateflags = image->GetInvAniFlags(state);
	else
		stateflags = image->GetAniFlags(state);

	if (newstate)
		newstate = FALSE;
	else
	{
		frame += framerate;

		if (framerate < 0)
		{
			if (frame <= 0)
			{
				prevstate = state;
				inst->SetCommandDone(TRUE);

				if (frame < 0)
				{
					if (stateflags & AF_LOOPING)
						frame = statesize - 1;
					else
					{
						if (stateflags & AF_PINGPONG)
						{
							frame = 1;
							framerate = 1;
						}
						else
						{
							complete = TRUE;
							frame = 0;
						}
					}
				}
			}
			else if (inst->CommandDone() == TRUE)
				inst->SetCommandDone(FALSE);
		}
		else
		{
			if (frame >= (statesize - 1))
			{
				prevstate = state;
				inst->SetCommandDone(TRUE);

				if (frame >= statesize)
				{
					if (stateflags & AF_LOOPING)
						frame = 0;
					else
					{
						if (stateflags & AF_PINGPONG)
						{
							frame = statesize - 1;
							framerate = -1;
						}
						else
						{
							complete = TRUE;
							frame = statesize - 1;
						}
					}
				}
			}
			else if (inst->CommandDone() == TRUE)
				inst->SetCommandDone(FALSE);
		}
	}
}

// *******************
// * TImageryBuilder *
// *******************

TImageryBuilder::TImageryBuilder(int newid)
{
	if (newid >= numimagerytypes)
		numimagerytypes = newid + 1;

	builders[newid] = this;
	imageryid = newid;
}

// ******************
// * TObjectImagery *
// ******************

TObjectImagery::TObjectImagery(int id)
{
	imageryid = id;
	entry = &EntryArray[id];

	entry->headerdirty = FALSE;
	entry->bodydirty = FALSE;

	if (!entry->body)
		LoadBody(FALSE); // Queue imagery load
}

TObjectImagery::~TObjectImagery()
{
	FreeBody();
}

int TObjectImagery::RegisterImagery(char *filename, PSImageryHeader header, DWORD headersize)
{
	for (int c = 0; c < EntryArray.NumItems(); c++)
	{
		if (EntryArray.Used(c) && !stricmp(EntryArray[c].filename, filename))
		{
			if (header)
				free(header);
			return c;
		}
	}

	if (!header)
	{
		char buf[FILENAMELEN];
		strcpy(buf, imagerypath);
		strcat(buf, filename);
		header   = (PSImageryHeader)LoadResourceHeader(buf, -1, (DWORD *)&headersize);
	}

	if (!header)
	{
		Status("WARNING: Unable to load imagery header for %s", filename);
		return -1;
	}

	SImageryEntry ie;
	memset(&ie, 0, sizeof(SImageryEntry));
	strncpy(ie.filename, filename, MAXIMFNAMELEN - 1);

	ie.status     = QE_NONE;
	ie.header     = header;
	ie.headersize = headersize;
	ie.body       = NULL;
	ie.usecount   = 0;
	ie.imagery    = NULL;

	ie.headerdirty = FALSE;
	ie.bodydirty = FALSE;

//	VirtualLock(ie.header, ie.headersize);

#ifdef CHECK_IMAGERY_HEADER_VALIDITY

// This stuff checks the header validity of the imagery by checking the size
// of the bounding box compared to the walkmap.  To turn checking off, comment
// out the define above.  To turn on auto-fix mode (rebuilds any corrupted headers
// found, killing whatever walkmaps they might have had) comment the three FatalError()
// calls out, below, and change the #if 0 to #if 1.

	int size = sizeof(SImageryHeader);

	BOOL fixit = FALSE;

	for (int i = 0; i < ie.header->numstates; i++)
	{
		if (i > 0)
			size += sizeof(SImageryStateHeader);

		size += ie.header->states[i].wwidth * ie.header->states[i].wlength;
		if (ie.header->states[i].wwidth < 1 || ie.header->states[i].wlength < 1)
		{
			if (ie.header->states[i].walkmap.ptr() != NULL)
			{
				FatalError("State has walkmap but no bounding box");
				fixit = TRUE;
			}
		}
		else
		{
			if (ie.header->states[i].walkmap.ptr() == NULL)
			{
				FatalError("State has bounding box but no walkmap");
				fixit = TRUE;
			}
		}
	}

	size = (size + 3) & 0xFFFFFFFCL;		 // Round to even 4 bytes

	if ((fixit || size != ie.headersize) && !strstr(ie.filename, "i3d"))
	{
		FatalError("'Holy shitballs, Batman!  The imagery is fucked up again!  Curse that infernal Joker!'");
#if 0
		BYTE *newbuf = (BYTE *)malloc(size);
		int skipdist = sizeof(SImageryHeader) + (sizeof(SImageryStateHeader) * (ie.header->numstates - 1));
		BYTE *ptr = newbuf + skipdist;

		PSImageryHeader head = (PSImageryHeader)newbuf;
		memcpy(newbuf, ie.header, sizeof(SImageryHeader));

		for (i = 0; i < ie.header->numstates; i++)
		{
			PSImageryStateHeader sh = &(head->states[i]);

			memcpy(sh, &ie.header->states[i], sizeof(SImageryStateHeader));

			int w = ie.header->states[i].wwidth;
			int l = ie.header->states[i].wlength;

			if (w && l)
			{
				sh->walkmap.set(ptr);
				memset(ptr, 0, w * l);
				ptr += w * l;
			}
			else
				sh->walkmap.set(NULL);
		}

		ie.header = (PSImageryHeader)newbuf;
		ie.headersize = size;
		ie.headerdirty = TRUE;
#endif
	}
#endif

	int id = EntryArray.Add(ie);

	if (id < 0)
		FatalError("Not enough room for imagery in imagery entry array!");

	return id;
}

PSImageryEntry TObjectImagery::GetImageryEntry(int id)
{
	return &(EntryArray[id]);
}

void TObjectImagery::FreeImagery(int imageryentry)
{
    if (EntryArray[imageryentry].header)
        free(EntryArray[imageryentry].header);

    if (EntryArray[imageryentry].body)
        free(EntryArray[imageryentry].body);

    memset(&EntryArray[imageryentry], 0, sizeof(SImageryEntry));
}

void TObjectImagery::FreeAllImagery()
{
	if (Editor)
		SaveAllHeaders();

	for (int c = 0; c < EntryArray.NumItems(); c++)
        FreeImagery(c);
}

void TObjectImagery::ReloadImagery()
{
	BEGIN_CRITICAL();

	for (int loop = 0; loop < EntryArray.NumItems(); loop++)
	{
		if (EntryArray.Used(loop))
		{
			EntryArray[loop].status  = QE_NONE;
			EntryArray[loop].imagery = NULL;
			EntryArray[loop].body    = NULL;
			EntryArray[loop].ressize = 0;
		}
	}

	END_CRITICAL();
}

void TObjectImagery::SetImageryPath(char *path)
{
	if (path)
		strcpy(imagerypath, path);
}

char *TObjectImagery::GetImageryPath()
{
	return imagerypath;
}

BOOL TObjectImagery::RenameImageryFile(int imageryid, char *newfile)
{
    if ((imageryid < 0) || (EntryArray.Used(imageryid) == FALSE) ||
        (imageryid >= EntryArray.NumItems()) || (strlen(newfile) >= MAXIMFNAMELEN))
        return FALSE;

    strcpy(EntryArray[imageryid].filename, newfile);
    EntryArray[imageryid].headerdirty = TRUE;

    return TRUE;
}

void TObjectImagery::SaveAllHeaders()
{
	for (int c = 0; c < EntryArray.NumItems(); c++)
		SaveHeader(c);

	QuickSaveHeaders();  // Save a single file with all headers in it
}

void TObjectImagery::SetEntryReg(int imageryid, int state, int regx, int regy, int regz)
{
    EntryArray[imageryid].header->states[state].regx = regx;
    EntryArray[imageryid].header->states[state].regy = regy;
    EntryArray[imageryid].header->states[state].regz = regz;
    EntryArray[imageryid].headerdirty = TRUE;
}

PTObjectImagery TObjectImagery::LoadImagery(int imgid)
{
	if (imgid < 0 || EntryArray.Used(imgid) == FALSE ||
		imgid >= EntryArray.NumItems())
		return NULL;

	RSImageryEntry ie = EntryArray[imgid];

	if (ie.imagery)
	{
		ie.usecount++;
	}

	else
	{
		PTImageryBuilder imbuilder = TImageryBuilder::GetBuilder(ie.header->imageryid);
		if (!imbuilder)
			return NULL;

		ie.imagery = imbuilder->Build(imgid);
		if (!ie.imagery)
			return NULL;

		ie.usecount = 1;
	}

	ie.imagery->imageryid = imgid;

	return ie.imagery;
}

void TObjectImagery::FreeImagery(PTObjectImagery imagery)
{
	if (!imagery || (DWORD)imagery->imageryid >= (DWORD)EntryArray.NumItems())
		return;

	if (!EntryArray.Used(imagery->imageryid))
		return;

	RSImageryEntry ie = EntryArray[imagery->imageryid];

	ie.usecount--;
	if (ie.usecount <= 0)
	{
		imagery->FreeBody();

		if (Editor && ie.imagery)	// Save header information if in editor
		{
			ie.imagery->SaveHeader();

			ImageryMemUsage -= ie.imagery->GetResSize();

			delete ie.imagery;
			ie.imagery = NULL;
		}

		ie.usecount = 0;
	}
}

// Restores all lost imagery surfaces, etc.
void TObjectImagery::RestoreAll()
{
	for (int c = 0; c < EntryArray.NumItems(); c++)
	{
		RSImageryEntry ie = EntryArray[c];
		if (ie.imagery != NULL)
			ie.imagery->Restore();
	}
}

int TObjectImagery::FindState(char *name, int pcnt)
{
	if (!name)
		return -1;

	int lowest = 100000; // Lowest frequency value
	int found = -1;		 // State with closest percent

	for (int loop = 0; loop < GetHeader()->numstates; loop++)
	{
		char *n = GetHeader()->states[loop].animname;
		char *pcntchar;
		int freq;

		if (n[0] <= '9' && n[0] >= '0' &&			// Starts with a number AND
			(pcntchar = strchr(n, '%')) != NULL)	// Number is a frequency percentage
		{
			freq = atoi(n);
			n = pcntchar + 1;
		}
		else
			pcntchar = NULL;

		if (!strcmpi(n, name))
		{
		  // Found what we're looking for, and it doesn't have a frequency prefix.. DONE!
			if (!pcntchar)
			{
				found = loop;
				break;
			}
		
		  // We have a frequency prefix.. do we have a random percentage value?
			if (pcnt < 0)
				pcnt = random(1, 100);	// No.. then get one!

		  // Check to see if frequency is closest to, but still >= percentage value
			if (freq >= pcnt && freq < lowest)
			{
				lowest = freq;
				found = loop;
			}
		}
	}

	return found;
}

// This function checks string against statename allowing for the "or" seperator.
// For example, "one" would match up against "one or two or three".
BOOL StateMatch(char *string, char *statename)
{
	if (!string || !statename)
		return FALSE;

	char buf[80];

	char *ptr = statename;
	do
	{
		char *sep = strstr(ptr, " or ");
		if (sep == NULL)
		{
			if (strcmpi(string, ptr) == 0)
				return TRUE;

			break;
		}
		else
		{
			int len = (int)(sep - ptr);
			memcpy(buf, ptr, len);
			buf[len] = 0;
		}

		if (strcmpi(string, buf) == 0)
			return TRUE;

		ptr = sep + 4;			// skip past the "or"
	} while (ptr);

	return FALSE;
}

// Finds a transition state, such as "stand to walk" if you passed in "stand" and "walk".
// Note that "stand or walk to walk", "stand to walk or run", and "stand or turn to walk" would also work.
int TObjectImagery::FindTransitionState(char *from, char *to, int pcnt)
{
	if (!from || !to)
		return -1;

	BOOL samestate = (strcmpi(from, to) == 0);

	char buf[80];

	int lowest = 100000; // Lowest frequency value
	int found  = -1;	 // State with closest percent
	int highest = -1;

	for (int loop = 0; loop < GetHeader()->numstates; loop++)
	{
		char *left = GetHeader()->states[loop].animname;
		char *pcntchar;
		int freq;

	  // Check to see if state has frequency prefix
		if (left[0] <= '9' && left[0] >= '0' &&		// Starts with a number AND
			(pcntchar = strchr(left, '%')) != NULL)	// Number is a frequency percentage
		{
			freq = atoi(left);
			left = pcntchar + 1;
		}
		else
			pcntchar = NULL;

		BOOL any_state;
		char *right;
		
		if(strncmp(left, "to ", 3) == 0)
		{
			any_state = TRUE;
			right = left + 3;
		}
		else
		{
			any_state = FALSE;
		  // Find the " to " in the name if it has one
			right = strstr(left, " to ");

		   // If has " to ", get separate right/left strings
			if (right)
			{
				int len = (int)(right - left);
				memcpy(buf, left, len);
				buf[len] = 0;
				left = buf;
				right += 4;		// skip the "to"
			}
		}

	  // State names match?
		if ((StateMatch(from, left) || any_state) &&	   			  // Matches left AND...
		    ((right == NULL && samestate) || StateMatch(to, right)))  // no right, or matches right
		{
		  // Found what we're looking for, and it doesn't have a frequency prefix.. DONE!
			if (!pcntchar)
			{
				found = loop;
				break;
			}
		
		  // We have a frequency prefix.. do we have a random percentage value?
			if (pcnt < 0)
				pcnt = random(1, 100);	// No.. then get one!

		  // Check to see if frequency is closest to, but still >= percentage value
			if (freq >= pcnt && freq < lowest)
			{
				lowest = freq;
				found = loop;
			}
		}
	}

	return found;
}

int TObjectImagery::GetUseCount()
{
	return entry->usecount;
}

// Returns screen update area and 'onscreen' intersection rectangle given data from state
void TObjectImagery::GetScreenRect(PTObjectInstance oi, SRect &r)
{
	if ((DWORD)oi->GetState() >= (DWORD)NumStates())
	{
		r.left = r.right = r.top = r.bottom = 0;
		return;
	}

	int x, y;
	oi->GetScreenPos(x, y);

	PSImageryStateHeader st = GetState(oi->GetState());

	if (st->width == 0 || st->height == 0) // Set some kind of initial value here
	{
		st->regx = 64;
		st->regy = 120;
		st->width = 128;
		st->height = 160;
		SetHeaderDirty(TRUE);
	}

	r.left   = x - st->regx;
	r.right  = r.left + st->width - 1;
	r.top    = y - st->regy;
	r.bottom = r.top + st->height - 1;
}

void TObjectImagery::GetAnimRect(PTObjectInstance oi, SRect &r)
{
	PSImageryStateHeader st = GetState(oi->GetState());

	if (!st || (st->animregx == 0 && st->animregy == 0))
	{
		r.left = r.right = r.top = r.bottom = 0;
		return;
	}

	int x, y;
	oi->GetScreenPos(x, y);

	r.left   = x + st->animregx;
	r.right  = r.left + st->width - 1;
	r.top    = y + st->animregy;
	r.bottom = r.top + st->height - 1;
}

void TObjectImagery::ResetScreenRect(PTObjectInstance oi, int state)
{
	if (state < 0)
	{
		for (int i = 0; i < NumStates(); i++)
			ResetScreenRect(oi, i);
	}
	else if ((DWORD)state < (DWORD)NumStates())
	{
		PSImageryStateHeader st = GetState(state);
		st->regx = st->regy = 0;
		st->width = st->height = 0;

		SetHeaderDirty(TRUE);
	}
}

void TObjectImagery::SaveHeader(int imgid)
{
	if (imgid < 0 || EntryArray.Used(imgid) == FALSE ||
		imgid >= EntryArray.NumItems())
		 FatalError("Invalid id when saving header");

	RSImageryEntry ie = EntryArray[imgid];

	if (ie.headerdirty)
	{
		char buf[120];
		strcpy(buf, imagerypath);
		strcat(buf, ie.filename);
		SaveResourceHeader(buf, ie.header, ie.headersize);

		ie.headerdirty = FALSE;
	}
}

void TObjectImagery::SetWorldBoundBox(int state, int width, int length, int height)
{
	if ((DWORD)state >= (DWORD)entry->header->numstates)
		return;

	if (width != entry->header->states[state].wwidth ||
		length != entry->header->states[state].wlength)
	{
		// reallocating the walkmap requires changing the structure size;
		// therefore, must start over with a new buffer and copy over
		// all the old data
		int size = sizeof(SImageryHeader);

		for (int i = 0; i < entry->header->numstates; i++)
		{
			if (i > 0)
				size += sizeof(SImageryStateHeader);

			if (i == state)
				size += width * length;
			else
				size += entry->header->states[i].wwidth * entry->header->states[i].wlength;
		}

		size = (size + 3) & 0xFFFFFFFCL;		 // Round to even 4 bytes
		BYTE *newbuf = (BYTE *)malloc(size);
		int skipdist = sizeof(SImageryHeader) + (sizeof(SImageryStateHeader) * (entry->header->numstates - 1));
		BYTE *ptr = newbuf + skipdist;

		PSImageryHeader head = (PSImageryHeader)newbuf;
		memcpy(newbuf, entry->header, sizeof(SImageryHeader));

		for (i = 0; i < entry->header->numstates; i++)
		{
			PSImageryStateHeader sh = &(head->states[i]);

			memcpy(sh, &entry->header->states[i], sizeof(SImageryStateHeader));

			if (i == state)
			{
				if (width && length)
				{
					sh->walkmap.set(ptr);
					memset(ptr, 0, width * length);
					ptr += width * length;
				}
				else
					sh->walkmap.set(NULL);
			}
			else
			{
				int w = entry->header->states[i].wwidth;
				int l = entry->header->states[i].wlength;

				if (w && l)
				{
					sh->walkmap.set(ptr);
					memcpy(ptr, entry->header->states[i].walkmap.ptr(), w * l);
					ptr += w * l;
				}
				else
					sh->walkmap.set(NULL);
			}
		}

//		VirtualUnlock(entry->header, entry->headersize);
		free(entry->header);

		entry->header = (PSImageryHeader)newbuf;
		entry->headersize = size;
//		VirtualLock(entry->header, entry->headersize);
	}

	entry->header->states[state].wwidth = width;
	entry->header->states[state].wlength = length;
	entry->header->states[state].wheight = height;

	entry->headerdirty = TRUE;
}

// ******************* Progressive Load System ******************

static BOOL QuitThread;
static HANDLE LoadBodyEvent, LoadCompleteEvent, PauseLoaderMutex, LoaderThreadHandle;
static unsigned LoaderThreadId;

void TObjectImagery::BeginLoaderThread()
{
	LoadBodyEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	LoadCompleteEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	PauseLoaderMutex = CreateMutex(NULL, FALSE, NULL);

	QuitThread = FALSE;

	LoaderThreadHandle = (HANDLE)_beginthreadex(
		NULL, 0,
		&TObjectImagery::LoaderThread, NULL, TRUE,
        &LoaderThreadId );
}

void TObjectImagery::EndLoaderThread()
{
	while (ReleaseMutex(PauseLoaderMutex));
	QuitThread = TRUE;
	PulseEvent(LoadBodyEvent);

	WaitForSingleObject(LoaderThreadHandle, INFINITE);
}

unsigned _stdcall TObjectImagery::LoaderThread(void *)
{
	for (;;)
	{
		WaitForSingleObject(LoadBodyEvent, INFINITE);

		if (QuitThread)
			break;

		for (int loop = 0; loop < EntryArray.NumItems(); loop++)
		{
			WaitForSingleObject(PauseLoaderMutex, INFINITE);

			if (!EntryArray.Used(loop))
				continue;

			RSImageryEntry ie = EntryArray[loop];

			BEGIN_CRITICAL();

			if (ie.status == QE_QUEUED)
			{
				ie.status = QE_LOADING;

				END_CRITICAL();

				char buf[120];
				strcpy(buf, imagerypath);
				strcat(buf, ie.filename);

				DWORD ressize;
				PSImageryBody body = (PSImageryBody)LoadResource(buf, -1, &ressize);

				BEGIN_CRITICAL();

				if (!body)								// Mark load as failed
				{
					ie.status = QE_FAILED;

					PulseEvent(LoadCompleteEvent);
				}
				if (ie.imagery != NULL)	// Did system delete imagery while we were loading body
				{
					ie.ressize = ressize;			// No, then fill out data
					ie.body = body;
					ImageryMemUsage += ressize;
					ie.status = QE_LOADED;

//					VirtualLock(body, ressize);

					PulseEvent(LoadCompleteEvent);
				}
				else
				{
					delete body;						// YES?.. delete body and continue
					ie.status =	QE_NONE;
				}
			}

			END_CRITICAL();

			while (ReleaseMutex(PauseLoaderMutex));
		}
	}

  // Kill the events
	while (ReleaseMutex(PauseLoaderMutex)); // Release if I own it just in case
	CloseHandle(LoadCompleteEvent);
	CloseHandle(LoadBodyEvent);
	CloseHandle(PauseLoaderMutex);

    _endthreadex( 0 );

	return 0;
}

void TObjectImagery::PauseLoader()
{
	WaitForSingleObject(PauseLoaderMutex, INFINITE);
}

void TObjectImagery::ResumeLoader()
{
	ReleaseMutex(PauseLoaderMutex);
}

PSImageryBody TObjectImagery::LoadBody(BOOL wait)
{
	if (entry->status == QE_LOADED)
		return entry->body;

	ReleaseMutex(PauseLoaderMutex); // Just in case somebody forgot to unpause the loader thread

	BEGIN_CRITICAL();
	if (entry->status == QE_NONE || entry->status == QE_QUEUED)
	{
		if (wait)
		{
			entry->status = QE_LOADING;

			END_CRITICAL();

			char buf[120];
			strcpy(buf, imagerypath);
			strcat(buf, entry->filename);

			entry->body = (PSImageryBody)LoadResource(buf, -1, (DWORD *)&entry->ressize);

			BEGIN_CRITICAL();

			if (!entry->body)								// Mark load as failed
			{
				entry->status = QE_FAILED;
			}
			else
			{
				ImageryMemUsage += entry->ressize;

				entry->status = QE_LOADED;
			}
		}
		else
		{
			entry->status = QE_QUEUED;
			QuitThread = FALSE;
			PulseEvent(LoadBodyEvent);
		}
	}
	END_CRITICAL();

	if (entry->status == QE_LOADING)
	{
		if (wait)
		{
			while (entry->status == QE_LOADING)
			{
				WaitForSingleObject(LoadCompleteEvent, INFINITE);
			}
		}
	}

	if (entry->status == QE_FAILED)
	{
		FatalError("Imagery body load failed!");
	}

	return entry->body;
}

void TObjectImagery::FreeBody()
{
	BEGIN_CRITICAL();

	if (entry->status == QE_LOADING)
	{
		END_CRITICAL();

		while (entry->status == QE_LOADING)
		{
			WaitForSingleObject(LoadCompleteEvent, INFINITE);
		}

		BEGIN_CRITICAL();
	}

	if (entry->status == QE_QUEUED || entry->status == QE_FAILED || entry->status == QE_NONE)
	{
		entry->status = QE_NONE;
		entry->body = NULL;

		END_CRITICAL();
		return;
	}

	if (entry->status == QE_LOADED)
	{
		entry->status = QE_NONE;
//		VirtualUnlock(entry->body, entry->ressize);
		free(entry->body);
		entry->body = NULL;

		END_CRITICAL();
		return;
	}
}

// ******************* END OF Progressive Load System ******************

// *******************************
// * Imagery Quickload Functions *
// *******************************

struct SQuickLoadHeader
{
	DWORD id;
	DWORD version;
	DWORD numheaders;
};

#define QUICKLOADFILEID   (('H') | ('D' << 8) | ('R' << 16) | ('S' << 24))
#define QUICKLOADFILEVER  (1)

BOOL TObjectImagery::QuickLoadHeaders(time_t iflater)
{
	char filename[FILENAMELEN];
	struct _stat s;

  // We can only do a quickload if there's nothing in there yet!!
	if (EntryArray.NumItems() > 0)
		return FALSE;

	strcpy(filename, ResourcePath);
	strcat(filename, "IMAGERY.DAT");

	FILE *f = fopen(filename, "rb");
	if (!f)
		return FALSE;

  // Is file later than the iflater time?
	_fstat(fileno(f), &s);
	if (s.st_mtime <= iflater)
	{
		fclose(f);
		return FALSE;	// No: don't use file, it's out of date
	}

	SQuickLoadHeader qh;

	if (fread(&qh, sizeof(SQuickLoadHeader), 1, f) < 1)
	{
		fclose(f);
		return FALSE;
	}

	if (qh.id != QUICKLOADFILEID || qh.version != QUICKLOADFILEVER)
	{
		fclose(f);
		return FALSE;
	}

	for (int c = 0; c < (int)qh.numheaders; c++)
	{
		char filename[MAXIMFNAMELEN];

		if (fread(&filename, MAXIMFNAMELEN, 1, f) < 1)
		{
			fclose(f);
			return FALSE;
		}

		DWORD headersize;
		if (fread(&headersize, 4, 1, f) < 1)
		{
			fclose(f);
			return FALSE;
		}

		PSImageryHeader header = (PSImageryHeader)malloc(headersize);
		if (fread(header, headersize, 1, f) < 1)
		{
			fclose(f);
			return FALSE;
		}

		RegisterImagery(filename, header, headersize);
	}

	fclose(f);

	return TRUE;
}

BOOL TObjectImagery::QuickSaveHeaders()
{
	char filename[FILENAMELEN];
	int c;

	strcpy(filename, ResourcePath);
	strcat(filename, "IMAGERY.DAT");

	FILE *f = fopen(filename, "wb");
	if (!f)
		return FALSE;

	SQuickLoadHeader qh;
	memset(&qh, 0, sizeof(SQuickLoadHeader));

	qh.id = QUICKLOADFILEID;
	qh.version = QUICKLOADFILEVER;
	qh.numheaders = 0;

	for (c = 0; c < EntryArray.NumItems(); c++)
	{
		if (EntryArray.Used(c))
			qh.numheaders++;
	}

	if (fwrite(&qh, sizeof(SQuickLoadHeader), 1, f) < 1)
	{
		fclose(f);
		return FALSE;
	}

	for (c = 0; c < EntryArray.NumItems(); c++)
	{
		if (!EntryArray.Used(c))
			continue;

		RSImageryEntry ie = EntryArray[c];

		if (fwrite(&ie.filename, MAXIMFNAMELEN, 1, f) < 1)
		{
			fclose(f);
			return FALSE;
		}

		if (fwrite(&ie.headersize, 4, 1, f) < 1)
		{
			fclose(f);
			return FALSE;
		}

		if (fwrite(ie.header, ie.headersize, 1, f) < 1)
		{
			fclose(f);
			return FALSE;
		}
	}

	fclose(f);

	return TRUE;
}
// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                  Inventory.cpp - TInvetory object                     *
// *************************************************************************

#include <stdlib.h>

#include "revenant.h"
#include "inventory.h"
#include "object.h"
#include "mappane.h"
#include "display.h"
#include "cursor.h"
#include "player.h"
#include "equip.h"
#include "font.h"
#include "money.h"
#include "animation.h"
#include "textbar.h"

BOOL TInventory::Initialize()
{
	grabslot = heldslot = -1;
	isdragging = FALSE;

	SetDirty(TRUE);

	return TRUE;
}

void TInventory::Close()
{
}

void TInventory::DrawBackground()
{
	if (container && IsDirty())
	{
		Display->Box(INVENTORYCONTX, INVENTORYCONTY,
			INVITEMREALHEIGHT, INVITEMREALWIDTH, 0, 0xffff, 0, DM_BACKGROUND);
		container->DrawInvItem(INVENTORYCONTX, INVENTORYCONTY);

		for (int y = 0; y < INVITEMSY; y++)
			for (int x = 0; x < INVITEMSX; x++)
				Display->Box((x * INVITEMHEIGHT) + INVENTORYSTARTX,
					(y * INVITEMWIDTH) + INVENTORYSTARTY, INVITEMREALHEIGHT,
					INVITEMREALWIDTH, 0, 0xffff, 0, DM_BACKGROUND);

		for (TInventoryIterator i(container); i; i++)
		{
			PTObjectInstance oi = i.Item();

			if ((!isdragging || oi->InventNum() != grabslot) && oi->InventNum() < 256)
			{
				int x = (oi->InventNum() % INVITEMSX) * INVITEMWIDTH;
				int y = (oi->InventNum() / INVITEMSX) * INVITEMHEIGHT;
				x += INVENTORYSTARTX;
				y += INVENTORYSTARTY;

				oi->DrawInvItem(x, y);

				if (oi->Amount() > 1)
				{
					char buf[80];
					itoa(oi->Amount(), buf, 10);
					Display->WriteText(buf, x, y-1, 1, GameData->Font("numbers"));
				}
			}
		}

		if (grabslot < 0)
			heldslot = -1;
		SetDirty(FALSE);
	}
}

void TInventory::Animate(BOOL draw)
{
	if (draw && container && !mousebutton)
	{
		PTObjectInstance inst = container->GetInventorySlot(OnSlot(cursorx - GetPosX(), cursory - GetPosY()));
		CursorOverObject(inst);
	}
}

void TInventory::MouseClick(int button, int x, int y)
{
	if (!container)
		return;

	if (button == MB_LEFTDOWN)
	{
		heldslot = grabslot = OnSlot(x, y);
		startposx = x;
		startposy = y;
		isdragging = FALSE;
	}
	else if (button == MB_LEFTUP)
	{
		// check to see if they are on the far left (ie, chest/bag/pack icon)
		if (x >= 0 && x <= INVENTORYSTARTX && y >= 0 && y < INVENTORYPANEHEIGHT)
		{
			if (container->GetOwner())
			{
				if (grabslot < 0)
					SetContainer(container->GetOwner());
				else
				{
					PTObjectInstance inst = container->GetInventorySlot(grabslot);
					if (inst && container->GetOwner()->FindFreeInventorySlot() < MAXINVITEMS)
					{
						inst->RemoveFromInventory();
						container->GetOwner()->AddToInventory(inst);
					}
				}
			}
		}
		else if (grabslot >= 0)
		{
			// handle swaping and using objects
			int newslot = OnSlot(x, y);

			if (newslot >= 0)
			{
				PTObjectInstance inst = container->GetInventorySlot(grabslot);
				PTObjectInstance oi = container->GetInventorySlot(newslot);

				BOOL used = FALSE;

				if (inst && oi && ((isdragging && oi != inst) || (!isdragging && oi == inst)))
				{
					if (oi->Use(GetTopContainer(), oi != inst ? inst->GetMapIndex() : -1))
					{
						used = TRUE;
						Update();
					}
				}

				if (!used)
					SwapSlots(grabslot, newslot);
			}
		}
		else if (InPane(x, y))
		{
			// handle transfers from other panes
			if (EquipPane.GetHeldSlot() >= 0)
			{
				PTObjectInstance inst = ((PTPlayer)GetTopContainer())->GetEquip(EquipPane.GetHeldSlot());
				int newslot = OnSlot(x, y);
				if (inst && newslot >= 0)
				{
					if (GetTopContainer()->GetInventorySlot(newslot) == NULL)
					{
						((PTPlayer)GetTopContainer())->Equip(NULL, EquipPane.GetHeldSlot());	// clear from eq list
						inst->SetInventNum(newslot);					// add to inventory
						Update();
					}
				}
			}
		}

		grabslot = -1;
		SetDragBitmap(NULL);
		SetDragObj(NULL);
		isdragging = FALSE;

		if (InPane(x, y))
			Update();
	}
}

void TInventory::MouseMove(int button, int x, int y)
{
	if (!container)
		return;

	if (!isdragging)
		if (button == MB_LEFTDOWN || button == MB_RIGHTDOWN)
		{
			// don't bother switching to drag mode until they actually move it
			if (absval(startposx - x) >= 2 || absval(startposy - y) >= 2)
			{
				PTObjectInstance inst = container->GetInventorySlot(grabslot);

				if (inst && inst->InventoryImage())
				{
					int grabx = (startposx - INVENTORYSTARTX) % INVITEMWIDTH;
					int graby = (startposy - INVENTORYSTARTY) % INVITEMHEIGHT;

					if (!inst->InventoryImage()->OnPixel(grabx, graby))
						grabx = graby = 20;

					SetDragBitmap(inst->InventoryImage(), grabx, graby);
					SetDragObj(inst);
				}

				isdragging = TRUE;
				Update();
			}
		}
}

void TInventory::DrawAnim(PTObjectInstance inst, PTBitmap bm)
{
	if (!container || inst->GetOwner() != container)
		return;

	if (inst->InventNum() >= 256)
		EquipPane.DrawAnim(inst, bm);
	else
	{
		int x = (inst->InventNum() % INVITEMSX) * INVITEMWIDTH;
		int y = (inst->InventNum() / INVITEMSX) * INVITEMHEIGHT;
		x += INVENTORYSTARTX;
		y += INVENTORYSTARTY;

		int sx, sy, sw, sh;
		Display->GetClipRect(sx, sy, sw, sh);
		SetClipRect();
		Display->Put(x, y, bm);
		Display->SetClipRect(sx, sy, sw, sh);
	}
}

int TInventory::OnSlot(int x, int y)
{
	x -= INVENTORYSTARTX;
	y -= INVENTORYSTARTY;

	if (x < 0 || y < 0 ||
		(x / INVITEMWIDTH) >= INVITEMSX || (y / INVITEMHEIGHT) >= INVITEMSY ||
		(x % INVITEMWIDTH) >= INVITEMREALWIDTH || (y % INVITEMHEIGHT) >= INVITEMREALHEIGHT)
		return -1;
		
	return ((y / INVITEMHEIGHT) * INVITEMSX) + (x / INVITEMWIDTH);
}

void TInventory::SwapSlots(int oldslot, int newslot)
{
	PTObjectInstance inst0 = container->GetInventorySlot(oldslot);
	PTObjectInstance inst1 = container->GetInventorySlot(newslot);

	if (inst0)
		inst0->SetInventNum(newslot);

	if (inst1)
		inst1->SetInventNum(oldslot);
}
// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                        key.cpp - TKey module                          *
// *************************************************************************

#include "revenant.h"
#include "key.h"
#include "object.h"
#include "mappane.h"
#include "player.h"

REGISTER_BUILDER(TKey)
TObjectClass KeyClass("KEY", OBJCLASS_KEY, 0);

// Hard coded class stats
DEFSTAT(Key, Value, VAL, 0, 0, 0, 1000000)

// Hard codes object stats
DEFOBJSTAT(Key, KeyId, KEY, 0, 0, 0, 1000000)


// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                lightsource.cpp - TLightSource module                  *
// *************************************************************************

#include "revenant.h"
#include "lightsource.h"

REGISTER_BUILDER(TLightSource)
TObjectClass LightSourceClass("LIGHTSOURCE", OBJCLASS_LIGHTSOURCE, 0);

// Hard coded class stats
DEFSTAT(LightSource, EqSlot, EQSL, 0, 4, 0, 6)
DEFSTAT(LightSource, Value,  VAL,  1, 0, 0, 1000000)
// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                  MainWnd.cpp - Main Window Module                     *
// *************************************************************************

#include <windows.h>

#include <mmsystem.h>
#include <stdio.h>
#include <string.h>

#include "multimon.h"

#include "revenant.h"
#include "rc.h"
#include "graphics.h"
#include "display.h"
#include "imagery.h"
#include "mainwnd.h"
#include "mappane.h"
#include "screen.h"
#include "player.h"
#include "cursor.h"


#define ID_ICON 101

BOOL AppActive;         // Flag for if the game is the active application

// Used to set the cursor position for "screen.h"
extern BOOL InitDirectDraw();
extern void CloseSystem();

// *** Main Window Procedure ***

/* Take all the parameters for WndMain, process them, create a window
 * that takes up the whole screen, then return. */

BOOL TMainWindow::Initialize(HANDLE hInstance, HANDLE hPrevInstance,
		LPSTR lpCmdLine, int nCmdShow)
{
  // Set instance handles
	::hInstance = hInstance;

    if (Windowed == TRUE && !Borderless)
    {
	 // Make a class
		WNDCLASS c;
		c.style         = CS_HREDRAW | CS_VREDRAW;
		c.lpfnWndProc   = MainWndProc;
		c.cbClsExtra    = 0;
		c.cbWndExtra    = 0;
		c.hInstance     = hInstance;
		c.hIcon         = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_PROGRAMICON));
	    c.hCursor       = LoadCursor(hInstance, MAKEINTRESOURCE(IDC_BLANKCURSOR));
		c.hbrBackground = NULL;
		c.lpszMenuName  = NULL;
		c.lpszClassName = "REVENANTClass";
		RegisterClass(&c);

		DWORD style = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_BORDER; 
		DWORD exstyle = WS_EX_OVERLAPPEDWINDOW;

		RECT r;
		r.left = MonitorX + ((MonitorW - WIDTH) / 2);
		r.top = MonitorY + ((MonitorH - HEIGHT) / 2);
		r.right = r.left + WIDTH;
		r.bottom = r.top + HEIGHT;

		AdjustWindowRectEx(&r, style, TRUE, exstyle);
		
		r.bottom -= GetSystemMetrics(SM_CYMENU); // Get rid of menu bar space

      // Make the main window
        hwnd = CreateWindowEx(exstyle, "REVENANTClass", "Revenant", style, 
							  r.left, r.top, r.right - r.left, r.bottom - r.top,
							  NULL, NULL /*LoadMenu(hInstance, MAKEINTRESOURCE(IDR_PROGRAMMENU))*/,
							  hInstance, NULL);
	}
    else if (Windowed == TRUE && Borderless)
    {
	 // Make a class
		WNDCLASS c;
		c.style         = CS_HREDRAW | CS_VREDRAW;
		c.lpfnWndProc   = MainWndProc;
		c.cbClsExtra    = 0;
		c.cbWndExtra    = 0;
		c.hInstance     = hInstance;
		c.hIcon         = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_PROGRAMICON));
	    c.hCursor       = LoadCursor(hInstance, MAKEINTRESOURCE(IDC_BLANKCURSOR));
		c.hbrBackground = NULL;
		c.lpszMenuName  = "REVENANTClass";
		c.lpszClassName = "REVENANTClass";
		RegisterClass(&c);

		DWORD style = WS_POPUP;
		DWORD exstyle = 0;

		RECT r;
		r.left = MonitorX + ((MonitorW - WIDTH) / 2);
		r.top = MonitorY + ((MonitorH - HEIGHT) / 2) + 19;
		r.right = r.left + WIDTH;
		r.bottom = r.top + HEIGHT;

		AdjustWindowRectEx(&r, style, TRUE, exstyle);

      // Make the main window
        hwnd = CreateWindowEx(exstyle, "REVENANTClass", "Revenant", style, 
							  r.left, r.top, r.right - r.left, r.bottom - r.top,
							  NULL, NULL, hInstance, NULL);
	}
    else
    {
	 // Make a class
		WNDCLASS c;
		c.style         = CS_HREDRAW | CS_VREDRAW;
		c.lpfnWndProc   = MainWndProc;
		c.cbClsExtra    = 0;
		c.cbWndExtra    = 0;
		c.hInstance     = hInstance;
		c.hIcon         = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_PROGRAMICON));
	    c.hCursor       = NULL;
		c.hbrBackground = NULL;
		c.lpszMenuName  = "REVENANTClass";
		c.lpszClassName = "REVENANTClass";
		RegisterClass(&c);

      // Make the main window
       hwnd = CreateWindowEx(WS_EX_TOPMOST, "REVENANTClass", "Revenant", WS_POPUP,
							 MonitorX, MonitorY, WIDTH, HEIGHT,
							 NULL, NULL, hInstance, NULL);

		ShowCursor(FALSE);
    }

 	if (!hwnd)
		FatalError("Couldn't create main window");

	ShowWindow(hwnd, nCmdShow);
	UpdateWindow(hwnd);
	SetFocus(hwnd);

	return TRUE;
}

void TMainWindow::Close()
{
	if (hwnd)
		hwnd = NULL;
}

TMainWindow::~TMainWindow()
{
	if (hwnd)
		hwnd = NULL;
}

LRESULT CALLBACK MainWndProc(HWND hWnd, UINT wMessage, WPARAM wParam, LPARAM lParam)
{
	long result = 0;
	int x, y;//, button;

	switch (wMessage)
	{
	  case WM_ACTIVATEAPP:
	  {
		AppActive = wParam;
		result = DefWindowProc(hWnd, wMessage, wParam, lParam);

		if (AppActive)
		{
			if (PauseWhenNotActive)
				ResumeThreads();
			RestrictCursor();
			Display->Restore();
			TObjectImagery::RestoreAll();
			if (CurrentScreen)
				CurrentScreen->Redraw();
		}
		else
		{
			if (PauseWhenNotActive)
				PauseThreads();
			ReleaseCursor();
		}

	    break;
	  }

	  case WM_CREATE:
	  {
		break;
	  }

	  case WM_DESTROY:
	  {
		MainWindow.hwnd = NULL;
		PostQuitMessage(0);
		ShowCursor(TRUE);
		Closing = TRUE;
		break;
	  }

	  case WM_PAINT:
	  {
		if (Windowed)
		{
			Display->FlipPage();
		}
	  }

      case WM_SYSCOMMAND:
	  { 
		if((wParam & 0xFFF0) == SC_SCREENSAVE || (wParam & 0xFFF0) ==
			SC_MONITORPOWER)
            return 0;
		result = DefWindowProc(hWnd, wMessage, wParam, lParam);
		break;
	  }

   	  case WM_KEYDOWN:
	  {
		if (wParam == VK_CONTROL)
			CtrlDown = TRUE;
		else if (wParam == VK_MENU)
			AltDown = TRUE;
		else if (wParam == VK_SHIFT)
			ShiftDown = TRUE;

		if (!AppActive)
			return 0;

		if (LOWORD(lParam) > 1)
			break;

		// Handle system keypresses
		if (CtrlDown && ShiftDown)
		{
			switch (wParam)
			{
				case ' ':	{TOGGLE(Show3D);				break;}
				case 'D':	{TOGGLE(ShowDrawing);			break;}
				/*case 'N':	{TOGGLE(NoNormals);
							 MapPane.ReloadImagery();		break;}*/
				case 'F':	{TOGGLE(ShowFramesPerSecond);	break;}
				case 'T':	{TOGGLE(DisableTimer);			break;}
				case 'S':	{TOGGLE(FlatShade);				break;}
				case 'E':	{TOGGLE(DitherEnable);			break;}
				case 'B':	{TOGGLE(BlendEnable);			break;}
				case 'H':	{TOGGLE(SpecularEnable);		break;}
				case 'X':	{TOGGLE(UseTextures);			break;}
				case 'Z':	{TOGGLE(ZEnable);				break;}
				case 'L':	{TOGGLE(BilinearFilter);		break;}
				case 'K':	{TOGGLE(NoFrameSkip);			break;}
				case 'C':	{TOGGLE(ClearBeforeDraw);		break;}
				case 'Q':	{TOGGLE(NoScrollZBuffer);		break;}
                case 'O':   {TOGGLE(SmoothScroll);          break;}
				case 'U':	{TOGGLE(NoUpdateRects);			break;}
				case 'R':	{TOGGLE(ScrollLock);			break;}
				case 'G':	{TOGGLE(GridSnap);				break;}
				case 'P':	{TOGGLE(UseDrawPrimitive);		break;}
				case 'M':	{TOGGLE(NoPulseObjs);			break;}
				case 'N':	{TOGGLE(NoAnimateObjs);			break;}
				case 'I':	{TOGGLE(Interpolate);			break;}
				case '2':	{TOGGLE(Double3D);				break;}
				case '3':	{TOGGLE(Triple3D);				break;}

			  // Special... make this one hard to hit since it will stop screen updating
				case VK_BACK: {TOGGLE(DoPageFlip);			break;}

			}

			if (!UseDirect3D2) // Can't toggle drawprimitive if using direct3D 2
				UseDrawPrimitive = FALSE;

			break;
		}

		// check for cheat codes
		if (ShiftDown && !Editor && wParam != VK_SHIFT)
		{
			static char keywordbuf[11];
			static int end = 0;

			if ((char)wParam == VK_RETURN)
			{
				if (!strcmp(keywordbuf, "HOG"))
				{
					if (Player)
						Player->GetOnYerHog();
				}

				keywordbuf[end = 0] = 0;
			}
			else
			{
				if (end < 10)
				{
					keywordbuf[end++] = (char)wParam;
					keywordbuf[end] = 0;
				}
			}

			return 0;
		}

		if (CurrentScreen)
			CurrentScreen->KeyPress(wParam, TRUE);

		break;
	  }

	  case WM_CHAR:
	  {
		if (!AppActive)
			return 0;

		if (CtrlDown && ShiftDown)
			break;

		if (CurrentScreen)
			CurrentScreen->CharPress(wParam, TRUE);
		break;
	  }

	  case WM_KEYUP:
	  {
		if (wParam == VK_CONTROL)
			CtrlDown = FALSE;
		else if (wParam == VK_MENU)
			AltDown = FALSE;
		else if (wParam == VK_SHIFT)
			ShiftDown = FALSE;

		if (!AppActive)
			return 0;

		if (CtrlDown && ShiftDown)
			break;;

		if (CurrentScreen)
			CurrentScreen->KeyPress(wParam, FALSE);
		break;
	  }

	  case WM_SHOWWINDOW: 
	  {
		if (Windowed == TRUE)
			result = DefWindowProc(hWnd, wMessage, wParam, lParam);
	    break;
	  }

/*
	  case WM_MOUSEMOVE:
	  {
		if (wParam & MK_LBUTTON) button = MB_LEFTDOWN;
		else if (wParam & MK_RBUTTON) button = MB_RIGHTDOWN;
		else if (wParam & MK_MBUTTON) button = MB_MIDDLEDOWN;

		x = LOWORD(lParam);
		y = HIWORD(lParam);
		cursorx = x;
		cursory = y;

		if (CurrentScreen)
			CurrentScreen->MouseMove(button, x, y);
		break;
	  }
*/

	  case WM_LBUTTONDOWN:
	  {
		x = LOWORD(lParam);
		y = HIWORD(lParam);
		//cursorx = x;
		//cursory = y;

		if (!AppActive)
			return 0;

		if (CurrentScreen)
			CurrentScreen->MouseClick(MB_LEFTDOWN, x, y);
		mousebutton |= MB_LEFTDOWN;
		break;
	  }

	  case WM_LBUTTONUP:
	  {
		x = LOWORD(lParam);
		y = HIWORD(lParam);
		//cursorx = x;
		//cursory = y;

		if (!AppActive)
			return 0;

		if (CurrentScreen)
			CurrentScreen->MouseClick(MB_LEFTUP, x, y);
		mousebutton &= ~MB_LEFTDOWN;
		break;
	  }

	  case WM_LBUTTONDBLCLK:
	  {
		x = LOWORD(lParam);
		y = HIWORD(lParam);
		//cursorx = x;
		//cursory = y;

		if (!AppActive)
			return 0;

		if (CurrentScreen)
			CurrentScreen->MouseClick(MB_LEFTDBLCLK, x, y);
		break;
	  }

	  case WM_MBUTTONDOWN:
	  {
		x = LOWORD(lParam);
		y = HIWORD(lParam);
		//cursorx = x;
		//cursory = y;

		if (!AppActive)
			return 0;

		if (CurrentScreen)
			CurrentScreen->MouseClick(MB_MIDDLEDOWN, x, y);
		mousebutton |= MB_MIDDLEDOWN;
		break;
	  }

	  case WM_MBUTTONUP:
	  {
		x = LOWORD(lParam);
		y = HIWORD(lParam);
		//cursorx = x;
		//cursory = y;

		if (!AppActive)
			return 0;

		if (CurrentScreen)
			CurrentScreen->MouseClick(MB_MIDDLEUP, x, y);
		mousebutton &= ~MB_MIDDLEDOWN;
		break;
	  }

	  case WM_MBUTTONDBLCLK:
	  {
		x = LOWORD(lParam);
		y = HIWORD(lParam);
		//cursorx = x;
		//cursory = y;

		if (!AppActive)
			return 0;

		if (CurrentScreen)
			CurrentScreen->MouseClick(MB_MIDDLEDBLCLK, x, y);
		break;
	  }

	  case WM_RBUTTONDOWN:
	  {
		x = LOWORD(lParam);
		y = HIWORD(lParam);
		//cursorx = x;
		//cursory = y;

		if (!AppActive)
			return 0;

		if (CurrentScreen)
			CurrentScreen->MouseClick(MB_RIGHTDOWN, x, y);
		mousebutton |= MB_RIGHTDOWN;
		break;
	  }

	  case WM_RBUTTONUP:
	  {
		x = LOWORD(lParam);
		y = HIWORD(lParam);
		//cursorx = x;
		//cursory = y;

		if (!AppActive)
			return 0;

		if (CurrentScreen)
			CurrentScreen->MouseClick(MB_RIGHTUP, x, y);
		mousebutton &= ~MB_RIGHTDOWN;
		break;
	  }

	  case WM_RBUTTONDBLCLK:
	  {
		x = LOWORD(lParam);
		y = HIWORD(lParam);
		//cursorx = x;
		//cursory = y;

		if (!AppActive)
			return 0;

		if (CurrentScreen)
			CurrentScreen->MouseClick(MB_RIGHTDOWN, x, y);
		break;
	  }

	  default:
	  {
		result = DefWindowProc(hWnd, wMessage, wParam, lParam);
		break;
	  }

	}

	return result;
}
// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                    mappane.cpp - Map pane object                      *
// *************************************************************************

#include <windows.h>
#include <mmsystem.h>

#include <string.h>
#include <stdio.h>
#include <stdlib.h> 
#include <memory.h>
#include <math.h>
#include <process.h>
#include <time.h>

#include "revenant.h"
#include "graphics.h"
#include "mappane.h"
#include "stream.h"
#include "3dscene.h"
#include "bmsurface.h"
#include "ddsurface.h"
#include "multisurface.h"
#include "mosaicsurf.h"
#include "display.h"
#include "dls.h"
#include "editor.h"
#include "playscreen.h"
#include "inventory.h"
#include "player.h"
#include "spell.h"
#include "script.h"
#include "cursor.h"
#include "multi.h"
#include "savegame.h"
#include "money.h"
#include "exit.h"
#include "textbar.h"
#include "statusbar.h"
#include "directdraw.h"
#include "directinput.h"

extern TEditStatusPane StatusBar;
extern TConsolePane Console;
extern TEditClassPane ClassPane;
extern PTBitmap PointerCursor;
extern PTMulti EditorData;

extern PTObjectInstance TakenObject;
extern PTObjectInstance DroppedObject;

#define GRIDZOFF	334

// NoSmoothScroll stuff

#define SCROLLEDGESIDES		32
#define SCROLLEDGETOP		32
#define SCROLLEDGEBOTTOM	32

#define CHARACTER_HEIGHT	32

#define MAPGRIDWIDTH		(MAPPANEWIDTH - (SCROLLEDGESIDES * 2))
#define MAPGRIDHEIGHT		(MAPPANEHEIGHT - SCROLLEDGETOP - SCROLLEDGEBOTTOM)

inline int ScreenGrid(int n, int s)
{
	if (absval(n) < (s/2))
		return 0;

	if (n < 0)
		n -= s / 2;
	else
		n += s / 2;

	return (n / s);
}

// Generate a random map index
int TMapPane::MakeIndex()
{
	static int incrementor = 0;

	// Start with the current time
	time_t t;
	time(&t);

	int index = t - 0x34d6574c;
	if (index < 0)
	{
		// hrm...messed up clock, just flip it
		index *= -1;
	}

	// Throw in a semi-random element
	// make sure that the index level does NOT match old style indexes
	if (MapPane.GetMapLevel() == incrementor)
		incrementor++;

	if (incrementor > 0x1f)
		incrementor = 0;

	index |= incrementor++ << 26;

	return index;
}

// ****************
// * TMapIterator *
// ****************

// Initializes iterator with a range value (makes rect and calls Initialize)
TMapIterator::TMapIterator(RS3DPoint pos, int range, int fl, int objset)
{
	SRect r;
	r.left = pos.x - range; 
	r.top = pos.y - range;
	r.right = pos.x + range; 
	r.bottom = pos.y + range;
	Initialize(&r, fl, objset);
}

// Initializes iterator with an object using default LOCALRANGE value.  This is the 
// standard way to do searches in the map system for objects nearby other objects.
TMapIterator::TMapIterator(RTObjectInstance oi, int fl, int objset)
{
	S3DPoint pos;
	oi.GetPos(pos); 
	SRect r;
	r.left = pos.x - LOCALRANGE; 
	r.top = pos.y - LOCALRANGE;
	r.right = pos.x + LOCALRANGE; 
	r.bottom = pos.y + LOCALRANGE;
	Initialize(&r, fl | CHECK_MAPRECT, objset);
}

void TMapIterator::Initialize(PSRect sr, int fl, int os)
{
	if (sr)
	{
		if (!(fl & (CHECK_RECT | CHECK_MAPRECT | CHECK_SCRRECT | CHECK_SECTRECT)))
			fl |= CHECK_RECT;
		memcpy(&r, sr, sizeof(SRect));
	}
	else
	{
		memset(&r, 0, sizeof(SRect));
	}
	flags = fl;
	objset = os;
	sx = -1;		// Causes NextItem() to start at sx=0
	sy = 0;
	index = 0;
	numitems = 0;
	sector = NULL;
	parent = NULL;
	invindex = 0;
	parent = item = NULL;
	NextItem();
}


PTObjectInstance TMapIterator::NextItem()
{
	// OPTIONAL Inventory Iterator
	// ***************************

  // Check Inventory	
	if (flags & CHECK_NOINVENT)
		item = NULL;
	else
	{
		if (item && item->NumInventoryItems() > 0)
		{
			parent = item;
			invindex = 0;
		}

		item = NULL;

		while (parent && !item)
		{
			if (invindex < parent->NumInventoryItems())
				item = parent->GetInventory(invindex++);
			else
			{
				invindex = parent->InvIndex() + 1;
				parent = parent->GetOwner();
			}
		}
	}

	// Main Sector Iterator Loop
	// *************************

	while (!item)
	{
		index++;					// Try to increment index

		// INFREQUENT Get Next Sector
		// **************************

		while (index >= numitems)	// If at end of array (or no array) get next sector
		{
			if (++sx >= SECTORWINDOWX)
			{
				sx = 0;
				sy++;
			}
				
			if (sy >= SECTORWINDOWY)
				return NULL;
			
			if (!MapPane.sectors[sx][sy])
				continue;

			if (flags & CHECK_SECTRECT)
			{
				// Does rectangle intersect sector
				SRect sr;
				MapPane.sectors[sx][sy]->GetMaxScreenRect(sr);
				if (!r.Intersects(sr))
					continue;
			}
			else if (flags & CHECK_MAPRECT)
			{
				// Does rectangle intersect sector
				SRect sr;
				MapPane.sectors[sx][sy]->GetMaxMapRect(sr);
				if (!r.Intersects(sr))
					continue;
			}

			sector = MapPane.sectors[sx][sy];
			numitems = sector->NumObjSetItems(objset);
			index = 0;
		}

		item = sector->GetObjSetInstance(objset, index);	// Get item

		// OPTIONAL: Checks
		// ****************

		while (item && (flags & (CHECK_MOVING | CHECK_INVIS | CHECK_SCRRECT | CHECK_LIGHT | CHECK_MAPRECT)))
		{
			if (flags & CHECK_MOVING)
			{
				if (item->GetFlags() & OF_MOVING)
				{
					item = NULL;
					break;
				}
			}

			if (flags & CHECK_INVIS)
			{
				if (item->GetFlags() & OF_INVISIBLE)
				{
					item = NULL;
					break;
				}
			}

			BOOL good, checked = FALSE;
			SRect ir;

			if (flags & CHECK_SCRRECT)
			{
				checked = TRUE;
				item->GetScreenRect(ir);
				good = r.Intersects(ir);
			}
			else if (flags & CHECK_MAPRECT)
			{
				checked = TRUE;
				S3DPoint p;
				item->GetPos(p);
				good = r.In(SPoint(p.x, p.y));
			}

			if (flags & CHECK_LIGHT && item->GetFlags() & OF_LIGHT &&
				item->GetLightIntensity() != 0)
			{
				if (!checked || !good)
				{
					checked = TRUE;
					item->GetLightRect(ir);
					good = r.Intersects(ir);
				}
			}

			if (checked && !good)
			{
				item = NULL;			// go to next item, screen rect doesn't intersect
				break;
			}

			break;		// all tests passed, exit loop
		}
	}

	return item;
}

void TMapIterator::Nuke()
{
	if (item)
	{
		MapPane.DeleteObject(item);
		item = NULL;
	}
}

// ************************
// * Initialize and Close *
// ************************

BOOL TMapPane::Initialize()
{
  // Initialize the 3D
	Scene3D.Initialize();

	TPane::Initialize(); // Initialize values and create background areas

	int px = MAPPANEX = GetPosX();
	int py = MAPPANEY = GetPosY();
	int pw = MAPPANEWIDTH = GetWidth();
	int ph = MAPPANEHEIGHT = GetHeight();

	oldposx = posx = oldposy = posy = 
	oldsectorx = oldsectory = sectorx = sectory =
	oldscrollx = scrollx = oldscrolly = scrolly = 0x80000000;
	oldlevel = level = 0;

	for (int sy = 0; sy < SECTORWINDOWY; sy++)
		for (int sx = 0; sx < SECTORWINDOWX; sx++)
			sectors[sx][sy] = NULL;

	SColor c;
	c.red = 255;
	c.green = 255;
	c.blue = 255;
	SetLightColor(0, c, 35);

  // Setup ambient stuff
	SetAmbientLight(10);
	SColor color = {(BYTE)255, (BYTE)255, (BYTE)255};
	SetAmbientColor(color);

  // Initialize Dynamic Light
	dlight.intensity = 0;
	dlight.lightindex = -1;
	dlight.pos.x = dlight.pos.y = dlight.pos.z = 0;

  // Init cash
	TMoney::Initialize();

  // Init exits
	TExit::Initialize();

  // Target finder
	targetcallback = NULL;
	abortcallback = NULL;

  // Walkmap draw
	wmrevealx = 0;
	wmrevealy = 0;
	wmrevealsizex = (SECTORHEIGHT >> WALKMAPSHIFT);
	wmrevealsizey = (SECTORWIDTH >> WALKMAPSHIFT);

	dragmode = FALSE;
	clicked = FALSE;

	memset(&center, 0, sizeof(S3DPoint));

  // Make sure update thread is going  
	BeginUpdateThread();

	return TRUE;
}

void TMapPane::Close()
{
  // Make sure update thread is finished  
	EndUpdateThread();

  // Delete all sectors (saving them if in editor)
	FreeAllSectors();

  // Free imagery in imagery system
	TObjectImagery::FreeAllImagery();

  // Death to realtime 3D
	Scene3D.Close();
 
  // Call base class close function
	TPane::Close(); // Free's background areas
}

// This function gets called when the pane is created, or resized, to set the pane's
// background buffer.  We also put our 3D viewport resize here too.
void TMapPane::CreateBackgroundBuffers()
{
  // Set global map size variables
	MAPPANEX = GetPosX();
	MAPPANEY = GetPosY();
	MAPPANEWIDTH = GetWidth();
	MAPPANEHEIGHT = GetHeight();
	SCROLLBUFWIDTH = MAPPANEWIDTH + UPDATEWIDTH * 2;
	SCROLLBUFHEIGHT = MAPPANEHEIGHT + UPDATEHEIGHT * 2;

  // Set 3D system viewport size
	Scene3D.SetSize(MAPPANEX, MAPPANEY, MAPPANEWIDTH, MAPPANEHEIGHT);

  // Do lit multi for map pane update surface for the update thread
	litmulti = new TMosaicSurface(
			SCROLLBUFWIDTH / MOSAICTILEX,
			SCROLLBUFHEIGHT / MOSAICTILEY,
			MOSAICTILEX,
			MOSAICTILEY,
			MOSAICSURF_SYSTEMMEM | MOSAICSURF_ZBUFFER | MOSAICSURF_ZSYSTEMMEM);
	litmulti->SetClipMode(CLIP_WRAP);

  // Make a clone of the litmulti for the main thread so it has its own origin/clip rect
  // which can be set independently even while the update thread is running.
	updatemulti = new TMosaicSurface(litmulti);
	updatemulti->SetClipMode(CLIP_WRAP);

  // Clone tiles and zbuffer from lit multi, and add 32 bit buffer tiles
//	if (!IsMMX)
//	{
		unlitmulti = new TMosaicSurface(litmulti,
			MOSAICSURF_BMSURFACE | MOSAICSURF_32BIT | MOSAICSURF_CLONEZBUFFER);
		unlitmulti->SetClipMode(CLIP_WRAP);
		zbufferiscloned = TRUE;
//		lightmulti = NULL;
//	}
//	else
//	{
//		unlitmulti = new TMosaicSurface(litmulti,
//			MOSAICSURF_BMSURFACE | MOSAICSURF_CLONEZBUFFER);
//		unlitmulti->SetClipMode(CLIP_WRAP);
//		zbufferiscloned = TRUE;
//		lightmulti = new TMosaicSurface(lightmulti,
//			MOSAICSURF_BMSURFACE | MOSAICSURF_8BIT);
//	}


  // IMPORTANT NOTE:
  //
  // THE 'litmulti' SURFACE MUST ONLY BE USED IN THE UPDATE THREAD (i.e. DrawUnlit(),
  // DrawLights(), DrawLit(), DrawSelected(), etc.  Conversely, the updatemulti
  // MUST ****NOT**** be used in the update thread.  If these rules are not followed,
  // the program will not work correctly!!!

	int bgbuffer = Display->UseBackgroundArea(
		GetPosX(), GetPosY(), GetWidth(), GetHeight(), updatemulti);
	SetBackgroundBuffer(bgbuffer);

  // Start the update thread going
	BeginUpdateThread();
	Update(); // Cause whole pane to be redrawn
}

void TMapPane::FreeBackgroundBuffers()
{
  // End the update thread
	EndUpdateThread();
	
  // Free background scrolling area for this pane
	Display->FreeBackgroundArea(GetBackgroundBuffer());
	ClearBackgroundBuffer();

  // Kill surfaces
	if (unlitmulti && litmulti && updatemulti)
	{
		delete unlitmulti;
		unlitmulti = NULL;
		delete litmulti;
		litmulti = NULL;
		delete updatemulti;
		updatemulti = NULL;
	}
}

// ******************
// * Map Management *
// ******************

// Loads the current map in the "curmap" directory from the given directory 
// (i.e. "savegame.001"), or clears the "curmap" directory if NULL, forces
// reload of all sectors.
void TMapPane::LoadCurMap(char *from)
{
	char frompath[MAX_PATH], topath[MAX_PATH];
	
	ClearCurMap();

	if (!from)
		return;

	makepath(from, frompath, MAX_PATH);
	strcat(frompath, "\\*.DAT");
	makepath(CURMAPDIR, topath, MAX_PATH);

	copyfiles(frompath, topath);
}

// Saves map in curmap to the given game subdirectory 
//(i.e. "savegame.001") or "map" if null
void TMapPane::SaveCurMap(char *to)
{
	ReloadSectors(); // Forces sectors to be saved

	LOCKSECTORS;		// Prevent update thread from accessing sectors while we change them
						// (MAKE SURE UNLOCK IS ALWAYS CALLED.. THERE MUST BE NO RETURN 
						//  BETWEEN THESE TWO FUNCTIONS!!)

	TSector::ClearPreloadSectors();
	
	UNLOCKSECTORS;		// Do not return between these two things

	if (!to)
		to = BASEMAPDIR;

	char frompath[MAX_PATH], topath[MAX_PATH];

	makepath(CURMAPDIR, frompath, MAX_PATH);
	strncatz(frompath, "\\*.DAT", MAX_PATH);
	makepath(to, topath, MAX_PATH);
	strncatz(topath, "\\", MAX_PATH);

	copyfiles(frompath, topath);
}

// Deletes all files in the "curmap" directory, and forces sectors to reload.
void TMapPane::ClearCurMap()
{
	char path[MAX_PATH];
	
	ReloadSectors();

	LOCKSECTORS;		// Prevent update thread from accessing sectors while we change them
						// (MAKE SURE UNLOCK IS ALWAYS CALLED.. THERE MUST BE NO RETURN 
						//  BETWEEN THESE TWO FUNCTIONS!!)

	TSector::ClearPreloadSectors();
	
	UNLOCKSECTORS;		// Do not return between these two things

	makepath("curmap", path, MAX_PATH);
	strncatz(path, "\\*.DAT", MAX_PATH);

	deletefiles(path);
}

// ******************
// * Input Handling *
// ******************

void TMapPane::SnapWalkDisplay(int mapindex)
{
	if (mapindex < 0)
		return;

	PTObjectInstance inst = GetInstance(mapindex);
	if (inst && inst->GetImagery())
	{
		S3DPoint pos;
		inst->GetPos(pos);
		pos.x >>= WALKMAPSHIFT;
		pos.y >>= WALKMAPSHIFT;
		pos.x %= SECTORWIDTH >> WALKMAPSHIFT;
		pos.y %= SECTORHEIGHT >> WALKMAPSHIFT;

		int x, y, width, length;
		inst->GetFacingBoundBox(x, y, width, length);

		wmrevealx = pos.x - x;
		wmrevealy = pos.y - y;

		wmrevealsizex = wmrevealx + width;
		wmrevealsizey = wmrevealy + length;

		RedrawAll();
	}
}

void TMapPane::KeyPress(int key, BOOL down)
{
	BOOL interuptforreals = TRUE;

	if (down && Editor && StatusBar.EditWalkmap())
	{
		switch (key)
		{
		  case VK_UP:
			if (CtrlDown)
				wmrevealy--;
			else
				wmrevealsizey--;

			RedrawAll();
			break;
		  case VK_DOWN:
			if (CtrlDown)
				wmrevealy++;
			else
				wmrevealsizey++;

			RedrawAll();
			break;
		  case VK_LEFT:
			if (CtrlDown)
				wmrevealx--;
			else
				wmrevealsizex--;

			RedrawAll();
			break;
		  case VK_RIGHT:
			if (CtrlDown)
				wmrevealx++;
			else
				wmrevealsizex++;

			RedrawAll();
			break;
		  case VK_HOME:
			if (CtrlDown)
			{
				wmrevealx = (center.x - ((sectorx + 1) << SECTORWSHIFT)) >> WALKMAPSHIFT;
				wmrevealy = (center.y - ((sectory + 1) << SECTORHSHIFT)) >> WALKMAPSHIFT;
			}
			else
			{
				wmrevealsizex = (center.x - ((sectorx + 1) << SECTORWSHIFT)) >> WALKMAPSHIFT;
				wmrevealsizey = (center.y - ((sectory + 1) << SECTORHSHIFT)) >> WALKMAPSHIFT;
			}

			RedrawAll();
			break;
		  case VK_END:
			if (CtrlDown)
			{
				wmrevealx = 0;
				wmrevealy = 0;
				wmrevealsizex = (SECTORHEIGHT >> WALKMAPSHIFT);
				wmrevealsizey = (SECTORWIDTH >> WALKMAPSHIFT);
			}
			else
			{
				SnapWalkDisplay(StatusBar.GetSelectedObj());
			}
			RedrawAll();
			break;
		}
	}

	if (down && key == VK_ESCAPE)
		PostQuitMessage(0);
}

void TMapPane::FindClickPos(int x, int y, RS3DPoint start, RS3DPoint target)
{
	int bottomy = posy + GetHeight() + ((255 * 866) / 1000);

	S3DPoint top, bottom;
	ScreenToWorld(x + posx, y + posy, top);
	ScreenToWorld(x + posx, bottomy, bottom);
	top &= (DWORD)~(WALKMAPGRANULARITY - 1);
	bottom &= (DWORD)~(WALKMAPGRANULARITY - 1);

	BOOL found = FALSE;

	for ( ; bottom.y >= top.y && !found; bottom.x -= 16, bottom.y -= 16)
		for (int i = 0; i < 3; i++)
		{
			S3DPoint oldbottom = bottom;
			if (i == 1)
				bottom.y -= 16;
			else if (i == 2)
				bottom.x -= 16;

			int height = GetWalkHeight(bottom);

			S3DPoint walkpos;
			ScreenToWorld(x+posx, y+posy + ((height * 866) / 1000), walkpos);
			walkpos.x += 8;
			walkpos.y += 8;

			if (walkpos.x >> WALKMAPSHIFT == bottom.x >> WALKMAPSHIFT &&
				walkpos.y >> WALKMAPSHIFT == bottom.y >> WALKMAPSHIFT)
			{
				bottom.z = height;
				found = TRUE;
				break;
			}

			bottom = oldbottom;
		}

	if (!found)
		ScreenToWorld(x+posx, y+posy, bottom, start.z);

	target = bottom;
}

// ************* Draw order change functions ***************

BOOL TMapPane::SwapDrawOrder(PTObjectInstance inst0, PTObjectInstance inst1)
{
	for (TMapIterator i; i; i++)
		if (i == inst0)
			break;

	for (TMapIterator j; j; j++)
		if (j == inst1)
			break;

	if (!i || !j || i.SectorX() != j.SectorX() || i.SectorY() != j.SectorY())
		return FALSE;		// no dice, items are in different sectors

	int pos0 = i.SectorIndex();
	int pos1 = j.SectorIndex();

	PTSector sect = sectors[i.SectorX()][i.SectorY()];

	sect->RemoveObject(pos0);
	sect->RemoveObject(pos1);

	sect->SetObject(inst0, pos1);
	sect->SetObject(inst1, pos0);

	return TRUE;
}

void TMapPane::PushToFront(PTObjectInstance inst)
{
	for (TMapIterator i; i; i++)
		if (i == inst)
			break;

	if (!i)
		return;

	PTObjectInstance top = NULL;
	for (TMapIterator j; j; j++)
		top = j;

	SwapDrawOrder(inst, top);
}

void TMapPane::PushToBack(PTObjectInstance inst)
{
	for (TMapIterator i; i; i++)
		if (i == inst)
			break;

	if (!i)
		return;

	TMapIterator j;
	SwapDrawOrder(inst, j);
}

// ************** Movement control ******************

char *Directions[] = { "ne", "e", "se", "s", "sw", "w", "nw", "n", "ne" };

void TMapPane::UpdateMouseMovement(int x, int y)
{
	if (!Player)
		return;

	S3DPoint curpos, target;
	Player->GetPos(curpos);

	ScreenToWorld(x + posx, y + posy, target, curpos.z + 50);

	int angle = ConvertToFacing(curpos, target);

	target -= curpos;
	if (absval(target.x) < 16 && absval(target.y) < 16)
	{
		SetMouseBitmap(GameData->Bitmap("cursor"));
		Player->Stop();
	}
	else
	{
		angle += 0x10;

		char buf[32];
		sprintf(buf, "wedge-%s", Directions[angle >> 5]);
		SetMouseBitmap(GameData->Bitmap(buf));
		strcat(buf, "shadow");
		SetMouseShadow(GameData->Bitmap(buf), 0, 43);
		SetMouseCornerBitmap((PTBitmap)NULL, TRUE);

		Player->Go(angle & 0xE0);
	}

	clicked = TRUE;
}

void TMapPane::MouseClick(int button, int x, int y)
{
	if (Editor)
	{
		if (button == MB_LEFTDOWN && InPane(x, y))
		{
			if (dragmode)
			{
				StatusBar.StopMoving();
			}
			else if (StatusBar.EditWalkmap())
			{
				for (int sy = SECTORWINDOWY - 1; sy >= 0; sy--)
					for (int sx = SECTORWINDOWX - 1; sx >= 0; sx--)
						if (sectors[sx][sy])
						{
							for (int gy = min(wmrevealsizey, (SECTORHEIGHT >> WALKMAPSHIFT)) - 1; gy >= wmrevealy; gy--)
								for (int gx = min(wmrevealsizex, (SECTORWIDTH >> WALKMAPSHIFT)) - 1; gx >= wmrevealx; gx--)
								{
									S3DPoint pos, screenpos, wpos;
									pos.x = gx;
									pos.y = gy;
									wpos.x = ((sectorx + sx) << SECTORWSHIFT) + (gx << WALKMAPSHIFT);
									wpos.y = ((sectory + sy) << SECTORHSHIFT) + (gy << WALKMAPSHIFT);
									wpos.z = sectors[sx][sy]->ReturnWalkmap(pos.x, pos.y);

									int scrx, scry;
									WorldToScreen(wpos, scrx, scry);

									// wacky formula to get diamond shape
									int dx = (scrx - (x + posx)) / 2;
									int dy = scry - (y + posy);
									if ((absval(dx) + absval(dy)) < 8)
									{
										// hang onto the data for dragging
										grabx = sectorx + sx;
										graby = sectory + sy;
										objx = gx;
										objy = gy;
										onobject = wpos.z;
										oldz = y + posy;

										SRect ir;
										ir.left = scrx - 16;
										ir.top = scry - 17;
										ir.right = scrx + 15;
										ir.bottom = scry;
										AddBgUpdateRect(ir);
										return;
									}
								}
						}

				grabx = graby = objx = objy = oldz = onobject = -1;
			}
			else
			{
				PTObjectInstance oi = OnObject(x, y);
				if (oi)
				{
					S3DPoint pos;
					oi->GetPos(pos);
					WorldToScreen(pos, objx, objy);
					grabx = posx - objx;
					graby = posy - objy;
					objx = x + grabx;
					objy = y + graby;
					oldz = pos.z;
					StatusBar.Select(oi->GetMapIndex(), CtrlDown);
				}
			}
		}
		if (button == MB_MIDDLEDOWN && InPane(x, y))
		{
			PTObjectInstance oi = OnObject(x, y);
			if (oi)
				StatusBar.Select(oi->GetMapIndex());
			Console.Input("follow\n");
		}
		else if (button == MB_LEFTUP)
		{
			if (targetcallback)
			{
				S3DPoint pos;
				ScreenToWorld(x+posx-objx, y+posy-objy, pos, center.z);

				if (StatusBar.GridSnap())
				{
					pos.x = pos.x & GRIDMASK;
					pos.y = pos.y & GRIDMASK;
					// z is kind of a special case, so just use the exact value
					//pos.z = pos.z & GRIDMASK;
				}

				(*targetcallback)(pos);
				if (mode == MODE_MOVE)
				{
					dragmode = FALSE;
					targetcallback = NULL;
					SetMouseBitmap(PointerCursor);
				}
			}
			else if (StatusBar.EditWalkmap())
			{
				if (objx >= 0 && objy >= 0)
				{
					S3DPoint wpos, pos;
					pos.x = objx;
					pos.y = objy;
					wpos.x = (grabx << SECTORWSHIFT) + (objx << WALKMAPSHIFT);
					wpos.y = (graby << SECTORHSHIFT) + (objy << WALKMAPSHIFT);
					wpos.z = sectors[grabx - sectorx][graby - sectory]->ReturnWalkmap(pos.x, pos.y);
					int scrx, scry;
					WorldToScreen(wpos, scrx, scry);
					SRect ir;
					ir.left = scrx - 16;
					ir.top = scry - 17;
					ir.right = scrx + 15;
					ir.bottom = scry;
					AddBgUpdateRect(ir);
					grabx = graby = objx = objy = oldz = onobject = -1;
				}
			}
			else
				StatusBar.StopMoving();
		}
		else if (button == MB_RIGHTDOWN)
		{
			if (targetcallback)
			{
				if (abortcallback)
					(*abortcallback)();

				targetcallback = NULL;
				SetMouseBitmap(PointerCursor);
				//PlayScreen.ReleaseExclusivePane(&MapPane);
				dragmode = FALSE;
			}
			else
			{
				if (mousebutton == MB_LEFTDOWN)
					StatusBar.Undo();		// command was aborted, move everything back

				while (StatusBar.Deselect());
				dragmode = FALSE;
			}
		}
	}
	else		// if not in the editor (normal gameplay)
	{
		Notify(N_CANCELCONTROL, Player);

		if (button == MB_RIGHTDOWN)
		{
			if (Player)
			{
				UpdateMouseMovement(x, y);
			}
		}
		else if (button == MB_RIGHTUP)
		{
			if (Player && clicked)
			{
				SetMouseBitmap(GameData->Bitmap("cursor"));
				Player->Stop();
				clicked = FALSE;
			}
		}
		else if (button == MB_LEFTDOWN)
		{
			if (Player)
			{
				if (Player->IsFighting())
				{
					Player->Attack(random(1,3));
				}
				else
				{
					PTObjectInstance oi = OnObject(x, y);
					if (oi)
						onobject = oi->GetMapIndex();
					else
						onobject = -1;
					clicked = TRUE;
				}
			}
		}
		else if (button == MB_LEFTUP)
		{
			if (InPane(x, y))
			{
				PTObjectInstance inst = Inventory.GetContainer()->GetInventorySlot(Inventory.GetHeldSlot());
				if (!inst && Player)
					inst = Player->GetInventorySlot(EquipPane.GetHeldSlot() + 256);

				int objindex = -1;
				PTObjectInstance oninst = OnObject(x, y, inst);
				if (oninst)
					objindex = oninst->GetMapIndex();

				if (clicked)
				{
					PTObjectInstance inst = oninst;

					BOOL used = FALSE;

					if (onobject == objindex && inst)
					{
						if (!inst->IsInventoryItem())
							used = inst->Use(Player);
						else
						{
							TakenObject = GetInstance(objindex);
							Player->Pickup(TakenObject);

							char buf[80];
							if (inst->Amount() > 1)
								sprintf(buf, "Picked up %d %ss.", inst->Amount(), inst->GetName());
							else
								sprintf(buf, "Picked up %s.", inst->GetTypeName());
							TextBar.Print(buf);

							used = TRUE;
						}
					}

//					if (!used)
//					{
//						S3DPoint target, curpos;
//						Player->GetPos(curpos);
//						FindClickPos(x, y, curpos, target);
//						Player->Goto(target.x, target.y, TRUE, 64);
//					}
				}
				else
				{
					// dragging from the inventory or equipment to map pane
					if (inst)
					{
						BOOL used = FALSE;
						if (objindex >= 0)
						{
							// use the dragged object with the object clicked on
							PTObjectInstance oi = GetInstance(objindex);
							if (oi)
							{
								used = oi->Use(Player, inst->GetMapIndex());
								if (used)
									Inventory.Update();
							}
						}

						if (!used)
						{
							// didn't click on anything special, so just drop it on the ground
							if (inst->InventNum() >= 256)
								((PTPlayer)Player)->Equip(NULL, EquipPane.GetHeldSlot());	// clear from eq list

							S3DPoint curpos, target;
							Player->GetPos(curpos);
							ScreenToWorld(x+posx, y+posy, target, curpos.z + 30);

							inst->RemoveFromInventory();
							inst->SetPos(target, Player->GetLevel());
							inst->AddToMap();

							char buf[80];
							if (inst->Amount() > 1)
								sprintf(buf, "%d %ss dropped.", inst->Amount(), inst->GetName());
							else
								sprintf(buf, "%s dropped.", inst->GetName());
							TextBar.Print(buf);

							DroppedObject = inst;
						}
					}
				}
			}

			clicked = FALSE;
		}
	}
}

#define MOUSESCROLLSPEED	8
#define MOUSEBOUNDARY		1

void TMapPane::MouseMove(int button, int x, int y)
{
	if (Editor)
	{
		// mouse scrolling on screen edges
		mx = my = 0;

		if (cursorx < MOUSEBOUNDARY)
			mx = -MOUSESCROLLSPEED;
		else if (cursorx >= (Display->Width() - MOUSEBOUNDARY))
			mx = MOUSESCROLLSPEED;

		if (cursory < MOUSEBOUNDARY)
			my = -MOUSESCROLLSPEED;
		else if (cursory >= (Display->Height() - MOUSEBOUNDARY))
			my = MOUSESCROLLSPEED;

		if (InPane(x, y) &&
			((button == MB_LEFTDOWN && !dragmode) || (dragmode && button != MB_LEFTDOWN)))
		{
			if (StatusBar.EditWalkmap() && !dragmode)
			{
				if (objx >= 0 && objy >= 0)
				{
					S3DPoint pos;
					pos.x = objx;
					pos.y = objy;
					pos.z = min(255, max(0, (((oldz - (y + posy)) * 1000) / 866) + onobject));
					sectors[grabx - sectorx][graby - sectory]->SetWalkmap(pos.x, pos.y, pos.z);
				}
			}
			else
			{
				if (ShiftDown)
				{
					PTObjectInstance inst = OnObject(x, y);
					if (inst)
						StatusBar.Select(inst->GetMapIndex(), TRUE);
				}
				else
				{
					PTObjectInstance oi = GetInstance(StatusBar.GetSelectedObj());
					if (oi && !(oi->GetFlags() & OF_EDITORLOCK))
					{
						if (!(oi->GetFlags() & OF_SELDRAW))
						{
							// avoid accidental dragging
							if (!dragmode &&
								(absval((posx + x) - grabx) + absval((posy + y) - graby)) <= 3)
								return;

							StatusBar.StartMoving();
						}
						
						S3DPoint oldpos;
						oi->GetPos(oldpos);

						MapPane.MoveObjScreen(StatusBar.GetSelectedObj(), x - objx, y - objy);

						S3DPoint newpos;
						oi->GetPos(newpos);

						// handle z moving here, since it is relative to the object, not the map
						if (!StatusBar.RestrictZ())
						{
							newpos.z = oldz - (y - (objy - graby));
							if (StatusBar.GridSnap())
								newpos.z &= GRIDMASK;
							oi->SetPos(newpos);
						}

						// move other selected objects relative to this one
						S3DPoint delta = newpos;
						delta -= oldpos;

						for (int i = StatusBar.GetFirstObj(); i >= 0; i = StatusBar.GetNextObj())
						{
							PTObjectInstance inst = GetInstance(i);
							if (!inst || inst == oi)
								continue;

							S3DPoint pos;
							inst->GetPos(pos);
							pos += delta;
							inst->SetPos(pos);
						}
					}
				}
			}
		}
	}
	else		// if not in the editor (normal gameplay)
	{
		if (button == MB_RIGHTDOWN && clicked)
			UpdateMouseMovement(x, y);
	}
}

// utility function for dragging objects with the mouse
void TMapPane::MoveObjScreen(int index, int x, int y)
{
	if (index < 0)
		return;

	PTObjectInstance oi = GetInstance(index);
	if (oi)
	{
		S3DPoint newpos;
		oi->GetPos(newpos);
/*
		PTObjectInstance overinst = GetInstance(OnObject(x, y));
		if (overinst)
		{
			S3DPoint opos;
			overinst->GetPos(opos);
			ScreenToWorld(x + posx, y + posy + opos.z, newpos);
			newpos.z = opos.z;
		}
		else*/
		{
			S3DPoint tmppos = newpos;
			ScreenToWorld(x + posx, y + posy, newpos, tmppos.z);

			if (StatusBar.GridSnap())
			{
				newpos.x = newpos.x & GRIDMASK;
				newpos.y = newpos.y & GRIDMASK;
			}
			if (StatusBar.RestrictX())
				newpos.x = tmppos.x;
			if (StatusBar.RestrictY())
				newpos.y = tmppos.y;
		}

		oi->SetPos(newpos);
		StatusBar.SetDirty(TRUE);
	}
}

// *********************
// * Pane Manipulation *
// *********************

// Set Map Pos
void TMapPane::SetMapPos(RS3DPoint newpos)
{
	int nposx, nposy;
	WorldToScreen(newpos, nposx, nposy);
	SetScrollPos(nposx - (MAPPANEWIDTH/2), nposy - (MAPPANEHEIGHT/2));
	center = newpos;
}

// ********************
// * Object Functions *
// ********************

// Create object
int TMapPane::NewObject(PSObjectDef def)
{
	PTObjectClass oc = TObjectClass::GetClass(def->objclass);
	if (!oc)
	{
		_RPT0(_CRT_WARN, "MAPPANE: Bad class in NewObject");
		return -1;
	}
	PTObjectInstance oi = oc->NewObject(def);
	if (!oi)
	{
		_RPT0(_CRT_WARN, "MAPPANE: Unable to create obj in NewObject");
		return -1;
	}

	int shadowindex = AddShadow(oi);

	oi->SetMapIndex(-1);
	int index = AddObject(oi);

	if (index < 0 && shadowindex >= 0)
	{
		PTObjectInstance shadow = GetInstance(shadowindex);
		if (shadow)
		{
			DeleteObject(shadow);
			delete shadow;
		}
	}

	return index;
}

// Add object
int TMapPane::AddObject(PTObjectInstance oi)
{
	if (oi->GetSector() != NULL)	// Object is already in the map
	{
		_RPT0(_CRT_WARN, "MAPPANE: Object already in a sector in AddObject");
		return -1;
	}

	if (oi->GetLevel() != GetMapLevel())
	{
		_RPT0(_CRT_WARN, "MAPPANE: Invalid level in AddObject");
		return -1;
	}

	S3DPoint pos;
	oi->GetPos(pos);

	int sx = (pos.x >> SECTORWSHIFT);
	int sy = (pos.y >> SECTORHSHIFT);

	if ((DWORD)sx >= MAXSECTORX || sx < sectorx || sx >= sectorx + SECTORWINDOWX ||
		(DWORD)sy >= MAXSECTORY || sy < sectory || sy >= sectory + SECTORWINDOWY)
	{
		_RPT0(_CRT_WARN, "MAPPANE: Object not in current map area in AddObject");
		return -1;
	}

	PTSector sect = sectors[sx - sectorx][sy - sectory];
	if (!sect)
	{
		_RPT0(_CRT_WARN, "MAPPANE: Sector unavailable in AddObject");
		return -1;
	}

	LOCKSECTORS;	   // Lock sector system so update won't access it
				       // (MAKE SURE UNLOCK IS ALWAYS CALLED.. THERE MUST BE NO RETURN 
				       // BETWEEN THESE TWO FUNCTIONS!!)

	sect->AddObject(oi);

	UNLOCKSECTORS;		// If this isn't called, system will lock up

	if (oi->GetMapIndex() < 0)
		oi->SetMapIndex(MakeIndex());

	if (oi->InventNum() < 0)
	{
		TransferWalkmap(oi);
		AddObjectUpdateRect(oi->GetMapIndex());
	}

	return oi->GetMapIndex();
}

// Remove object (The main place objects are removed)
PTObjectInstance TMapPane::RemoveObject(int index)
{
	PTObjectInstance inst = NULL;
	TMapIterator i;

	for ( ; i; i++)
		if (i->GetMapIndex() == index)
		{
			inst = i;
			break;
		}

	if (!inst)
		return NULL;

  // Notify that object is being deleted
	Notify(N_DELETINGOBJECT, inst);

	if (i.Parent())
	{
		// extract from inventory
		inst->RemoveFromInventory();
	}
	else
	{
		RemoveFromSector(inst, i.SectorX(), i.SectorY(), i.SectorIndex());
	}

	if (inst)
	{
		if (inst->GetShadow() >= 0)
			RemoveObject(inst->GetShadow());

		if (inst->HasAnimator())
			inst->FreeAnimator();
	}

	return inst;
}

// Delete object
void TMapPane::DeleteObject(PTObjectInstance obj)
{
	if (RemoveObject(obj->GetMapIndex()) == NULL)
		FatalError("Tried to delete an object not in the sector.  This is a Very Bad Thing(tm).  Get Adam to check this out RIGHT AWAY!");
	delete obj;
}

// Delete sector
void TMapPane::DeleteSector(PTSector sect)
{
	Notify(N_DELETINGSECTOR, sect);

  // Make sure all objects know they are off screen now
	for (TObjectIterator i(sect->ObjectArray()); i; i++)
	{
		if (!i.Item())
			continue;
		i.Item()->OffScreen();
	}

  // Saves and deletes
	TSector::CloseSector(sect);
}

PTObjectInstance TMapPane::RemoveFromSector(PTObjectInstance inst, int sx, int sy, int sectindex)
{
	// extract from sector
	ExtractWalkmap(inst);

	LOCKSECTORS;	    // Prevent update system from accessing sector stuff
						// Group the update rect and the actual removal below so update system doesn't
						// accidently redraw this object before it is deleted

	AddObjectUpdateRect(inst->GetMapIndex());  
	sectors[sx][sy]->RemoveObject(sectindex);

	UNLOCKSECTORS;

	return inst;
}

// Add the shadow (if any) associated with an object
int TMapPane::AddShadow(PTObjectInstance oi)
{
	extern TObjectClass ShadowClass;

	if (oi->ObjClass() == OBJCLASS_SHADOW)
	{
		oi->SetShadow(-1);
		return -1;
	}

	SObjectDef def;
	memset(&def, 0, sizeof(SObjectDef));

	char buf[80];
	sprintf(buf, "shadow_%s", oi->GetTypeName());

	def.objclass = OBJCLASS_SHADOW;
	int objtype = ShadowClass.FindObjType(buf);
	if (objtype < 0)
		return -1;

	def.objtype = objtype;
	oi->GetPos(def.pos);

	int index = NewObject(&def);
	if (index >= 0)
		oi->SetShadow(index);

	return index;
}

// Object find functions
PTObjectInstance TMapPane::FindObject(char *name, int occurance, int objset)
{
	int found = 0;

	for (TMapIterator i(NULL, CHECK_NOINVENT, objset); i; i++)
	{
		char *instname = i->GetName();

		if (!stricmp(name, instname) && ++found == occurance)
			return i;
	}

	return NULL;
}

PTObjectInstance TMapPane::FindClosestObject(char *name, S3DPoint frompos, BOOL partial, int objset)
{
	PTObjectInstance closest = NULL;
	int closestdist = 0x800000;

	for (TMapIterator i(NULL, CHECK_NOINVENT, objset); i; i++)
	{
		char *instname = i->GetName();

		BOOL found = FALSE;

		if (partial)
		{
			if (instname && stricmp(name, instname) == 0)
				 found = TRUE;
		}
		else
		{
			if (instname && abbrevcmp(name, instname) > 0)
				 found = TRUE;
		}

		if (found)
		{
			S3DPoint pos;
			i->GetPos(pos);

			if (SQRDIST(pos, frompos) < closestdist)
			{
				closest = i;
				closestdist = SQRDIST(pos, frompos);
			}
		}
	}

	return closest;
}

PTObjectInstance TMapPane::FindClosestObject(char *name, PTObjectInstance from, BOOL partial, int objset)
{
	S3DPoint frompos;
	if (from)
		from->GetPos(frompos);
	else
		frompos = center;

	return FindClosestObject(name, frompos, partial, objset);
}

int TMapPane::FindObjectsInRange(S3DPoint pos, int *array, int width, int height, int objclass, int maxnum, int objset)
{
	if (maxnum < 1)
		return 0;

	S3DPoint itempos;
	int sqrwidth = sqr(width);
	int *dist = new int[maxnum];
	int found = 0, d;

	for (TMapIterator i(NULL, CHECK_NOINVENT, objset); i; i++)
	{
		PTObjectInstance inst = i;

		if (inst->IsInInventory() || (objclass != -1 && inst->ObjClass() != objclass))
			continue;

		inst->GetPos(itempos);

		if (height < 1) // This is a radius check
		{
			int r;

			// if we're looking for a character or player, take into account radius
			if (objclass != OBJCLASS_CHARACTER && objclass != OBJCLASS_PLAYER)
				r = 0;
			else
			{
				float tr = ((PTCharacter)inst)->Radius() / 2.5f;
				r = (int)(tr * tr);
			}

			if ((d = (SQRDIST(pos, itempos) - r)) < sqrwidth)
			{
				for (int j = 0; j < found && d > dist[j]; j++)
					;

				if (j >= maxnum)
					continue;

				if (j != found)
					memcpy(&(dist[j+1]), &(dist[j]), min(maxnum - 1, found) - j);

				array[j] = inst->GetMapIndex();
				dist[j] = d;

				if (found < maxnum)
					found++;
			}
		}

		else
		{
			int dx = absval(pos.x - itempos.x);
			int dy = absval(pos.y - itempos.y);

			if (dx <= (width >> 1) && dy <= (height >> 1))
			{
				d = sqr(dx) + sqr(dy);

				for (int j = 0; j < found && d > dist[j]; j++)
					;

				if (j >= maxnum)
					continue;

				if (j != found)
					memcpy(&(dist[j+1]), &(dist[j]), min(maxnum - 1, found) - j);

				array[j] = inst->GetMapIndex();
				dist[j] = d;

				if (found < maxnum)
					found++;
			}
		}
	}

	delete dist;
	return found;
}

PTObjectInstance TMapPane::ObjectInCube(PS3DRect cube, int objset)
{
	PTObjectInstance in = NULL;

	for (TMapIterator i(NULL, CHECK_NOINVENT, objset); i; i++)
	{
		if (cube->In(i->Pos()))
			return i;
	}

	return NULL;
}	

PTObjectInstance TMapPane::OnObject(int screenx, int screeny, PTObjectInstance with)
{
	BOOL IsPriorityItem = FALSE;
	PTObjectInstance on = NULL;

	screenx += posx;
	screeny += posy;

	SRect r;
	SPoint p;
	p.x = screenx;
	p.y = screeny;

	updatemulti->SetClipRect(screenx, screeny, 1, 1);

	for (TMapIterator i(NULL, CHECK_NOINVENT); i; i++)
	{
		if (!i->OnObject(p))
			continue;

		PTObjectInstance inst = i;


		if (inst->IsInInventory() || (!Editor && inst->ObjClass() == OBJCLASS_TILE))
			continue;

        if (!on || inst->AlwaysOnTop() || (!IsPriorityItem && inst->GetZ(updatemulti)))
		{
			BOOL good = TRUE;

			if (!Editor)
			{
				if ((GetDragObj() || !inst->IsInventoryItem()) && inst->CursorType(with) == CURSOR_NONE)
					good = FALSE;
			}

			if (good)
			{
				on = inst;
				IsPriorityItem = inst->AlwaysOnTop();
			}
		}
	}

	updatemulti->ResetClipRect();

	return on;
}

// Returns the instance structure given an object index
PTObjectInstance TMapPane::GetInstance(int index, int objset)
{
	if (index < 0)
		return NULL;

	TMapIterator i(NULL, 0, objset);

	for ( ; i; i++)
		if (i->GetMapIndex() == index)
			break;

	return i;

#ifdef OLD_STYLE_MAP_INDEXES
	int lv = GETLEVEL(index);

	if (lv != level)
		return NULL;

	int sx = GETSECTORX(index);
	int sy = GETSECTORY(index);

	if ((DWORD)sx >= MAXSECTORX || sx < sectorx || sx >= sectorx + SECTORWINDOWX ||
		(DWORD)sy >= MAXSECTORY || sy < sectory || sy >= sectory + SECTORWINDOWY)
			return NULL;

	if (!sectors[sx - sectorx][sy - sectory])
		return NULL; 

	return sectors[sx - sectorx][sy - sectory]->GetInstance(GETITEM(index));
#endif
}

// *********************
// * Walkmap Functions *
// *********************

void PosToWalkGrid(RS3DPoint pos, int &x, int &y)
{
	// because 0, 0 is actually the center of a walk grid, not the edge,
	// everything has to be offset by half the walk grid size

	x = (pos.x + (GRIDSIZE / 2)) >> WALKMAPSHIFT;
	y = (pos.y + (GRIDSIZE / 2)) >> WALKMAPSHIFT;
}

void WalkGridToPos(int x, int y, RS3DPoint pos)
{
	// because 0, 0 is actually the center of a walk grid, not the edge,
	// everything has to be offset by half the walk grid size

	pos.x = (x << WALKMAPSHIFT) - (GRIDSIZE / 2);
	pos.y = (y << WALKMAPSHIFT) - (GRIDSIZE / 2);
	pos.z = 0;
}

// General purpose handler for transfer, extract, clear etc
void TMapPane::WalkmapHandler(PTObjectInstance oi, int mode)
{
	if (!oi || oi->GetMapIndex() < 0)
		return;

	PTObjectImagery imagery = oi->GetImagery();
	if (!imagery)
		return;

	BYTE *walk = imagery->GetWalkMap(oi->GetState());
	if (!walk)
		return;

	int width, length, height;
	imagery->GetWorldBoundBox(oi->GetState(), width, length, height);

	int regx = imagery->GetWorldRegX(oi->GetState());
	int regy = imagery->GetWorldRegY(oi->GetState());

	BYTE *appliedwalk = NULL;
	if (oi->GetFace() != 0)
	{
		// apply rotations to walkmap based on facing
		appliedwalk = (BYTE *)malloc(width * length);

		int nx, ny, nsx, nsy;
		oi->GetFacingBoundBox(nx, ny, nsx, nsy);

		if (oi->GetFace() < 128)
		{
			for (int y = 0; y < nsy; y++)
				for (int x = 0; x < nsx; x++)
					*(appliedwalk+(y*nsx)+x) = *(walk+((length-x-1)*width)+y);
		}
		else if (oi->GetFace() < 192)
		{
			for (int y = 0; y < nsy; y++)
				for (int x = 0; x < nsx; x++)
					*(appliedwalk+(y*nsx)+x) = *(walk+(y*width)+(width-x-1));
		}
		else
		{
			for (int y = 0; y < nsy; y++)
				for (int x = 0; x < nsx; x++)
					*(appliedwalk+(y*nsx)+x) = *(walk+((length-x-1)*width)+(width-x-1));
		}

		regx = nx;
		regy = ny;
		width = nsx;
		length = nsy;
	}

	S3DPoint pos;
	oi->GetPos(pos);

	BOOL override = (oi->ObjClass() == OBJCLASS_EXIT);
	if (oi->ObjClass() == OBJCLASS_EXIT)
		override = TRUE;

	int x = (pos.x >> WALKMAPSHIFT) - regx;
	int y = (pos.y >> WALKMAPSHIFT) - regy;

	int startsectx = (x << WALKMAPSHIFT) >> SECTORWSHIFT;
	int startsecty = (y << WALKMAPSHIFT) >> SECTORHSHIFT;
	int endsectx = ((x + width - 1) << WALKMAPSHIFT) >> SECTORWSHIFT;
	int endsecty = ((y + length - 1) << WALKMAPSHIFT) >> SECTORHSHIFT;

	for (int sy = startsecty; sy <= endsecty; sy++)
		for (int sx = startsectx; sx <= endsectx; sx++)
		{
			if ((DWORD)sx >= MAXSECTORX || sx < sectorx || sx >= sectorx + SECTORWINDOWX ||
				(DWORD)sy >= MAXSECTORY || sy < sectory || sy >= sectory + SECTORWINDOWY)
				continue;

			PTSector sect = sectors[sx - sectorx][sy - sectory];
			if (!sect)
				continue;

			if (mode == WALK_EXTRACT)
			{
				sect->WalkmapHandler(WALK_CLEAR, appliedwalk ? appliedwalk : walk, 0, x, y, width, length, width);
				RedrawWalkmapRect(oi, x, y, width, length, sect);
			}
			else
				sect->WalkmapHandler(mode, appliedwalk ? appliedwalk : walk, pos.z, x, y, width, length, width, override);
		}

	imagery->SetHeaderDirty(TRUE);

	if (appliedwalk)
		free(appliedwalk);
}

void TMapPane::RedrawWalkmapRect(PTObjectInstance oi, int x, int y, int w, int l, PTSector dsect)
{
	for (int sx = 0; sx < SECTORWINDOWX; sx++)
		for (int sy = 0; sy < SECTORWINDOWY; sy++)
		{
			PTSector sect = sectors[sx][sy];
			if (!sect)
				continue;

			for (TObjectIterator i(sect->ObjectArray()); i; i++)
			{
				PTObjectInstance inst = i.Item();

				if (!inst || oi == inst || inst->IsInInventory())
					continue;

				PTObjectImagery imagery = inst->GetImagery();
				if (!imagery)
					continue;

				BYTE *walk = imagery->GetWalkMap(inst->GetState());
				if (!walk)
					continue;

				int iw, il, ih;
				imagery->GetWorldBoundBox(inst->GetState(), iw, il, ih);

				int rx, ry;
				rx = imagery->GetWorldRegX(inst->GetState());
				ry = imagery->GetWorldRegY(inst->GetState());

				S3DPoint pos;
				inst->GetPos(pos);

				int ix = (pos.x >> WALKMAPSHIFT) - rx;
				int iy = (pos.y >> WALKMAPSHIFT) - ry;

				// clip this bad boy
				int cx = ix - x, cy = iy - y, cw = iw, cl = il;
				int ax = 0, ay = 0;

				if (cx < 0)
				{
					cw += cx;
					ax = -cx;
					cx = 0;
				}

				if (cy < 0)
				{
					cl += cy;
					ay = -cy;
					cy = 0;
				}

				if ((cx + cw) > w)
					cw = w - cx;

				if ((cy + cl) > l)
					cl = l - cy;

				if (cw <= 0 || cl <= 0)
					continue;

				cx += x;
				cy += y;
				walk += (ay * iw) + ax;

				dsect->WalkmapHandler(WALK_TRANSFER, walk, pos.z, cx, cy, cw, cl, iw);
			}
		}
}

int TMapPane::GetWalkHeight(RS3DPoint pos)
{
	// because 0, 0 is actually the center of a walk grid, not the edge,
	// everything has to be offset by half the walk grid size

	int x = pos.x + (GRIDSIZE / 2);
	int y = pos.y + (GRIDSIZE / 2);

	int sx = (x >> SECTORWSHIFT) - sectorx;
	int sy = (y >> SECTORHSHIFT) - sectory;

	if (sx < 0 || sx >= SECTORWINDOWX || sy < 0 || sy >= SECTORWINDOWY || !sectors[sx][sy])
		return 0;

	x = (x & (SECTORWIDTH - 1)) >> WALKMAPSHIFT;
	y = (y & (SECTORHEIGHT - 1)) >> WALKMAPSHIFT;

	return sectors[sx][sy]->ReturnWalkmap(x, y);
}

int TMapPane::GetWalkGridHeight(int x, int y)
{
	// because 0, 0 is actually the center of a walk grid, not the edge,
	// everything has to be offset by half the walk grid size

	int sx = (x >> (SECTORWSHIFT - WALKMAPSHIFT)) - sectorx;
	int sy = (y >> (SECTORHSHIFT - WALKMAPSHIFT)) - sectory;

	if (sx < 0 || sx >= SECTORWINDOWX || sy < 0 || sy >= SECTORWINDOWY || !sectors[sx][sy])
		return 0;

	int wx = x & ((1 << (SECTORWSHIFT - WALKMAPSHIFT)) - 1);
	int wy = y & ((1 << (SECTORHSHIFT - WALKMAPSHIFT)) - 1);

	return sectors[sx][sy]->ReturnWalkmap(wx, wy);
}

// Returns the maximum walk height in the area bounded by 
// pos - width/2,height/2 to pos + with/2,height/2
int TMapPane::GetWalkHeightArea(RS3DPoint pos, int width, int height)
{
	if (width == 0)
		return GetWalkHeight(pos);

	width /= 2;		// to make the calculations simpler
	height /= 2;

	// make sure they are aligned values
	width &= GRIDMASK;
	height &= GRIDMASK;

	S3DPoint p(0, 0, 0);
	int highest = 0;

	for (p.y = (pos.y - height); p.y <= (pos.y + height); p.y += GRIDSIZE)
		for (p.x = (pos.x - width) ; p.x <= (pos.x + width); p.x += GRIDSIZE)
		{
			int h = GetWalkHeight(p);

			if (h == 0)
				return 0;

			if (h > highest)
				highest = h;
		}

	return highest;
}

// Returns the minimum delta (fall), and maximum delta (rise) between any two walk grids 
// within the radius, and also the height at the current position.

#define MAXRADIUS 8

void TMapPane::GetWalkHeightRadius(RS3DPoint pos, int radius, 
	int &mindelta, int &maxdelta, int &curheight)
{
	static int heights[MAXRADIUS][MAXRADIUS]; 
	mindelta = 0;
	maxdelta = 0;

	curheight = GetWalkHeight(pos);

	if (radius <= 0)
		return;

	if (((radius + (GRIDSIZE - 1)) >> WALKMAPSHIFT) >= MAXRADIUS)
		radius = ((MAXRADIUS - 1) << WALKMAPSHIFT) - 1;

	S3DPoint p(0, 0, 0);

	int startx = (pos.x - radius) & (int)GRIDMASK;
	int starty = (pos.y - radius) & (int)GRIDMASK;
	int endx =   (pos.x + radius + GRIDSIZE) & (int)GRIDMASK;
	int endy =   (pos.y + radius + GRIDSIZE) & (int)GRIDMASK;

	mindelta = 1000;
	maxdelta = -1000;

	for (p.y = starty; p.y <= endy; p.y += GRIDSIZE)
	{
		for (p.x = startx; p.x <= endx; p.x += GRIDSIZE)
		{
			int x = (p.x - startx) >> WALKMAPSHIFT;
			int y = (p.y - starty) >> WALKMAPSHIFT;

			int xdelta, ydelta, height;
			
			xdelta = ydelta = 0;

		  // Test closest corners of walk grids
			if (p.y <= pos.y)
			{
			  if (p.x <= pos.x) 
			  {
			    if (dist(p.x + GRIDSIZE / 2 - 1, p.y + GRIDSIZE / 2 - 1, pos.x, pos.y) > radius)
				{
					heights[x][y] = -1;
					continue;
				}
  
              // Within radius, now get deltas between this grid and grid to left and above
              // Deltas will be positive or negative depending on direction from center
				height = heights[x][y] = GetWalkHeight(p);
				if (x > 0 && heights[x - 1][y] >= 0)
					xdelta = heights[x - 1][y] - height;
				if (y > 0 && heights[x][y - 1] >= 0)
					ydelta = heights[x][y - 1] - height;
			  }
			  else
			  {
			    if (dist(p.x - GRIDSIZE / 2, p.y + GRIDSIZE / 2 - 1, pos.x, pos.y) > radius)
				{
					heights[x][y] = -1;
					continue;
				}

              // Within radius, now get deltas between this grid and grid to left and above
              // Deltas will be positive or negative depending on direction from center
				height = heights[x][y] = GetWalkHeight(p);
				if (x > 0 && heights[x - 1][y] >= 0)
					xdelta = height - heights[x - 1][y];
				if (y > 0 && heights[x][y - 1] >= 0)
					ydelta = heights[x][y - 1] - height;
			  }
			}
			else
			{
			  if (p.x <= pos.x) 
			  {
			    if (dist(p.x + GRIDSIZE / 2 - 1, p.y - GRIDSIZE / 2, pos.x, pos.y) > radius)
				{
					heights[x][y] = -1;
					continue;
				}

              // Within radius, now get deltas between this grid and grid to left and above
              // Deltas will be positive or negative depending on direction from center
				height = heights[x][y] = GetWalkHeight(p);
				if (x > 0 && heights[x - 1][y] >= 0)
					xdelta = heights[x - 1][y] - height;
				if (y > 0 && heights[x][y - 1] >= 0)
					ydelta = height - heights[x][y - 1];
			  }
			  else
			  {
			    if (dist(p.x - GRIDSIZE / 2, p.y - GRIDSIZE / 2, pos.x, pos.y) > radius)
				{
					heights[x][y] = -1;
					continue;
				}

              // Within radius, now get deltas between this grid and grid to left and above
              // Deltas will be positive or negative depending on direction from center
				height = heights[x][y] = GetWalkHeight(p);
				if (x > 0 && heights[x - 1][y] >= 0)
					xdelta = height - heights[x - 1][y];
				if (y > 0 && heights[x][y - 1] >= 0)
					ydelta = height - heights[x][y - 1];
			  }
			}

          // Get minimum/maximum deltas
			if (xdelta > maxdelta)
				maxdelta = xdelta;
			else if (xdelta < mindelta)
				mindelta = xdelta;
			if (ydelta > maxdelta)
				maxdelta = ydelta;
			else if (ydelta < mindelta)
				mindelta = ydelta;
		}
	}
}

void TMapPane::TransferAllWalkmaps()
{
	for (TMapIterator i(NULL, CHECK_NOINVENT); i; i++)
		TransferWalkmap(i);
}

BOOL TMapPane::LineOfSight(RS3DPoint pos, RS3DPoint to, PS3DPoint obst)
{
	int sx, sy, sz, ex, ey, ez, dx, dy, dz;

  // Get starting values in grid coordinates
	PosToWalkGrid(pos, sx, sy);
	PosToWalkGrid(to, ex, ey);
	sz = pos.z;
	ez = to.z;

	dx = ex - sx;
	dy = ey - sy;
	dz = ez - sz;

  // Make fixed point increment values for drawing line, and set loop to bigest value	
	int loop;
	if (abs(dx) >= abs(dy))
	{
		loop = abs(dx);
		if (loop > 0)
		{
		  dx = (dx << 16) / loop;
		  dy = (dy << 16) / loop + ((dy >= 0)?1:-1);  
		  dz = (dz << 16) / loop + ((dz >= 0)?1:-1);
		}
	}
	else
	{
		loop = abs(dy);
		if (loop > 0)
		{
		  dx = (dx << 16) / loop + ((dx >= 0)?1:-1);
		  dy = (dy << 16) / loop;  
		  dz = (dz << 16) / loop + ((dz >= 0)?1:-1);
		}
	}

	int x = sx << 16; 
	int y = sy << 16;
	int z = sz << 16;

	for (int c = 0; c <= loop; c++)
	{
		if (GetWalkGridHeight(x >> 16, y >> 16) > (z >> 16))
		{
			if (obst)
			{
				WalkGridToPos(x >> 16, y >> 16, *obst);
				obst->z = z >> 16;
			}
			return FALSE;
		} 
		x += dx;
		y += dy;
		z += dz;
	}
						
	return TRUE;
}

// ***************************
// * Dynamic Light Functions *
// ***************************

void TMapPane::DrawDLight()
{
	static int oldintensity = 0;

	return;

	if (oldintensity != dlight.intensity && dlight.lightindex >= 0)
	{
		Scene3D.DeleteLight(dlight.lightindex);
		dlight.lightindex = -1;
	}
	oldintensity = dlight.intensity;

    if (dlight.intensity == 0)
		return;

	if (dlight.lightindex < 0)
	{
		dlight.lightindex = Scene3D.AddLight(dlight.pos, dlight.color, dlight.intensity, dlight.multiplier);
	}
	else
	{
		Scene3D.SetLightPosition(dlight.lightindex, dlight.pos);
	}

	S3DPoint spos;
	WorldToScreen(dlight.pos, spos);

//	if (NoNormals)
		DrawLightNoNormals(spos, dlight.color, dlight.intensity, Display);
//	else
//		DrawLight(spos, dlight.color, dlight.intensity, Display);

	PTBitmap bitmap = GameData->Bitmap("dlight");
	Display->Put(spos.x - bitmap->width / 2,
				 spos.y - bitmap->width / 2 - 20, 
				 bitmap, DM_ALPHALIGHTEN); //, NULL, 31 - (dlight.intensity / 8));
}

void TMapPane::SetAmbientLight(int light, BOOL stopfade)
{
	if (stopfade)
		totambfadeframes = totambfadesteps = 0; // Stop fading

	if (totambfadeframes > 0)  // Doing fade? Then change target value
	{
		newambient = light;
	}
	else
	{
		if (ambient == light)
			return;
		ambient = light; 
		ambientchanged = TRUE;  // Causes ambient to be reset in next call to DrawBackground()
	}
}	

void TMapPane::SetAmbientColor(SColor &color, BOOL stopfade)
{
	if (stopfade)
		totambfadeframes = totambfadesteps = 0; // Stop fading

	if (totambfadeframes > 0)  // Doing fade? Then change target value
	{
		newambcolor = color;
	}
	else
	{
		if (ambcolor.red == color.red &&
			ambcolor.green == color.green &&
			ambcolor.blue == color.blue)
				return;
		ambcolor = color;
		ambientchanged = TRUE;  // Causes ambient to be reset in next call to DrawBackground()
	}
}

// Fades to the given ambient light in 'frame' frames in 'steps' discreet steps
void TMapPane::FadeAmbient(int light, SColor &color, int frames, int steps)
{
	if (GameSpeed == 5)
		steps = frames; // Do smooth ambient fading for fast computers

	if (light == ambient && 
		color.red == ambcolor.red && 
		color.green == ambcolor.green && 
		color.blue == ambcolor.blue)
			return;

	oldambient = ambient;
	oldambcolor = ambcolor;
	newambient = light;
	newambcolor = color;
	totambfadeframes = frames;
	totambfadesteps = steps;
	ambfadeframes = 0;
	ambfadesteps = 0;
}

// Called to actually set the new ambient values
void TMapPane::PulseFadeAmbient()
{
	if (totambfadeframes <= 0 || totambfadesteps <= 0)
		return;

	if (ambfadeframes != totambfadeframes * ambfadesteps / totambfadesteps)
	{
		ambfadeframes++;
		return;
	}

  // Interpolate between old and new ambient values
	ambient = oldambient * (totambfadesteps - ambfadesteps) / totambfadesteps + 
			newambient * ambfadesteps / totambfadesteps;
	ambcolor.red = (BYTE)((int)((int)oldambcolor.red * (totambfadesteps - ambfadesteps) / totambfadesteps + 
			(int)newambcolor.red * ambfadesteps / totambfadesteps));
	ambcolor.green = (BYTE)((int)((int)oldambcolor.green * (totambfadesteps - ambfadesteps) / totambfadesteps + 
			(int)newambcolor.green * ambfadesteps / totambfadesteps));
	ambcolor.blue = (BYTE)((int)((int)oldambcolor.blue * (totambfadesteps - ambfadesteps) / totambfadesteps + 
			(int)newambcolor.blue * ambfadesteps / totambfadesteps));
	ambientchanged = TRUE;

  // Next fade step
	ambfadeframes++;
	ambfadesteps++;
	if (ambfadesteps > totambfadesteps)			// Done
		totambfadeframes = totambfadesteps = 0;
}

// ********************************
// * Background Drawing Functions *
// ********************************

void TMapPane::Update3DScenePos()
{
	S3DPoint source;
	S3DPoint target;
	S3DPoint scrn;

	target = center;

	// convert the position to have no z height for d3d - it makes no difference
	// for what you see on the screen, and seems to fix some problems with the d3d view
	if (target.z > 0)
	{
		int x, y;
		WorldToScreen(target, x, y);
		ScreenToWorld(x, y, target);
	}


	WorldToScreen(target, scrn);

	Scene3D.SetCameraPos(target, (int)(scrn.z * ZSCALE));
}

// UpdateMapPos - Checks the system movement params and sets the map pane position.

void TMapPane::UpdateMapPos()
{

	if (Editor)		// Set map position code for editor
	{				// --------------------------------
		if (SmoothScroll)
		{
			if (mx || my)
			{
				S3DPoint mpos;
				ScreenToWorld(mx, my, mpos);
				mpos += center;
				SetMapPos(mpos);
				StatusBar.SetDirty(TRUE);
			}
		}
		else
		{
			int sx, sy;
			WorldToScreen(center, sx, sy);
			int x = ScreenGrid(sx, MAPGRIDWIDTH) * MAPGRIDWIDTH;
			int y = ScreenGrid(sy - CHARACTER_HEIGHT, MAPGRIDHEIGHT) * MAPGRIDHEIGHT;

			if (x != sx || y != sy)
			{
				S3DPoint newpos;
				ScreenToWorld(x, y, newpos);
				SetMapPos(newpos);
				RedrawAll();
			}
		}
	}
	else		// Set map position code for regular game
	{			// --------------------------------------

		S3DPoint pos, newpos;
		GetMapPos(newpos);
		int newlevel = GetMapLevel();
		static S3DPoint vel(0, 0, 0);

	  // Regular game uses the contents of the 'centeron' structure to attempt
	  // to center on either a point or an object.  The center on structure is
	  // set by the CenterOn() functions, and can be called from a script.

	  // Get what we're supposed to center on
		if (centeron.flags & CENTERON_OBJ)
		{
			if (centeron.obj)	// Note: check for validity of this object in Notify()
			{
				centeron.obj->GetPos(pos);
				newlevel = centeron.obj->GetLevel();
			}
		}
		else if (centeron.flags & CENTERON_POS)
		{
			pos = centeron.pos;
			newlevel = centeron.level;
		}
		else
		{
			pos = newpos; // Center on nothing
			newlevel = GetMapLevel();
		}

	  // If scrolling, handle scroll velocities to new position (only if scroll on and level is same)
		if (SmoothScroll && newlevel == GetMapLevel() && (centeron.flags & CENTERON_SCROLL))
		{
			S3DPoint newvel;

			int factor = 10;
			if (ScrollLock)
				factor = 6;

			newvel.x = (pos.x - center.x) / factor;
			newvel.y = (pos.y - center.y) / factor;
			newvel.z = (pos.z - center.z) / factor;

			if (newvel.x > vel.x)
				vel.x++;
			else if (newvel.x < vel.x)
				vel.x--;

			if (newvel.y > vel.y)
				vel.y++;
			else if (newvel.y < vel.y)
				vel.y--;

			if (newvel.z > vel.z)
				vel.z++;
			else if (newvel.z < vel.z)
				vel.z--;

			vel.x = max(-12, min(12, vel.x));
			vel.y = max(-12, min(12, vel.y));
			vel.z = max(-12, min(12, vel.z));

			newpos += vel;
		}
		else
		{
			vel.x = vel.y = vel.z = 0;
			newpos = pos;	// No scrolling,.. just set pos
		}
		
		if (SmoothScroll)
			SetMapPos(newpos);
		else				// Non smooth scrolling, calculate screen grid and set pos
		{
			int x, y;
			WorldToScreen(pos, x, y);
			x = ScreenGrid(x, MAPGRIDWIDTH);
			y = ScreenGrid(y - CHARACTER_HEIGHT, MAPGRIDHEIGHT);

			int sx, sy;
			WorldToScreen(center, sx, sy);
			sx = ScreenGrid(sx, MAPGRIDWIDTH);
			sy = ScreenGrid(sy, MAPGRIDHEIGHT);

			x *= MAPGRIDWIDTH;
			y *= MAPGRIDHEIGHT;
			ScreenToWorld(x, y, newpos);
			if (absval(newpos.x - center.x) > 4 || absval(newpos.y - center.y) > 4)
			//if (x != sx || y != sy)
			{
				//x *= MAPGRIDWIDTH;
				//y *= MAPGRIDHEIGHT;
				//ScreenToWorld(x, y, newpos);
				SetMapPos(newpos);
				MapPane.RedrawAll();
			}
		}

		SetMapLevel(newlevel);

	}		
}

// The pulse function is pretty much the first function that's called in a screen refresh.
// You can move objects around, change the map pane position, and do anything else you
// want to before the map pane is scrolled or moved, the background is drawn, etc.
//
// The Pulse function should be where the object AI stuff is called so that it can be
// updated before the objects are displayed in the DrawBackground() and Animate() funcitons.

void TMapPane::Pulse()
{
  // Pulse fading ambient values
	PulseFadeAmbient();	

  // Update map position (uses mouse scrolling for editor or 'centeron' state for game)
	UpdateMapPos();

  // Pulse objects (does object AI)
	PulseObjects();

  // Set new screen map position now that objects have been pulsed
	oldposx     = posx;
	posx        = GetScrollX();
	oldposy     = posy;
	posy        = GetScrollY();

  // Update 3D position
	Update3DScenePos();

  // Update Sectors
	UpdateSectors();

  // Leave Pulse with new map position completely set
}

void TMapPane::DrawBackground()
{
  // *********************** GLOBAL STATE CHANGES *************************
  
  // **** THIS IS WHERE ANY GLOBAL GAME IMAGERY CHANGES SHOULD BE MADE ****
  // **** FUNCTIONS WHICH CHANGE IMAGERY STATES (like ambient lighting,****
  // **** ETC. SHOULD FLAG THAT THEY NEED TO BE UPDATED, AND THIS      ****
  // **** FUNCTION SHOULD ACTUALLY DO THE UPDATING.  THIS PREVENTS A   ****
  // **** GOBAL STATE FROM BEING SET HALFWAY THROUGH A FRAME           ****
	
  // Causes ambient values to be changed at the beginning of a frame refresh
	if (ambientchanged)
	{
		::SetAmbientLight(ambient);
		Scene3D.SetAmbientLight(ambient);
		::SetAmbientColor(ambcolor);
		Scene3D.SetAmbientColor(ambcolor);
	
		ambientchanged = FALSE;

		SRect r;
		r.left = GetScrollX() - 10000;
		r.top = GetScrollY() - 10000;
		r.right = GetScrollX() + 10000;
		r.bottom = GetScrollY() + 10000;
		AddBgUpdateRect(r, BGDRAW_LIGHTS);
	}

  // Update edges of screen
	int updatex = GetScrollX() & UPDATEMASKX;
	int updatey = GetScrollY() & UPDATEMASKY;
	UpdateEdges(updatex, updatey);

  // If redraw all, refresh the whole zbuffer
	if (IsDirty())
	{
		SRect r;
		r.left = posx;
		r.top = posy;
		r.right = r.left + GetWidth() - 1;
		r.bottom = r.top + GetHeight() - 1;
		Scene3D.RestoreZBuffer(r);
	}

	SetDirty(FALSE);
}

void TMapPane::RedrawAll()
{
	SetDirty(TRUE);
	scrollx += 1000000;
	scrolly += 1000000;
	ClearLights();

	// stuff to make the smoothscroll command work better
	if (!Editor && Player && !SmoothScroll)
	{
		S3DPoint pos, newpos;
		Player->GetPos(pos);

		int x, y;
		WorldToScreen(pos, x, y);
		x = ScreenGrid(x, MAPGRIDWIDTH);
		y = ScreenGrid(y - CHARACTER_HEIGHT, MAPGRIDHEIGHT);
		x *= MAPGRIDWIDTH;
		y *= MAPGRIDHEIGHT;
		ScreenToWorld(x, y, newpos);

		if (absval(newpos.x - center.x) > 4 || absval(newpos.y - center.y) > 4)
			SetMapPos(newpos);
	}
}

void TMapPane::AddBgUpdateRect(SRect &r, int bgdraw)
{
	if (IsDirty() || bgdraw >= BGDRAW_NONE)
		return; // No need since everything will be redrawn anyway

	if (numbgrects >= MAXMAPBGRECTS)
	{
		SetDirty(TRUE);		// This pane is nasty bad (causes pane to redraw everything)
		numbgrects = 0;
		return;
	}

	bgrects[numbgrects].rect = r;
	bgrects[numbgrects].bgdraw = bgdraw;
	numbgrects++;
}

void TMapPane::AddObjectUpdateRect(int index)
{
	PTObjectInstance inst = GetInstance(index);
	if (!inst)
		return;

	SRect ir;
	inst->GetScreenRect(ir);
	AddBgUpdateRect(ir);

	inst->RedrawLight();			// in case it's a light
}

void TMapPane::ReloadImagery()
{
	if (NoNormals == TRUE)
		TObjectImagery::SetImageryPath(NONORMALPATH);
	else
		TObjectImagery::SetImageryPath(NORMALPATH);
	
	TObjectImagery::ReloadImagery();

	RedrawAll();
}

// ***************************************************************************************
// ***************************  Progressive Update System   ******************************
// ***************************************************************************************

static BOOL ThreadRunning, QuitThread, Updating, UpdateCancelled;
static HANDLE UpdateStartEvent, UpdateDoneEvent, PauseUpdateMutex;
static HANDLE SectorMutex, ObjectMutex;
static HANDLE UpdateThreadHandle;
static unsigned UpdateThreadId;

#define UPDATEWAITSAMPLES 5
static int UpdateWaitSample, UpdateSleep;
static int UpdateWaitFrames[UPDATEWAITSAMPLES];
static int UpdateWaitTime[UPDATEWAITSAMPLES];

#define MAXQUEUERECTS (MAXMAPBGRECTS + 2)
static int numqueuerects;
static SBgUpdateRect queuerects[MAXQUEUERECTS];

static char *PauseMutexFile, *SectorMutexFile, *ObjectMutexFile;
static int PauseMutexLine, SectorMutexLine, ObjectMutexLine;

static TObjectArray UpdateObjs;

void TMapPane::BeginUpdateThread()
{
	if (ThreadRunning)
		return;

 	UpdateWaitSample = 0;
	UpdateSleep = 0;

	UpdateStartEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
	UpdateDoneEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
	PauseUpdateMutex = CreateMutex(NULL, FALSE, NULL);
	SectorMutex = CreateMutex(NULL, FALSE, NULL);
	ObjectMutex = CreateMutex(NULL, FALSE, NULL);

	QuitThread = FALSE;
	Updating = FALSE;
	UpdateCancelled = FALSE;

	UpdateThreadHandle = (HANDLE)_beginthreadex(NULL, 0, TMapPane::UpdateThread, NULL, TRUE,
        &UpdateThreadId);

	ThreadRunning = TRUE;
}

void TMapPane::EndUpdateThread()
{
	if (!ThreadRunning)
		return;

	while (ReleaseMutex(PauseUpdateMutex));
	while (ReleaseMutex(SectorMutex));
	while (ReleaseMutex(ObjectMutex));

	CancelUpdate();
	QuitThread = TRUE;
	PulseEvent(UpdateStartEvent);

	WaitForSingleObject(UpdateThreadHandle, INFINITE);
	
	ThreadRunning = FALSE;
}

void ClearMutex(HANDLE hmutex)
{
#ifdef DEBUG
	char *err = "%s not released in file %s line %s";
	char buf[80];
	if (hmutex == PauseUpdateMutex && PauseMutexFile != NULL)
	{
		sprintf(buf, err, "PauseUpdateMutex", PauseMutexFile, PauseMutexLine);
		ThreadError(buf);
	}
	else if (hmutex == SectorMutex && SectorMutexFile != NULL)
	{
		sprintf(buf, err, "SectorMutex", SectorMutexFile, SectorMutexLine);
		ThreadError(buf);
	}
	else if (hmutex == ObjectMutex && ObjectMutexFile != NULL)
	{
		sprintf(buf, err, "ObjectMutex", ObjectMutexFile, ObjectMutexLine);
		ThreadError(buf);
	}
#endif

	while (ReleaseMutex(hmutex));
}

int TMapPane::GetUpdateSleep()
{
	return UpdateSleep;
}

void TMapPane::UpdateTimeSlice(BOOL draw)
{
	if (!ThreadRunning)
		return;
	
 // Check to see if queued update is finished yet
	if (isrecqueued)
	{
		if (UpdateDone())
		{
			scrollrect = queuedrect; // Set valid scroll area to queued rect if done
			isrecqueued = FALSE;
			PutQueueRectsToDisplay();  // Causes display to show new rects
			ClearQueueRects();
		}
		else // If still waiting, allow time for update thread to run
		{
			if (UpdateSleep > 0)
			{
				int start = GetTickCount();
				SetEvent(UpdateStartEvent);
				WaitForSingleObject(UpdateDoneEvent, UpdateSleep); // Not too long
				ResetEvent(UpdateDoneEvent);
				int end = GetTickCount();
				int time = end - start;
//				if (time < UpdateSleep)
//					Sleep(UpdateSleep - time);
				UpdateWaitTime[UpdateWaitSample] += time;
			}
		} 
	}

	UpdateWaitFrames[UpdateWaitSample]++;
	if (UpdateWaitFrames[UpdateWaitSample] > 24)
		AdjustTimeSlice(0);
}

void TMapPane::AdjustTimeSlice(int milliseconds)
{
	if (!ThreadRunning)
		return;

	UpdateWaitTime[UpdateWaitSample] += milliseconds;

	UpdateSleep = 0;
	for (int c = 0; c < UPDATEWAITSAMPLES; c++)
	{
		UpdateSleep = max(UpdateSleep, 
			(UpdateWaitTime[c] * 100 + 80) / (max(UpdateWaitFrames[c], 1) * 100));
	}

	if (UpdateSleep > 70)
		UpdateSleep = 70;

	UpdateWaitSample++;
	if (UpdateWaitSample >= UPDATEWAITSAMPLES)
		UpdateWaitSample = 0;

	UpdateWaitTime[UpdateWaitSample] = 0;
	UpdateWaitFrames[UpdateWaitSample] = 0;
}

void TMapPane::FlushUpdate(BOOL updatetimeslice)
{
	int wait = WaitUpdate();	// Wait for previous queue to finish
	if (updatetimeslice)
		AdjustTimeSlice(wait);	// Adjust update wait value by how long we waited here
	if (isrecqueued)
	{
		scrollrect = queuedrect;	// Update current refreshed rect
		isrecqueued = FALSE;		// Set no rect as being queued
	}
	PutQueueRectsToDisplay();	// Causes display to show new rects
	ClearQueueRects();			// Make sure queue is empty
}

void TMapPane::UpdateEdges(int updatex, int updatey)
{
	if (!ThreadRunning)
		return;

	oldscrollx = scrollx;
	oldscrolly = scrolly;

	scrollx    = updatex;
	scrolly    = updatey;

  // Check to see if queued update is finished yet
	if (isrecqueued && UpdateDone())
		FlushUpdate();

  // Hey, do we update everything?
	BOOL redrawall = level != oldlevel || IsDirty();

  // If no scrolling occured, just draw bg rects and return
	if (scrollx == oldscrollx && 
		scrolly == oldscrolly && 
		!redrawall)
	{
		if (numbgrects > 0)
		{
			FlushUpdate();

		  // Add new bg rects to fresh queue
			for (int c = 0; c < numbgrects; c++)
			{
				SRect dr;
				if (!ClipRect(scrollrect, bgrects[c].rect, dr))
					continue;
				QueueUpdateRect(dr, bgrects[c].bgdraw);
			}
			numbgrects = 0;

			BeginUpdate(); // Start updating
			FlushUpdate(); // Flush it right now
		}

		return;
	}

  // Screen is always within this rect
	SRect innerscrollrect = SRect(scrollx, scrolly, 
		scrollx + SCROLLBUFWIDTH - UPDATEWIDTH - 1, 
		scrolly + SCROLLBUFHEIGHT - UPDATEHEIGHT - 1);
	SRect outerscrollrect = innerscrollrect;

  // Redraw the whole scroll buffer
	if (redrawall || 
		(!outerscrollrect.Intersects(scrollrect) &&
		 !outerscrollrect.Intersects(queuedrect)))
	{
		CancelUpdate(); // Cancel any current updating and clear queue rects

	 // Draw whole screen with one update edge on each side
		innerscrollrect = SRect(scrollx, scrolly,
			scrollx + SCROLLBUFWIDTH - 1, scrolly + SCROLLBUFHEIGHT - 1);
		outerscrollrect = innerscrollrect;

		QueueUpdateRect(outerscrollrect, BGDRAW_UNLIT);

		queuedrect = outerscrollrect;
		isrecqueued = TRUE;

		BeginUpdate();
		FlushUpdate();

		numbgrects = 0;

		return;
	}

  // Redraw just the edges
	else
	{
		FlushUpdate(TRUE);		// TRUE = Update timeslice values

	  // Since we're drawing two update edges in front of us, and there are only 2 edges
	  // extra in the scroll buffer, make sure we don't draw the right edge when scrolling
	  // left, or the left edge when scrolling right, etc. etc.   If we draw all outside
	  // edges, the drawing will wrap around.

	  // Figure out our movment vector (What's our vector Victor,.  rodger Rodger.. etc. etc.)

		if (scrollx > oldscrollx)		// Moving right
		{
		  // We've drawing two edges in front of us to the right, there are no edges to the left
			outerscrollrect.right += UPDATEWIDTH;
		}
		else if (scrollx < oldscrollx)  // Moving left
		{
		  // We're drawing two edges in front of us to the left, there are no edges to the right
			outerscrollrect.left -= UPDATEWIDTH;
		}
		else
		{
			outerscrollrect.left = scrollrect.left;
			outerscrollrect.right = scrollrect.right;
		}

		if (scrolly > oldscrolly)		// Moving down
		{
		  // We've drawing two edges in front of us to the bottom, there are no edges to the top
			outerscrollrect.bottom += UPDATEHEIGHT;
		}
		else if (scrolly < oldscrolly)  // Moving up
		{
		  // We've drawing two edges in front of us to the top, there are no edges to the bottom
			outerscrollrect.top -= UPDATEHEIGHT;
		}
		else
		{
		  // Just keep the edges we already have
			outerscrollrect.top = scrollrect.top;
			outerscrollrect.bottom = scrollrect.bottom;
		}

	  // Subtract the current valid area from new area and draws invalid edges
		SRect edgerects[4];
		int numedgerects;
		if (SubtractRect(outerscrollrect, scrollrect, edgerects, numedgerects))
		{
			for (int c = 0; c < numedgerects; c++)
				QueueUpdateRect(edgerects[c], BGDRAW_UNLIT);
		}

	  // Get part of valid scroll area that is within the new area
		ClipRect(scrollrect, outerscrollrect, scrollrect);

	  // Cause update system to update background rects
		for (int c = 0; c < numbgrects; c++)
		{
			SRect r = bgrects[c].rect;

		  // Clip to not intersect edge rects which we're already drawing
  			if (!ClipRect(r, scrollrect, r))
				continue;

			QueueUpdateRect(r, bgrects[c].bgdraw);
		}

		queuedrect = outerscrollrect;
		isrecqueued = TRUE;

		BeginUpdate();

	  // If inner scrolling rect not in current valid scroll rect, or bgrects, wait for update	
		if (numbgrects > 0 || !innerscrollrect.In(scrollrect))
			FlushUpdate(TRUE);		// TRUE = Adjust time slice

		numbgrects = 0;
	}

}

void TMapPane::BeginUpdate()
{
	if (!ThreadRunning)
		return;

	BEGIN_CRITICAL();

	Updating = TRUE;
	UpdateCancelled = FALSE;
	SetEvent(UpdateStartEvent);
	
	END_CRITICAL();
}

BOOL TMapPane::UpdateDone()
{
	return !Updating;
}

void TMapPane::CancelUpdate()
{
	if (!ThreadRunning)
		return;

	if (!Updating)
	{
		UpdateCancelled = FALSE;
		return;
	}

	BEGIN_CRITICAL();

	Updating = FALSE;
	UpdateCancelled = TRUE;

	END_CRITICAL();

	FlushUpdate();
}

DWORD TMapPane::WaitUpdate()
{
	if (!ThreadRunning)
		return 0;

	if (!Updating)
	{
		UpdateCancelled = FALSE;
		return 0;
	}

    // Get start time in milliseconds
	DWORD start = GetTickCount();

  // Release all mutexes just in case we're still blocking the loader
	ClearMutex(PauseUpdateMutex);
	ClearMutex(SectorMutex);
	ClearMutex(ObjectMutex);

	while (Updating)
	{
		SetEvent(UpdateStartEvent);
		WaitForSingleObject(UpdateDoneEvent, INFINITE);
		ResetEvent(UpdateDoneEvent);
	}

	UpdateCancelled = FALSE;

	// Get end time in milliseconds
	DWORD end = GetTickCount();

	return end - start; // Return elapsed time for wait
}

void TMapPane::ClearQueueRects()
{
	if (!ThreadRunning)
		return;

	if (Updating)
		WaitUpdate();	// Wait for update to finish before clearing queue

	BEGIN_CRITICAL();

	numqueuerects = 0;

	END_CRITICAL();
}

void TMapPane::QueueUpdateRect(RSRect rect, int bgdraw)
{
	if (!ThreadRunning)
		return;

	if (Updating)
		FlushUpdate();

	if (numqueuerects >= MAXQUEUERECTS)  // This should never happen
		return;

//	SRect dr;
//	if (!ClipRect(scrollrect, rect, dr))
//		return;

	BEGIN_CRITICAL();

	queuerects[numqueuerects].rect = rect; //dr;
	queuerects[numqueuerects].bgdraw = bgdraw;
	numqueuerects++;
	
	END_CRITICAL();
}

void TMapPane::PutQueueRectsToDisplay()
{
	if (!ThreadRunning)
		return;

	if (Updating)
		WaitUpdate();  // Wait for update to finish before adding display rects

	for (int c = 0; c < numqueuerects; c++)
	{
		Display->AddBackgroundUpdateRect(		
			GetBackgroundBuffer(), 	
			queuerects[c].rect.x(), queuerects[c].rect.y(), queuerects[c].rect.w(), queuerects[c].rect.h(),
			UPDATE_BUFFERTOSCREEN | UPDATE_NEXTFRAME);
	}
}

unsigned _stdcall TMapPane::UpdateThread(void *)
{
	SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_BELOW_NORMAL);

	MapPane.UpdateLoop();

  // Kill the events
	ClearMutex(PauseUpdateMutex); // Release if I own it just in case
	ClearMutex(SectorMutex);
	ClearMutex(ObjectMutex);

	CloseHandle(UpdateStartEvent);
	CloseHandle(UpdateDoneEvent);
	CloseHandle(PauseUpdateMutex);
	CloseHandle(SectorMutex);
	CloseHandle(ObjectMutex);

    _endthreadex( 0 );

	return 0;
}

void TMapPane::UpdateLoop()
{
	HANDLE pause[2];
	pause[0] = PauseUpdateMutex; 
	pause[1] = SectorMutex;

	for (;;)
	{
		if (!Updating)
			WaitForSingleObject(UpdateStartEvent, INFINITE);

		ResetEvent(UpdateStartEvent);

		if (QuitThread)
			break;

		if (!Updating)
		{
			ClearMutex(PauseUpdateMutex);
			ClearMutex(SectorMutex);
			ClearMutex(ObjectMutex);
			SetEvent(UpdateDoneEvent);
			continue;
		}

		BEGIN_CRITICAL();
		BOOL dodraw = numqueuerects > 0;
		END_CRITICAL();		

	  // Draw update rect list	
		if (dodraw)
		{
			for (int c = 0; ; c++)
			{
				BEGIN_CRITICAL();

				SRect r;
				int bgdraw;
				BOOL done;

				if (c < numqueuerects)
				{
					r = queuerects[c].rect;
					bgdraw = queuerects[c].bgdraw;
					done = FALSE;
				}
				else
					done = TRUE;
				
				END_CRITICAL();

				if (done == TRUE || UpdateCancelled)
					break;

				WaitForMultipleObjects(2, pause, TRUE, INFINITE);

			  // Draw the update region	
				DrawUpdateRect(r, bgdraw);
				
				ReleaseMutex(PauseUpdateMutex);
				ReleaseMutex(SectorMutex);
				ReleaseMutex(ObjectMutex);

				ClearMutex(PauseUpdateMutex);
				ClearMutex(SectorMutex);
				ClearMutex(ObjectMutex);
			}
		}
		
		BEGIN_CRITICAL();

		if (UpdateCancelled)   // If cancelled, values were reset in cancel, don't change
		{					   // Now because we could have more new rects queued already
			UpdateCancelled = FALSE;
		}
		else				   // If not cancelled, reset all values here
		{
			Updating = FALSE;
			UpdateCancelled = FALSE;
			SetEvent(UpdateDoneEvent);
		}

		END_CRITICAL();

		if (QuitThread)
			break;
	}

}

void TMapPane::PauseUpdate(char *file, int line)
{
	if (!ThreadRunning)
		return;

	WaitSingleErr(PauseUpdateMutex);

	PauseMutexFile = file;
	PauseMutexLine = line;
}

void TMapPane::ResumeUpdate()
{
	if (!ThreadRunning)
		return;

	ReleaseMutex(PauseUpdateMutex);
	ClearMutex(PauseUpdateMutex);

	PauseMutexFile = NULL;
	PauseMutexLine = 0;

}	

void TMapPane::LockSectors(char *file, int line)
{
	if (!ThreadRunning)
		return;

	WaitSingleErr(SectorMutex);

	SectorMutexFile = file;
	SectorMutexLine = line;
}

void TMapPane::UnlockSectors()
{
	if (!ThreadRunning)
		return;

	ReleaseMutex(SectorMutex);
	ClearMutex(SectorMutex);

	SectorMutexFile = NULL;
	SectorMutexLine = 0;
}

void TMapPane::LockObjects(char *file, int line)
{
	if (!ThreadRunning)
		return;

	WaitSingleErr(ObjectMutex);

	ObjectMutexFile = file;
	ObjectMutexLine = line;
}

void TMapPane::UnlockObjects()
{
	if (!ThreadRunning)
		return;

	ReleaseMutex(ObjectMutex);
	ClearMutex(ObjectMutex);

	ObjectMutexFile = NULL;
	ObjectMutexLine = 0;
}

void TMapPane::DrawUpdateRect(RSRect r, int bgdraw)
{
	bgdraw = bgdraw & (~(DWORD)BGDRAW_REDRAW);

	GetUpdateObjs(r); // Get list of objects to draw

	SRect dr = r;

  // Leave origin at 0,0 (for wrap clipping) and set clip rect to current rect)
	unlitmulti->SetClipRect(dr.x(), dr.y(), dr.w(), dr.h());
	unlitmulti->SetClipMode(CLIP_WRAP);

  // Leave origin at 0,0 (for wrap clipping) and set clip rect to current rect)
	litmulti->SetClipRect(dr.x(), dr.y(), dr.w(), dr.h());
	litmulti->SetClipMode(CLIP_WRAP);

  // Draw the tile and lighting pipeline - unlit first, then lights, then lit
	if (bgdraw <= BGDRAW_UNLIT)
		DrawUnlitObjects(dr);
	if (QuitThread || UpdateCancelled)
		return;

	if (bgdraw <= BGDRAW_LIGHTS)
	{
		if (bgdraw > BGDRAW_UNLIT) // Clear lighting values
			DrawAmbientLight(unlitmulti, dr);
		DrawStaticLights(dr);
	}
	if (QuitThread || UpdateCancelled)
		return;

	if (bgdraw <= BGDRAW_LIT)
		DrawLitObjects(dr);
	if (QuitThread || UpdateCancelled)
		return;

	if (Editor)
		DrawSelectedObjects(dr);
	if (QuitThread || UpdateCancelled)
		return;
}

void TMapPane::GetUpdateObjs(SRect &r)
{
	UpdateObjs.Clear();

	for (TMapIterator i(&r, CHECK_RECT|CHECK_LIGHT|CHECK_MOVING|CHECK_INVIS|CHECK_NOINVENT); i; i++)
	{
		UpdateObjs.Add(i);

	// Check to see if update was canceled
		if (UpdateCancelled)
			return;
	}
}

void TMapPane::DrawUnlitObjects(SRect &r)
{
	if (ClearBeforeDraw || level != 0)
		unlitmulti->Box(r.x(), r.y(), r.w(), r.h(), 0, 0xFFFF, 0,
			DM_WRAPCLIP | DM_ZBUFFER | DM_NORMALS);
	else
		unlitmulti->Box(r.x(), r.y(), r.w(), r.h(), 0, 0xFFFF, 0,
			DM_WRAPCLIP | DM_ZBUFFER | DM_NORMALS | DM_NODRAW);

	for (TObjectIterator i(&UpdateObjs); i; i++)
	{
		WaitSingleErr(ObjectMutex);
		i.Item()->DrawUnlit(unlitmulti);
		ReleaseMutex(ObjectMutex);

	// Check to see if update was canceled
		if (UpdateCancelled)
			return;

	}
}

void TMapPane::DrawStaticLights(SRect &r)
{
	for (TObjectIterator i(&UpdateObjs); i; i++)
	{
		WaitSingleErr(ObjectMutex);
		i.Item()->DrawLight(unlitmulti, IsDirty());
		ReleaseMutex(ObjectMutex);

	// Check to see if update was canceled
		if (UpdateCancelled)
			return;
	}

  // Transfer graphic/lighting data to lit buffer
	TransferAndLight32to16(litmulti, unlitmulti, r);

  // Transfer zbuffer data to lit buffer
	if (!zbufferiscloned)
		litmulti->Blit(r.x(), r.y(), unlitmulti, r.x(), r.y(), r.w(), r.h(), DM_NODRAW | DM_ZBUFFER | DM_WRAPCLIP);
}

void TMapPane::DrawLitObjects(SRect &r)
{
	if (Editor && StatusBar.EditWalkmap())
		DrawWalkMap(r);

	for (TObjectIterator i(&UpdateObjs); i; i++)
	{
		if (i.Item()->GetFlags() & OF_EDITOR && !Editor)
			continue;

		WaitSingleErr(ObjectMutex);
		i.Item()->DrawLit(litmulti);
		ReleaseMutex(ObjectMutex);

	// Check to see if update was canceled
		if (UpdateCancelled)
			return;
	}

	// debug stuff
//	if (ShowZBuffer)
//		litmulti->Blit(0, 0, litmulti->GetZBuffer()); 
//	if (ShowNormalBuffer)
//		litmulti->Blit(0, 0, litmulti->GetNormalBuffer()); 
}

void TMapPane::DrawWalkMap(SRect &r)
{
	SRect sr;
	int sx, sy;

	// draw walkmap
	for (sx = 0; sx < SECTORWINDOWX; sx++)
	{
		for (sy = 0; sy < SECTORWINDOWY; sy++)
		{
			if (sectors[sx][sy])
			{
				sectors[sx][sy]->GetMaxScreenRect(sr);
				if (!r.Intersects(sr))
					continue;

				for (int y = wmrevealy; y < (SECTORHEIGHT >> WALKMAPSHIFT) && y < wmrevealsizey; y++)
					for (int x = wmrevealx; x < (SECTORWIDTH >> WALKMAPSHIFT) && x < wmrevealsizex; x++)
					{
						if (x == objx && y == objy &&
							(sectorx+sx) == grabx && (sectory+sy) == graby)
							continue;			// dragging it

						S3DPoint pos, screenpos;

						pos.x = x;
						pos.y = y;
						pos.z = sectors[sx][sy]->ReturnWalkmap(pos.x, pos.y);

						pos.x = ((sectorx + sx) << SECTORWSHIFT) + (x << WALKMAPSHIFT);
						pos.y = ((sectory + sy) << SECTORHSHIFT) + (y << WALKMAPSHIFT);
						WorldToScreen(pos, screenpos);
						screenpos.y += 8;
						screenpos.z -= GRIDZOFF;

						SColor color;
						color.red = max(30, 255 - 4*absval(pos.z - 20));
						color.green = max(30, 255 - 4*absval(pos.z - 100));
						color.blue = max(30, 255 - 4*absval(pos.z - 180));
						if (pos.z > 0)
							litmulti->ZPut(screenpos.x, screenpos.y, screenpos.z, EditorData->Bitmap("grid"), DM_TRANSPARENT | DM_WRAPCLIP | DM_ZBUFFER | DM_USEREG | DM_BACKGROUND);
						litmulti->Put(screenpos.x, screenpos.y, EditorData->Bitmap("gridout"), DM_TRANSPARENT | DM_WRAPCLIP | DM_USEREG | DM_BACKGROUND | DM_CHANGECOLOR, &color);
					}
			}
		}
	}
}

void TMapPane::DrawSelectedObjects(SRect &r)
{
	SRect sr;
	SColor color;
	color.red = 220; color.green = 20; color.blue = 50;

	for (int i = StatusBar.GetFirstObj(); i >= 0; i = StatusBar.GetNextObj())
	{
		PTObjectInstance inst = GetInstance(i);
		if (!inst || inst->IsInInventory() || inst->GetFlags() & OF_SELDRAW)
			continue;

 	  // Check to see if update was canceled
		if (UpdateCancelled)
			return;

		inst->DrawSelected(litmulti);
	}
}

// ***************************************************************************************
// ******************************  End Of UPDATE SYSTEM  *********************************
// ***************************************************************************************

void TMapPane::AnimateSelectedObjects()
{
	SetClipRect();

	if (StatusBar.EditWalkmap())
	{
		if (objx >= 0 && objy >= 0)
		{
			S3DPoint pos, screenpos;
			pos.x = objx;
			pos.y = objy;
			pos.z = sectors[grabx - sectorx][graby - sectory]->ReturnWalkmap(pos.x, pos.y);
			pos.x = (grabx << SECTORWSHIFT) + (objx << WALKMAPSHIFT);
			pos.y = (graby << SECTORHSHIFT) + (objy << WALKMAPSHIFT);
			WorldToScreen(pos, screenpos);
			screenpos.x += MAPPANEX - PosX();
			screenpos.y += MAPPANEY - PosY();
			screenpos.y += 8;
			screenpos.z -= GRIDZOFF;

			SColor color;
			color.red = max(30, 255 - 4*absval(pos.z - 20));
			color.green = max(30, 255 - 4*absval(pos.z - 100));
			color.blue = max(30, 255 - 4*absval(pos.z - 180));
			Display->ZPut(screenpos.x, screenpos.y, screenpos.z, EditorData->Bitmap("grid"), DM_TRANSPARENT | DM_WRAPCLIP | DM_ZBUFFER | DM_USEREG);
			Display->Put(screenpos.x, screenpos.y, EditorData->Bitmap("gridout"), DM_TRANSPARENT | DM_WRAPCLIP | DM_USEREG | DM_CHANGECOLOR, &color);
		}
	}

	for (int i = StatusBar.GetFirstObj(); i >= 0; i = StatusBar.GetNextObj())
	{
		PTObjectInstance inst = GetInstance(i);
		if (!inst || inst->IsInInventory() || !(inst->GetFlags() & OF_SELDRAW))
			continue;

		inst->DrawSelected(Display);

		if (inst->GetShadow() >= 0)
		{
			PTObjectInstance s = GetInstance(inst->GetShadow());
			if (!s || s->IsInInventory() || !(s->GetFlags() & OF_SELDRAW))
				continue;

			s->DrawSelected(Display);
		}
	}

	Display->ResetClipRect();
}

void TMapPane::PulseObjects()
{
	if (NoPulseObjs)
		return;

	for (TMapIterator i; i; i++)
	{
		if (i->GetFlags() & OF_KILL)
			i.Nuke();
		else if (i->GetFlags() & OF_PULSE)
			i->Pulse();
	}
}

void TMapPane::AnimateObjects(BOOL draw)
{
	if (NoAnimateObjs)
		return;

	SRect r; // Get area of screen where we should turn on animators
	r.top    = scrolly - 128;
	r.left   = scrollx - 64;
	r.bottom = scrolly + GetHeight() + 128 - 1;
	r.right  = scrollx + GetWidth() + 64 - 1;

	Display->SetClipRect(MAPPANEX, MAPPANEY, GetWidth(), GetHeight());

	for (TMapIterator i(&r, CHECK_SECTRECT|CHECK_INVIS|CHECK_NOINVENT); i; i++)
	{
		PTObjectInstance inst = i;
		if (!(inst->GetFlags() & (OF_ANIMATE | OF_LIGHT)))
			continue;

		SRect ir, ar;
		inst->GetScreenRect(ir);
		inst->GetAnimRect(ar);

		BOOL intersects = r.Intersects(ir) || r.Intersects(ar);

		if (intersects && !inst->HasAnimator())
			inst->OnScreen();

		else if (!intersects)
			inst->OffScreen();

		inst->Animate(draw);
	}

	Display->ResetClipRect();
}

// *******************************
// * Sector Management Functions *
// *******************************

void TMapPane::SaveAllSectors()
{
	int sx, sy;

	LOCKSECTORS;		// Prevent update thread from accessing sectors while we change them
						// (MAKE SURE UNLOCK IS ALWAYS CALLED.. THERE MUST BE NO RETURN 
						//  BETWEEN THESE TWO FUNCTIONS!!)

	for (sx = 0; sx < SECTORWINDOWX; sx++)
		for (sy = 0; sy < SECTORWINDOWY; sy++)
			if (sectors[sx][sy])
				sectors[sx][sy]->Save();

	UNLOCKSECTORS;		 // Allow update system to access sector arrays again
						 // If lock is called without unlock, system will CRASH!!
}

void TMapPane::FreeAllSectors()
{
	int sx, sy;

	LOCKSECTORS;		// Prevent update thread from accessing sectors while we change them
						// (MAKE SURE UNLOCK IS ALWAYS CALLED.. THERE MUST BE NO RETURN 
						//  BETWEEN THESE TWO FUNCTIONS!!)

	// NOTE: We don't need to call the LockSectors() function here because the
	// update system is turned off by the time we get here

	for (sx = 0; sx < SECTORWINDOWX; sx++)
		for (sy = 0; sy < SECTORWINDOWY; sy++)
			if (sectors[sx][sy])
			{
				DeleteSector(sectors[sx][sy]);
				sectors[sx][sy] = NULL;
			}

	UNLOCKSECTORS;		 // Allow update system to access sector arrays again
						 // If lock is called without unlock, system will CRASH!!
}

void TMapPane::ReloadSectors()
{
	FreeAllSectors();
	sectorx += 10000000;
	sectory += 10000000;
	RedrawAll();
}

void TMapPane::UpdateSectors()
{
	int x, y;

  // Change sector position
	oldlevel = level;
	level = newlevel;
	oldsectorx = sectorx;
	oldsectory = sectory;

  // account for the character actually being at (sectorx+1, sectory+1)
	sectorx = (center.x >> SECTORWSHIFT) - 1;
	sectory = (center.y >> SECTORHSHIFT) - 1;

  // If sector has changed.. reload sectors
	if (sectorx != oldsectorx || sectory != oldsectory || level != oldlevel || IsDirty())
	{
		LOCKSECTORS;		// Prevent update thread from accessing sectors while we change them
							// (MAKE SURE UNLOCK IS ALWAYS CALLED.. THERE MUST BE NO RETURN 
							//  BETWEEN THESE TWO FUNCTIONS!!)

	  // Temporary sectors
		PTSector tempsectors[SECTORWINDOWX][SECTORWINDOWY];

	  // Clear sector pointers
		PTSector *s = (PTSector *)tempsectors;
		for (int c = 0; c < SECTORWINDOWX * SECTORWINDOWY; c++, s++)
			*s = NULL;

	  // Delete unused sectors
		int nx, ny;

		for (x = 0; x < SECTORWINDOWX; x++)
		{
			for (y = 0; y < SECTORWINDOWY; y++)
			{
				// offset by one, because sectorx refers to middle sector
				nx = oldsectorx - sectorx + x;
				ny = oldsectory - sectory + y;

				if (level != oldlevel || (DWORD)nx >= SECTORWINDOWX || (DWORD)ny >= SECTORWINDOWY)
				{
					if (sectors[x][y])
						DeleteSector(sectors[x][y]);
				}
				else
				{
					if ((DWORD)nx >= MAXSECTORX || (DWORD)ny >= MAXSECTORY)
						tempsectors[nx][ny] = NULL;
					else
						tempsectors[nx][ny] = sectors[x][y];
				}

				sectors[x][y] = NULL;
			}
		}

	  // Preload sectors if level changed (hack until area system is done)	
		if (!PreloadSectors)
			TSector::ClearPreloadSectors();
		else if (!TSector::InPreloadArea(center, level)) // Reload cache if we're not in cache rect
		{

		  // Deallocate all sectors so we can clear sector cache
			for (int sx = 0; sx < SECTORWINDOWX; sx++)
				for (int sy = 0; sy < SECTORWINDOWY; sy++)
					if (tempsectors[sx][sy])
					{
						DeleteSector(tempsectors[sx][sy]);
						tempsectors[sx][sy] = NULL;
					}

		  // Get new sector rectangle area
			SRect r;
			r.left = center.x - SECTORWIDTH * PreloadSectorSize / 2;
			r.right = center.x + SECTORWIDTH * PreloadSectorSize / 2;
			r.top = center.y - SECTORHEIGHT * PreloadSectorSize / 2;
			r.bottom = center.y + SECTORHEIGHT * PreloadSectorSize / 2;

			if (TextBar.IsOpen() && !TextBar.IsHidden() && CurrentScreen->FrameCount() > 0)
			{
				TextBar.Print("Loading Map... Please Wait");
				TextBar.Draw();
				TextBar.PutToScreen();
			}

		  // Now reload cache around current pos
			TSector::LoadPreloadSectors(level, 1, &r); // Don't care if this works or not

			if (TextBar.IsOpen() && !TextBar.IsHidden() && CurrentScreen->FrameCount() > 0)
			{
				TextBar.Print("");
				TextBar.Draw();
				TextBar.PutToScreen();
			}
		}

	  // Load new sectors if needed
		BOOL loaded = FALSE;

		for (x = 0; x < SECTORWINDOWX; x++)
		{
			for (y = 0; y < SECTORWINDOWY; y++)
			{
				if (!tempsectors[x][y])
				{
					if ((DWORD)(sectorx+x) < MAXSECTORX && (DWORD)(sectory+y) < MAXSECTORY)
					{
					 	sectors[x][y] = TSector::LoadSector(level, sectorx+x, sectory+y);
						loaded = TRUE;
					}
					else
						sectors[x][y] = NULL;
				}
				else
					sectors[x][y] = tempsectors[x][y];
			}
		}

		if (loaded)
			TransferAllWalkmaps();

		// Make sure all selected objects are still valid
		if (Editor)
			StatusBar.Validate();

		UNLOCKSECTORS;		 // Allow update system to access sector arrays again
							 // If lock is called without unlock, system will CRASH!!


	  // Now that sectors have changed, attempt to readd player characters to map
	  // if they aren't in it yet.
	  //
	  // Since player characters are OF_NONMAP. They aren't saved or deleted by the
	  // sector system.  When the map changes, we simply go through the list of characters.
	  // and add them into the current map if they aren't in there already.

		for (int player = 0; player < PlayerManager.NumPlayers(); player++)
		{
			PTPlayer p = PlayerManager.GetPlayer(player);
			if (p && !p->GetSector())
				AddObject(p); // Attempt to add player to current sector area
		}

	}
}

/*void TMapPane::GetPlayerFocus(RS3DPoint pos)
{
	if (!Player)
		return;

	if (ScrollLock)
		Player->GetPos(pos);
	else
	{
		// find the vector of facing (where's he's currently focusing his eyes)
		ConvertToVector(((PTCharacter)Player)->GetFacingTarget(), 96, pos);

		S3DPoint curpos;		// add in current position
		Player->GetPos(curpos);
		pos += curpos;
	}

	pos.x -= 42;			// account for character height on screen
	pos.y -= 42;
}
*/

// ***************************
// * Main Animation Function *
// ***************************

void TMapPane::Animate(BOOL draw)
{
	// Draw dynamic light
	if (!Editor && Player)
	{
		S3DPoint pos;
		Player->GetPos(pos);
		static int brighttick;
		brighttick++;
		S3DPoint lpos = pos;
		lpos.x += (int)(10.0 * sin((double)brighttick / 7.0));
		lpos.y += (int)(10.0 * cos((double)brighttick / 7.0));
		lpos.z += 100 + (int)(20.0 * sin((double)brighttick / 12.0));
		MapPane.SetDLightPos(lpos);

		if (draw)
		{
			SetClipRect();
			DrawDLight();
		}
	}

  // Update zbuffers before animation begins
	if (draw)
	{
		SetClipRect();
		Scene3D.RefreshZBuffer();
	}

  // Draw objects being dragged around
	if (Editor && draw && !mx && !my)
		AnimateSelectedObjects();

  // Draw object animations
	AnimateObjects(draw);

	// Draw 3D scene stuff	
	SetClipRect();
    if (draw)
		Scene3D.DrawScene();

  // Update mouse cursor
	if (draw)
	{
		int x = cursorx - GetPosX();
		int y = cursory - GetPosY();

		if (InPane(x, y))
		{
			int type = CURSOR_NONE;

			if (!Editor)
			{
				PTObjectInstance inst = OnObject(x, y);
				if (inst)
					if (GetDragObj() == NULL && inst->IsInventoryItem())
						type = CURSOR_HAND;			// can pick up while in the map pane
					else
						type = inst->CursorType(GetDragObj());
			}

			SetMouseCornerBitmap(type);
		}
	}

  // Release time slice to update thread if necessary
	UpdateTimeSlice(draw);	
}

// ***********************
// * Object Manipulation *
// ***********************

BOOL TMapPane::MoneyHandler(PTObjectInstance oi, int amount)
{
	if (oi == NULL)
		return 0;

	BOOL subtract = (amount > 0);

	int total = 0;

	for (TInventoryIterator i(oi); i; i++)
	{
		if (i->ObjClass() == OBJCLASS_MONEY)
		{
			int val = i->Amount() * i->Value();

			if (subtract)
			{
				if (amount < val)
					i->SetAmount((val - amount) / i->Value());
				else	// extract the object, it's used up
					DeleteObject( i);
			}

			total += val;
		}

		if (subtract && total >= amount)
			break;
	}

	for (TInventoryIterator j(oi); j; j++)
	{
		if (subtract && total >= amount)
			break;

		total += MoneyHandler(j, subtract ? amount - total : 0);
	}

	return total;
}

int TMapPane::SubtractMoney(PTObjectInstance oi, int amount)
{
	if (amount < 1 || GetTotalMoney(oi) < amount)
		return 0;

	return MoneyHandler(oi, amount);
}

int TMapPane::GetTotalMoney(PTObjectInstance oi)
{
	return MoneyHandler(oi, 0);
}

// Checks new position and transfers object between sectors if object crosses a sector
// boundry.  Also prevents objects from going outside of loaded sector list
int TMapPane::CheckPos(PTObjectInstance inst, RS3DPoint newpos, int newlevel)
{
  // If default, or object is owned by map, set level to object level
  // Note: only floating NONMAP objects like TPlayer objects can change their level
	if (newlevel == -1 || !(inst->Flags() & OF_NONMAP))
		newlevel = inst->GetLevel();

	// basic bounds checking
	if (newpos.x < 0)
		newpos.x = 0;
	else if (newpos.x >= MAXMAPWIDTH)
		newpos.x = MAXMAPWIDTH;

	if (newpos.y < 0)
		newpos.y = 0;
	else if (newpos.y >= MAXMAPHEIGHT)
		newpos.y = MAXMAPHEIGHT;

	int newsx = (newpos.x >> SECTORWSHIFT) - sectorx;
	int newsy = (newpos.y >> SECTORHSHIFT) - sectory;


	// Note: Since non map objects are usually characters, it's ok to move them outside of
	if (inst->Flags() & OF_NONMAP)  // Non map can be outside of current sector list (it's OK)
	{

	// Non map objects (usually characters), can be teleported outside of the current map.
	// When this happens, they are removed from the current sector list until the DrawBackground()
	// function reloads a new sector list which contains them again.  Objects outside of sectors
	// will never get Pulse or Animate calls (to make sure they don't somehow hose the system).

		if (newsx < 0 || newsx >= SECTORWINDOWX || 
			newsy < 0 || newsy >= SECTORWINDOWY || 
			newlevel != GetMapLevel())
		{
			RemoveObject(inst);
			return 0;
		}
	}
	else
	{

	// For normal objects, make sure new sector is within loaded sectors - 
	// if not leave it bumping up against the sector boundry

		if (newsx < 0)
		{
			newsx = 0;
			newpos.x = max(sectorx, 0) << SECTORWSHIFT;
		}
		else if (newsx >= SECTORWINDOWX)
		{
			newsx = SECTORWINDOWX - 1;
			newpos.x = ((sectorx + newsx) << SECTORWSHIFT) + SECTORWIDTH - 1;
		}

		if (newsy < 0)
		{
			newsy = 0;
			newpos.y = max(sectory, 0) << SECTORHSHIFT;
		}
		else if (newsy >= SECTORWINDOWY)
		{
			newsy = SECTORWINDOWY - 1;
			newpos.y = ((sectory + newsy) << SECTORHSHIFT) + SECTORHEIGHT - 1;
		}
	}

	// Check to see if it changed sectors while moving
	if (!inst->IsInInventory())
	{
		S3DPoint pos;
		inst->GetPos(pos);
		int sx = (pos.x >> SECTORWSHIFT) - sectorx;
		int sy = (pos.y >> SECTORHSHIFT) - sectory;

		if (newsx != sx || newsy != sy)
			return TransferObject(inst, sx, sy, newsx, newsy);
	}

	return inst->GetMapIndex();
}

// Moves an object from one sector to another
int TMapPane::TransferObject(PTObjectInstance inst, int sx, int sy, int newsx, int newsy)
{
	if (!inst)
		return -1;

	TMapIterator i;

	for ( ; i; i++)
		if (i == inst)
			break;

	if (!i)
		return -1;

	LOCKSECTORS;	  // Prevent update system from accessing sectors

	sectors[sx][sy]->RemoveObject(i.SectorIndex());
	sectors[newsx][newsy]->AddObject(inst);

	UNLOCKSECTORS;	  // Allow update system to access sectors again

	return inst->GetMapIndex();
}

// Walkmap auto-generator for current sector
void TMapPane::CalculateWalkmap()
{
	PTSector sector = sectors[1][1];
	if (!sector)
		return;

	for (int y = 0; y < (SECTORWIDTH >> WALKMAPSHIFT); y++)
		for (int x = 0; x < (SECTORHEIGHT >> WALKMAPSHIFT); x++)
		{
			S3DPoint pos, screenpos;

			pos.x = ((sectorx+1) << SECTORWSHIFT) + (x << WALKMAPSHIFT);
			pos.y = ((sectory+1) << SECTORHSHIFT) + (y << WALKMAPSHIFT);
			pos.z = 0;
			WorldToScreen(pos, screenpos);

			if (screenpos.x < posx || screenpos.x >= (posx+GetWidth()) ||
				screenpos.y < posy || screenpos.y >= (posy+GetHeight()))
				continue;

			for (pos.z = 255; pos.z > 1; pos.z--)
			{
				pos.x = ((sectorx+1) << SECTORWSHIFT) + (x << WALKMAPSHIFT);
				pos.y = ((sectory+1) << SECTORHSHIFT) + (y << WALKMAPSHIFT);
				WorldToScreen(pos, screenpos);

				if (screenpos.x < posx || screenpos.x >= (posx+GetWidth()) ||
					screenpos.y < posy || screenpos.y >= (posy+GetHeight()))
					continue;

				updatemulti->SetClipRect(screenpos.x, screenpos.y, 1, 1);
				screenpos.y += 8;
				screenpos.z -= GRIDZOFF;

				if (!updatemulti->ZFind(screenpos.x, screenpos.y, screenpos.z, EditorData->Bitmap("grid"), DM_USEREG | DM_ZBUFFER))
				{
					pos.x = x;
					pos.y = y;
					sector->SetWalkmap(pos.x, pos.y, pos.z);
					break;
				}
			}
		}

	MapPane.RedrawAll();
}

void TMapPane::AdjustWalkmap(int deltaz, BOOL absolute, BOOL nonzero)
{
	PTSector sect = sectors[1][1];
	if (!sect || !deltaz)
		return;

	S3DPoint pos;
	for (pos.y = min(wmrevealsizey, (SECTORHEIGHT >> WALKMAPSHIFT)) - 1; pos.y >= wmrevealy; pos.y--)
		for (pos.x = min(wmrevealsizex, (SECTORWIDTH >> WALKMAPSHIFT)) - 1; pos.x >= wmrevealx; pos.x--)
		{
			pos.z = sect->ReturnWalkmap(pos.x, pos.y);
			if (nonzero && pos.z == 0)
				continue;

			if (absolute)
				pos.z = 0;

			pos.z = min(255, max(0, pos.z + deltaz));
			sect->SetWalkmap(pos.x, pos.y, pos.z);
		}

	RedrawAll();
}


char *ModeCursorName[NUMMODES] = { "crosshar", "stamp", "marrow" };

// Handler for special editor modes
void TMapPane::SetMode(void (*tfunc)(S3DPoint), void (*afunc)(), int newmode)
{
	if (newmode >= NUMMODES || newmode < 0)
		return;

	targetcallback = tfunc;
	abortcallback = afunc;
	mode = newmode;

	if (mode == MODE_CLONE || mode == MODE_MOVE)
	{
		dragmode = TRUE;
		PTObjectInstance inst = GetInstance(StatusBar.GetSelectedObj());
		if (inst)
		{
			SRect r;
			inst->GetScreenRect(r);
			objx = 0;
			objy = -((r.bottom - r.top + 1) / 2);
		}
	}

	SetMouseBitmap(EditorData->Bitmap(ModeCursorName[mode]));

	//PlayScreen.SetExclusivePane(&MapPane);
}

// Notify objects of changes
void TMapPane::Notify(DWORD notify, void *ptr)
{
  // If nothing has requested notify, just quit	
	if (!(notify & notifyflags))
		return;

	BOOL notifyanything = FALSE;

	// Find objects to notify
	for (TMapIterator i; i; i++)
	{
		if (i->GetFlags() & OF_NOTIFY)
		{
			i->Notify(notify, ptr);
			notifyanything = TRUE;
		}
	}

    // Nothing wants to be notified anymore.. so set flags to 0
	if (!notifyanything)
		notifyflags = 0;
}
// *************************************************************************
// *                           Cinematix EXILE                             *
// *                    Copyright (C) 1996 Cinematix                       *
// *              MissileEffect.cpp - TMissileEffect module                *
// *************************************************************************

#include <ddraw.h>
#include <d3d.h>
#include <d3drmwin.h>
#include <math.h>
#include "d3dmacs.h"
#include "d3dmath.h"

#include "MissileEffect.H"
#include "Effect.H"

// ******************
// * TMissileEffect *
// ******************

void TMissileEffect::Initialize()
{
    SetState(MISSILE_LAUNCH);
	angle = 0;
	range = 32768;

    SetSpeed( 16);

	status = FALSE;
}

int TMissileEffect::GetSpeed()
{
    return speed / ROLLOVER;
}

void TMissileEffect::SetSpeed(int newspeed)
{
    speed = newspeed * ROLLOVER;
}

void TMissileEffect::Pulse()
{
    DWORD bits = Move();

    switch(state)
    {
        case MISSILE_LAUNCH :
        {
            if (status)
            {
				if (speed)
				{
					ConvertToVector(GetAngle(), speed, vel); 
					flags = (flags & ~OF_IMMOBILE) | OF_MOVING | OF_WEIGHTLESS;
					vel.z = (speed / -16);

		   			range = (240 * MISSILE_RANGE) / (speed / ROLLOVER);
				}
				SetState( MISSILE_FLY);
            }
            break;
        }

        case MISSILE_FLY :
        {
            BOOL explode = FALSE;
			int num;

            range--;
            if (range <= 0)
                explode = TRUE;

            // See if we hit the ground
            if (bits & MOVE_BLOCKED)
                explode = TRUE;
            else
            {
				int targets[MAXFOUNDOBJS];
				S3DPoint new_pos;
				new_pos.x = pos.x;
				new_pos.y = pos.y;
				new_pos.z = pos.z - 100;
                // See if we've hit a character
                num = MapPane.FindObjectsInRange(new_pos, targets, 5, 0, OBJCLASS_CHARACTER);
				for(int i = 0; i < num; ++i)
				{
                    PTObjectInstance inst = MapPane.GetInstance(targets[i]);
                    if (inst && inst != spell->GetInvoker())
						explode = TRUE;
				}
            }

            // See if we need to change the state to MISSILE_EXPLODE
            if (explode)
            {
                // Stop the missile moving and cause it to explode
                flags = (flags & ~OF_MOVING & ~OF_WEIGHTLESS) | OF_IMMOBILE;
                SetState(MISSILE_EXPLODE);
            }
            break;
        }

        case MISSILE_EXPLODE :
        {
			if (commanddone || !animator)
                KillThisEffect();
            break;
        }
    }
}

void TMissileEffect::OffScreen()
{
	if (animator && (state == MISSILE_EXPLODE) && status)
		TObjectInstance::OffScreen();
}

// *****************
// * TPhotonEffect *
// *****************

DEFINE_BUILDER("Photon", TPhotonEffect)
REGISTER_BUILDER(TPhotonEffect)

void TPhotonEffect::Initialize()
{
    TMissileEffect::Initialize();

    SetSpeed(PHOTON_SPEED);

    SoundPlayer.Mount(LIGHTNING_SOUND);

    firsttime = TRUE;
}

void TPhotonEffect::Pulse()
{
    TMissileEffect::Pulse();

    if ((state == MISSILE_FLY) && (firsttime))
    {
        firsttime = FALSE;
		SoundPlayer.Play(LIGHTNING_SOUND);
    }
}

// *******************
// * Photon Animator *
// *******************

REGISTER_3DANIMATOR("Photon", TPhotonAnimator)

//==============================================================================
//    Function : Initialize.
//------------------------------------------------------------------------------
// Description : This will setup the initial state for a photon animator. The
//               photon effect starts with a launch sequence which is made up
//               of a sparkle effect around the player.  The initial positions
//               of each of the sparks are set here.
//==============================================================================

void TPhotonAnimator::Initialize()
{
    S3DTex tex;

	T3DAnimator::Initialize();

    // Get how many frames are in the texture
    Get3DImagery()->GetTexture(0, &tex);
    numtexframes = tex.numframes;

    // Set the beginning state of the effect
    state = oldstate = MISSILE_LAUNCH;

    // Initialize the values for the central flare
    p[0].x = p[0].y = p[0].z = 0;
    scale[0] = 1.0;
	framenum[0] = 0;

    // Initialize the starting position of each spark, its scale and a delay
    // before it starts (a neg. framenum)
    for (int n = 1; n < NUM_PHOTON_SPARKS; n++)
    {
        p[n].x = (D3DVALUE)(random(-PHOTON_LAUNCH_RADIUS, PHOTON_LAUNCH_RADIUS));
        p[n].y = (D3DVALUE)(random(-PHOTON_LAUNCH_RADIUS, PHOTON_LAUNCH_RADIUS));
        p[n].z = (D3DVALUE)(random(-PHOTON_LAUNCH_RADIUS, PHOTON_LAUNCH_RADIUS));

        // Set a vector for most of the sparks to move them to the center of the effect
        if (n > NUM_PHOTON_SPARKS / 3)
        {
            v[n].x = - p[n].x / (PHOTON_LAUNCH_DURATION * 3 / 4);
            v[n].y = - p[n].y / (PHOTON_LAUNCH_DURATION * 3 / 4);
            v[n].z = - p[n].z / (PHOTON_LAUNCH_DURATION * 3 / 4);
        }
        else
            v[n].x = v[n].y = v[n].z = 0;

        scale[n] = 0.0;

        framenum[n] = random(-PHOTON_LAUNCH_DURATION / 2, 0);
    }

    // Initialize the framenums for the trailing photon sparks
    for (n = NUM_PHOTON_SPARKS; n < NUM_PHOTON_SPARKS * 2; n++)
        framenum[n] = -1;

    // Set how many photon sparks are active at the beginning
    activesparks = NUM_PHOTON_SPARKS - 1;
}

//==============================================================================
//    Function : Animate.
//------------------------------------------------------------------------------
// Description : This updates the frame number, position, and scale values
//               for the three different states of the photon effect.
//==============================================================================

void TPhotonAnimator::Animate(BOOL draw)
{
    int n;
    int t;

	T3DAnimator::Animate(draw);
	((PTMissileEffect)inst)->SetStatus(FALSE);
	inst->SetCommandDone(TRUE);

    switch(state)
    {
        case MISSILE_LAUNCH :
        {
            // Adjust the framenum & scale for the central flare
            framenum[0]++;
            if ((framenum[0] > PHOTON_LAUNCH_DURATION / 2) && (scale[0] < (D3DVALUE)5.5))
                scale[0] += PHOTON_LAUNCH_SCALE_STEP;

            // Adjust the framenum, position, and scale vals for all the other sparks
            for (n = 1; n < NUM_PHOTON_SPARKS; n++)
            {
                framenum[n]++;

                if (framenum[n] >= 0)
                {
                    // Move the sparks
                    p[n].x += v[n].x;
                    p[n].y += v[n].y;
                    p[n].z += v[n].z;

                    // If the effect is over half over, scale the sparks down
                    if (framenum[n] > PHOTON_LAUNCH_DURATION / 2)
                    {
                        if (scale[n])
                        {
                            scale[n] -= PHOTON_LAUNCH_SCALE_STEP;
                            // Check for the end of this spark
                            if (scale[n] <= 0)
                            {
                                // Take this spark off the active spark list
                                // and see if there are any sparks left
                                activesparks--;
                                if (activesparks < NUM_PHOTON_SPARKS / 3)
                                    ((PTMissileEffect)inst)->SetStatus(TRUE);
                                scale[n] = 0;
                            }
                        }
                    }
                    else
                    // Otherwise, scale the sparks up
                        scale[n] += PHOTON_LAUNCH_SCALE_STEP;
                }
            }
            break;
        }

        case MISSILE_FLY :
        {
            // See if this is our first time
            if (state != oldstate)
            {
                S3DPoint dir;
                inst->GetVel(dir);

                // Initialize the variables for the leading photon
                p[0].x = p[0].y = p[0].z = 0;
                scale[0] = (D3DVALUE)3.5;
                framenum[0] = 0;

                // Initialize the variables for the trailing photons
				for (n = NUM_PHOTON_SPARKS, t = 1; n < NUM_PHOTON_SPARKS * 2; n++, t++)
                {
                    framenum[n] = -t;
                    framenum[t] = -1;
                    p[n].x = (D3DVALUE)-dir.x * t / ROLLOVER;
                    p[n].y = (D3DVALUE)-dir.y * t / ROLLOVER;
                    p[n].z = (D3DVALUE)-dir.z * t / ROLLOVER;
                    scale[n] = (D3DVALUE)3.5 - t * (D3DVALUE)PHOTON_LAUNCH_SCALE_STEP;
                }
            }
            else
            {
                // Otherwise, just update the frame counter
                for (n = NUM_PHOTON_SPARKS; n < NUM_PHOTON_SPARKS * 2; n++)
                    framenum[n]++;
            }
            break;
        }

        case MISSILE_EXPLODE :
        {
            // See if this is our first time
            if (state != oldstate)
            {
                S3DPoint dir;
                inst->GetVel(dir);

                // Initialize the sparks that come off of the explosion
                for (n = 0; n < NUM_PHOTON_SPARKS; n++)
                {
                    p[n].x = p[n].y = p[n].z = 0;
                    scale[n] = (D3DVALUE)3.0;

                    v[n].x = (D3DVALUE)random(-3, 3) * (D3DVALUE)3.0 / (D3DVALUE)2.0;
                    v[n].y = (D3DVALUE)random(-3, 3) * (D3DVALUE)3.0 / (D3DVALUE)2.0;
                    v[n].z = (D3DVALUE)random(-3, 3) * (D3DVALUE)3.0 / (D3DVALUE)2.0;

                    framenum[n] = 0;
                }
                activesparks = NUM_PHOTON_SPARKS;
            }
            else
            {
                // It's not our first time, so update the frame numbers, the
                // positions and the scale values
                for (n = 0, t = NUM_PHOTON_SPARKS; n < NUM_PHOTON_SPARKS; n++, t++)
                {
                    framenum[n]++;

                    // Move the sparks
                    p[n].x += v[n].x;
                    p[n].y += v[n].y;
                    p[n].z += v[n].z;

                    if (scale[n] > 0)
                    {
                        scale[n] -= PHOTON_LAUNCH_SCALE_STEP / 2;
                        // Check for the end of this spark
                        if (scale[n] <= 0)
                        {
                            scale[n] = 0;
                            // If it has, take it off the active spark list and
                            // see if there are any sparks left
                            activesparks--;
                            if (activesparks == 0)
                                inst->SetCommandDone(TRUE);
                        }
                    }

                    // Update any remaining trailing photons
                    if (scale[t])
                    {
                        framenum[t]++;
                        scale[t] -= PHOTON_LAUNCH_SCALE_STEP / 2;
                        // Check for the end of this trailing photon
                        if (scale[t] <= 0)
                            scale[t] = 0;
                    }
                }
            }
            break;
        }
    }

    // Keep track of the state we're in
    oldstate = state;
}

//==============================================================================
//    Function : Render.
//------------------------------------------------------------------------------
// Description : This loops through all the photon sparks and renders each
//               at the appropriate location and scale value.
//==============================================================================

BOOL TPhotonAnimator::Render()
{
    SaveBlendState();
    SetBlendState();

    PS3DAnimObj obj = GetObject(0);

    for (int n = 0; n < NUM_PHOTON_SPARKS * 2; n++)
    {
        // Only render the spark if it's framenum is positive
        if (framenum[n] >= 0)
        {
            // Reset render extents
            Get3DImagery()->ResetExtents();

            // Set the scale and position of the object
			obj->flags |= OBJ3D_SCL1 | OBJ3D_POS2;
            obj->scl.x = obj->scl.y = obj->scl.z = (D3DVALUE)scale[n];
            obj->pos = p[n];

            // Set the frame number manually
            frame = framenum[n] % numtexframes;

            RenderObject(obj);

            // Update bounding rect and screen rect
            UpdateExtents();
        }
    }

    RestoreBlendState();

	return TRUE;
}

void TPhotonAnimator::RefreshZBuffer()
{
	S3DPoint effect, map, screen;
	((PTEffect)inst)->GetPos(effect);
	int tex_u= 16;
	int tex_v = 16;
	int x_size, y_size;

    for (int n = 0; n < NUM_PHOTON_SPARKS * 2; n++)
	{
        // Only refresh the spark if it's framenum is positive
        if (framenum[n] >= 0)
        {
            // Set the scale and position of the object
			x_size = (int)((float)scale[n] * (float)tex_u);
            y_size = (int)((float)scale[n] * (float)tex_v);

			// get the coordinates
			map.x = (int)p[n].x + effect.x;
			map.y = (int)p[n].y + effect.y;
			map.z = (int)p[n].z + effect.z;

			// convert
			WorldToScreen(map, screen);

			RestoreZ(screen.x - (x_size / 2), screen.y - (y_size / 2), x_size, y_size);
        }
    }
}

// ***************************
// * The FireBall Effect *
// ***************************

DEFINE_BUILDER("FireBall", TFireBallEffect)
REGISTER_BUILDER(TFireBallEffect)

void TFireBallEffect::Initialize()
{
	TMissileEffect::Initialize();

	SetSpeed(FIREBALL_SPEED);
}

void TFireBallEffect::Pulse()
{
	TMissileEffect::Pulse();
}

// *************************
// * The FireBall Animator *
// *************************

REGISTER_3DANIMATOR("FireBall", TFireBallAnimator)

// init the fireball animation, just for kicks
void TFireBallAnimator::Initialize()
{
	// call the 3d animator init
	T3DAnimator::Initialize();

	PS3DAnimObj o = GetObject( 0);
    GetVerts(o, D3DVT_LVERTEX);
	// *** FIREBALL ***

	// init the fireball's position
	fireball.pos.x = fireball.pos.y = fireball.pos.z = 0;
	PLAY("fireball grow");
	// init the fireball's scale
	fireball.scale = 0.0f;
	// init the fireball's rotation
	fireball.rotation = 0;
	// increment the fireball's frame
	fireball.frame = 0.0f;

	// frame stuff
	frame_count = FIREBALL_MAX_FRAME;
	glow_frame = FIREBALL_GLOW_FRAME;

	// sparkle stuff
	fireball.glow = 1.5f;

	// spark init
	o = GetObject( 1);
	spark.Init(this, o);

	// init the ring
	o = GetObject( 2);
	ring.Init(this, o, 4, 24);

	explode = 0;

	for(int i = 0; i < FIREBALL_MAX_BURST; ++i)
		burst[i].used = 0;

	old_state = state;
}

void TFireBallAnimator::Animate(BOOL draw)
{
	// base class animation
	T3DAnimator::Animate(draw);

	// override being done
	inst->SetCommandDone(FALSE);
	((PTMissileEffect)inst)->SetStatus(FALSE);

	if(old_state != state)
		firsttime = 1;
	else
		firsttime = 0;

	// explosion state stuff
	if(explode == 1)
		explode = -1;
	else if(explode == 0 && state == MISSILE_EXPLODE)
		explode = 1;

	S3DPoint effect_pos;
	((PTEffect)inst)->GetPos(effect_pos);

	// set the new spark parameters
	SSubParticleParams params;

	if(explode == -1)
		params.particles = 0;
	else if(explode == 1)
		params.particles = FIREBALL_MAX_SPARK;
	else
		params.particles = FIREBALL_NORM_SPARK;

	if(state == MISSILE_LAUNCH)
		params.chance = 25;
	else if(state == MISSILE_FLY)
		params.chance = 30;
	else
		params.chance = 100;

	params.velocity_dir.x = 0.0f;
	params.velocity_dir.y = 0.0f;
	params.velocity_dir.z = 0.0f;

	params.pos.x = (float)effect_pos.x;
	params.pos.y = (float)effect_pos.y;
	params.pos.z = (float)effect_pos.z;
	params.pos_spread.x = params.pos_spread.y = params.pos_spread.z = 0.0f;

	params.scale.x = params.scale.y = params.scale.z = .15f;
	params.scale_dec.x = params.scale_dec.y = params.scale_dec.z = .90f;
	params.scale_spread.x = params.scale_spread.y = params.scale_spread.z = 0.0f;

	params.velocity.x = params.velocity.y = params.velocity.z = 0.0f;

	if(state == MISSILE_LAUNCH)
	{
		params.velocity_spread.z = 1.0f;
		params.velocity_spread.x = params.velocity_spread.y = 3.0f;
	}
	else
		params.velocity_spread.x = params.velocity_spread.y = params.velocity_spread.z = 1.0f;


	params.gravity = 0.37f;

	params.min_life = 15;
	params.max_life = 20;

	params.flicker = TRUE;
	params.flicker_size = 1.75f;

	spark.Set(&params);

	// do the spark animation
	spark.Animate();

	// do the trails
	for(int i = FIREBALL_TRAIL_SIZE - 1; i > 0; --i)
	{
		trail[i] = trail[i - 1];
		trail[i].scale *= FIREBALL_TRAIL_SCALE;
	}
	trail[0] = fireball;
	trail[0].scale *= FIREBALL_TRAIL_SCALE;
	trail[0].pos.x += (float)effect_pos.x;
	trail[0].pos.y += (float)effect_pos.y;
	trail[0].pos.z += (float)effect_pos.z;

	// change the glow's size
	fireball.glow = 1.0f + (.05f * (float)random(0, 15));

	// change the frame
	fireball.frame += 1.0f;
	if(fireball.frame > frame_count)
		fireball.frame = 0.0f;
	if((int)fireball.frame == glow_frame)
	{
		fireball.frame += 1.0f;
		if(fireball.frame > frame_count)
			fireball.frame = 0.0f;
	}
#ifdef FIREBALL_WHITE_FADE
	fireball.rotation = (fireball.rotation + 12) % 360;
#else
	fireball.rotation = (fireball.rotation + 2) % 360;
#endif

	int count = 0;
	switch(state)
	{
		// make the fireball grow above the caster
		case MISSILE_LAUNCH: 
			if(fireball.scale < FIREBALL_MAX_SIZE)
				fireball.scale += FIREBALL_GROW_RATE;
			else
				((PTMissileEffect)inst)->SetStatus(TRUE);
			break;
		// when the fireball is launched
		case MISSILE_FLY:
			break;
		// when the fireball impacts the target
		case MISSILE_EXPLODE:			
			if(firsttime)
			{
				S3DPoint pos;
				pos.x = (int)fireball.pos.x + effect_pos.x;
				pos.y = (int)fireball.pos.y + effect_pos.y;
				pos.z = (int)fireball.pos.z + effect_pos.z;
		        BlastCharactersInRange(((PTEffect)inst)->GetSpell()->GetInvoker(), pos, 200, FIREBALL_DAMAGE_MIN, FIREBALL_DAMAGE_MAX, DAMAGE_FIRE, ((PTMissileEffect)inst)->GetAngle(), ((PTMissileEffect)inst)->GetMissileSpeed());
				PLAY("fireball explosion");
				for(i = 0; i < FIREBALL_MAX_BURST; ++i)
				{
					burst[i].used = 1;
					burst[i].pos.x = fireball.pos.x + random(-15, 20);
					burst[i].pos.y = fireball.pos.y + random(-15, 20);
					burst[i].pos.z = fireball.pos.z + random(-15, 20);
					burst[i].scale = .75f + (float)random(0, 5) * .15f;
					burst[i].rotation = 0;
					burst[i].glow = 1.0f + (.05f * (float)random(0, 15));
					burst[i].frame = (float)random(0, frame_count - 1);
					if(burst[i].frame == glow_frame)
						++burst[i].frame;
				}
				// ring setting code
				SShockParam param;
				// position
				param.pos.x = fireball.pos.x + (float)effect_pos.x;
				param.pos.y = fireball.pos.y + (float)effect_pos.y;
				param.pos.z = fireball.pos.z + (float)effect_pos.z;
				// rotation
				param.rot.x = 0.0f;
				param.rot.y = 0.0f;
				param.rot.z = 0.0f;
				// scale
				param.scale.x = 25.0f;
				param.scale.y = 25.0f;
				param.scale.z = 25.0f;
				// scale factor
				param.scale_factor.x = 1.085f;
				param.scale_factor.y = 1.085f;
				param.scale_factor.z = 1.085f;
				// flags
				param.flags = SHOCKWAVE_FLAG_FADE;
				// setting limits
				param.max_size.x = 120.0f;
				param.max_size.y = 120.0f;
				param.max_size.z = 120.0f;

				ring.Set(&param);

				// color
				ring.SetRingColor(0, D3DRGBA(.62f, .06f, .05f, 0.0f));
				ring.SetRingColor(1, D3DRGBA(.78f, .24f, .06f, 1.0f));
				ring.SetRingColor(2, D3DRGBA(.97f, .61f, .06f, .75f));
				ring.SetRingColor(3, D3DRGBA(.99f, .83f, .52f, 0.0f));
			}
			else
			{
				ring.Animate();
				for(i = 0; i < FIREBALL_MAX_BURST; ++i)
				{
					if(!burst[i].used)
						continue;
					++count;
					burst[i].scale *= .90f;
					if(burst[i].scale < .50f)
						burst[i].used = 0;						
					burst[i].glow = 1.0f + (.05f * (float)random(0, 15));
					++burst[i].frame;
					if(burst[i].frame == glow_frame)
						++burst[i].frame;
					burst[i].frame = (float)((int)burst[i].frame % frame_count);
				}
			}
			// rewrite this section for an explosion
			if(!IsTrail() && !spark.GetCount() && !count && ring.IsDone())
			{
				inst->SetCommandDone(TRUE);
			}
			break;
	}
	old_state = state;
}

void TFireBallAnimator::SetAnimFrame(int frame_num, PS3DAnimObj obj)
{
	float u = (float)(frame_num % 4) * .25f;
	float v = (float)(frame_num / 4) * .25f;

	obj->flags |= OBJ3D_VERTS;

	obj->lverts[0].tu = u;
	obj->lverts[0].tv = v;
	obj->lverts[2].tu = u + .25f;
	obj->lverts[2].tv = v;


	obj->lverts[1].tu = u;
	obj->lverts[1].tv = v + .25f;

	obj->lverts[3].tu = u + .25f;
	obj->lverts[3].tv = v + .25f;
}

int TFireBallAnimator::IsTrail()
{
	if(trail[FIREBALL_TRAIL_SIZE - 1].pos.x != trail[0].pos.x)
		return 1;
	if(trail[FIREBALL_TRAIL_SIZE - 1].pos.y != trail[0].pos.y)
		return 1;
	if(trail[FIREBALL_TRAIL_SIZE - 1].pos.z != trail[0].pos.z)
		return 1;

	return 0;
}

void TFireBallAnimator::RenderFireBallBurst()
{
	PS3DAnimObj obj;

	// grab the object
	obj = GetObject( 0);

	for(int i = 0; i < FIREBALL_MAX_BURST; ++i)
	{
		if(!burst[i].used)
			continue;		

		// *** GLOW ***
		ResetExtents();

		// texture rearranging here
		obj->flags = OBJ3D_ROT1 | OBJ3D_SCL2 | OBJ3D_POS3;

		SetAnimFrame(glow_frame, obj);

		// rotate the to face user
		obj->rot.z = (float)(-M_PI / 3.0f);
		obj->rot.x = (float)(-M_PI / 4.0f);
		obj->rot.y = 0;

		// scale the thing
		obj->scl.x = obj->scl.y = obj->scl.z = (burst[i].scale * burst[i].glow);

		// position the thing
		obj->pos.x = burst[i].pos.x;
		obj->pos.y = burst[i].pos.y;
		obj->pos.z = burst[i].pos.z;

		RenderObject( obj);

		UpdateExtents();
		// *** END GLOW ***

		// *** FIREBALL ***
		// reset the extents DUH!
		ResetExtents();

		obj->flags = OBJ3D_MATRIX;

#ifndef FIREBALL_WHITE_FADE
		SetAnimFrame((int)burst[i].frame, obj);
#else
		SetAnimFrame(0, obj);
#endif

		// clear the matrix
		D3DMATRIXClear( &obj->matrix);
	
		D3DMATRIXRotateZ( &obj->matrix, D3DVAL( -burst[i].rotation * TORADIAN));
		D3DMATRIXRotateX( &obj->matrix, D3DVAL( -30 * TORADIAN));
		D3DMATRIXRotateY( &obj->matrix, D3DVAL( 60 * TORADIAN));

		// Offset for our base rotation
		D3DMATRIXRotateZ( &obj->matrix, D3DVAL( -((inst->GetFace() * 360) / 256) * TORADIAN));

		// scale the thing
		obj->scl.x = obj->scl.y = obj->scl.z = burst[i].scale;
		D3DMATRIXScale( &obj->matrix, &obj->scl);

		// position the thing
		obj->pos.x = burst[i].pos.x;
		obj->pos.y = burst[i].pos.y;
		obj->pos.z = burst[i].pos.z;
		D3DMATRIXTranslate( &obj->matrix, &obj->pos);

		RenderObject( obj);

		// update the extents DUH!
		UpdateExtents();
		// *** END FIREBALL ***
	}
}

void TFireBallAnimator::RenderFireBallTrail()
{
	S3DPoint effect_pos;
	((PTEffect)inst)->GetPos(effect_pos);

	PS3DAnimObj obj;

	// grab the object
	obj = GetObject( 0);

	int start =	FIREBALL_TRAIL_SIZE;
	for(int i = FIREBALL_TRAIL_SIZE - 1; i >= 1; --i)
	{
		if(trail[i].pos.x == trail[0].pos.x && trail[i].pos.y == trail[0].pos.y && trail[i].pos.z == trail[0].pos.z)
			break;
		start = i;
	}

	for(i = FIREBALL_TRAIL_SIZE - 1; i >= start; --i)
	{
#ifdef FIREBALL_SPACEOUT
		if(!(i % 2))
			continue;
#endif
		ResetExtents();

		// texture rearranging here
		obj->flags = OBJ3D_MATRIX;
		D3DMATRIXClear(&obj->matrix);

		SetAnimFrame(glow_frame, obj);

		// rotate the to face user
		D3DMATRIXRotateX( &obj->matrix, D3DVAL( -30 * TORADIAN));
		D3DMATRIXRotateY( &obj->matrix, D3DVAL( 60 * TORADIAN));
		D3DMATRIXRotateZ( &obj->matrix, D3DVAL( -((inst->GetFace() * 360) / 256) * TORADIAN));

		// scale the thing
		obj->scl.x = obj->scl.y = obj->scl.z = (trail[i].scale * trail[i].glow);
		D3DMATRIXScale(&obj->matrix, &obj->scl);

		// position the thing
		obj->pos.x = trail[i].pos.x - effect_pos.x;
		obj->pos.y = trail[i].pos.y - effect_pos.y;
		obj->pos.z = trail[i].pos.z - effect_pos.z;

		D3DMATRIXTranslate(&obj->matrix, &obj->pos);

		RenderObject( obj);

		UpdateExtents();
	}
	for(i = FIREBALL_TRAIL_SIZE - 1; i >= start; --i)
	{
#ifdef FIREBALL_SPACEOUT
		if(!(i % 2))
			continue;
#endif
		// reset the extents
		ResetExtents();

		obj->flags = OBJ3D_MATRIX;

#ifndef FIREBALL_WHITE_FADE
		SetAnimFrame((int)trail[i].frame, obj);
#else
		int n = i + 1;
		if(n >= glow_frame)
			++n;
		if(n > frame_count)
			n = frame_count - 1;
		SetAnimFrame(n, obj);
#endif

		// clear the matrix
		D3DMATRIXClear( &obj->matrix);
	
		D3DMATRIXRotateZ( &obj->matrix, D3DVAL( -trail[i].rotation * TORADIAN));
		D3DMATRIXRotateX( &obj->matrix, D3DVAL( -30 * TORADIAN));
		D3DMATRIXRotateY( &obj->matrix, D3DVAL( 60 * TORADIAN));

		// Offset for our base rotation
		D3DMATRIXRotateZ( &obj->matrix, D3DVAL( -((inst->GetFace() * 360) / 256) * TORADIAN));


		// scale the thing
		obj->scl.x = obj->scl.y = obj->scl.z = trail[i].scale;
		D3DMATRIXScale( &obj->matrix, &obj->scl);

		// position the thing
		obj->pos.x = trail[i].pos.x - effect_pos.x;
		obj->pos.y = trail[i].pos.y - effect_pos.y;
		obj->pos.z = trail[i].pos.z - effect_pos.z;

		D3DMATRIXTranslate( &obj->matrix, &obj->pos);
		
		// render the object
		RenderObject( obj);

		// update the extents
		UpdateExtents();
	}
}

void TFireBallAnimator::RenderFireBall()
{
	PS3DAnimObj obj;

	// grab the object
	obj = GetObject( 0);

// *** FIREBALL ***
	// reset the extents DUH!
	ResetExtents();

	obj->flags = OBJ3D_MATRIX;

#ifndef FIREBALL_WHITE_FADE
	SetAnimFrame((int)fireball.frame, obj);
#else
	SetAnimFrame(0, obj);
#endif

	// clear the matrix
	D3DMATRIXClear( &obj->matrix);
	
	D3DMATRIXRotateZ( &obj->matrix, D3DVAL( -fireball.rotation * TORADIAN));
	D3DMATRIXRotateX( &obj->matrix, D3DVAL( -30 * TORADIAN));
	D3DMATRIXRotateY( &obj->matrix, D3DVAL( 60 * TORADIAN));

	// Offset for our base rotation
	D3DMATRIXRotateZ( &obj->matrix, D3DVAL( -((inst->GetFace() * 360) / 256) * TORADIAN));


	// scale the thing
	obj->scl.x = obj->scl.y = obj->scl.z = fireball.scale;
	D3DMATRIXScale( &obj->matrix, &obj->scl);

	// position the thing
	obj->pos.x = fireball.pos.x;
	obj->pos.y = fireball.pos.y;
	obj->pos.z = fireball.pos.z;
	D3DMATRIXTranslate( &obj->matrix, &obj->pos);

	RenderObject( obj);

	// update the extents DUH!
	UpdateExtents();
// *** END FIREBALL ***
}

void TFireBallAnimator::RenderFireBallGlow()
{
	PS3DAnimObj obj;

	// grab the object
	obj = GetObject( 0);
// *** GLOW ***
	ResetExtents();

	// texture rearranging here
	obj->flags = OBJ3D_MATRIX;

	SetAnimFrame(glow_frame, obj);

	// clear the matrix
	D3DMATRIXClear( &obj->matrix);
	
	D3DMATRIXRotateX( &obj->matrix, D3DVAL( -30 * TORADIAN));
	D3DMATRIXRotateY( &obj->matrix, D3DVAL( 60 * TORADIAN));
	D3DMATRIXRotateZ( &obj->matrix, D3DVAL( -((inst->GetFace() * 360) / 256) * TORADIAN));

	// scale the thing
	obj->scl.x = obj->scl.y = obj->scl.z = (fireball.scale * fireball.glow);
	D3DMATRIXScale(&obj->matrix, &obj->scl);

	// position the thing
	obj->pos.x = fireball.pos.x;
	obj->pos.y = fireball.pos.y;
	obj->pos.z = fireball.pos.z;
	D3DMATRIXTranslate(&obj->matrix, &obj->pos);

	RenderObject( obj);

	UpdateExtents();

// *** END GLOW ***
}

BOOL TFireBallAnimator::Render()
{
	SaveBlendState();
	SetBlendState();

	spark.Render();

	switch(state) 
	{
		case MISSILE_LAUNCH:
		case MISSILE_FLY:
			RenderFireBallGlow();
			RenderFireBallTrail();
			RenderFireBall();
			break;
		case MISSILE_EXPLODE:			
			RenderFireBallTrail();
			RenderFireBallBurst();
			ring.Render();
			break;
	}

	RestoreBlendState();

	return TRUE;
}

void TFireBallAnimator::RefreshZBuffer()
{
	S3DPoint effect_pos, pos, map_pos, screen_pos;

	((PTEffect)inst)->GetPos(effect_pos);

	int rect_u, rect_v;
	int i;

	spark.RefreshZBuffer(FIREBALL_SPARK_TEXTURE_U, FIREBALL_SPARK_TEXTURE_V);

	for(i = 0; i < FIREBALL_MAX_BURST; ++i)
	{
		if(!burst[i].used)
			continue;
		rect_u = (int)(FIREBALL_TEXTURE_U * burst[i].scale * burst[i].glow);
		rect_v = (int)(FIREBALL_TEXTURE_V * burst[i].scale * burst[i].glow);

		pos.x = (int)(burst[i].pos.x + effect_pos.x);
		pos.y = (int)(burst[i].pos.y + effect_pos.y);
		pos.z = (int)(burst[i].pos.z + effect_pos.z);

		WorldToScreen(pos, screen_pos);

		RestoreZ((int)screen_pos.x - (rect_u / 2), (int)screen_pos.y - (rect_v / 2), rect_u, rect_v);
	}

	switch(state) 
	{
		case MISSILE_LAUNCH:
		case MISSILE_FLY:
		case MISSILE_EXPLODE:
			ring.RefreshZBuffer(6, 3);
			rect_u = (int)(FIREBALL_TEXTURE_U * fireball.scale * fireball.glow);
			rect_v = (int)(FIREBALL_TEXTURE_V * fireball.scale * fireball.glow);

			pos.x = (int)(fireball.pos.x + effect_pos.x);
			pos.y = (int)(fireball.pos.y + effect_pos.y);
			pos.z = (int)(fireball.pos.z + effect_pos.z);

			WorldToScreen(pos, screen_pos);

			RestoreZ((int)screen_pos.x - (rect_u / 2), (int)screen_pos.y - (rect_v / 2), rect_u, rect_v);

			for(i = 0; i < FIREBALL_TRAIL_SIZE; ++i)
			{
#ifdef FIREBALL_SPACEOUT
				if(!(i % 2))
					continue;
#endif
				rect_u = (int)(FIREBALL_TEXTURE_U * trail[i].scale);
				rect_v = (int)(FIREBALL_TEXTURE_V * trail[i].scale);

				pos.x = (int)(trail[i].pos.x);
				pos.y = (int)(trail[i].pos.y);
				pos.z = (int)(trail[i].pos.z);

				WorldToScreen(pos, screen_pos);

				RestoreZ((int)screen_pos.x - (rect_u / 2), (int)screen_pos.y - (rect_v / 2), rect_u, rect_v);
			}
			break;
	}
}

// *********************
// * TFireColumnEffect *
// *********************

DEFINE_BUILDER("FIRECOLUMN", TFireColumnEffect)
REGISTER_BUILDER(TFireColumnEffect)

void TFireColumnEffect::Initialize()
{
    TMissileEffect::Initialize();

    SetSpeed( FIRECOLUMN_SPEED);

//    SoundPlayer.Mount(LIGHTNING_SOUND);

    firsttime = TRUE;
}

void TFireColumnEffect::Pulse()
{
    TMissileEffect::Pulse();

	switch(state)
	{
		case MISSILE_LAUNCH:
		{
			if (firsttime)
			{
				firsttime = FALSE;
//				SoundPlayer.Play(LIGHTNING_SOUND);
			}
			break;
		}
		case MISSILE_FLY:
		{
			if (commanddone)
				range = 0;
			break;
		}
	}
}

REGISTER_3DANIMATOR("FireColumn", TFireColumnAnimator)

//==============================================================================
//    Function : Initialize.
//------------------------------------------------------------------------------
// Description : This will setup the initial state for a fireball animator. The
//               fireball effect starts with a launch sequence which is made up
//               of a sparkle effect around the player.  The initial positions
//               of each of the sparks are set here.
//==============================================================================

void TFireColumnAnimator::Initialize()
{
    S3DTex tex;
	int	n;

	T3DAnimator::Initialize();

    // Get how many frames are in the texture
    Get3DImagery()->GetTexture(0, &tex);
    numtexframes = tex.numframes;

    // Set the beginning state of the effect
    state = oldstate = MISSILE_LAUNCH;

	ConvertToVector( inst->GetFace(), 10, vctr);
	p[0].x = p[0].y = 0;
	OffsetPoint( 0);
	for (n = 0; n < NUM_FIRE_COLUMNS; n++)
	{
		framenum[n] = (0 - (n / 3));
//		if (n < (NUM_FIRE_COLUMNS - 2))
//		{
			p[n].x = D3DVAL( vctr.x * (n + 3));
			p[n].y = D3DVAL( vctr.y * (n + 3));
//		}
//		else
//		{
//			p[n].x = D3DVAL( vctr.x * (n + 4));
//			p[n].y = D3DVAL( vctr.y * (n + 4));
//		}
		rotation[n] = D3DVAL( random( 0, 360) * TORADIAN);
	    scale[n] = 100;
	}
    activesparks = 0;
}

void TFireColumnAnimator::OffsetPoint( int pnt) {
	p[pnt].x += D3DVAL( vctr.x);
	p[pnt].y += D3DVAL( vctr.y);
}

//==============================================================================
//    Function : Animate.
//------------------------------------------------------------------------------
// Description : This updates the frame number, position, and scale values
//               for the three different states of the firecolumn effect.
//==============================================================================

void TFireColumnAnimator::Animate(BOOL draw)
{
    int n;

	T3DAnimator::Animate(draw);
	inst->SetCommandDone(FALSE);

    switch (state)
    {
        case MISSILE_LAUNCH:
        {
			// No fancy launch, yet
			inst->SetCommandDone(TRUE);
            break;
        }

        case MISSILE_FLY:
        {
			for (n = 0; n < NUM_FIRE_COLUMNS; n++)
			{
				framenum[n]++;

				if (framenum[n] >= numtexframes)	// Add flames sequentially
				{
					if (n == (NUM_FIRE_COLUMNS - 1))
					{
						activesparks++;	// Loop counter
					    if (activesparks == 5)
						{
							activesparks = NUM_FIRE_COLUMNS;	// Used for finale
							inst->SetCommandDone(TRUE);
						}
					}
					framenum[n] = random( 0, 5); // -32768
				}
			}
            break;
        }

        case MISSILE_EXPLODE:
        {
			for (n = 0; n < NUM_FIRE_COLUMNS; n++)
			{
				// Remove trail sequentially, but keep explosion going
				if (activesparks > 2)
				{
					if (n <= (NUM_FIRE_COLUMNS - activesparks))	// Start to Finish
					{
						if (scale[n] <= 10)	// If too small to see, kill it
						{
							if (framenum[n] >= 0)	// Only need to do this once
							{
								activesparks--;
								framenum[n] = -1;
							}
						} else
						    scale[n] -= 33;
					}
				}
				else
				    scale[n] -= 8;

				if (framenum[n] >= 0)	// Animate if still visible
				{
					framenum[n]++;
					if (framenum[n] >= numtexframes)
						framenum[n] = random( 0, 5); // -32768
				}

				// We're done when the big boy is 10% of its size
				if (scale[(NUM_FIRE_COLUMNS - 1)] < 10)
					inst->SetCommandDone(TRUE);
			}
            break;
        }
    }

    // Keep track of the state we're in
    oldstate = state;
}

//==============================================================================
//    Function : Render.
//------------------------------------------------------------------------------
// Description : This loops through all the fire columns and renders each
//               at the appropriate location and scale value.
//==============================================================================

BOOL TFireColumnAnimator::Render()
{
	DWORD savedcull;
	PS3DAnimObj obj;

	SaveBlendState();
	SetBlendState();

	// So I can render any face
	TRY_D3D(Device2->GetRenderState( D3DRENDERSTATE_CULLMODE, &savedcull));
	TRY_D3D(Device2->SetRenderState( D3DRENDERSTATE_CULLMODE, D3DCULL_NONE));

	obj = GetObject(0);	// Column

    for (int n = 0; n < (NUM_FIRE_COLUMNS - 2); n++)
    {
        // Only render the spark if it's framenum is positive
        if (framenum[n] >= 0)
        {
            // Reset render extents
            Get3DImagery()->ResetExtents();

            // Set the scale and position of the object
			obj->flags = OBJ3D_MATRIX | OBJ3D_ABSPOS;
			if (n == (NUM_FIRE_COLUMNS - 3))
			{
	            obj->scl.x = D3DVAL( 2 * scale[n] / 100);
				obj->scl.y = D3DVAL( 3 * scale[n] / 100);
				obj->scl.z = D3DVAL( 4 * scale[n] / 100);
			}
			else
			{
	            obj->scl.x = D3DVAL( 1 * scale[n] / 100);
				obj->scl.y = D3DVAL( 2 * scale[n] / 100);
				obj->scl.z = D3DVAL( 3 * scale[n] / 100);
			}
			obj->pos.x = pos.x + p[n].x;
			obj->pos.y = pos.y + p[n].y;
			obj->pos.z = pos.z + 5;

			D3DMATRIXClear(&obj->matrix);

            D3DMATRIXScale(&obj->matrix, &obj->scl);
            D3DMATRIXRotateZ(&obj->matrix, rotation[n]);
			D3DMATRIXTranslate(&obj->matrix, &obj->pos);

            // Set the frame number manually
			frame = framenum[n] % numtexframes;

            RenderObject(obj);

            // Update bounding rect and screen rect
            UpdateExtents();
        }
    }

	obj = GetObject(1);	// Explosion

    for (; n < NUM_FIRE_COLUMNS; n++)
	{
		// Only render the spark if it's framenum is positive
		if (framenum[n] >= 0)
		{
			// Reset render extents
			Get3DImagery()->ResetExtents();

			// Set the scale and position of the object
			obj->flags = OBJ3D_MATRIX | OBJ3D_ABSPOS;
			if (n == (NUM_FIRE_COLUMNS - 2))
			{
				obj->scl.x = D3DVAL( 2.5 * ((scale[n] / 2) + 50) / 100);
				obj->scl.y = D3DVAL( 2.5 * ((scale[n] / 2) + 50) / 100);
				obj->scl.z = D3DVAL( 3.5 * scale[n] / 100);
			}
			else
			{
				obj->scl.x = D3DVAL( 3 * ((scale[n] / 2) + 50) / 100);
				obj->scl.y = D3DVAL( 3 * ((scale[n] / 2) + 50) / 100);
				obj->scl.z = D3DVAL( 4 * scale[n] / 100);
			}
			obj->pos.x = pos.x + p[n].x;
			obj->pos.y = pos.y + p[n].y;
			obj->pos.z = pos.z + 5;

			D3DMATRIXClear(&obj->matrix);

			D3DMATRIXScale(&obj->matrix, &obj->scl);
			D3DMATRIXRotateZ(&obj->matrix, rotation[n]);
			D3DMATRIXTranslate(&obj->matrix, &obj->pos);

			// Set the frame number manually
			frame = framenum[n] % numtexframes;

			RenderObject(obj);

			// Update bounding rect and screen rect
			UpdateExtents();
		}
	}

	TRY_D3D(Device2->SetRenderState(D3DRENDERSTATE_CULLMODE, savedcull));

	RestoreBlendState();

	return TRUE;
}

// ********************
// * TFlameDiscEffect *
// ********************

DEFINE_BUILDER("FLAMEDISC", TFlameDiscEffect)
REGISTER_BUILDER(TFlameDiscEffect)

void TFlameDiscEffect::Initialize()
{
	// Initialize the values for the central flare
	pos.x += (random(-FLAMEDISC_LAUNCH_RADIUS, FLAMEDISC_LAUNCH_RADIUS));
	pos.y += (random(-FLAMEDISC_LAUNCH_RADIUS, FLAMEDISC_LAUNCH_RADIUS));
	pos.z += (random(-FLAMEDISC_LAUNCH_RADIUS, FLAMEDISC_LAUNCH_RADIUS));

    TMissileEffect::Initialize();

    SetSpeed(FLAMEDISC_SPEED);

    SoundPlayer.Mount(LIGHTNING_SOUND);

    firsttime = TRUE;
}

void TFlameDiscEffect::Pulse()
{
    TMissileEffect::Pulse();

    if ((state == MISSILE_FLY) && (firsttime))
    {
        firsttime = FALSE;
		SoundPlayer.Play(LIGHTNING_SOUND);
    }
}

// **********************
// * FlameDisc Animator *
// **********************

REGISTER_3DANIMATOR("FLAMEDISC", TFlameDiscAnimator)

//==============================================================================
//    Function : Initialize.
//------------------------------------------------------------------------------
// Description : This will setup the initial state for a flame disc animator. The
//               flame disc effect starts with a launch sequence which is made up
//				 of a scaling, rotating disc
//==============================================================================

void TFlameDiscAnimator::Initialize()
{
    S3DTex tex;
	S3DPoint pnt;
	int	n;

	T3DAnimator::Initialize();

    // Get how many frames are in the texture
    Get3DImagery()->GetTexture(0, &tex);
    numtexframes = tex.numframes;
    activesparks = 0;

    // Set the beginning state of the effect
    state = oldstate = MISSILE_LAUNCH;

	angle = ((TMissileEffect*)inst)->GetAngle();
	for (n = 0; n <= NUM_FLAME_SPARKS; n++)
	{
	    scale[n] = 0.0;
		framenum[n] = -random(2,8);
	    p[n].x = p[n].y = p[n].z = 0;

//        v[n].x = D3DVAL(2-random(0,4));
//        v[n].y = D3DVAL(random(1,4));
//        v[n].z = D3DVAL(-random(0,2));
		ConvertToVector(((angle + 128 + random(-32,32)) % 256), ((TMissileEffect*)inst)->GetSpeed(), pnt);
        v[n].x = D3DVAL(pnt.x);
        v[n].y = D3DVAL(pnt.y);
        v[n].z = D3DVAL(0);
	}
}

//==============================================================================
//    Function : Animate.
//------------------------------------------------------------------------------
// Description : This updates the frame number, position, and scale values
//               for the three different states of the photon effect.
//==============================================================================

#define FLAMEDISC_MAX_SCALE_STEP 3.0 // 5.0
#define FLAMEDISC_SCALE_STEP .2

void TFlameDiscAnimator::Animate(BOOL draw)
{
	S3DPoint pnt;
	int	n;

	T3DAnimator::Animate(draw);
	inst->SetCommandDone(FALSE);

    switch(state)
    {
        case MISSILE_LAUNCH :
        {
            // Adjust the framenum & scale for the central flare
            if (scale[0] < (D3DVALUE)FLAMEDISC_MAX_SCALE_STEP)
			{
	            framenum[0]++;
				if (framenum[0] >= 0)
	                scale[0] += (float)FLAMEDISC_SCALE_STEP;
			}
			else
				inst->SetCommandDone(TRUE);
            break;
        }

        case MISSILE_FLY :
        {
            // Adjust the framenum & scale for the central flare
			for (n = 1; n <= NUM_FLAME_SPARKS; n++)
			{
	            framenum[n]++;
				if (framenum[n] >= 0)
				{
					if (framenum[n] == 0)
					{
						scale[n] = 3.0;
					    activesparks++;
					}
					else
					{
						scale[n] -= (float)FLAMEDISC_SCALE_STEP;
						if (scale[n] <= 0)
						{
							activesparks--;
							framenum[n] = -random(2,8);
							p[n].x = p[n].y = p[n].z = 0;
//							v[n].x = D3DVAL(2-random(0,4));
//							v[n].y = D3DVAL(random(1,4));
//							v[n].z = D3DVAL(-random(0,2));
							ConvertToVector(((angle + 128 + random(-32,32)) % 256), ((TMissileEffect*)inst)->GetSpeed(), pnt);
							v[n].x = D3DVAL(pnt.x);
							v[n].y = D3DVAL(pnt.y);
							v[n].z = D3DVAL(0);
						}
						else
						{
							p[n].x += v[n].x;
							p[n].y += v[n].y;
							p[n].z += v[n].z;
						}
					}
				}
			}
			break;
        }

        case MISSILE_EXPLODE :
        {
		    if (activesparks == 0)
				inst->SetCommandDone(TRUE);

            // Adjust the framenum & scale for the central flare
			for (n = 1; n <= NUM_FLAME_SPARKS; n++)
			{
	            framenum[n]++;
				if (framenum[n] >= 0)
				{
					if (framenum[n] == 0)
					{
					    activesparks++;
						scale[n] = 3.0;
					}
					else
					{
						scale[n] -= (float)FLAMEDISC_SCALE_STEP;
						if (scale[n] <= 0)
						{
							activesparks--;
							framenum[n] = -32767;
						}
						else
						{
							p[n].x += v[n].x;
							p[n].y += v[n].y;
							p[n].z += v[n].z;
						}
					}
				}
			}
			break;
        }
    }

    // Keep track of the state we're in
    oldstate = state;
}

//==============================================================================
//    Function : Render.
//------------------------------------------------------------------------------
// Description : This loops through all the photon sparks and renders each
//               at the appropriate location and scale value.
//==============================================================================

BOOL TFlameDiscAnimator::Render()
{
	PS3DAnimObj obj;
	int	n;

    SaveBlendState();
    SetBlendState();

	// Only render the spark if it's framenum is positive
	for (n = 0; n <= NUM_FLAME_SPARKS; n++)
	{
		if (framenum[n] >= 0)
		{
			if (n)
			    obj = GetObject(0); // 0 is Spark, 1 is FlameDisc
			else
			    obj = GetObject(1); // 0 is Spark, 1 is FlameDisc
			
			// Reset render extents
		    Get3DImagery()->ResetExtents();

			// Set the scale and position of the object
			obj->scl.x = obj->scl.y = obj->scl.z = (D3DVALUE)scale[0];
			obj->rot.x = D3DVAL(-(M_PI / 2.0));
			obj->rot.y = D3DVAL(0.0);
			obj->rot.z = D3DVAL(0.0);
			if (n)
			{
				obj->flags |= OBJ3D_ROT1 | OBJ3D_SCL2 | OBJ3D_POS3;
				obj->pos = p[n];
			}
			else
				obj->flags |= OBJ3D_ROT1 | OBJ3D_SCL2;;

	        // Set the frame number manually
		    frame = framenum[n] % numtexframes;

	        RenderObject(obj);

		    // Update bounding rect and screen rect
			UpdateExtents();
		}
    }

    RestoreBlendState();

	return TRUE;
}// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                      money.cpp - TMoney module                        *
// *************************************************************************

#include "revenant.h"
#include "bitmap.h"
#include "imagery.h"
#include "money.h"
#include "mappane.h"
#include "inventory.h"

REGISTER_BUILDER(TMoney)
TObjectClass MoneyClass("MONEY", OBJCLASS_MONEY, 0);

// Hard coded class stats
DEFSTAT(Money, Value,		VAL, 0, 1, 1, 10000)

// Hard coded object stats
DEFOBJSTAT(Money, Amount,	AMT, 0, 1, 1, 10000)


// These were originally static members of TMoney but the compiler wasn't
// very hip on that, so they are now here.
PTBitmap invitem[MAXMONEYTYPES][MAXMONEYIMAGE];	// Bitmaps built on the fly
int invusecount[MAXMONEYTYPES][MAXMONEYIMAGE];		// Use count for each image

PTBitmap grounditem[MAXMONEYTYPES][MAXMONEYIMAGE];	// Ground images
int groundusecount[MAXMONEYTYPES][MAXMONEYIMAGE];	// Use count for ground

struct { int x, y; } MoneyPos[MAXMONEYIMAGE] =
{ { 20, 28 }, { 13, 22 }, { 22, 18 }, { 22, 31 }, { 13, 35 }, { 0, 27 }, { 9, 25 },
  { 32, 27 }, { 5, 32 }, { 29, 30 }, { 12, 29 }, { 25, 24 }, { 6, 17 }, { 30, 34 }, { 19, 33 },
  // stacks
  { 19, 19 }, { 8, 21 }, { 15, 24 }, { 20, 17 }, { 9, 19 }, { 30, 23 }, { 20, 15 }, { 8, 17 }, 
  { 8, 15 }, { 16, 22 }, { 15, 20 }, { 19, 13 }, { 31, 21 }, { 31, 19 }, { 4, 25 }, { 21, 28 }, 
  { 19, 11 }, { 8, 13 }, { 9, 11 }, { 15, 18 }, { 14, 16 }, { 14, 14 }, { 30, 17 }, { 19, 9 },
  { 20, 7 }, { 5, 23 }, { 11, 28 }, { 30, 15 }, { 31, 13 }, { 22, 26 }, { 8, 9 }, { 5, 21 }, 
  { 29, 11 }, { 19, 5 }, { 18, 3 }, { 9, 7 }, { 19, 1 }, { 15, 12 }, { 29, 9 }, { 4, 19 },
  { 4, 17 }, { 21, 24 }, { 22, 22 }, { 10, 26 }, { 15, 10 }, { 30, 7 }, { 5, 15 }, { 22, 20 },
  { 10, 24 }
};

BOOL TMoney::Initialize()
{
	for (int t = 0; t < MAXMONEYTYPES; t++)
		for (int i = 0; i < MAXMONEYIMAGE; i++)
		{
			invitem[t][i] = grounditem[t][i] = NULL;
			invusecount[t][i] = groundusecount[t][i] = 0;
		}

	return TRUE;
}

void TMoney::Close()
{
	for (int t = 0; t < MAXMONEYTYPES; t++)
		for (int i = 0; i < MAXMONEYIMAGE; i++)
		{
			if (invusecount[t][i])
			{
				invusecount[t][i] = 1;
				FreeInvItem(t, i);
			}

			if (groundusecount[t][i])
			{
				groundusecount[t][i] = 1;
				FreeGroundItem(t, i);
			}
		}
}

TMoney::~TMoney()
{
	int count = max(1, min(Amount(), MAXMONEYIMAGE-1));

	if (invusecount[objtype][count] && GetOwner() == Inventory.GetContainer())
		FreeInvItem(objtype, count);

	if (groundusecount[objtype][count])
		FreeGroundItem(objtype, count);
}

void TMoney::SignalAddedToInventory()
{
	TObjectInstance::SignalAddedToInventory();

	if (GetOwner() == Inventory.GetContainer() && imagery)
		AllocInvItem(imagery->GetInvImage(GetState()), objtype, Amount());
}

void TMoney::RemoveFromInventory()
{
	TObjectInstance::RemoveFromInventory();

	if (GetOwner() == Inventory.GetContainer())
		FreeInvItem(objtype, Amount());
}

void TMoney::SetAmount(int amt)
{
	if (Amount() == amt || amt < 1)
		return;

	if (GetOwner() == Inventory.GetContainer())
	{
		FreeInvItem(objtype, Amount());
		if (imagery)
			AllocInvItem(imagery->GetInvImage(GetState()), objtype, amt);
	}

	if (!GetOwner())
	{
		FreeGroundItem(objtype, Amount());
		if (imagery)
			AllocGroundItem(imagery->GetStillImage(GetState()), objtype, amt);
	}

	SetStat(se_Amount.id, amt);
}

BOOL TMoney::Use(PTObjectInstance user, int with)
{
	PTObjectInstance inst = MapPane.GetInstance(with);
	if (inst && inst->ObjClass() == ObjClass() && inst->ObjType() == ObjType() &&
		inst->Amount() < MAXMONEYIMAGE && Amount() < MAXMONEYIMAGE)
	{
		int amt = inst->Amount() + Amount();

		if (amt > MAXMONEYIMAGE)
		{
			// keep both, just adjust their values
			SetAmount(MAXMONEYIMAGE);
			inst->SetAmount(amt - MAXMONEYIMAGE);
		}
		else
		{
			// nuke one, and combine values into the second
			MapPane.RemoveObject(with);
			delete inst;

			SetAmount(amt);
		}

		return TRUE;
	}

	return FALSE;
}

int TMoney::CursorType(PTObjectInstance with)
{
	if (with && with->ObjClass() == ObjClass() && with->ObjType() == ObjType() &&
		with->Amount() < MAXMONEYIMAGE && Amount() < MAXMONEYIMAGE)
		return CURSOR_HAND;

	return CURSOR_NONE;
}

void TMoney::Load(RTInputStream is, int version, int objversion)
{
	TObjectInstance::Load(is, version, objversion);

	if (version < 5)
	{
		int amount;
		is >> amount;
		amount++;
		SetStat("Amount", amount);
	}
}

void TMoney::Save(RTOutputStream os)
{
	TObjectInstance::Save(os);
}

void TMoney::AllocInvItem(PTBitmap inv, int type, int count)
{
	if (!inv)
		return;

	count = max(1, min(count, MAXMONEYIMAGE-1));

	if (invusecount[type][count] < 1)
	{
		invitem[type][count] = TBitmap::NewBitmap(INVITEMREALWIDTH, INVITEMREALHEIGHT, BM_15BIT);

		memset(invitem[type][count]->data16, 0, INVITEMREALWIDTH*INVITEMREALHEIGHT*2);

		for (int i = 0; i < count; i++)
			invitem[type][count]->Put(MoneyPos[i].x, MoneyPos[i].y, inv, DM_TRANSPARENT);

		invusecount[type][count] = 1;
	}
	else
		invusecount[type][count]++;
}

void TMoney::FreeInvItem(int type, int count)
{
	count = max(1, min(count, MAXMONEYIMAGE-1));

	if (invusecount[type][count] == 0)
		return;

	if (--(invusecount[type][count]) < 1 && invitem[count])
	{
		delete invitem[type][count];
		invitem[type][count] = NULL;
	}
}

void TMoney::AllocGroundItem(PTBitmap ground, int type, int count)
{
	if (!ground)
		return;

	count = max(1, min(count, MAXMONEYIMAGE-1));

	if (groundusecount[type][count] < 1)
	{
		grounditem[type][count] = TBitmap::NewBitmap(INVITEMREALWIDTH/2, INVITEMREALHEIGHT/2, BM_8BIT | BM_PALETTE);

		memset(grounditem[type][count]->data16, 0, (INVITEMREALWIDTH/2)*(INVITEMREALHEIGHT/2));
		memcpy(grounditem[type][count]->palette.ptr(), ground->palette.ptr(), ground->palettesize);

		for (int i = 0; i < count; i++)
			grounditem[type][count]->Put(MoneyPos[i].x >> 1, MoneyPos[i].y >> 1, ground, DM_TRANSPARENT);

		groundusecount[type][count] = 1;
	}
	else
		groundusecount[type][count]++;
}

void TMoney::FreeGroundItem(int type, int count)
{
	count = max(1, min(count, MAXMONEYIMAGE-1));

	if (groundusecount[type][count] == 0)
		return;

	if (--(groundusecount[type][count]) < 1 && grounditem[count])
	{
		delete grounditem[type][count];
		grounditem[type][count] = NULL;
	}
}

void TMoney::DrawInvItem(int x, int y)
{
	int count = max(1, min(Amount(), MAXMONEYIMAGE-1));

	if (invusecount[objtype][count] < 1 && imagery)
		AllocInvItem(imagery->GetInvImage(GetState()), objtype, count);

	imagery->DrawInvItem(this, x, y);
}

PTBitmap TMoney::InventoryImage()
{
	return invitem[objtype][max(1, min(Amount(), MAXMONEYIMAGE-1))];
}

void TMoney::GetScreenRect(SRect &r)
{
	if (imagery)
	{
		PSImageryStateHeader st = imagery->GetState(GetState());

		int x, y;
		WorldToScreen(pos, x, y);

		r.left   = x - st->regx;
		r.right  = r.left + (INVITEMREALWIDTH / 2) - 1;
		r.top    = y - st->regy;
		r.bottom = r.top + (INVITEMREALHEIGHT / 2) - 1;
	}
}

void TMoney::DrawUnlit(PTSurface surface)
{
	int count = min(Amount(), MAXMONEYIMAGE-1);

	if (groundusecount[objtype][count] < 1 && imagery)
		AllocGroundItem(imagery->GetStillImage(GetState()), objtype, count);

	imagery->DrawUnlit(this, surface);
}

PTBitmap TMoney::GetStillImage(int ostate)
{
	return grounditem[objtype][min(Amount(), MAXMONEYIMAGE-1)];
}
// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *              mosaicsurf.cpp - 3D Surface Include File                 *
// *************************************************************************

#include <windows.h>

#include "revenant.h"
#include "mosaicsurf.h"
#include "directdraw.h"
#include "ddsurface.h"
#include "multisurface.h"
#include "bitmap.h"
#include "bmsurface.h"

TMosaicSurface::TMosaicSurface()
{
	tilex = tiley = numtilex = numtiley = 0;
	flags = 0;
	tiles = NULL;
}

TMosaicSurface::~TMosaicSurface()
{
	Close();
}

BOOL TMosaicSurface::Initialize(
	int ntilex, int ntiley, int nnumtilex, int nnumtiley, DWORD ncreateflags)
{
	tilex = ntilex;
	tiley = ntiley;
	numtilex = nnumtilex;
	numtiley = nnumtiley;
	createflags = ncreateflags;

	if (createflags & MOSAICSURF_CLONEGRAPHICS)
		createflags &= ~(MOSAICSURF_SYSTEMMEM | 
			MOSAICSURF_VIDEOMEM | MOSAICSURF_VIDEOMEMONLY | MOSAICSURF_BMSURFACE |
			MOSAICSURF_8BIT | MOSAICSURF_16BIT | MOSAICSURF_24BIT | MOSAICSURF_32BIT);

	if (createflags & MOSAICSURF_CLONEZBUFFER)
		createflags &= ~(MOSAICSURF_ZBUFFER | MOSAICSURF_ZSYSTEMMEM | MOSAICSURF_ZVIDEOMEM | MOSAICSURF_ZVIDEOMEMONLY);

	if (createflags & MOSAICSURF_CLONENORMALS)
		createflags &= ~(MOSAICSURF_NORMALS | MOSAICSURF_NSYSTEMMEM | MOSAICSURF_NVIDEOMEM | MOSAICSURF_NVIDEOMEMONLY);

	if (!(createflags & (MOSAICSURF_BMSURFACE | MOSAICSURF_CLONEGRAPHICS))
	   && !(createflags & (MOSAICSURF_SYSTEMMEM | MOSAICSURF_VIDEOMEM)))
		return FALSE;  // Must be one or other

	if ((createflags & MOSAICSURF_ZBUFFER) 
	   && !(createflags & (MOSAICSURF_ZSYSTEMMEM | MOSAICSURF_ZVIDEOMEM)))
		return FALSE;  // Must be one or other

	if ((createflags & MOSAICSURF_NORMALS) 
	   && !(createflags & (MOSAICSURF_NSYSTEMMEM | MOSAICSURF_NVIDEOMEM)))
		return FALSE;  // Must be one or other

	bitsperpixel = 16;
	if (createflags & MOSAICSURF_8BIT)
	{
		bitsperpixel = 8;
		createflags |= MOSAICSURF_BMSURFACE;
	}
	else if (createflags & MOSAICSURF_16BIT)
	{
		bitsperpixel = 16;
	}
	else if (createflags & MOSAICSURF_24BIT)
	{
		bitsperpixel = 24;
		createflags |= MOSAICSURF_BMSURFACE;
	}
	else if (createflags & MOSAICSURF_32BIT)
	{
		bitsperpixel = 32;
		createflags |= MOSAICSURF_BMSURFACE;
	}
	int bytesperpixel = bitsperpixel >> 3;

	int freevidmem = GetFreeVideoMem();

	if (createflags & MOSAICSURF_VIDEOMEM)
	{
		freevidmem -= tilex * tiley * numtilex * numtiley * bytesperpixel;

		if (freevidmem < TEXTURERESERVE)
		{
			if (createflags & MOSAICSURF_VIDEOMEMONLY)
				return FALSE;
			createflags &= ~MOSAICSURF_VIDEOMEM;
			createflags |= MOSAICSURF_SYSTEMMEM;
		}
	}

	if ((createflags & MOSAICSURF_ZBUFFER) && (createflags & MOSAICSURF_ZVIDEOMEM))
	{
		freevidmem -= tilex * tiley * numtilex * numtiley * 2;

		if (freevidmem < TEXTURERESERVE)
		{
			if (createflags & MOSAICSURF_ZVIDEOMEMONLY)
				return FALSE;
			createflags &= ~MOSAICSURF_ZVIDEOMEM;
			createflags |= MOSAICSURF_ZSYSTEMMEM;
		}
	}

	if ((createflags & MOSAICSURF_NORMALS) && (createflags & MOSAICSURF_NVIDEOMEM))
	{
		freevidmem -= tilex * tiley * numtilex * numtiley * 2;

		if (freevidmem < TEXTURERESERVE)
		{
			if (createflags & MOSAICSURF_NVIDEOMEMONLY)
				return FALSE;
			createflags &= ~MOSAICSURF_NVIDEOMEM;
			createflags |= MOSAICSURF_NSYSTEMMEM;
		}
	}
	
	int vflags;
	if (createflags & MOSAICSURF_VIDEOMEM)
		vflags = VSURF_VIDEOMEM;
	else
		vflags = VSURF_SYSTEMMEM;

	int zflags;
	if (createflags & MOSAICSURF_ZVIDEOMEM)
		zflags = VSURF_VIDEOMEM;
	else
		zflags = VSURF_SYSTEMMEM;

	int nflags;
	if (createflags & MOSAICSURF_NVIDEOMEM)
		nflags = VSURF_VIDEOMEM;
	else
		nflags = VSURF_SYSTEMMEM;

	int bmbits;
	if (createflags & MOSAICSURF_8BIT)
		bmbits = BM_8BIT;
	else if (createflags & MOSAICSURF_16BIT)
		bmbits = BM_16BIT;
	else if (createflags & MOSAICSURF_24BIT)
		bmbits = BM_24BIT;
	else if (createflags & MOSAICSURF_32BIT)
		bmbits = BM_32BIT;
	else
		bmbits = BM_16BIT;

	tiles = new PTSurface[numtilex * numtiley];

	PTSurface vsurf, zsurf, nsurf;
	TSurface **surf = tiles;

	int x, y, offx, offy;
	for (y = 0, offy = 0; y < numtiley; y++, offy += tiley)
	{
	  for (x = 0, offx = 0; x < numtilex; x++, surf++, offx += tiley)
	  {
		vsurf = zsurf = nsurf = NULL;

		if (!(createflags & MOSAICSURF_CLONEGRAPHICS))
		{
			if (createflags & MOSAICSURF_BMSURFACE)
				vsurf = new TBitmapSurface(tilex, tiley, bmbits);
			else
			{
				vsurf = new TDDSurface(tilex, tiley, vflags);
				if (vsurf->Stride() != tilex && NoWideBuffers)
				{
					delete vsurf;
					vflags = (vflags & (~(DWORD)VSURF_VIDEOMEM)) | VSURF_SYSTEMMEM;
					vsurf = new TDDSurface(tilex, tiley, vflags);
				}
			}
		}
		if (createflags & MOSAICSURF_ZBUFFER)
		{
			zsurf = new TDDSurface(tilex, tiley, zflags | VSURF_ZBUFFER); // Voodoo doesn't like this
			if (zsurf->Stride() != tilex && NoWideBuffers)
			{
				delete zsurf;
				zflags = (zflags & (~(DWORD)VSURF_VIDEOMEM)) | VSURF_SYSTEMMEM;
				zsurf = new TDDSurface(tilex, tiley, zflags | VSURF_ZBUFFER); // Voodoo doesn't like this
			}
		}
//		if (createflags & MOSAICSURF_NORMALS)
//			nsurf = new TDDSurface(tilex, tiley, nflags, stride);

		*surf = new TMultiSurface(vsurf, zsurf, nsurf, TRUE);
	  }
	}

	width        = tilex * numtilex;
	height       = tiley * numtiley;
	stride       = width;
	bitsperpixel = tiles[0]->BitsPerPixel();
	flags        = tiles[0]->flags;

	Reset();

	return TRUE;
}

// Initializes a cloned mosaic surface
// 
// A Cloned surface uses the same surface buffers as the original surface, but stores
// its own local origin and clipping rectangle.  This is very useful for... say.. 
// a surface used simultaneously by two different threads.

BOOL TMosaicSurface::Initialize(PTMosaicSurface clone, DWORD ncreateflags)
{
	Initialize(clone->tilex, clone->tiley, 
		clone->numtilex, clone->numtiley, ncreateflags | MOSAICSURF_ISCLONE);

	PTSurface vsurf, zsurf, nsurf;
	TMultiSurface **surf = (TMultiSurface **)tiles;

	int x, y, offx, offy;
	for (y = 0, offy = 0; y < numtiley; y++, offy += tiley)
	{
	  for (x = 0, offx = 0; x < numtilex; x++, surf++, offx += tiley)
	  {
	
		PTMultiSurface tile = clone->GetTile(x, y);
		vsurf = zsurf = nsurf = NULL;

		if ((createflags & MOSAICSURF_CLONEGRAPHICS) && tile->GetGraphicsBuffer())
		{
			if (clone->createflags & MOSAICSURF_BMSURFACE)
				vsurf = new TBitmapSurface(
					((PTBitmapSurface)tile->GetGraphicsBuffer())->GetBitmap());
			else
				vsurf = new TDDSurface(tile->GetGraphicsBuffer()->GetDDSurface());
			(*surf)->SetGraphicsBuffer(vsurf);
		}
		if ((createflags & MOSAICSURF_CLONEZBUFFER) && tile->GetZBuffer())
		{
			zsurf = new TDDSurface(tile->GetZBuffer()->GetDDSurface());
			(*surf)->SetZBuffer(zsurf);
		}
		if ((createflags & MOSAICSURF_CLONENORMALS) && tile->GetNormalBuffer())
		{
			nsurf = new TDDSurface(tile->GetNormalBuffer()->GetDDSurface());
			(*surf)->SetNormalBuffer(nsurf);
		}

	  }
	}

	width        = tilex * numtilex;
	height       = tiley * numtiley;
	stride       = width;
	bitsperpixel = tiles[0]->BitsPerPixel();
	flags        = tiles[0]->flags;

	Reset();

	return TRUE;
}

void TMosaicSurface::Close()
{
	if (tiles == NULL)
		return;

	TSurface **surf = tiles;
	for (int y = 0; y < numtiley; y++)
	{
	  for (int x = 0; x < numtilex; x++, surf++)
	  {
		delete (*surf);
	  }
	}

	delete tiles;
	tiles = NULL;
}

void TMosaicSurface::SetOrigin(int x, int y)
{
	TSurface::SetOrigin(x, y);

	TSurface **surf = tiles;
	int tx, ty, offx, offy;
	for (ty = 0, offy = 0; ty < numtiley; ty++, offy += tiley)
	{
	  for (tx = 0, offx = 0; tx < numtilex; tx++, surf++, offx += tilex)
	  {
		(*surf)->SetOrigin(x - offx, y - offy);
	  }
	}
}

void TMosaicSurface::SetClipRect(int x, int y, int w, int h)
{
	TSurface::SetClipRect(x, y, w, h);

	TSurface **surf = tiles;
	int tx, ty, offx, offy;
	for (ty = 0, offy = 0; ty < numtiley; ty++, offy += tiley)
	{
	  for (tx = 0, offx = 0; tx < numtilex; tx++, surf++, offx += tilex)
	  {
		(*surf)->SetClipRect(0, 0, width, height); // Use standard clip rect for subtiles
	  }
	}
}

// NOTE: Mosaic surfaces don't support CLIP_WRAP
void TMosaicSurface::SetClipMode(int mode)
{
	TSurface::SetClipMode(mode);

	// Note: Tile surfaces are ALWAYS CLIP_EDGES, wrap clipping is implemented by this object
	// for tiles, as a wrapped blits can span multiple tiles
	TSurface **surf = tiles;
	for (int ty = 0; ty < numtiley; ty++)
	{
	  for (int tx = 0; tx < numtilex; tx++, surf++)
	  {
		(*surf)->SetClipMode(CLIP_EDGES);		// Use standard clip mode for subtiles
	  }
	}
}

// Copies specified bitmap to current bitmap
BOOL TMosaicSurface::ParamDraw(PSDrawParam dp, PTBitmap bitmap)
{
	SDrawParam dpv = *dp;
	BOOL drew = FALSE;
	SDrawParam dparray[4];
	SDrawBlock db;
	int numrects;

	if (!ParamDrawSetup(dpv, bitmap))
		return FALSE;

	memset(&db, 0, sizeof(SDrawBlock));

	db.dbufwidth  = width;
	db.dbufheight = height;
	db.dstride    = stride;

	if (bitmap)
	{
		db.sbufwidth  = bitmap->width;
		db.sbufheight = bitmap->height;
		db.sstride    = bitmap->width;
	}
	else
	{
		db.sbufwidth = db.sbufheight = db.sstride = 0;
	}

	if (!Clip(&db, &dpv, dparray, numrects))
		return FALSE;

	for (int cliploop = 0; cliploop < numrects; cliploop++)
	{
		RSDrawParam dpa = dparray[cliploop];
					
		dpa.drawmode &= ~(DWORD)(DM_WRAPCLIP | DM_WRAPCLIPSRC);

		TSurface **surf = tiles;
		for (int ty = 0; ty < numtiley; ty++)
		{
		  for (int tx = 0; tx < numtilex; tx++, surf++)
		  {
			drew |= (*surf)->ParamDraw(&dpa, bitmap);
		  }
		}
	}

	return drew;
}

// Blits from surface to surface. RECT sets size of blit. 
// X & Y specifies dest. origin
BOOL TMosaicSurface::ParamBlit(PSDrawParam dp, PTSurface surface, int flags, LPDDBLTFX fx)
{
	SDrawParam dpv = *dp;
	BOOL drew = FALSE;
	SDrawParam dparray[4];
	SDrawBlock db;
	int numrects;

  // Allow special case of blitting from one mosaic surface with identical size and tile
  // layout to another!!
	PTMosaicSurface mosaicsrc = NULL;
	if (surface && surface->SurfaceType() == SURFACE_MOSAIC)
	{
		mosaicsrc = (PTMosaicSurface)surface;
		if (mosaicsrc->tilex != tilex || mosaicsrc->tiley != tiley ||
			mosaicsrc->numtilex != numtilex || mosaicsrc->numtiley != numtiley)
				FatalError("Attempt to blit between non-identical mosaic surfaces");
	}

	if (!ParamBlitSetup(dpv, surface, flags, fx))
		return FALSE;

	memset(&db, 0, sizeof(SDrawBlock));

	db.dbufwidth  = width;
	db.dbufheight = height;
	db.dstride    = stride;

	if (surface)
	{
		db.sbufwidth  = surface->Width();
		db.sbufheight = surface->Height();
		db.sstride    = surface->Stride();
	}
	else
	{
		db.sbufwidth = db.sbufheight = db.sstride = 0;
	}

	if (!Clip(&db, &dpv, dparray, numrects))
		return FALSE;

	int soriginx, soriginy;
	surface->GetOrigin(soriginx, soriginy);

	PTSurface src = surface;
	for (int cliploop = 0; cliploop < numrects; cliploop++)
	{
		RSDrawParam dpa = dparray[cliploop];
		
	  // Re-add originx and originy since Clip ParamBlitSetup will subtract these out				
		dpa.sx -= soriginx;
		dpa.sy -= soriginy;

		dpa.drawmode &= ~(DWORD)(DM_WRAPCLIP | DM_WRAPCLIPSRC);

		TSurface **surf = tiles;
		for (int ty = 0; ty < numtiley; ty++)
		{
		  for (int tx = 0; tx < numtilex; tx++, surf++)
		  {
			if (mosaicsrc)
				src = mosaicsrc->GetTile(tx, ty);

			drew |= (*surf)->ParamBlit(&dpa, src, flags, fx);
		  }
		}
	}

	return drew;
}

// Blits from surface to surface. RECT sets size of blit. 
// X & Y specifies dest. origin
BOOL TMosaicSurface::ParamGetBlit(PSDrawParam dp, PTSurface surface, int flags, LPDDBLTFX fx)
{
	SDrawParam dpv = *dp;
	BOOL drew = FALSE;
	SDrawParam dparray[4];
	SDrawBlock db;
	int numrects;

  // Get blits always have two surfaces
	if (!surface)
		return FALSE;

  // Allow special case of blitting from one mosaic surface with identical size and tile
  // layout to another!!
	PTMosaicSurface mosaicdest = NULL;
	if (surface->UseGetBlit())
	{
		BOOL err = FALSE;
		if (surface->SurfaceType() != SURFACE_MOSAIC)
			err = TRUE;
		if (!err)
		{
			mosaicdest = (PTMosaicSurface)surface;
			if (mosaicdest->tilex != tilex || mosaicdest->tiley != tiley ||
				mosaicdest->numtilex != numtilex || mosaicdest->numtiley != numtiley)
				err = TRUE;
		}
		if (err)
			FatalError("Attempt to blit between non-identical mosaic surfaces");
	}

	if (!surface->ParamBlitSetup(dpv, this, flags, fx))
		return FALSE;

	memset(&db, 0, sizeof(SDrawBlock));

	db.dbufwidth  = surface->Width();
	db.dbufheight = surface->Height();
	db.dstride    = surface->Stride();

	db.sbufwidth  = width;
	db.sbufheight = height;
	db.sstride    = stride;

	if (!Clip(&db, &dpv, dparray, numrects))
		return FALSE;

	PTSurface dest = surface;
	for (int cliploop = 0; cliploop < numrects; cliploop++)
	{
		RSDrawParam dpa = dparray[cliploop];

		dpa.drawmode &= ~(DWORD)(DM_WRAPCLIP | DM_WRAPCLIPSRC);
					
		TSurface **surf = tiles;
		for (int ty = 0; ty < numtiley; ty++)
		{
		  for (int tx = 0; tx < numtilex; tx++, surf++)
		  {
			if (mosaicdest)
				dest = mosaicdest->GetTile(tx, ty);

			drew |= dest->ParamBlit(&dpa, *surf, flags, fx);
		  }
		}
	}

	return drew;
}

// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                resource.cpp - Resource object module                  *
// *************************************************************************

#include <stdio.h>
#include <string.h>

#include "revenant.h"
#include "multi.h"

void *TMulti::Object(char *name)
{
	for (int c = 0; c < numoffsets; c++)
	{
		char *p = (char *)((void *)names[c]);
		if (p && !stricmp(p, name))
			return (void *)offsets[c]; 
	}

	char buf[80];
	sprintf(buf, "Unable to find '%s' in multiresource", name);
	FatalError(buf);

	return NULL;
}
// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                multictrl.cpp - Multipane Control Panel                *
// *************************************************************************

#include "revenant.h"
#include "multictrl.h"
#include "button.h"

// Pane list
PTPane MultiPanes[NUMMCBUTTONS] =
	{ (PTPane)&EquipPane, (PTPane)&AutoMap, (PTPane)&SpellPane, (PTPane)&StatPane };

// Button functions

void BtnEquip()
{
	MultiCtrl.ActivatePane(0);
}

void BtnMap()
{
	MultiCtrl.ActivatePane(1);
}

void BtnSpell()
{
	MultiCtrl.ActivatePane(2);
}

void BtnStats()
{
	MultiCtrl.ActivatePane(3);
}

// ******************
// * TMultiCtrlPane *
// ******************

BOOL TMultiCtrlPane::Initialize()
{
	TButtonPane::Initialize();

	buttondata = TMulti::LoadMulti("intrface.dat");

	NewButton("Equip",	30+BUTTONRADIUS,  2+BUTTONRADIUS, BUTTONRADIUS, BUTTONRADIUS, VK_F1, BtnEquip, buttondata->Bitmap("equipdown"), buttondata->Bitmap("equipup"), TRUE, FALSE, TRUE, 1);
	NewButton("Map",	2+BUTTONRADIUS,  35+BUTTONRADIUS, BUTTONRADIUS, BUTTONRADIUS, VK_F2, BtnMap, buttondata->Bitmap("mapdown"), buttondata->Bitmap("mapup"), TRUE, FALSE, FALSE, 1);
	NewButton("Spell",	2+BUTTONRADIUS,  77+BUTTONRADIUS, BUTTONRADIUS, BUTTONRADIUS, VK_F3, BtnSpell, buttondata->Bitmap("spelldown"), buttondata->Bitmap("spellup"), TRUE, FALSE, FALSE, 1);
	NewButton("Stat",	30+BUTTONRADIUS, 109+BUTTONRADIUS, BUTTONRADIUS, BUTTONRADIUS, VK_F4, BtnStats, buttondata->Bitmap("skilldown"), buttondata->Bitmap("skillup"), TRUE, FALSE, TRUE, 1);

	curpane = -1;
	ActivatePane(0);
	Button(0)->SetState(TRUE);
	return TRUE;
}

void TMultiCtrlPane::Close()
{
	delete buttondata;
}

void TMultiCtrlPane::ActivatePane(int pane)
{
	if (pane == curpane)
		return;

	for (int p = 0; p < NUMMCBUTTONS; p++)
		if (p != pane)
			MultiPanes[p]->Hide();

	MultiPanes[pane]->Show();

	curpane = pane;
}

void TMultiCtrlPane::Hide()
{
	TButtonPane::Hide();

	for (int p = 0; p < NUMMCBUTTONS; p++)
		MultiPanes[p]->Hide();
}

void TMultiCtrlPane::Show()
{
	TButtonPane::Show();

	MultiPanes[curpane]->Show();
}

void TMultiCtrlPane::RedrawCurPane()
{
	MultiPanes[curpane]->SetDirty(TRUE);
}

// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *             multisurface.cpp - 3D Surface Include File                *
// *************************************************************************

#include "revenant.h"
#include "multisurface.h"

TMultiSurface::TMultiSurface()
{
	graphics = zbuffer = normals = NULL;
	deletesurf = FALSE;
}

TMultiSurface::~TMultiSurface()
{
	Close();
}

void TMultiSurface::Initialize(PTSurface surface1, 
	PTSurface surface2, PTSurface surface3, BOOL delsurf)
{
	SetGraphicsBuffer(surface1);
	SetZBuffer(surface2);
	SetNormalBuffer(surface3);
	Reset();
	deletesurf = delsurf;
}

void TMultiSurface::SetGraphicsBuffer(PTSurface surface)
{
	graphics = surface;

	if (surface)
	{
		width        = surface->Width();
		height       = surface->Height();
		bitsperpixel = surface->BitsPerPixel();
		stride       = surface->Stride();
		flags        = surface->flags;

		Reset();
	}
	else
	{
		width        = 0;
		height       = 0;
		bitsperpixel = 0;
		stride       = 0;
		flags        = 0;
	}

}

void TMultiSurface::Reset()
{
	char *sizeerr = "Multisurface sizes don't match";
	if (graphics && zbuffer)
	  if (graphics->Width() != zbuffer->Width() ||
		  graphics->Height() != zbuffer->Height())
	  FatalError(sizeerr);
	if (graphics && normals)
	  if(graphics->Width() != normals->Width() ||
		 graphics->Height() != normals->Height())
	  FatalError(sizeerr);

	TSurface::Reset();
	if (graphics)
	{
		graphics->SetOrigin(0, 0);
		graphics->ResetClipRect();
		graphics->SetClipMode(CLIP_EDGES);
	}
	if (zbuffer)
	{
		zbuffer->SetOrigin(0, 0);
		zbuffer->ResetClipRect();
		zbuffer->SetClipMode(CLIP_EDGES);
	}
	if (normals)
	{
		normals->SetOrigin(0, 0);
		normals->ResetClipRect();
		normals->SetClipMode(CLIP_EDGES);
	}
}

void TMultiSurface::SetOrigin(int x, int y)
{
	TSurface::SetOrigin(x, y);
	if (graphics)
		graphics->SetOrigin(x, y);
	if (zbuffer)
		zbuffer->SetOrigin(x, y);
	if (normals)
		normals->SetOrigin(x, y);
}

void TMultiSurface::SetClipRect(int x, int y, int w, int h)
{
	TSurface::SetClipRect(x, y, w, h);
	if (graphics)
		graphics->SetClipRect(x, y, w, h);
	if (zbuffer)
		zbuffer->SetClipRect(x, y, w, h);
	if (normals)
		normals->SetClipRect(x, y, w, h);
}

void TMultiSurface::SetClipMode(int mode)
{
	TSurface::SetClipMode(mode);
	if (graphics)
		graphics->SetClipMode(mode);
	if (zbuffer)
		zbuffer->SetClipMode(mode);
	if (normals)
		normals->SetClipMode(mode);
}

void TMultiSurface::Close()
{
	if (deletesurf)
	{
		if (graphics)
			delete graphics;
		if (zbuffer)
			delete zbuffer;
		if (normals)
			delete normals;
		graphics = zbuffer = normals = NULL;
		deletesurf = FALSE;
	}
}

// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                     Object.cpp - TObject module                       *
// *************************************************************************

#include <windows.h>
#include <stdio.h>
#include <math.h>
#include <sys/types.h>
#include <sys/stat.h>

#include "revenant.h"

#include "3dscene.h"
#include "display.h"
#include "dls.h"
#include "mappane.h"
#include "object.h"
#include "stream.h"
#include "parse.h"
#include "playscreen.h"
#include "resource.h"
#include "script.h"
#include "inventory.h"
#include "player.h"
#include "file.h"
#include "command.h"

// Declarations of global arrays for object classes, imagery, and builders

int TObjectClass::numclasses = 0;
PTObjectClass TObjectClass::classes[MAXOBJECTCLASSES];

// TRUE if classes need be be resaved
BOOL TObjectClass::classesdirty = FALSE;

int TObjectBuilder::numobjtypes = 0;
PTObjectBuilder TObjectBuilder::builders[MAXOBJECTTYPES];


// Tables for ConvertToFacing, Move, and other angle/distance related functions
extern BYTE AngleTable[256][256];
extern BYTE DistTable[256][256];
extern short DistX[256];
extern short DistY[256];

extern DWORD ImageryMemUsage;

WORD UniqueTypeID;

#define WORLDZOFFSET 0x3900 + 0x7FFF

// *******************************
// * Map/Screen Conversion Utils *
// *******************************

void WorldToScreen(RS3DPoint pos, int &x, int &y)
{
	// 2:1
	x = pos.x - pos.y;
    y = ((pos.x + pos.y) / 2) - (int)((pos.z * 866)/1000);
		// the screen z is actually pos.z * cos(30), cos(30) = .866
}

void WorldToScreen(RS3DPoint pos, RS3DPoint spos)
{
	// 2:1
	spos.x = pos.x - pos.y;
    spos.y = ((pos.x + pos.y) / 2) - (int)((pos.z * 866)/1000);
    spos.z = (WORD)(WORLDZOFFSET - (int)(pos.z / 2) - (int)((pos.x + pos.y) * 866 / 1000));
    //spos.z = (WORD)(WORLDZOFFSET - (int)(pos.z * 2560 / 5120) - (int)((pos.x + pos.y) * 4434 / 5120));
		// Z must be figured out based on the plates being tilted at a 30 degree angle
		// zratio = 512.0 * sin(30) = 256.0, yratio = 512.0 * cos(30) = 443.4
}

void WorldToScreenZ(RS3DPoint pos, int &z)
{
    z = (WORD)(WORLDZOFFSET - (int)(pos.z / 2) - (int)((pos.x + pos.y) * 866 / 1000));
}

void ScreenToWorld(RS3DPoint pos, RS3DPoint spos)
{
    pos.z = (-3464 * spos.y / 1000 - 2 * spos.z) / 4;
    pos.y = - spos.x / 2 + 866 * pos.z / 1000 + spos.y;
    pos.x = spos.x + pos.y;
}

void ScreenToWorld(int x, int y, RS3DPoint pos, int zheight)
{
	if (zheight)
		y += (int)((zheight * 866)/1000);

	// 2:1
	pos.x = (x / 2) + y;
	pos.y = y - (x / 2);
	pos.z = zheight;
}

void ConvertToVector(int angle, int speed, RS3DPoint vect, int zangle)
{
	if (zangle == 0)
	{
		vect.x = (DistX[angle] * speed) / 256;
		vect.y = (DistY[angle > 128 ? angle - 128 : 128 - angle] * speed) / 256;
		vect.z = 0;
	}
	else
	{
		ConvertToVector(angle, (DistX[zangle] * speed) / 256, vect, 0);
		vect.z = (DistY[zangle] * speed) / 256;
	}
}

int ConvertToFacing(RS3DPoint target)
{
	int absx = absval(target.x);
	int absy = absval(target.y);

	while (absx > 255 || absy > 255)
	{
		absx >>= 1;
		absy >>= 1;
	}

	int angle = 64 - AngleTable[absx][absy];

	// adjust for sign (which of the quadrants does the angle fall into?)
	if (target.x < 0 && target.y > 0)
		angle += 128;
	else if (target.x < 0)
		angle = 256 - angle;
	else if (target.y > 0)
		angle = 128 - angle;

	return angle;
}

int ConvertToFacing(RS3DPoint pos, RS3DPoint target)
{
	S3DPoint p;

	p.x = target.x - pos.x;
	p.y = target.y - pos.y;
	p.z = 0;

	return ConvertToFacing(p);
}

int ConvertZToFacing(RS3DPoint target)
{
	int absdist = abs(Distance(target));
	int absz = abs(target.z);

	while (absdist > 255 || absz > 255)
	{
		absdist >>= 1;
		absz >>= 1;
	}

	int angle = AngleTable[absdist][absz];

	// adjust for sign (which of the quadrants does the angle fall into?)
	if (target.z < 0 && target.y < 0)
		angle += 128;
	else if (target.z < 0)
		angle = 256 - angle;
	else if (target.y < 0)
		angle = 128 - angle;

	return angle;
}

int ConvertZToFacing(RS3DPoint pos, RS3DPoint target)
{
	S3DPoint p;

	p.x = target.x - pos.x;
	p.y = target.y - pos.y;
	p.z = target.z - pos.z;

	return ConvertZToFacing(p);
}

int Distance(RS3DPoint pos)
{
	int numshifts = 0;
	int x = pos.x;
	int y = pos.y;

	while (x > 255 || y > 255)
	{
		x >>= 1;
		y >>= 1;
		numshifts++;
	}

	int d = (int)DistTable[x][y];
	d <<= numshifts;

	return d;
}

int Distance(RS3DPoint pos, RS3DPoint target)
{
	S3DPoint p;

	p.x = abs(target.x - pos.x);
	p.y = abs(target.y - pos.y);
	p.z = 0;

	return Distance(p);
}

int AngleDiff(int angle1, int angle2)
{
	int diff = (angle1 & 255) - (angle2 & 255);
	if (diff > 128)
		diff -= 255;
	else if (diff <= -128)
		diff += 255;
	return diff;
}

// ******************
// * TObjectBuilder *
// ******************

TObjectBuilder::TObjectBuilder(char *name)
{
	if (numobjtypes < MAXOBJECTTYPES)
		builders[numobjtypes++] = this;

	objtypename = _strdup(name);
}

PTObjectBuilder TObjectBuilder::GetBuilder(int objtype)
{
	if (objtype < numobjtypes)
		return builders[objtype];

	return NULL;
}

PTObjectBuilder TObjectBuilder::GetBuilder(char *name)
{
	for (int i = 0; i < numobjtypes; i++)
		if (stricmp(name, builders[i]->objtypename) == 0)
			return builders[i];

	return NULL;
}

// **********************
// * TInventoryIterator *
// **********************

PTObjectInstance TInventoryIterator::NextItem()
{
	// Currently this DOES NOT recurse into other object's inventories,
	// because nothing uses it that way.  Copying some code from TMapIterator
	// would make it possible to do so if it is ever needed.
	item = NULL;

	if (owner)
	{
		do
		{
			if (invindex >= owner->NumInventoryItems())
				break;

			item = owner->GetInventory(invindex++);

		} while (!item);
	}

	return item;
}

// *******************
// * TObjectInstance *
// *******************

void TObjectInstance::ClearObject()
{
	SetNotify(N_SCRIPTADDED);

	animator            = NULL;
	lightdef.lightindex = -1;
	lightdef.lightid	= -1;
	lightdef.multiplier = -1;
	SetCommandDone(FALSE);
	script				= NULL;

	objclass = objtype	= -1;
	flags				= 0;
	notifyflags			= 0;
	sector				= NULL;
	state				= 0;
	group				= 0;

	frame				= 0;
	framerate			= 1;

	level = 0;
	pos.x = pos.y = pos.z = 0;
	vel.x = vel.y = vel.z = 0;
	rotatex = rotatey = rotatez = 0;
	accum.x = accum.y = accum.z = 0;
	invindex = inventnum = -1;
	shadow = -1;

	owner = NULL;

	memset(&nextmove, 0, sizeof(S3DPoint));
	moveangle = 0;

	stats.Clear();

	// make oldpos DIFFERENT from pos here
	oldpos.x = pos.x + 1; oldpos.y = pos.y + 1; oldpos.z = pos.z + 1;
	screenx = screeny = screenz = 0;
}

TObjectInstance::TObjectInstance(PTObjectImagery img)
{
	ClearObject();
	imagery = img;

	if (imagery->NeedsAnimator(this))
		flags |= OF_ANIMATE;

	if (ObjClass() != OBJCLASS_TILE && ObjClass() != OBJCLASS_SHADOW)
		flags |= OF_PULSE;
}

TObjectInstance::TObjectInstance(PSObjectDef def, PTObjectImagery img)
{
	ClearObject();

	memcpy(&objclass, def, sizeof(SObjectDef));

  // Set imagery
	imagery = img;

  // Set ANIMATE and PULSE flags
	if (imagery->NeedsAnimator(this))
		flags |= OF_ANIMATE;

	if (ObjClass() != OBJCLASS_TILE)
		flags |= OF_PULSE;
	
  // Set Object info pointer
	cl = TObjectClass::GetClass(objclass);
	if (!cl)
		FatalError("Bad object class!"); // This should never happen!!
	inf = cl->GetObjType(objtype);
	name = inf->name;

  // Setup stat array
	if (cl->NumObjStats() > 0)
	{
		stats.SetNumItems(cl->NumObjStats());
		for (int c = 0; c < cl->NumObjStats(); c++)
			ResetObjStat(c);
	}

	if (objclass != OBJCLASS_TILE) // No scripts for regular tiles (for efficiency sake)
		InitScript(ScriptManager.ObjectScript(this));
}

TObjectInstance::~TObjectInstance()
{
	if (objclass == -1)
		return;

	if (Inventory.GetContainer() == this)
		Inventory.SetContainer(NULL);

	if (animator)
		delete animator;

	TObjectImagery::FreeImagery(imagery);

	if (lightdef.lightindex != -1)
		Scene3D.DeleteLight(lightdef.lightindex);

	if (lightdef.lightid != -1)
		FreeLightIndex(lightdef.lightid);

	// recursively delete all the objects in its inventory
	for (TInventoryIterator i(this); i; i++)
	{
		i.Item()->RemoveFromInventory();
		delete i.Item();
	}

	// take itself out of owner's inventory
	RemoveFromInventory();

	// If in map, remove from map
	if (GetSector() != NULL)
		MapPane.RemoveObject(this);

	// Delete the name
	if (name && name != inf->name)
	{
		free(name);
		name = NULL;
	}

	// If we're being centered on, cancel that
	if (MapPane.GetCenterOnObj() == this)
		MapPane.CenterOnObj(NULL, FALSE); // Don't center on anything

	// Kill the script
	if (script)
		delete script;

}

void TObjectInstance::SetName(char *newname)
{
	if (name && name != inf->name)  // If name is not set to point to objinfo name string
	{
		free(name);					// delete it
		name = NULL;
	}

	if (newname && *newname)
		name = _strdup(newname);	// Name set to a specific name
	else
		name = inf->name;			// Name cleared, set to objinfo name instead

  // Reset script when name changes (could have a new script)	
	if (script)
	{
		delete script;
		script = NULL;
	}

	if (objclass != OBJCLASS_TILE) // No scripts for regular tiles (for efficiency sake)
		InitScript(ScriptManager.ObjectScript(this));
}

PTObjectImagery TObjectInstance::GetImagery()
{
	return 	imagery;
}

BOOL TObjectInstance::CreateAnimator()
{
	animator = imagery->NewObjectAnimator(this);

	if (animator)
		animator->Initialize();		 // Call the animator's initialize function

	return (animator != NULL);
}

void TObjectInstance::FreeAnimator()
{
	if (animator)
	{
		delete animator;
		animator = NULL;
	}
}

BOOL TObjectInstance::NeedsAnimator()
{
	if (!animator && imagery)
		return imagery->NeedsAnimator(this);

	return FALSE;
}

void TObjectInstance::Damage(int damage, int type)
{
	if (damage < Health())
		SetHealth(Health() - damage);
	else
		SetHealth(0);
}

void TObjectInstance::RepaintObject()
{
}

int TObjectInstance::Distance(PTObjectInstance inst)
{
	return ::Distance(pos, inst->pos);
}

// Returns the angle to the other instance
int TObjectInstance::AngleTo(PTObjectInstance inst)
{
	S3DPoint tpos;
	inst->GetPos(tpos);
	return ConvertToFacing(pos, tpos);
}

// Returns the + or - difference between this objects facing and the dest obj
int TObjectInstance::FaceAngleTo(PTObjectInstance inst)
{
	int angle = AngleTo(inst) - GetFace();
	if (angle >= 128)
		angle = angle - 256;
	else if (angle <= -128)
		angle = angle + 256;
	return angle;
}

void TObjectInstance::GetScreenPos(int &x, int &y)
{
	if (oldpos == pos)
	{
		x = screenx;
		y = screeny;
	}
	else
	{
		WorldToScreen(pos, x, y);
		WorldToScreenZ(pos, screenz);

		screenx = x;
		screeny = y;

		oldpos = pos;
	}
}

void TObjectInstance::GetScreenPos(S3DPoint &s)
{
	if (oldpos == pos)
	{
		s.x = screenx;
		s.y = screeny;
		s.z = screenz;
	}
	else
	{
		WorldToScreen(pos, screenx, screeny);
		WorldToScreenZ(pos, screenz);

		s.x = screenx;
		s.y = screeny;
		s.z = screenz;

		oldpos = pos;
	}
}

// Sets the current object position
int TObjectInstance::SetPos(RS3DPoint newpos, int newlevel, BOOL override)
{
	int index = GetMapIndex();

  // Note: can't change level of regular map objects, only non map objects
	if (newlevel < 0 || !(flags & OF_NONMAP))
		newlevel = MapPane.GetMapLevel();

  // Didn't move
	if (newpos == pos && newlevel == level)
		return index;							// no movement, so bail out

  // Isn't in map
	if (override || !sector || index < 0)
	{
		pos = newpos;
		level = newlevel;
		return index;
	}

  // Handle shadow, if any
	if (shadow >= 0)
	{
		PTObjectInstance s = MapPane.GetInstance(shadow);
		if (s)
		{
			S3DPoint delta = newpos;
			delta -= pos;

			S3DPoint spos;
			s->GetPos(spos);
			spos += delta;
			s->SetPos(spos);
		}
	}

  // Make sure we're still in currently loaded map after we move
	index = MapPane.CheckPos(this, newpos, newlevel);

  // Get original screen rectangle
	SRect oldrect;
	GetScreenRect(oldrect);

	MapPane.ExtractWalkmap(this);

  // Sets new position
	pos = newpos;
	level = newlevel;

	MapPane.TransferWalkmap(this);

  // Update 3D system light
	if (lightdef.lightindex != -1)
	{
		S3DPoint lpos = pos;
		lpos += lightdef.pos;
		Scene3D.SetLightPosition(lightdef.lightindex, lpos);
	}

  // Get new screen rectangle
	SRect newrect;
	GetScreenRect(newrect);

  // Update background
	if (BgDrawMode() != BGDRAW_NONE)
	{
		int numrects = 0;
		SRect rects[4];
		if (SubtractRect(oldrect, newrect, rects, numrects))
		{
			for (int c = 0; c < numrects; c++)
				MapPane.AddBgUpdateRect(rects[c], BgDrawMode());
		}
		RedrawBackground();
	}

	return index;
}

// Moves this object so that it is the given distance 'dist' from 'oi'
void TObjectInstance::SnapDist(PTObjectInstance oi, int dist)
{
	if (dist >= 0)
	{
		int curdist = Distance(oi);
		if (dist != curdist)
		{
			S3DPoint p;
			ConvertToVector(oi->AngleTo(this), dist, p);
			p += oi->Pos();
			SetPos(p);
		}
	}
}

void TObjectInstance::ResetState()
{
	int stateflags = (imagery)?imagery->GetAniFlags(state):0;
	int statesize = (imagery)?imagery->GetAniLength(state):0;
	if (stateflags & AF_REVERSE)
	{
		frame = statesize - 1;
		framerate = -1;
	}
	else
	{
		frame = 0;
		framerate = 1;
	}
	if (animator)
		animator->ResetState();
}

// Sets the current animation state for the object
BOOL TObjectInstance::SetState(int newstate)
{
	if (GetImagery())
	{
		if ((DWORD)newstate >= (DWORD)GetImagery()->NumStates())
		{
			SetCommandDone(TRUE);
			return FALSE;
		}
	}

	RedrawBackground();
	MapPane.ExtractWalkmap(this);

	LOCKOBJECTS;   // Prevent update system from drawing objects while we change state

	prevstate = state;
	state = newstate;
	SetCommandDone(FALSE);
	ResetState();

	UNLOCKOBJECTS; // Ok, go ahead and draw objects again

	MapPane.TransferWalkmap(this);

	if (GetImagery()->NeedsAnimator(this))
		flags |= OF_ANIMATE;			// Cause Animate() function to be called
	else
	{
		FreeAnimator();
		flags &= ~(DWORD)OF_ANIMATE;	// Prevents Animate() function from being called
	}

	RedrawBackground();

	return TRUE;
}

BOOL TObjectInstance::AddToInventory(PTObjectInstance inst, int slot)
{
	if (slot < 0)
		slot = FindFreeInventorySlot();

	if ((DWORD)slot >= MAXINVITEMS)
		return FALSE;

	int index = inventory.Add(inst);
	if (index < 0)
		return FALSE;

	if (inst->GetMapIndex() < 0)
		inst->SetMapIndex(MapPane.MakeIndex());

	inst->invindex = index;
	inst->inventnum = slot;
	inst->owner = this;

	inst->pos.x = inst->pos.y = inst->pos.z = 0;
	inst->level = 0;
	inst->sector = NULL;

	inst->SignalAddedToInventory();

	if (this == Inventory.GetContainer())
		Inventory.Update();

	return TRUE;
}

BOOL TObjectInstance::AddToInventory(char *name, int number, int slot)
{
	PTObjectClass cl;
	for (int i = 0; i < MAXOBJECTCLASSES; i++)
	{
		cl = TObjectClass::GetClass(i);
		if (cl && (objtype = cl->FindObjType(name)) >= 0)
			break;
	}

	if (objtype < 0)
		return FALSE;

	SObjectDef def;
	memset(&def, 0, sizeof(SObjectDef));

	def.objclass = cl->ClassId();
	def.objtype = objtype;

	PTObjectInstance inst = cl->NewObject(&def);
	if (!inst)
		return FALSE;

	if (number != 1)
		inst->SetAmount(number);

	return AddToInventory(inst, slot);
}

void TObjectInstance::RemoveFromInventory()
{
	if (owner)
	{
		if (owner == Inventory.GetContainer())
			Inventory.Update();

		owner->inventory.Remove(invindex);
		owner = NULL;
	}

	invindex = -1;
	inventnum = -1;
}

int TObjectInstance::GiveInventoryTo(PTObjectInstance to, char *name, int number)
{
	int total = 0;
	if (number < 1)
		return 0;

	do
	{
		PTObjectInstance inst = FindObjInventory(name);

		if (!inst)
			return total;

		int amt = min(inst->Amount(), 1);

		if (number >= min(inst->Amount(), 1))
		{
			total += amt;
			number -= amt;
			inst->RemoveFromInventory();
			if (to)
				to->AddToInventory(inst);
			else
				delete inst;
		}
		else
		{
			inst->SetAmount(amt - number);
			if (to)
			{
				if (!to->AddToInventory(name, number))
					return total;
			}
			total += number;
			number = 0;
		}

	} while (number > 0);

	return total;
}

void TObjectInstance::SignalAddedToInventory()
{
}

BOOL TObjectInstance::AddToMap()
{
	return (MapPane.AddObject(this) >= 0);
}

void TObjectInstance::RemoveFromMap()
{
	for (TMapIterator i; i; i++)
		if (i.Item() == this)
			break;

	if (i.Item())
		MapPane.RemoveFromSector(this, i.SectorX(), i.SectorY(), i.SectorIndex());
}

int TObjectInstance::FindFreeInventorySlot()
{
	int lowest = 0;
	BOOL done = FALSE;

	while (!done)
	{
		done = TRUE;

		for (TInventoryIterator i(this); i; i++)
			if (i.Item()->InventNum() == lowest)
			{
				done = FALSE;
				lowest++;
				break;
			}
	}

	return lowest;
}

int TObjectInstance::RealNumInventoryItems()
{
	// count up the real number of items in the inventory
	int num = 0;
	for (TInventoryIterator i(this); i; i++)
		num++;

	return num;
}

PTObjectInstance TObjectInstance::GetInventory(int index)
{
	return inventory[index];
}

PTObjectInstance TObjectInstance::GetInventorySlot(int slot)
{
	for (TInventoryIterator i(this); i; i++)
		if (i.Item()->InventNum() == slot)
			return i.Item();

	return NULL;
}

PTObjectInstance TObjectInstance::FindObjInventory(char *name)
{
	for (TInventoryIterator i(this); i; i++)
		if (stricmp(i.Item()->GetName(), name) == 0)
			return i.Item();

	return NULL;
}

BOOL TObjectInstance::Use(PTObjectInstance user, int with)
{
	if (with >= 0)	// With object.. use with name as key
	{
		PTObjectInstance inst = MapPane.GetInstance(with);
		if (GetScript())
			GetScript()->Trigger(TRIGGER_USE, inst->GetName());
	}
	else		// No with object.. use 'use' object as key
	{
		if (GetScript())
			GetScript()->Trigger(TRIGGER_USE);
		if (user && user->GetScript())
			user->GetScript()->Trigger(TRIGGER_USE, this->GetName());
	}

	/*
	if (!inst || inst->GetOwner() != GetOwner() || inst->ObjClass() != objclass)
		return FALSE;

	PTObjectClass cl = TObjectClass::GetClass(ObjClass());

	if (GetStatistic("Combining") && inst->GetStatistic("Combining") &&
		absval(ObjType() - inst->ObjType()) == 1)
	{
		int slot = inst->InventNum();
		PTObjectInstance own = GetOwner();
		if (own)
		{
			MapPane.RemoveFromInventory(own, InventNum());
			MapPane.RemoveFromInventory(own, inst->InventNum());
		}

		SetFlags(OF_KILL);
		inst->SetFlags(OF_KILL);

		SObjectDef def;
		memset(&def, 0, sizeof(SObjectDef));

		def.objclass = ObjClass();
		def.objtype = ObjType() > inst->ObjType() ? (ObjType() + 1) : (inst->ObjType() + 1);
		Player->GetPos(def.pos);

		int index = MapPane.NewObject(&def);
		if (index >= 0 && own)
			MapPane.AddToInventory(own, index, slot);

		return TRUE;
	}
	*/
	return FALSE;
}

void TObjectInstance::Pulse()
{
/*	static int i = 230;
	static int d = 1;

	if (flags & OF_LIGHT) // TEST
	{
		SetLightIntensity(i);
		i += d;
		if (i >= 255)
		{
			i = 255;
			d = -1;
		}
		else if (i < 230)
		{
			i = 230;
			d = 1;
		}
	}
*/
	if (CommandDone())
		ContinueScript();

	Move();
}

DWORD TObjectInstance::Move()
{
	if (flags & OF_IMMOBILE || IsInInventory() || objclass == OBJCLASS_TILE || objclass == OBJCLASS_EXIT || objclass == OBJCLASS_SHADOW)
		return MOVE_NOTHING;

	S3DPoint newpos = pos;
	DWORD retval = 0;

	int h = MapPane.GetWalkHeight(pos);

	if (pos.z < h || h == 0)
		return MOVE_BLOCKED;				// very basic collision detection

    if (h < pos.z && vel.z > -TERMINAL_VELOCITY && !(flags & OF_WEIGHTLESS))
	{
		vel.z -= GRAVITY;
		retval |= MOVE_FALLING;
	}
	accum += nextmove;

	accum += vel;
	rollover(accum.x, newpos.x);
	rollover(accum.y, newpos.y);
	rollover(accum.z, newpos.z);

	if (newpos.z < h)
	{
		if (absval(vel.z) > GRAVITY)
			vel.z = -(vel.z / 4);				// bounce bounce
		else
			vel.z = 0;

		newpos.z = h;
		accum.z = 0;
	}

	if (newpos == pos && vel.x == 0 && vel.y == 0 && vel.z == 0)
		return MOVE_NOTHING;		// can only check this _after_ gravity

	if (newpos == pos)
		return MOVE_MOVED | retval;			// they moved, but not a whole unit

	//if (!MapPane.LineOfSight(pos, newpos))
	//	return MOVE_BLOCKED;

	SetPos(newpos);

	return MOVE_MOVED | retval;
}

void TObjectInstance::Animate(BOOL draw)
{
	if (animator)
	{
	  // Call animator
		animator->Animate(draw);

	  // Save laste frame and framerate in obj (so it can be saved in map file)
		frame = animator->GetFrame();
		framerate = animator->GetFrameRate();
	}
}

void TObjectInstance::OnScreen()
{
	if (NeedsAnimator())
		CreateAnimator();
	else
		FreeAnimator();

	if (flags & OF_LIGHT)
	{
		if (lightdef.lightindex == -1)
		{
			S3DPoint lpos = pos;
			lpos += lightdef.pos;
			lightdef.lightindex = Scene3D.AddLight(lpos, lightdef.color, lightdef.intensity, lightdef.multiplier);
		}
	}
}

void TObjectInstance::OffScreen()
{
	if (animator)
		FreeAnimator();

	if (lightdef.lightindex != -1)
	{
		Scene3D.DeleteLight(lightdef.lightindex);
		lightdef.lightindex = -1;
	}
	if (lightdef.lightid != -1)
	{
		FreeLightIndex(lightdef.lightid);
		lightdef.lightid = -1;
	}
}

void TObjectInstance::GetFacingBoundBox(int &nx, int &ny, int &nsx, int &nsy)
{
	int width, length, height;
	GetImagery()->GetWorldBoundBox(state, width, length, height);

	int regx = GetImagery()->GetWorldRegX(state);
	int regy = GetImagery()->GetWorldRegY(state);

	nx = regx;
	ny = regy;
	nsx = width;
	nsy = length;

	if (facing >= 0xE0 || facing < 0x20)
	{
		// north, which is default
		return;
	}
	else if (facing < 0x60)
	{
		// east
		nx = regy;
		ny = regx;
		nsx = length;
		nsy = width;
	}
	else if (facing < 0xA0)
	{
		// south
		nx = width - regx - 1;
	}
	else if (facing < 0xE0)
	{
		// west
		ny = width - regx - 1;
		nsx = length;
		nsy = width;
	}
}

// ********* Background Redrawing Function **********

// Returns the default point in bgdraw pipeline at which to redraw this object.  The
// bg draw pipeline draws the UNLIT data first (raw tile graphics/colors), then applies
// the lighting, then draws any lit graphics to the lit buffer, then copies the whole thing
// to the screen.  Objects like lights only need to refresh from the lighting stage on up,
// thus saving scads of time.
//
// This function doesn't currently check the imagery for what
int TObjectInstance::BgDrawMode()
{
	if (flags & OF_LIGHT)
		return BGDRAW_LIGHTS; 
	else if (flags & (OF_MOVING | OF_INVISIBLE | OF_SELDRAW))
		return BGDRAW_NONE;
	else return BGDRAW_UNLIT;
}

void TObjectInstance::RedrawBackground(int bgdraw)
{
  // If object is tile or light and drawn background buffers add
  // an update rectangle for the object. (moving objects not included)

	if (!(flags & OF_MOVING) &&						  // No moving objs
	    (!(flags & OF_SELDRAW) || (flags & OF_LIGHT)) // No sel objs (except lights)
		 && InventNum() < 0)						  // No objects inside another object
	{
		SRect r;
		GetScreenRect(r);
		if (bgdraw == -1)				// Use default draw pipeline flag for object
		{
			if (flags & OF_LIGHT)
				bgdraw = BGDRAW_LIGHTS; // Default to redraw from lights on up
			else
				bgdraw = BGDRAW_UNLIT;  // Default to draw from unlit on up (all)
		}
		MapPane.AddBgUpdateRect(r, bgdraw);
	}
}

// ********** Script Functions ************

void TObjectInstance::InitScript(PTScript newscr)
{
	if (objclass == OBJCLASS_TILE)
		return; // Tiles can't do scripts!!

	script = newscr;
	if (script)
	{
		flags |= OF_PULSE;			// Pulse me so script will run
		SetNotify(N_SCRIPTDELETED); // Tell us if script gets hacked
	}

	ResetScript();
}

void TObjectInstance::ResetScript()
{
	if (script)
		script->Start();
}

void TObjectInstance::ContinueScript()
{
	if (script && !(flags & OF_PAUSE))
		script->Continue(this);
}

void TObjectInstance::ScriptJump(char *label)
{
	if (script)
		script->Jump(this, label);
}

// ****************************** Parse Command ********************************

int TObjectInstance::ParseCommand(TToken &t)
{
	return CMD_BADCOMMAND;
}

// *************************** Lighting Functions *****************************

void TObjectInstance::RedrawLight()
{
	if (flags & OF_LIGHT && lightdef.intensity != 0)
	{
		SRect r;
		GetLightRect(r);
		MapPane.AddBgUpdateRect(r, BGDRAW_LIGHTS);
	}
}

void TObjectInstance::GetLightRect(RSRect r)
{
	S3DPoint wlpos = pos;
	wlpos += lightdef.pos;

	S3DPoint slpos;
	WorldToScreen(wlpos, slpos);

	r.left = slpos.x - lightdef.intensity;
	r.top = slpos.y - lightdef.intensity;
	r.right = r.left + lightdef.intensity + lightdef.intensity;
	r.bottom = r.top + lightdef.intensity + lightdef.intensity;
}

void TObjectInstance::SetLightIntensity(BYTE newintensity)
{
	if (!(flags & OF_LIGHT))
		return;

	LOCKOBJECTS;	// Prevent update system from drawing any lights right now

	BOOL bigger = newintensity > lightdef.intensity;

	if (!bigger)
		RedrawLight();

	lightdef.intensity = newintensity;

	if (lightdef.lightindex != -1)
		Scene3D.SetLightIntensity(lightdef.lightindex, lightdef.intensity);

	if (bigger)
		RedrawLight();

	UNLOCKOBJECTS; // Allow update system to draw lights now
}

void TObjectInstance::SetLightMultiplier(int mult)
{
	if (!(flags & OF_LIGHT))
		return;

	LOCKOBJECTS;	// Prevent update system from drawing any lights right now

	lightdef.multiplier = mult;

//	if (lightdef.lightindex != -1)
//		Scene3D.SetLightIntensity(lightdef.lightindex, lightdef.intensity);

	if (lightdef.lightid != -1)
	{
		FreeLightIndex(lightdef.lightid);
		lightdef.lightid = NewLightIndex(lightdef.color, lightdef.multiplier);
	}

	RedrawLight();

	UNLOCKOBJECTS; // Allow update system to draw lights now
}

void TObjectInstance::SetLightPos(RS3DPoint newpos)
{
	if (!(flags & OF_LIGHT))
		return;

	LOCKOBJECTS;	 // Prevent update system from drawing any lights right now

	RedrawLight();

	lightdef.pos = newpos;

	if (lightdef.lightindex != -1)
	{
		S3DPoint lpos = pos;
		lpos += lightdef.pos;
		Scene3D.SetLightPosition(lightdef.lightindex, lpos);
		RedrawLight();
	}

	UNLOCKOBJECTS;	 // Allow update system to draw lights now
}

void TObjectInstance::SetLightColor(SColor color)
{
	if (!(flags & OF_LIGHT) || (color.red == lightdef.color.red &&
		color.green == lightdef.color.green && color.blue == lightdef.color.blue))
		return;

	LOCKOBJECTS;	 // Prevent update system from drawing any lights right now

	lightdef.color = color;

	if (lightdef.lightindex != -1)
		Scene3D.SetLightColor(lightdef.lightindex, color);

	if (lightdef.lightid != -1)
	{
		FreeLightIndex(lightdef.lightid);
		lightdef.lightid = NewLightIndex(color, lightdef.multiplier);
	}

	RedrawLight();

	UNLOCKOBJECTS;	 // Allow update system to draw lights now
}

void TObjectInstance::DrawLight(PTSurface surface, BOOL resetid)
{
	if ((flags & OF_LIGHT) && (lightdef.intensity > 0))
	{
		if (imagery)
			imagery->DrawLight(this, surface);

		S3DPoint wlpos = pos;
		wlpos += lightdef.pos;

		S3DPoint slpos;
		WorldToScreen(wlpos, slpos);

		if (resetid || lightdef.lightid == -1)
			lightdef.lightid = NewLightIndex(lightdef.color, lightdef.multiplier);

//		if (NoNormals)
			DrawStaticLightNoNormals(slpos, lightdef.color, lightdef.intensity, surface, lightdef.lightid);
//		else if (lightdef.flags & LIGHT_DIR)
//			DrawStaticDirLight(slpos, lightdef.color, lightdef.intensity, surface, lightdef.lightid);
//		else
//			DrawStaticLight(slpos, lightdef.color, lightdef.intensity, surface, lightdef.lightid);
	}
}

// DLS brightness routine (gives brightness given distance)
extern double GetLightBrightness(int dist, int intensity, int multiplier);

// Get the amount of illumination from this light to this particular object
int TObjectInstance::GetIllumination(PTObjectInstance oi)
{
  // Not a light
	if (!(flags & OF_LIGHT) || (lightdef.intensity <= 0))
		return 0;

  // Dist from object to light (assumes char, and uses CHARHEIGHT value)
	S3DPoint p;
	oi->GetPos(p);
	p.z += LIGHTINGCHARHEIGHT;
	p -= pos;

  // Out of range
	if (abs(p.x) > lightdef.intensity || abs(p.y) > lightdef.intensity)
		return 0;

  // Get distance from light to object
	float d = (float)sqrt((double)(p.x * p.x + p.y * p.y));
	d = (float)sqrt((double)(d * d + p.z * p.z));

  // Get total brighness from dls brightness tables
	return (int)(
		min(GetLightBrightness((int)d, lightdef.intensity, lightdef.multiplier), 1.0) * 255.0);
}

// ********************** End of Light Functions ************************

void TObjectInstance::SetCommandDone(BOOL newcmd)
{
	commanddone = newcmd;
}

void TObjectInstance::SetNotify(DWORD newflags)
{
	if (newflags == 0)
		flags &= ~OF_NOTIFY;
	else
	{
		MapPane.SetNotify(newflags);	// Tells mappane there's at least one object that wants these flags
		flags |= OF_NOTIFY;				// Tell map that we want to be notified of stuff
	}
}

void TObjectInstance::Notify(int notify, void *ptr)
{
	if (notify == N_SCRIPTDELETED) // Check if we're using this script and delete it if so
	{
		if (script && script->GetScriptProto() == (PTScriptProto)ptr)
		{
			delete script;
			script = NULL;
		}
	}
	else if (notify == N_SCRIPTADDED)	// Check to see if new script matches us
	{
		if (!script && objclass != OBJCLASS_TILE) // No scripts for regular tiles
			InitScript(ScriptManager.ObjectScript(this));
	}
}

PTObjectInstance TObjectInstance::LoadObject(RTInputStream is, int version, BOOL ismap)
{
	DWORD uniqueid;
	short objversion = 0;
	short objclass;
	short objtype;
	short blocksize;
	SObjectDef def;
	BOOL forcesimple = FALSE;
	BOOL corrupted = FALSE;

	// ****** Load object block header ******

	// Get object version
	if (version >= 8)
		is >> objversion;

	if (objversion < 0)	// Objversion is the placeholder in map version 8 or above
		return NULL;

	is >> objclass;
	if (objclass < 0)	// Placeholder for empty object slot
		return NULL;

	// Check the sector map version before we read the type info
	if (version < 1)
	{
		// Version 0 - No Unique ID's, so just read the objtype directly
		is >> objtype;
		DWORD uniqueid = 0;
		blocksize = -1;		
	}
	else if (version < 4)
	{
		// Version 1 and above - Unique ID's used instead of objtype, so find
		//             the objtype given the Unique ID

		objtype = -1;
		is >> uniqueid;
		blocksize = -1;
	}
	else
	{
		// Version 4 has block size, so we can just skip over objects 
		//				we don't recognize
		objtype = -1;
		is >> uniqueid;
		is >> blocksize;
	}

	// ****** Is this object any good? ******
	
	PTObjectClass cl = TObjectClass::GetClass(objclass);
	if (!cl || !cl->ClassName())
	{
		if (Debug)
			FatalError("Object in map file has invalid class - possible file corruption");
		else if (blocksize >= 0)
		{
			is.MovePos(blocksize);	// Just quietly skip this object
			return NULL;
		}
		else						// Try to fix it by assuming its a tile
		{
			objclass = OBJCLASS_TILE;
			cl = TObjectClass::GetClass(objclass);
			corrupted = TRUE;
		}
	}

	if (objtype < 0)
	{			
		objtype = cl->FindObjType(uniqueid);

		if (objtype < 0)
		{
			// not found in this class, so check all of them
			int newobjtype, newobjclass;
			PTObjectClass newcl;
			for (newobjclass = 0; newobjclass < MAXOBJECTCLASSES; newobjclass++)
			{
				newcl = TObjectClass::GetClass(newobjclass);
				if (newcl && (newobjtype = newcl->FindObjType(uniqueid)) >= 0)
				{
					objclass = newobjclass;
					objtype = newobjtype;
					cl = newcl;
					forcesimple = TRUE;
					break;
				}
			}
		}

		if (objtype < 0)  // Still can't find type
		{
			if (Debug)
			{
				// give a more descriptive error
				char buf[80];
				sprintf(buf, "Object unique id 0x%x not found in class.def", uniqueid);
				FatalError(buf);
			}
			else if (blocksize >= 0)	// Just skip over this object
			{
				is.MovePos(blocksize);  
				return NULL;
			}
			else	  // If attempting to fix, assume type is type 0 - first type in list
			{	
				
				objtype = 0;
				corrupted = TRUE;
			}
		}
	}

	// ****** Create the object ******

	memset(&def, 0, sizeof(SObjectDef));
	def.objclass = objclass;
	def.objtype  = objtype;

	PTObjectInstance inst = cl->NewObject(&def);
	if (!inst)
		FatalError("Trouble creating loaded object (corrupted sector file?)");

	// ****** Load the object ******

  // Get start of object
	DWORD start = is.GetPos();

  // Load object and its inventory
	if (forcesimple)
		inst->TObjectInstance::Load(is, version, objversion); // Used if object changed class (for some reason)
	else
		inst->Load(is, version, objversion);				  // This should normally be used
	inst->LoadInventory(is, version);

  // Reset position to start of next object (in case object load is bad or forcesimple is true)
	if (blocksize >= 0)
		is.SetPos(start + blocksize);

  // If this object is corrupted in some way, delete it after doing load
	if (corrupted || (ismap && (inst->Flags() & OF_NONMAP)))
	{
		delete inst;
		return NULL;
	}

	return inst;
}

void TObjectInstance::SaveObject(PTObjectInstance inst, RTOutputStream os, BOOL ismap)
{

	os.MakeFreeSpace(1024); // Check for enough free space for object

  // Note: Main game sector files will not load or save players....
	if (!inst || (ismap && (inst->Flags() & OF_NONMAP)))
	{
		os << (short const)-1; // Keep empty spaces in object array
		return;
	}

	os << (short)inst->ObjVersion();// Object version id
	os << (short)inst->ObjClass();	// Class id
	os << (DWORD)inst->ObjId();		// Object id
	os << (short)0;					// Block size

	DWORD start = os.GetPos();

	inst->Save(os);
	inst->SaveInventory(os);

	DWORD end = os.GetPos();

	os.SetPos(start - 2);
	os << (short)(end - start);
	os.SetPos(end);
}

void TObjectInstance::LoadInventory(RTInputStream is, int version)
{
	if (version < 3)
		return;

	int num;
	is >> num;

	if (num > 2048) // Maddness!!  Maddness!!
	{
		_RPT1(_CRT_WARN, "Invalid inventory size for obj %s\n", this->GetName());
		return;
	}

	for (int i = 0; i < num; i++)
	{
		PTObjectInstance inst = LoadObject(is, version);
		if (inst)
		{
			inventory.Add(inst);
			inst->SetOwner(this);
		}
		else
		{
			_RPT1(_CRT_WARN, "Invalid inventory object for obj %s", this->GetName());
		}
	}
}

void TObjectInstance::SaveInventory(RTOutputStream os)
{
	int num = RealNumInventoryItems();

	os << num;

	if (num > 0)
	{
		// save them out recursively
		for (TInventoryIterator i(this); i; i++)
		{
			TObjectInstance::SaveObject(i.Item(), os);
		}
	}

}

void TObjectInstance::Load(RTInputStream is, int version, int objversion)
{
	BYTE len;
	is >> len;
	if (len > 0)
	{
		name = (char *)malloc(len + 1);
		for (int i = 0; i < len; i++)
			is >> name[i];
		name[i] = 0;
	}

	DWORD newflags;

	is >> newflags >> pos.x >> pos.y >> pos.z;

  // Make sure fixed flags remain the way they were set in the constructor
	flags = flags & OF_FIXEDFLAGS | (newflags & ~(OF_FIXEDFLAGS));
	
  // Don't load velocity vectors if not mobile
	if (version < 6 || !(flags & OF_IMMOBILE))
		is >> vel.x >> vel.y >> vel.z;
		
	is >> state;

  // Non map objects (i.e. players) store their level
  // Players are stored in the save game file, and not in the map, so we need to know what
  // level to put them in when we load them
	if (version >= 6 && (flags & OF_NONMAP))
		is >> level;
	else
		level = 0;
		
	BYTE health;
	if (version < 5)
		is >> health; // This is now an objstat
	
	if (version < 3)
	{
		BYTE dummy8;
		short dummy16;
		is >> facing >> dummy16 >> inventnum >> dummy16 >> shadow >> dummy8;

		// ignore inventories in old version
		inventnum = -1;

		// sector will set old-style indexes after object is loaded
		mapindex = -1;
	}
	else
	{
		is >> inventnum >> invindex >> shadow >> rotatex >> rotatey >> rotatez >> mapindex;
	}
	moveangle = rotatez;	// Set movement angle

	if (version < 5)  // Set up empty stat array and stick health in it
	{
		frame = 0;
		framerate = 1;
		group = 0;

		if (cl->NumObjStats() > 0)
		{
			stats.SetNumItems(cl->NumObjStats());
			for (int c = 0; c < cl->NumObjStats(); c++)
				ResetObjStat(c);
		}

		SetHealth(health);
	}
	else
	{
		if (version >= 6)
		{
			if (flags & OF_ANIMATE)
				is >> frame >> framerate;	// Save framerate and frame if animating
		}
		else
			is >> frame >> framerate;		// Version 5, always save

		is >> group;

	  // Sure stat storage is inefficient, but it's only for a few objects in the game
		if (cl->NumObjStats() > 0)
			stats.SetNumItems(cl->NumObjStats());

		BYTE numstats;
		is >> numstats;
 		if (numstats > 0)	// Note: oridnary tiles can't have stats..
		{
			int statid = 0;
			for (int st = 0; st < numstats; st++)
			{
				int stat;
				DWORD uniqueid;
				is >> stat >> uniqueid;

			  // Note: to allow us to change the stats for characters,
			  // we check the unique id of the stat and match it to our object stat array
				if (uniqueid == cl->ObjStatUniqueId(statid))
				{
					stats[statid] = stat;	// Quick case, id's all match
					statid++;
				}
				else				
				{							// Slow case.. search for id for stat
					for (int c = 0; c < cl->NumObjStats(); c++)
					{
						if (uniqueid == cl->ObjStatUniqueId(statid))
							stats[c] = stat;
					}
				}
			}
		}

	}

	if (flags & OF_LIGHT)
	{
		is >> lightdef.flags >> lightdef.pos.x >> lightdef.pos.y >> lightdef.pos.z >>
			lightdef.color.red >> lightdef.color.green >> lightdef.color.blue >>
			lightdef.intensity >> lightdef.multiplier;
	}

  // Set Object info pointer
	cl = TObjectClass::GetClass(objclass);
	if (!cl)
		FatalError("Bad object class!"); // This should never happen!!
	inf = cl->GetObjType(objtype);

  // Initialize the script (no tiles for efficiency)
	if (objclass != OBJCLASS_TILE)
		InitScript(ScriptManager.ObjectScript(this));

  // Reset inventory
	if (this == Inventory.GetContainer())
		Inventory.Update();
}

void TObjectInstance::Save(RTOutputStream os)
{
	BYTE len = strlen(name);
	os << len;
	for (int i = 0; i < len; i++)
		os << name[i];
  
  // Save general object data
	os << flags << pos.x << pos.y << pos.z;
	
	if (!(flags & OF_IMMOBILE))
		os << vel.x << vel.y << vel.z;
	
	os << state;

  // Non map objects (i.e. players) store their level
  // Players are stored in the save game file, and not in the map, so we need to know what
  // level to put them in when we load them
	if (flags & OF_NONMAP)
		os << level;
		
	os << inventnum << invindex << shadow << 
		rotatex << rotatey << rotatez << mapindex;
		
	if (flags & OF_ANIMATE)
		os << frame << framerate;
		
	os << group;

  // Save object specific stats (unique id is <=4 char code like "AMT", "TYPE", "AC")
  // Now I've got to say that the unique id thing is just pretty damn cool.  That's one
  // super tricky bit of coding there boy... wow.. what an idea.  Super groovy and all
  // that.  
	os << (BYTE)(cl->NumObjStats());
	for (int c = 0; c < cl->NumObjStats(); c++)
		os << stats[c] << cl->ObjStatUniqueId(c);

  // Save light data
	if (flags & OF_LIGHT)
		os << lightdef.flags << lightdef.pos.x << lightdef.pos.y << lightdef.pos.z <<
			lightdef.color.red << lightdef.color.green << lightdef.color.blue <<
			lightdef.intensity << lightdef.multiplier;
}

// ----------------- Flag Functions --------------

static char *flagnames[] = OBJFLAGNAMES;
#define NUMFLAGS sizearray(flagnames)

int TObjectInstance::GetNumFlags()
{
	return NUMFLAGS;
}

char *TObjectInstance::GetFlagName(int flagnum)
{
	return flagnames[flagnum];
}

int TObjectInstance::GetFlagNum(char *flagname)
{
	for (int c = 0; c < NUMFLAGS; c++)
	{
		if (!stricmp(flagnames[c], flagname))
			return c;
	}
	return -1;
}

void TObjectInstance::SetFlag(char *flagname, BOOL on)
{
	int flagnum = GetFlagNum(flagname);
	if (flagnum < 0)
		return;

	if (on)
		flags |= (1 << flagnum);
	else
		flags &= ~(1 << flagnum);
}

BOOL TObjectInstance::IsFlagSet(char *flagname)
{
	int flagnum = GetFlagNum(flagname);
	if (flagnum < 0)
		return FALSE;

	return (flags & (1 << flagnum)) != 0;
}

// ----------------- Object Instance Statistic Functions --------------

int TObjectInstance::GetStat(char *statname)
{
	int statid = cl->FindObjStat(statname);
	if (statid >= 0)
		return stats[statid];
	statid = cl->FindStat(statname);
	if (statid >= 0)
		return cl->GetStat(objtype, statid);
	return 0;
}

void TObjectInstance::SetStat(char *statname, int value)
{
	int statid = cl->FindObjStat(statname);
	if (statid >= 0)
	{
		stats[statid] = value;
		return;
	}
	statid = cl->FindStat(statname);
	if (statid >= 0)
		cl->SetStat(objtype, statid, value);
}

int TObjectInstance::GetStat(char *statname, char *str, int id)
{
	char buf[MAXNAMELEN];
	if (str && id >= 0)
	{
		sprintf(buf, "%s%d%s", statname, id, str);
		statname = buf;
	}
	else if (str)
	{
		sprintf(buf, "%s%s", statname, str);
		statname = buf;
	} 
		
	return GetStat(statname);
}

// ***********************
// * Statistic Functions *
// ***********************

// Statistic entry constructor (adds the given stat to the class)
SStatEntry::SStatEntry(PTObjectClass cl, char *statname, char *uniqueid, int statid, 
	int def, int min, int max, BOOL objstat)
{
	id = statid;
	SStatisticDef statdef;
	strncpyz(statdef.name, statname, MAXNAMELEN);
	char uid[5];
	uid[0] = uid[1] = uid[2] = uid[3] = uid[4] = 0;
	strncpyz(uid, uniqueid, 5);
	statdef.uniqueid = *(DWORD *)uid;
	statdef.def = def;
	statdef.min = min;
	statdef.max = max;
	if (objstat)
		cl->AddObjStat(statdef, id);
	else
		cl->AddStat(statdef, id);
}

// Add a new statistic
int TStatisticDefList::AddStat(SStatisticDef &newstatdef, int newid)
{
  // Statistic already exists.. update it
	for (int c = 0; c < statdefs.NumItems(); c++)
	{
		if (!stricmp(statdefs[c].name, newstatdef.name))
		{
			memcpy(&(statdefs[c]), &newstatdef, sizeof(SStatisticDef));
			return c;
		}
	}

	if (newid >= 0)
		return statdefs.Set(newstatdef, newid);

	return statdefs.Add(newstatdef);
}

BOOL TStatisticDefList::ParseStat(SStatisticDef &stat, TToken &t)
{
	char uniqueidstr[5];
	uniqueidstr[0] = uniqueidstr[1] = uniqueidstr[2] = uniqueidstr[3] = 0; 


	memset(&stat, 0, sizeof(SStatisticDef));

	if (t.Type() != TKN_TEXT && t.Type() != TKN_IDENT)
		return FALSE;
	strncpyz(stat.name, t.Text(), MAXNAMELEN);

	t.WhiteGet();
	if (t.Type() != TKN_IDENT) // Old style def
	{
		if (!Parse(t, "%d %d %d", &stat.def, &stat.min, &stat.max))
			return FALSE;

		stat.name[0] = NULL; // Eliminate all old style stats!
		return TRUE;
	}
	else
	{
		if (!Parse(t, "%5t %d %d %d", uniqueidstr, &stat.def, &stat.min, &stat.max))
			return FALSE;

		strupr(uniqueidstr);
		stat.uniqueid = *(DWORD *)uniqueidstr; // Get groovy 4 char unique id string for stats
	}

	return TRUE;
}

char *TStatisticDefList::GetStatDefString(int statid, char *buf)
{
	if ((DWORD)statid >= (DWORD)statdefs.NumItems())
		return "";

	PSStatisticDef stat = &(statdefs[statid]);

	char uniqueidstr[5];
	uniqueidstr[4] = 0;
	*(DWORD *)uniqueidstr = stat->uniqueid;

	sprintf(buf, "%s %s %d %d %d", 
		stat->name, uniqueidstr, stat->def, stat->min, stat->max);

	return buf;
}

int TStatisticDefList::FindStat(char *statname)
{
	for (TSizableIterator<SStatisticDef> i(&statdefs); i; i++)
	{
		if (stricmp(i.Item()->name, statname) == 0)
			return i.ItemNum();
	}

	return -1;
}

// ****************
// * TObjectClass *
// ****************

TObjectClass::TObjectClass(char *classname, int classid, WORD flags, PTObjectClass base)
{
	name     = classname;
	id       = classid;
	objflags = flags;
	basedon  = base;

	classes[id] = this;

	if (id >= numclasses)
		numclasses = id + 1;

	Clear();
}

TObjectClass::~TObjectClass()
{
	Clear();
}

void TObjectClass::Clear()
{
	for (int c = 0; c < objinfo.NumItems(); c++)  // Remove all object types
		RemoveType(c);

	statdefs.Clear();
	objstatdefs.Clear();
	objinfo.Clear();
}

int TObjectClass::AddType(char *name, char *imgfilename, DWORD uniqueid)
{
	PTObjectBuilder objbuilder = TObjectBuilder::GetBuilder(name);
	if (objbuilder == NULL)
		objbuilder = TObjectBuilder::GetBuilder(ClassName());
	if (uniqueid == 0)
		uniqueid = GenerateUniqueID();
	else
		uniqueid = uniqueid;
	int imageryid = TObjectImagery::RegisterImagery(imgfilename);
	if (imageryid < 0)
		return -1;

	PSObjectInfo inf = new SObjectInfo(name, objbuilder, imageryid, uniqueid);
	int objtype = objinfo.AddPtr(inf);

	inf->stats.SetNumItems(statdefs.NumStats());
	for (int i = 0; i < statdefs.NumStats(); i++)
		ResetStat(objtype, i);

	inf->objstats.SetNumItems(objstatdefs.NumStats());
	for (i = 0; i < objstatdefs.NumStats(); i++)
		ResetObjStat(objtype, i);

	classesdirty = TRUE;

	return objtype;
}

BOOL TObjectClass::RemoveType(int objtype)
{
    if ((objtype < 0) || (objtype >= objinfo.NumItems()))
        return FALSE;

    TObjectImagery::FreeImagery(objinfo[objtype].imageryid);

    objinfo.Remove(objtype);

	classesdirty = TRUE;

    return TRUE;
}

PTObjectInstance TObjectClass::NewObject(PSObjectDef objectdef)
{
	if (objectdef->pos.x < 0)
		objectdef->pos.x = 0;
	if (objectdef->pos.y < 0)
		objectdef->pos.y = 0;
	if (objectdef->pos.z < 0)
		objectdef->pos.z = 0;

	if ((DWORD)((int)((short)objectdef->objtype)) >= (DWORD)objinfo.NumItems())
		return NULL;

	if (!objinfo[objectdef->objtype].objbuilder)
		return NULL;

	objinfo[objectdef->objtype].imagery = TObjectImagery::LoadImagery(objinfo[objectdef->objtype].imageryid);

	if (!objinfo[objectdef->objtype].imagery)
		return NULL;

	PTObjectInstance inst = objinfo[objectdef->objtype].objbuilder->Build(objectdef,
		objinfo[objectdef->objtype].imagery);

	if (objectdef->objclass == OBJCLASS_TILE || objectdef->objclass == OBJCLASS_EXIT)
		inst->SetFlags(OF_IMMOBILE);

	return inst;
}

int TObjectClass::FindClass(char *name)
{
	for (int i = 0; i < numclasses; i++)
		if (classes[i] && classes[i]->name && stricmp(classes[i]->name, name) == 0)
			return i;

	return NULL;
}

int TObjectClass::FindObjType(char *objtypename, BOOL partial)
{
	for (TVirtualIterator<SObjectInfo> i(&objinfo); i; i++)
	{
		if (!i.Used())
			continue;

		if (partial)
		{
			if (abbrevcmp(objtypename, i.Item()->name) > 0)
				return i.ItemNum();
		}
		else
		{
			if (!stricmp(i.Item()->name, objtypename))
				return i.ItemNum();
		}
	}

	return -1;
}

int TObjectClass::FindObjType(DWORD uniqueid)
{
	for (TVirtualIterator<SObjectInfo> i(&objinfo); i; i++)
	{
		if (!i.Used())
			continue;

		if (i.Item()->uniqueid == uniqueid)
			return i.ItemNum();
	}

	return -1;
}

void TObjectClass::SetClassesDirty()
{
	classesdirty = TRUE;
}

// -------------------- Statistic Functions ----------------------

int TObjectClass::AddStat(SStatisticDef &newstatdef, int newid)
{
	int statid = FindStat(newstatdef.name);
	if (statid >= 0)
		return statid;
		
	statid = statdefs.AddStat(newstatdef, newid);
	if (statid < 0)
		return -1;

	for (int c = 0; c < objinfo.NumItems(); c++)
	{
		if (!objinfo.Used(c))
			continue;
		
		objinfo[c].stats.New();
		objinfo[c].stats.Set(statid, newstatdef.def);
	}

	classesdirty = TRUE;
	
	return statid;
}

void TObjectClass::DeleteStat(int statid)
{
	if ((DWORD)statid >= (DWORD)statdefs.NumStats())
		return;

	statdefs.DeleteStat(statid);

	for (int c = 0; c < objinfo.NumItems(); c++)
	{
		if (!objinfo.Used(c))
			continue;
		
		objinfo[c].stats.Collapse(statid);
	}

	classesdirty = TRUE;
}

BOOL TObjectClass::ParseNewStat(TToken &t, BOOL reload)
{
	SStatisticDef stat;

	if (!statdefs.ParseStat(stat, t))
		return FALSE;

  // Stat was eliminated
	if (stat.name[0] == NULL)
		return TRUE;

  // Make sure it doesn't already exist
	if (FindStat(stat.name) >= 0 || FindObjStat(stat.name) >= 0)
		return TRUE;

	// Only Add stats if we're NOT reloading the Class.Def
	if (!reload)
		AddStat(stat);

	return TRUE;
}

int TObjectClass::FindStatVal(int statid, int searchvalue)
{
	for (TVirtualIterator<SObjectInfo> i(&objinfo); i; i++)
	{
		if (!i.Used())
			continue;

		if (i.Item()->stats[statid] == searchvalue)
			return i.ItemNum();
	}

	return -1;
}

int TObjectClass::FindRandStatVal(int statid, int searchvalue, int *heightflux)
// This thing is designed exclusively for the use of the editor's map generator.
{
	int foundlist[64];
	int numfound = 0;
	int closest = 0, thisone;
	DWORD mask;

	if (heightflux)
		*heightflux = 0;

	for (TVirtualIterator<SObjectInfo> i(&objinfo); i; i++)
	{
		if (!i.Used())
			continue;

		DWORD value = i.Item()->stats[statid];

		// build a mask based on the wildcards in the stat value
		mask = 0;
		thisone = 0;
		if (value & 0xF0000000)
		{
			mask |= 0xFF000000;
			thisone++;
		}
		if (value & 0xF00000)
		{
			mask |= 0xFF0000;
			thisone++;
		}
		if (value & 0xF000)
		{
			mask |= 0xFF00;
			thisone++;
		}
		if (value & 0xF0)
		{
			mask |= 0xFF;
			thisone++;
		}

		if (thisone >= closest)
		{
			if (value == (searchvalue & mask))
			{
				if (thisone == closest)
					foundlist[numfound++] = i.ItemNum();
				else
				{
					foundlist[0] = i.ItemNum();
					numfound = 1;
				}

				closest = thisone;
				if (heightflux)
					*heightflux = 0;
			}
			else if (mask != 0xFFFFFFFF && heightflux)
			{
				int base = 1000;
				for (int j = 0; j < 4; j++)
				{
					if (value & (0xF0 << (j * 8)))
					{
						int v = (value >> (j * 8)) & 0x0F;

						if (v < base)
							base = v;
					}
				}

				if (base < 0xF)
				{
					for (DWORD b = 1; b <= 1/*base*/; b++)
					{
						DWORD v = value;
						for (int j = 0; j < 4; j++)
							if (v & (0xF0 << (j * 8)) && ((v >> (j * 8)) & 0x0F) >= b)
								v -= b << (j * 8);

						if (v == (searchvalue & mask))
						{
							if (thisone == closest)
								foundlist[numfound++] = i.ItemNum();
							else
							{
								foundlist[0] = i.ItemNum();
								numfound = 1;
							}

							closest = thisone;
							if (heightflux)
								*heightflux = b;
						}
					}
				}
			}
		}
	}

	if (numfound > 0)
		return foundlist[random(0, numfound - 1)];

	return -1;
}

int TObjectClass::AddObjStat(SStatisticDef &newstatdef, int newid)
{
  // MAKE SURE WE DON'T ABUSE THE STAT SYSTEM BY ADDING STATS TO TILES
	if (id == OBJCLASS_TILE)
		FatalError("Tile objects can't have object statistics (DUMMY)!");

	int statid = FindObjStat(newstatdef.name);
	if (statid >= 0)
		return statid;
		
	statid = objstatdefs.AddStat(newstatdef, newid);
	if (statid < 0)
		return -1;

	for (int c = 0; c < objinfo.NumItems(); c++)
	{
		if (!objinfo.Used(c))
			continue;
		
		objinfo[c].objstats.New();
		objinfo[c].objstats.Set(statid, newstatdef.def);
	}

	if (MapPane.IsOpen()) // Reset id's only if map is currently active
	{
		for (TMapIterator i; i; i++)
		{
			if (i.Item()->ObjClass() == id)
				i.Item()->SetObjStat(statid, newstatdef.def);
		}
	}

	classesdirty = TRUE;
	
	return statid;
}

void TObjectClass::DeleteObjStat(int statid)
{
	if ((DWORD)statid >= (DWORD)objstatdefs.NumStats())
		return;

	objstatdefs.DeleteStat(statid);

	for (int c = 0; c < objinfo.NumItems(); c++)
	{
		if (!objinfo.Used(c))
			continue;
		
		objinfo[c].objstats.Collapse(statid);
	}

	if (MapPane.IsOpen()) // Reset id's only if map is currently active
	{
		for (TMapIterator i; i; i++)
		{
			if (i.Item()->ObjClass() == id)
				i.Item()->DelStat(statid);
		}
	}

	classesdirty = TRUE;
}

BOOL TObjectClass::ParseNewObjStat(TToken &t, BOOL reload)
{
	SStatisticDef stat;

	if (!objstatdefs.ParseStat(stat, t))
		return FALSE;

  // Stat was eliminated
	if (stat.name[0] == NULL)
		return TRUE;

  // Make sure it doesn't already exist
	if (FindStat(stat.name) >= 0 || FindObjStat(stat.name) >= 0)
		return TRUE;

	// Only Add stats if we're NOT reloading the Class.Def
	if (!reload)
		AddObjStat(stat);

	return TRUE;
}

void TObjectClass::CopyStats(PTObjectClass from)
{
	int c;
	for (c = 0; c < basedon->NumStats(); c++)
		AddStat(*from->GetStatisticDef(c), c);
	for (c = 0; c < basedon->NumObjStats(); c++)
		AddObjStat(*from->GetObjStatisticDef(c), c);
}

// -------------------- Statistic Functions ----------------------

BOOL TObjectClass::LoadClasses(BOOL lock, BOOL reload)
{
	char fname[MAX_PATH];
	FILE *classfp;
	struct _stat st;

	sprintf(fname, "%sclass.def", ClassDefPath);

	classfp = TryOpen(fname, lock ? "w+" : "r");
	if (classfp == NULL)
		return FALSE;

	TFileParseStream s(classfp, fname);
	TToken t(s);

  // Attempt to quickload headers (if IMAGERY.DAT file is older than CLASS.DEF)
  // Note: might be nice to quickly do a date/time stamp search of the IMAGERY directory
  // and use the lastest time stamp from that.
	if (!NoQuickLoad && !reload)
	{
		_fstat(fileno(classfp), &st);
		TObjectImagery::QuickLoadHeaders(st.st_mtime);
	}

  // Now get first token...	
	t.LineGet();

	// See if they are reloading the Class.Def
	if (reload)
	{
		WORD tmp;

		// Read in the Unique Type ID into a tmp variable
		if (!Parse(t, "Unique Type ID = %d", &tmp))
			FatalError("Reading Unique Type ID from class.def");

		// Compare it against the UniqueTypeID that the program has already been
		// using and use whichever is larger
		if ((tmp > UniqueTypeID) || ((tmp < 32000) && (UniqueTypeID > 32000)))
			UniqueTypeID = tmp;
	}
	else
	{
		// Read in the Unique Type ID
		if (!Parse(t, "Unique Type ID = %d", &UniqueTypeID))
			FatalError("Reading Unique Type ID from class.def");
	}
	t.LineGet();


	do
	{
		if (t.Type() == TKN_RETURN || t.Type() == TKN_WHITESPACE)
			t.LineGet();

		if (t.Is("CLASS"))
		{
			if (!ParseClass(t, reload))
				return FALSE;
		}
		else
		{
			Error("Script identifier expected in class.def.");
			return FALSE;
		}

	} while (t.Type() != TKN_EOF);

	if (!lock)
		fclose(classfp);

	classesdirty = FALSE;

	return TRUE;
}

BOOL TObjectClass::SaveClasses(BOOL lock)
{
	if (!classesdirty)
		return TRUE;

	char fname[MAX_PATH];
	char bakname[MAX_PATH];
	char newname[MAX_PATH];
	FILE *classfp;

	// Reload the Class.Def to read any types that have been added since we
	// loaded it
	if (LoadClasses(FALSE, TRUE) == FALSE)
		return FALSE;

	sprintf(fname, "%sClass.Def", ClassDefPath);
	sprintf(bakname, "%sClass.Bak", ClassDefPath);
	sprintf(newname, "%sClass.New", ClassDefPath);

	// Try to open the file
	classfp = TryOpen(newname, "w+");

	// If the file didn't open, then return with failure
	if (classfp == NULL)
		return FALSE;

	fprintf(classfp, "// ********* Revenant Class Def Save File ********\n"
	            "// -----------------------------------------------\n\n"
				"// Revenant - Copyright 1998 Cinematix Studios, Inc.\n\n");

	fprintf(classfp, "Unique Type ID = 0x%04x\n\n", UniqueTypeID);

	for (int i = 0; i < numclasses; i++)
	{
		PTObjectClass cl = classes[i];
		if (cl)
			if (!cl->WriteClass(classfp))
				return FALSE;
	}

	if (!lock)
	{
		fclose(classfp);

		// Delete the Class.Bak file (if it exists)
		if (TryDelete(bakname) == FALSE)
			return FALSE;

		// Rename Class.Def to Class.Bak
		if (TryRename(fname, bakname) == FALSE)
			return FALSE;

		// Rename Class.New to Class.Def
		if (TryRename(newname, fname) == FALSE)
			return FALSE;
	}

	classesdirty = FALSE;

	return TRUE;
}

void TObjectClass::FreeClasses()
{
	for (int c = 0; c < numclasses; c++)
	{
		if (classes[c])
			classes[c]->Clear();
	}
}

BOOL TObjectClass::WriteClass(FILE *fp)
{
	// header
	fprintf(fp, "CLASS \"%s\"\nBEGIN\n\n", name);
	char buf[80];

	// stats
	if (statdefs.NumStats() > 0)
	{
		fprintf(fp, "\n\t// Stat Defs: <StatName> <FourCharId> <Default> <Min> <Max>\n\tSTATS\n\tBEGIN\n");

		for (int c = 0; c < statdefs.NumStats(); c++)
			fprintf(fp, "\t\t%s\n", statdefs.GetStatDefString(c, buf));

		fprintf(fp, "\tEND\n\n");
	}

	// object stats
	if (objstatdefs.NumStats() > 0)
	{
		fprintf(fp, "\n\t// Stat Defs: <StatName> <FourCharId> <Default> <Min> <Max>\n\tOBJSTATS\n\tBEGIN\n");

		for (int c = 0; c < objstatdefs.NumStats(); c++)
			fprintf(fp, "\t\t%s\n", objstatdefs.GetStatDefString(c, buf));

		fprintf(fp, "\tEND\n\n");
	}

	// types
	if (objinfo.NumItems() > 0)
	{
		fprintf(fp, "\n\tTYPES\n\tBEGIN\n");

		int objtype = 0;
		for (TVirtualIterator<SObjectInfo> o(&objinfo); o; o++, objtype++)
		{
			if (!o.Item() || !o.Used())
				continue;

			PSImageryEntry ie = TObjectImagery::GetImageryEntry(o.Item()->imageryid);
			if (!ie)
				continue;

			char *filename = ie->filename;

			if (strncmp(filename, "IMAGERY", 7) == 0)
			{
				int id = atoi(filename + 8);
				fprintf(fp, "\t\t\"%s\" %03d 0x%08x", o.Item()->name, id, o.Item()->uniqueid);
			}
			else
				fprintf(fp, "\t\t\"%s\" \"%s\" 0x%08x", o.Item()->name,
					filename, o.Item()->uniqueid);

			if (statdefs.NumStats() > 0)
			{
				int c;
				BOOL firsttime;

				fprintf(fp, " {");
				firsttime = TRUE;
				for (c = 0; c < statdefs.NumStats(); c++)
				{
					if (!firsttime)
						fprintf(fp, ",");

					fprintf(fp, "%d", (int)objinfo[objtype].stats[c]);
					firsttime = FALSE;
				}
				fprintf(fp, "}");

				fprintf(fp, " {");
				firsttime = TRUE;
				for (c = 0; c < objstatdefs.NumStats(); c++)
				{
					if (!firsttime)
						fprintf(fp, ",");

					fprintf(fp, "%d", (int)objinfo[objtype].objstats[c]);
					firsttime = FALSE;
				}
				fprintf(fp, "}");
			}

			fprintf(fp, "\n");
		}

		fprintf(fp, "\tEND\n\n");
	}

	if (fprintf(fp, "END\n\n") < 1)
		return FALSE;

	return TRUE;
}

BOOL TObjectClass::ParseClass(TToken &t, BOOL reload)
{
	_CrtMemState memstate;

	t.WhiteGet();
	if (t.Type() != TKN_TEXT)
	{
		Error("Expecting class name");
		return FALSE;
	}

	PTObjectClass cl = TObjectClass::GetClass(TObjectClass::FindClass(t.Text()));
	if (!cl)
	{
		_RPT1(_CRT_ASSERT, "Class %s not found", t.Text());
		t.LineGet();
		if (!t.SkipBlock())
			Error("Unexpected EOF");
		return TRUE;
	}

	t.LineGet();
	t.DoBegin();

  // Copy the base class's hard coded stats
	if (cl->basedon)
		cl->CopyStats(cl->basedon);

	while (!t.IsEnd())
	{
		_CrtMemCheckpoint(&memstate);

		if (t.Type() == TKN_EOF)
			Error("Unexpected EOF");

		if (t.Type() != TKN_IDENT)
		{
			t.WhiteGet();
			continue;
		}

	  // Get class stats
		if (t.Is("STATS"))
		{
			char *staterr = "Parsing class.def: STATS";

			t.LineGet();
			t.DoBegin();
			while (!(t.Type() == TKN_KEYWORD && t.Code() == KEY_END))
			{
				if (!cl->ParseNewStat(t, reload))
					t.Error(staterr);
				t.LineGet();
			}
			t.DoEnd();

			if (!_CrtCheckMemory())
			{
				_CrtMemDumpAllObjectsSince(&memstate);
				_RPT0(_CRT_ERROR, "Memory Error");
			}

		}

	  // Get object stats
		else if (t.Is("OBJSTATS"))
		{
			char *staterr = "Parsing class.def: OBJSTATS";

			t.LineGet();
			t.DoBegin();
			while (!(t.Type() == TKN_KEYWORD && t.Code() == KEY_END))
			{
				if (!cl->ParseNewObjStat(t, reload))
					t.Error(staterr);
				t.LineGet();
			}
			t.DoEnd();

			if (!_CrtCheckMemory())
			{
				_CrtMemDumpAllObjectsSince(&memstate);
				_RPT0(_CRT_ERROR, "Memory Error");
			}

		}
		else if (t.Is("TYPES"))
		{
			_CrtMemCheckpoint(&memstate);

			t.LineGet();
			t.DoBegin();
			while (!(t.Type() == TKN_KEYWORD && t.Code() == KEY_END))
			{
				char filename[MAXIMFNAMELEN];
				char name[MAXNAMELEN];
				int objtype;
				BOOL newtype = FALSE;
				DWORD uniqueid;

				strcpy(name, t.Text());

				if (t.Type() != TKN_TEXT)
					t.Error("Parsing class.def: TYPES (header)");

				t.WhiteGet();
				if (t.Type() == TKN_NUMBER)
				{
					sprintf(filename, "IMAGERY.%03d", t.Index());
				}
				else if (t.Type() == TKN_TEXT)
					strcpy(filename, t.Text());
				else
					t.Error("Parsing class.def: TYPES (imagery)");

				t.WhiteGet();

				// Get the Unique ID for this type
				if (t.Type() != TKN_NUMBER)
					t.Error("Missing Unique ID in class.def: TYPES (imagery)");
				else
				{
					if (!Parse(t, "%d", &uniqueid))
						t.Error("Parsing Unique ID in class.def: TYPES (imagery)");
				}

				// See if we are reloading the Class.Def
				if (reload)
				{
					// See if the type already exists
					objtype = cl->FindObjType(name);

					if (objtype == -1)
					{
						// It doesn't exist, so add it
						newtype = TRUE;

						objtype = cl->AddType(name, filename, uniqueid);
					}
				}
				else
				{
					objtype = cl->AddType(name, filename, uniqueid);
				}

				if (objtype < 0)
				{
					while (t.Type() != TKN_RETURN && t.Type() != TKN_EOF)
						t.Get();
					t.LineGet();
					continue;
				}
				
				int statid, value;

				char *typestaterr = "Parsing class.def: TYPES (stats)";

			 // Parse old style statistic list
				while (t.Type() != TKN_RETURN && !t.Is("{"))
				{
					char statname[80];

					if (!Parse(t, "%t = %d", statname, &value))
						t.Error(typestaterr);

					if ((!reload) || (newtype))
					{
						statid = cl->FindStat(statname);
						if (statid >= 0)
							cl->SetStat(objtype, statid, value);
						else
						{
							statid = cl->FindObjStat(statname);
							if (statid >= 0)
								cl->SetObjStat(objtype, statid, value);
						}
//						if (statid < 0)
//							Error("Invalid stat '%s'", statname);
					}

				}

			 // Parse class statistics
				if (t.Is("{")) // Use bracket style class def stat list
				{
					int statid = 0;
					t.WhiteGet();
				
					while (!t.Is("}") && statid < cl->NumStats())
					{
						int value;
						
						if (!Parse(t, "%i", &value))
							t.Error(typestaterr);
						
						if (!reload)
						{
							cl->objinfo[objtype].stats.New();
							cl->objinfo[objtype].stats[statid] = value;
						}

						statid++;
		
						if (t.Is(","))
							t.WhiteGet();

					}
					
					while (!t.Is("}") && !(t.Type() == TKN_RETURN || t.Type() == TKN_EOF))
					{
						t.WhiteGet(); // Skip any extra stats on list without erroring (just in case)

					}

					if (!t.Is("}"))
						t.Error(typestaterr);

					t.WhiteGet();
				}

			  // Parse object statistics
				if (t.Is("{")) // Do object Use bracket style class def stat list
				{
					int statid = 0;
					t.WhiteGet();
				
					while (!t.Is("}") && statid < cl->NumObjStats())
					{
						int value;
						
						if (!Parse(t, "%i", &value))
							t.Error(typestaterr);
						
						if (!reload)
						{
							cl->objinfo[objtype].objstats.New();
							cl->objinfo[objtype].objstats[statid] = value;
						}

						statid++;
		
						if (t.Is(","))
							t.WhiteGet();

					}
					
					while (!t.Is("}") && !(t.Type() == TKN_RETURN || t.Type() == TKN_EOF))
					{
						t.WhiteGet(); // Skip any extra stats on list without erroring (just in case)

					}

					if (!t.Is("}"))
						t.Error(typestaterr);

					t.WhiteGet();

				}

				t.LineGet();
			}
			t.DoEnd();

			if (!_CrtCheckMemory())
			{
				_CrtMemDumpAllObjectsSince(&memstate);
				_RPT0(_CRT_ERROR, "Memory Error");
			}
		}
		else
		{
			Error("Expecting STATS or TYPES for class %s", cl->ClassName());
			return FALSE;
		}
	}

	t.DoEnd();

	return TRUE;
}

// GenerateUniqueID.
//------------------------------------------------------------------------------
// This will return a Unique ID used for specifying unique object
// types.  The number is generated as follows:
//
// (high word) (high byte) = Random #
// (high word) (low  byte) = Low byte of Current Time (tick count)
// (low  word)             = UniqueTypeID stored in Class.Def
//
// UniqueTypeID is incremented on every call.

DWORD GenerateUniqueID()
{
	DWORD UniqueID;
	DWORD r = (DWORD)random(0, 255);
	DWORD t = GetTickCount() & 255;

	UniqueID = (r << 24) | (t << 16) | UniqueTypeID;

	UniqueTypeID++;

	return UniqueID;
}

// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *               parse.cpp - Low-level file parsing functions            *
// *************************************************************************

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <ctype.h>

#include "revenant.h"
#include "parse.h"

#ifdef _WINDOWS_
#error WINDOWS.H shouldn't be included here!
#endif

// **************************************
// * Identifiers - Array of identifiers *
// **************************************

TIdent::TIdent()
{
	idents = NULL;
 	numidents = 0;
}

TIdent::~TIdent()
{
	if (idents)
		delete idents;
}

Ident *TIdent::Find(char *text, int type)
{
	for (int c = 0; c < numidents; c++)
	{
		if (!strcmp(text, idents[c].ident) && type == idents[c].type)
		return &(idents[c]);
	}
	return NULL;
}

int TIdent::FindIndex(char *text, int type)
{
	for (int c = 0; c < numidents; c++)
	{
		if (!strcmp(text, idents[c].ident) && type == idents[c].type)
		return c;
	}
	return -1;
}

int TIdent::Add(char *ident, int type, int value)
{
	if (!idents)
		idents = new Ident[MAXIDENTS];
	if (!idents)
		FatalError("FATAL ERROR: Couldn't allocate identifier buffer\n");

	if (numidents + 1 > MAXIDENTS)
		return -1;

	strcpy(idents[numidents].ident, ident);
    idents[numidents].type = type;
	idents[numidents].value = value;

	numidents++;

	return numidents - 1;
}

// ************************
// * TToken - Token class *
// ************************

// Defs for parsing the object scripts
#define NUMKEYWORDS		4

char *keywords[NUMKEYWORDS] =
{
	"BEGIN",
	"END",
	"#define",
	"#include"
};

void TToken::Get()
{
	char ch;
	int c;
	int pos;

	if (lastch)
	{
		ch = lastch;
		lastch = 0;
	}
	else ch = stream->GetChar();

	while (ch == 0xD)				// skip CR altogether, \n will be line terminator
		ch = stream->GetChar();

  // Line continuation char
	if (ch == '\\')
	{
		while (ch != '\n' && ch != EOF)
			ch = stream->GetChar();
		if (ch == '\n')
		{
			linenum++;
        	ch = stream->GetChar();
		}
	}

  // End of file
	if (ch == EOF)
	{
		text[0] = NULL;
		type = TKN_EOF;
		return;
	}

  // Remark
	else if (ch == '/')
	{
		lastch = stream->GetChar();
		if (lastch == '/')
		{
			while (lastch != '\n' && lastch != EOF)
				lastch = stream->GetChar();
			lastch = 0;
			type = TKN_RETURN;
			text[0] = '\n';
			text[1] = NULL;
			linenum++;
			return;
		}
		else if (lastch == '*')
		{
			lastch = stream->GetChar();
			do
			{
			  while (lastch != '*' && lastch != EOF)
				lastch = stream->GetChar();
			  lastch = stream->GetChar();
			} while (lastch != '/' && lastch != EOF);
			lastch = stream->GetChar();
		}
		else
		{
			type = TKN_SYMBOL;
			code = ch;
			text[0] = ch;
			text[1] = NULL;
			type = TKN_SYMBOL;
			return;
		}
		type = TKN_WHITESPACE;
		index = 0;
		pos = 0;
		return;
	}

  // Whitespace
	else if ((ch == ' ') || (ch == '\t'))
	{
		type = TKN_WHITESPACE;
		index = 0;
		pos = 0;
		text[pos++] = ch;
		do
		{
			ch = stream->GetChar();
			if (pos < MAXTOKENTEXT - 1)
				text[pos++] = ch;
		}
		while ((ch == ' ') || (ch == '\t'));
		text[pos] = 0;
		lastch = ch;
		return;
	}

  // Return
	else if (ch == '\n')
	{
		type = TKN_RETURN;
		text[0] = '\n';
		text[1] = NULL;
		linenum++;
		return;
	}


  // Text
	else if (ch == '\"')
	{
		pos = 0;
moretext:
		ch = stream->GetChar();
		while (ch != EOF && ch != '\"' && ch != '\n')
		{
			if (pos >= MAXTOKENTEXT - 1)
				Error("String too long");
			if (ch == '\\')
			{
				ch = stream->GetChar();
				if (ch == 'n')
				{
					text[pos++] = '\n';
					ch = stream->GetChar();
				}
				else
					text[pos++] = '\\';
			}
			else
			{
				text[pos++] = ch;
				ch = stream->GetChar();
			}
		}
		/*
		if (ch != '\"')
			Error("ERROR: Unterminated string");
		*/
		lastch = stream->GetChar();
		if (lastch == '\\')
		{
			while (lastch != '\n' && lastch != EOF)
				lastch = stream->GetChar();
			do
			{
				ch = stream->GetChar();  // Skip whitespace (note, will not return a whitespace token)
			}
			while ((ch == ' ') || (ch == '\t'));
			lastch = ch;
			if (ch == '\"')                  // Skip
				goto moretext;
		}
		text[pos] = NULL;
		type = TKN_TEXT;
		index = pos;
		return;
	}

  // Identifier or keyword
	else if ((toupper(ch) >= 'A' && toupper(ch) <= 'Z') || ch == '#')
	{
		char upch;
		pos = 0;
		if (ch == '#')
		{
			text[pos++] = ch;
			ch = stream->GetChar();
			if (toupper(ch) < 'A' || toupper(ch) > 'Z')
			{
				type = TKN_SYMBOL;
				code = '#';
				text[1] = NULL;
				lastch = ch;
				return;
			}
        }
		do
		{
			text[pos++] = ch;
			ch = stream->GetChar();
			upch = toupper(ch);
		} while ((upch >= 'A' && upch <= 'Z') ||
		  (ch >= '0' && ch <= '9') ||
		  (ch == '_'));
		text[pos] = NULL;
		lastch = ch;

	  // Find keyword
		for (c = 0; c < NUMKEYWORDS; c++)
		{
			if (!stricmp(text, keywords[c]))
			{
				type = TKN_KEYWORD;
				code = c;
				return;
			}
		}

	  // Find identifer
		c = idents.FindIndex(text);
		if (c >= 0)
		{
			type = TKN_DEFINE;
			code = idents.Get(c)->value;
            number = code;
			index = c;
			return;
		}
		else
		{
			type = TKN_IDENT;
			code = -1;
			number = 0;
			index = -1;
			return;
		}
	}

  // Number
	else if ((ch >= '0' && ch <= '9') || (ch == '-'))
	{
		pos = 0;
        int numdec = 0;
        BOOL ishex = FALSE;

      // Check for HEX
		if (ch == '0')
		{
			text[pos++] = ch;
			ch = stream->GetChar();
			if (ch == 'x')
			{
                ishex = TRUE;
				text[pos++] = ch;
				ch = stream->GetChar();
                number = 0;
				while ((ch >= '0' && ch <= '9') ||
					(ch >= 'A' && ch <= 'F') ||
					(ch >= 'a' && ch <= 'f'))
                {
					ch = toupper(ch);
					if (ch <=  '9') number = number * 16 + ch - '0';
					  else number = number * 16 + 10 + ch - 'A';
					text[pos++] = ch;
					ch = stream->GetChar();
				}
				if (pos <= 2)
					Error("Invalid HEX constant"); 
				text[pos] = NULL;
			}
        }

      // Hey.. it's not HEX
		if (!ishex)
        {
			if (ch == '-')
			{
				text[pos++] = ch;
				ch = stream->GetChar();
				if (!(ch >= '0' && ch <= '9'))
				{
                    lastch = ch;
					type = TKN_SYMBOL;
					text[1] = NULL;
                    return;
				}
			}
			while ((ch >= '0' && ch <= '9') || (ch == '.' && numdec <= 1))
			{
				text[pos++] = ch;
				ch = stream->GetChar();
				if (ch == '.') numdec++;
			}
			text[pos] = NULL;
			number = atof(text);
		}

		lastch = ch;
		type = TKN_NUMBER;
		index = (int)number;
		return;
	}

  // Symbol
	else if ((ch > ' ') && (ch <= '~'))
	{
		type = TKN_SYMBOL;
		code = ch;
		text[0] = ch;
		text[1] = NULL;
		return;
	}

  // Invalid Character
	else
	{
		char chr[2];
		chr[0] = ch;
		chr[1] = NULL;
		Error("Invalid character '%s'", chr);

		return;
	}
}

BOOL TToken::DefineGet()
{
	LineGet();
	while (type == TKN_KEYWORD && code == KEY_DEFINE)
	{
		WhiteGet();
		char name[MAXIDENTLEN];
		int val;
		if (!Parse(*this, "%32t %d", name, &val)) 
			return FALSE;
		
		if (idents.Add(name, val) < 0)
			return FALSE;

		LineGet();
	}

	return TRUE;
}

void TToken::WhiteGet()
{
	Get();
	if (type == TKN_WHITESPACE) Get();
}

void TToken::LineGet()
{
	Get();
	while (type == TKN_WHITESPACE || type == TKN_RETURN)
		Get();
}

void TToken::SkipLine()
{
	while (type != TKN_RETURN && type != TKN_EOF)
		Get();
	Get();
}

BOOL TToken::SkipBlock()
{
	int skipdepth = 0;

	if (Type() == TKN_EOF)
		return FALSE;

	if (Type() == TKN_KEYWORD)
	{
		if (Code() == KEY_BEGIN)
			skipdepth++;
		else if (Code() == KEY_END)
			skipdepth--;
	}

	while (skipdepth)
	{
		Get();
		SkipBlanks();

		if (Type() == TKN_EOF)
		{
			if (skipdepth)
				return FALSE;
			else
				break;
		}

		if (Type() == TKN_KEYWORD)
		{
			if (Code() == KEY_BEGIN)
				skipdepth++;
			else if (Code() == KEY_END)
				skipdepth--;
		}

		while (Type() != TKN_RETURN && Type() != TKN_EOF)
			Get();

		if (Type() == TKN_EOF)
		{
			if (skipdepth)
				return FALSE;
			else
				break;
		}
	}

	return TRUE;
}

void TToken::SkipBlanks()
{
	while (type == TKN_WHITESPACE || type == TKN_RETURN)
		Get();
}

int abbrevcmp(char *abbrev, char *string)
// A string compare which allows abbreviation, ie abbrev = "fors" and
// string = "forsaken" would return 4.
{
	int i;

	for (i = 0; *abbrev && *string; string++, abbrev++, i++)
		if (tolower(*abbrev) != tolower(*string))
			return 0;

	if (*abbrev && *string == 0)
		return 0;

	return i;
}

BOOL TToken::Is(char *istext, int abbrevlen)
{
	if (abbrevlen)
		return (abbrevcmp(text, istext) >= abbrevlen);

	return (stricmp(istext, text) == 0);
}

void TToken::DoBegin()
{
	if (Type() != TKN_KEYWORD || Code() != KEY_BEGIN)
		Error("BEGIN Expected!");
	WhiteGet();
	if (Type() != TKN_RETURN)
		Error("RETURN Expected!");
	LineGet();
}

void TToken::DoEnd()
{
	if (Type() != TKN_KEYWORD || Code() != KEY_END)
		Error("END Expected!");
	WhiteGet();
	if (Type() != TKN_RETURN)
		Error("RETURN Expected!");
	LineGet();
}

void TToken::Error(char *err, char *extra)
{
	char buf[100];
	sprintf(buf, "Error in file %s line %d: ", stream->Name(), linenum);
	int len = strlen(buf);
	sprintf(buf + len, err, extra);
	FatalError(buf);
}

// **************************************************
// * Parse - Parses and sets variables (like scanf) *
// **************************************************

BOOL ParseAnything(BOOL stack, TToken &t, char *format, va_list ap)
{
	char *f = format;
	char keyword[41];
	int i, len;
	char *p;
	char **from = &p;

	if (!stack)
		from = va_arg(ap, char **);

	while (*f)
	{
		switch (*f)
		{

		// Spaces
		  case ' ':
		  case '\t':
		  {
			f++;
			break;
		  }

		// Continue to next line without using backslash (WHITESPACE INCLUDING RETURNS)
		  case '\\':
		  {
			f++;
			while (t.Type() == TKN_RETURN)
				t.LineGet();
			break;
		  }

		// Return
		  case '\n':
		  {
			if (t.Type() != TKN_RETURN)
				return FALSE;
			f++;
			t.LineGet();
			break;
		  }

		// Optional
		  case '<':
		  {
			f++;
			i = 0;
			while (*f && isalnum(*f))
				keyword[i++] = toupper(*f++);
			keyword[i] = NULL;
			if ((t.Type() != TKN_KEYWORD && t.Type() != TKN_IDENT)
			  || stricmp(keyword, t.Text()))
			{
				if (*f == '>') // If no parameters to keyword, treat it as a boolean
				{
					if (stack)
						*va_arg(ap,BOOL *) = (BOOL)FALSE;
					else
						*((BOOL *)(*from)++) = (BOOL)FALSE;

					f++;
				}
				else
				{
					while (*f && *f != '>')
					{
						if (*f == '%')
						{

						  // Get Len
							f++;
							if (isdigit(*f))
							{
								len = 0;
								while (isdigit(*f))
									len = len * 10 + *f++ - '0';
							} else len = 0;

							switch (*f)
							{
							  case 'b':
								if (stack)
									*va_arg(ap,unsigned char *) = (BYTE)t.Index();
								else
									*(unsigned char **)from += 1;
								break;
							  case 'h':
								if (stack)
									va_arg(ap,short *);
								else
									*(short **)from += 1;
								break;
							  case 'w':
								if (stack)
								{
									*va_arg(ap,WORD *) = (WORD)t.Index();
									t.WhiteGet();
								}
								else
									*(WORD **)from += 1;
								break;
							  case 'i':
								if (stack)
								{
									*va_arg(ap,long *) = t.Index();
									t.WhiteGet();
								}
								else
									*(long **)from += 1;
								break;
							  case 'd':
								if (stack)
								{
									*va_arg(ap,DWORD *) = t.Index();
									t.WhiteGet();
								}
								else
									*(DWORD **)from += 1;
								break;
							  case 'f':
								if (stack)
									va_arg(ap,double *);
								else
									*(double **)from += 1;
								break;
							  case 's':
							  case 't':
								if (stack)
									va_arg(ap,char *);
								else
									*from += len + 1;
								break;
							  case '#':
								if (stack)
									va_arg(ap,BYTE *);
								else
									*from += 4;
								break;
							  case '$':
								if (stack)
									va_arg(ap,BYTE *);
								else
									*from += 2;
								break;
							}
						}
						f++;
					}
				}
			}
			else
			{
				if (*f == '>') // If no parameters to keyword, treat it as a boolean
				{
					if (stack)
						*va_arg(ap,BOOL *) = (BOOL)TRUE;
					else
					{
						**(BOOL **)from = (BOOL)TRUE;
						*(BOOL **)from += 1;
					}
					f++;
				}

				t.WhiteGet();
			}

			break;
		  }

		// End Optional
		  case '>':
		  {
			f++; // Ignore end optional
			break;
		  }

		// Value
		  case '%':
		  {
			f++;
			if (isdigit(*f))
			{
				len = 0;
				while (isdigit(*f))
					len = len * 10 + *f++ - '0';
			} else len = 0;

			char *str;
			switch (*f)
			{

			// Number
			  case 'b':
			  case 'h':
			  case 'w':
			  case 'i':
			  case 'd':
			  case 'f':
			  {
				if (t.Type() != TKN_NUMBER && t.Type() != TKN_DEFINE && t.Type() != TKN_SCENEID)
					return FALSE;
				double n = t.Number();
				t.WhiteGet();

				DWORD d;
				if (*f != 'f')
				{
					d = (DWORD)n;
					while (t.Type() == TKN_SYMBOL && (t.Text())[0] == '|')
					{
						t.WhiteGet();
						if (t.Type() != TKN_NUMBER && t.Type() != TKN_DEFINE && t.Type() != TKN_SCENEID)
							return FALSE;
						d |= (DWORD)t.Number();
						t.WhiteGet();
					}
				}

				switch (*f)
				{
				  case 'c':
					if (stack)
						*va_arg(ap,signed char *) = (signed char)d;
					else
					{
						**(signed char **)from = (signed char)d;
						*(signed char **)from += 1;
					}
					break;
				  case 'b':
					if (stack)
						*va_arg(ap,unsigned char *) = (unsigned char)d;
					else
					{
						**(unsigned char **)from = (unsigned char)d;
						*(unsigned char **)from += 1;
					}
					break;
				  case 'h':
					if (stack)
						*va_arg(ap,short *) = (short)d;
					else
					{
						**(short **)from = (short)d;
						*(short **)from += 1;
					}
					break;
				  case 'w':
					if (stack)
						*va_arg(ap,WORD *) = (WORD)d;
					else
					{
						**(WORD **)from = (WORD)d;
						*(WORD **)from += 1;
					}
					break;
				  case 'i':
					if (stack)
						*va_arg(ap,long *) = (long)d;
					else
					{
						**(long **)from = (long)d;
						*(long **)from += 1;
					}
					break;
				  case 'd':
					if (stack)
						*va_arg(ap,DWORD *) = (DWORD)d;
					else
					{
						**(DWORD **)from = (DWORD)d;
						*(DWORD **)from += 1;
					}
					break;
				  case 'f':
					if (stack)
						*va_arg(ap,double *) = n;
					else
					{
						**(double **)from = n;
						*(double **)from += 1;
					}
					break;
				}
				f++;
				break;
			  }

			  // Text
			  case 't':
			  {
				f++;
				if (t.Type() != TKN_IDENT && t.Type() != TKN_DEFINE && t.Type() != TKN_SCENEID)
					return FALSE;
				if (stack)
					str = va_arg(ap,char *);
				else
					str = (*from);
				if (len)
				{
					memset(str, 0, len);
					strncpy(str, t.Text(), len - 1);
				}
				else
				{
					strcpy(str, t.Text());
					len = strlen(t.Text()) + 1;
				}
				if (!stack) (*from) += len;
				t.WhiteGet();
				break;
			  }

			  // String Constant
			  case 's':
			  {
				f++;
				if (t.Type() != TKN_TEXT)
					return FALSE;
				if (stack)
					str = va_arg(ap,char *);
				else
					str = (*from);
				if (len)
				{
					memset(str, 0, len);
					strncpy(str, t.Text(), len - 1);
				}
				else
				{
					strcpy(str, t.Text());
					len = strlen(t.Text()) + 1;
				}
				if (!stack) (*from) += len;
				t.WhiteGet();
				break;
			  }

			  default:
				Error("Invalid '%' field in GetLine()");
				break;

			} // End of '%' value parse
			break;
		  }

		// Keyword
		  default:
			if (isalpha(*f))
			{
				i = 0;
				while (*f && isalnum(*f))
					keyword[i++] = toupper(*f++);
				keyword[i] = NULL;
				if ((t.Type() != TKN_KEYWORD && t.Type() != TKN_IDENT)
				  || stricmp(keyword, t.Text()))
					return FALSE;
				t.WhiteGet();
			}
			else // Default
			{
				if (t.Type() != TKN_SYMBOL || t.Code() != *f)
				{
                	f[1] = NULL;
					return FALSE;
                }
				f++;
				t.WhiteGet();
			}
			break;
		}
	}

	return TRUE;
}

BOOL __cdecl Parse(TToken &t, char *format, ...)
{
	va_list ap;
	va_start(ap, format);
	BOOL retval = ParseAnything(TRUE, t, format, ap);
	va_end(ap);
	return retval;
}

BOOL __cdecl ParseString(char *string, char *format, ...)
{
	TStringParseStream s(string);
	TToken t(s);

	va_list ap;
	va_start(ap, format);
	BOOL retval = ParseAnything(TRUE, t, format, ap);
	va_end(ap);
	return retval;
}
	
// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                     Player.cpp - TPlayer module                       *
// *************************************************************************

#include "revenant.h"
#include "player.h"
#include "textbar.h"
#include "sound.h"
#include "weapon.h"
#include "armor.h"
#include "statusbar.h"
#include "equip.h"
#include "death.h"
#include "playscreen.h"
#include "inventory.h"
#include "mappane.h"

extern TDeathPane DeathPane;

extern TObjectClass  CharacterClass; // Used to indicate player is derived from character

REGISTER_BUILDER(TPlayer)
TObjectClass PlayerClass("PLAYER", OBJCLASS_PLAYER, 0, &CharacterClass);

// Miscellaneous character values
DEFOBJSTAT(Player, Level,			LEV,  PLRVAL_FIRST + PLRVAL_LEVEL, 1, 1, 100)
DEFOBJSTAT(Player, Exp,				EXP,  PLRVAL_FIRST + PLRVAL_EXP, 0, 0, 1000000)

// Character stats
DEFOBJSTAT(Player, Strn,			STRN, PLRSTAT_FIRST + PLRSTAT_STRN, 14, 0, 100)
DEFOBJSTAT(Player, Cons,			CONS, PLRSTAT_FIRST + PLRSTAT_CONS, 14, 0, 100)
DEFOBJSTAT(Player, Agil,			AGIL, PLRSTAT_FIRST + PLRSTAT_AGIL, 14, 0, 100)
DEFOBJSTAT(Player, Rflx,			RFLX, PLRSTAT_FIRST + PLRSTAT_RFLX, 14, 0, 100)
DEFOBJSTAT(Player, Mind,			MIND, PLRSTAT_FIRST + PLRSTAT_MIND, 14, 0, 100)
DEFOBJSTAT(Player, Luck,			LUCK, PLRSTAT_FIRST + PLRSTAT_LUCK, 14, 0, 100)

// Character skill values
DEFOBJSTAT(Player, Attack,			ATK,  SK_FIRST + SK_ATTACK, 0, 0, 100)
DEFOBJSTAT(Player, Defense,			DEF,  SK_FIRST + SK_DEFENSE, 0, 0, 100)
DEFOBJSTAT(Player, Invoke,			INV,  SK_FIRST + SK_INVOKE, 0, 0, 100)
DEFOBJSTAT(Player, Hands,			HAN,  SK_FIRST + SK_HANDS, 0, 0, 100)
DEFOBJSTAT(Player, ShortBlades,		SBL,  SK_FIRST + SK_SHORTBLADES, 0, 0, 100)
DEFOBJSTAT(Player, LongBlades,		LBL,  SK_FIRST + SK_LONGBLADES, 0, 0, 100)
DEFOBJSTAT(Player, Bludgeons,		BLD,  SK_FIRST + SK_BLUDGEONS, 0, 0, 100)
DEFOBJSTAT(Player, Axes,			AXE,  SK_FIRST + SK_AXES, 0, 0, 100)
DEFOBJSTAT(Player, Bows,			BOW,  SK_FIRST + SK_BOWS, 0, 0, 100)
DEFOBJSTAT(Player, Stealth,			SLT,  SK_FIRST + SK_STEALTH, 0, 0, 100)
DEFOBJSTAT(Player, LockPick,		LPK,  SK_FIRST + SK_LOCKPICK, 0, 0, 100)

// Character skill experience
DEFOBJSTAT(Player, AttackExp,		ATKE, SKE_FIRST + SK_ATTACK,0, 0, 1000000)
DEFOBJSTAT(Player, DefenseExp,		DEFE, SKE_FIRST + SK_DEFENSE,0, 0, 1000000)
DEFOBJSTAT(Player, InvokeExp,		INVE, SKE_FIRST + SK_INVOKE, 0, 0, 1000000)
DEFOBJSTAT(Player, HandsExp,		HANE, SKE_FIRST + SK_HANDS, 0, 0, 1000000)
DEFOBJSTAT(Player, ShortBladesExp,	SBLE, SKE_FIRST + SK_SHORTBLADES, 0, 0, 1000000)
DEFOBJSTAT(Player, LongBladesExp,	LBLE, SKE_FIRST + SK_LONGBLADES, 0, 0, 1000000)
DEFOBJSTAT(Player, BludgeonsExp,	BLDE, SKE_FIRST + SK_BLUDGEONS, 0, 0, 1000000)
DEFOBJSTAT(Player, AxesExp,			AXEE, SKE_FIRST + SK_AXES, 0, 0, 1000000)
DEFOBJSTAT(Player, BowsExp,			BOWE, SKE_FIRST + SK_BOWS, 0, 0, 1000000)
DEFOBJSTAT(Player, StealthExp,		SLTE, SKE_FIRST + SK_STEALTH, 0, 0, 1000000)
DEFOBJSTAT(Player, LockPickExp,		LPKE, SKE_FIRST + SK_LOCKPICK, 0, 0, 1000000)

// **************
// * Skill Tree *
// **************

SSkill SkillTree[NUM_SKILLS] =
{
	{ "Attack",			TRUE,	FALSE,	-1,	3 },
	{ "Defence",		TRUE,	FALSE,	-1,	3 },
	{ "Short Blades",	TRUE,	FALSE,	-1,	3 },
	{ "Long Blades",	TRUE,	FALSE,	-1,	3 },
	{ "Bludgeons",		TRUE,	FALSE,	-1,	3 },
	{ "Axes",			TRUE,	FALSE,	-1,	3 },
	{ "Bows",			TRUE,	FALSE,	-1,	3 },
	{ "Stealth",		TRUE,	FALSE,	-1,	3 },
	{ "Lockpicking",	TRUE,	FALSE,	-1,	3 },
	{ "Invocation",		TRUE,	FALSE,	-1,	3 }
};

// *********************************************
// * TPlayer - Represents a game player object *
// *********************************************

// REMEMBER: !!!!! Please attempt to put MOST of player functionality into character instead.
// Player should only be the place for functionality that CAN'T be placed into character!!

TPlayer::TPlayer(PTObjectImagery newim) : TCharacter(newim)
{
	ClearPlayer();
}

TPlayer::TPlayer(PSObjectDef def, PTObjectImagery newim) : TCharacter(def, newim)
{
	ClearPlayer();
}

TPlayer::~TPlayer()
{
	PlayerManager.RemovePlayer(this);
}

void TPlayer::ClearPlayer()
{
	memset(equipment, 0, NUM_EQ_SLOTS * sizeof(PTObjectInstance));

	flags |= OF_NONMAP;	// Allows us to insert object into the game map, and not
						// worry about it getting deleted, saved, or whatnot

	OnTheHog = FALSE;
}

int deathframe = 0;

void TPlayer::Pulse()
{
	TCharacter::Pulse();

	if (!Editor)
	{
		if (Health() <= 0)
		{
			if (deathframe++ > 100)
				PlayScreen.SetNextPane(&DeathPane);
		}
		else
			deathframe = 0;
	}
}

DWORD TPlayer::Move()
{
	DWORD retval = TCharacter::Move();

	if (!OnTheHog)
		return retval;

	static BOOL riding = FALSE;
	BOOL oldriding = riding;

	if (nextmove.x || nextmove.y || nextmove.z)
		riding = TRUE;
	else
		riding = FALSE;

	if (oldriding && !riding)
	{
		SoundPlayer.Stop("hog drive");
		SoundPlayer.Play("hog idle");
	}
	else if (!oldriding && riding)
	{
		SoundPlayer.Stop("hog idle");
		SoundPlayer.Play("hog drive");
	}

	return retval;
}

void TPlayer::Damage(int damage, int type)
{
	TCharacter::Damage(damage, type);
}

int TPlayer::GetResistance(int type)
{
	return 0; // Huhh?
}

int TPlayer::ResolveCombat(PTActionBlock ab, int bits)
{
	if (ab->firsttime && !ab->transition && ab->Is("combat"))
		PLAY("draw sword");

	return TCharacter::ResolveCombat(ab, bits);
}

void TPlayer::RefreshEquip()
{
	for (TInventoryIterator i(this); i; i++)
	{
		if (i.Item()->InventNum() > 255)
			Equip(i.Item(), i.Item()->InventNum() - 256);

		if (this == Player)
			EquipPane.SetDirty(TRUE);
	}
}

void TPlayer::Equip(PTObjectInstance oi, int slot)
{
	if ((DWORD)slot < NUM_EQ_SLOTS)
	{
		equipment[slot] = oi;
		if (this == Player)
			EquipPane.SetDirty(TRUE);
	}
}

// Returns the modifier value for the given player stat
int TPlayer::PlyrStatMod(int plyrstat, int flags)
{
	int mod;

	switch (PlyrStat(plyrstat))
	{
	  case 0: case 1:  case 2:
		mod = -4;
		break;
	  case 3: case 4: case 5: case 6:
	    mod = -3;
		break;
	  case 7: case 8: case 9:
	    mod = -2;
		break;
	  case 10: case 11:
	    mod = -1;
		break;
	  case 12: case 13: case 14: case 15:
		mod = 0;
		break;
	  case 16: case 17:
	    mod = 1;
		break;
	  case 18: case 19: case 20:
	    mod = 2;
		break;
	  case 21: case 22: case 23: case 24:
	    mod = 3;
		break;
	  case 25: case 26: case 27: case 28: case 29:
	    mod = 4;
		break;
	  default:
	    if (plyrstat < 0)
			mod = -5;
		else
			mod = 5;
		break;
	}

	if (flags == PLYRSTATMOD_HALFROUNDUP)
	{
		if (mod > 0)
			mod = (mod + 1) / 2;
		else
			mod = (mod - 1) / 2;
	}
	else if (flags == PLYRSTATMOD_HALFROUNDDOWN)
	{
		mod = mod / 2;
	}

	return mod;
}

// Returns a modifier value for skill based on a physical attribute
int TPlayer::PlyrStatSkillMod(int skill)
{
	return 0;
}

void TPlayer::SetHealth(int v)
{
	TCharacter::SetHealth(v);

	if (this == Player)
		HealthBar.ChangeLevel(v * 1000 / MaxHealth());
}

void TPlayer::SetFatigue(int v)
{
	TCharacter::SetFatigue(v);

//	if (this == Player)
//		StaminaBar.ChangeLevel(v * 1000 / MaxFatigue());
}

void TPlayer::SetMana(int v)
{
	TCharacter::SetMana(v);

	if (this == Player)
		StaminaBar.ChangeLevel(v * 1000 / MaxMana());
}

// Special cheat function
void TPlayer::GetOnYerHog()
{
	int newtype = PlayerClass.FindObjType(OnTheHog ? "Locke" : "Hog");
	if (newtype < 0)
		return;

	if (animator)
	{
		delete animator;
		animator = NULL;
	}
	
	TObjectImagery::FreeImagery(imagery);
	imagery = TObjectImagery::LoadImagery(PlayerClass.GetObjType(newtype)->imageryid);
	if (!imagery)
		return;

	objtype = newtype;

	if (!OnTheHog)
	{
		SoundPlayer.Mount("hog idle");
		SoundPlayer.Mount("hog drive");

		SoundPlayer.Play("hog idle");

		OnTheHog = TRUE;
	}
	else
	{
		SoundPlayer.Unmount("hog idle");
		SoundPlayer.Mount("hog drive");

		OnTheHog = FALSE;
	}
}

// *******************************************************************
// * TPlayerManager - Object to manager the player list for the game *
// *******************************************************************

// Initialize the player manager
BOOL TPlayerManager::Initialize()
{
	players.Clear();
	mainplayernum = -1;
	Player = NULL;

	return TRUE;
}

// Closes the player manager
void TPlayerManager::Close()
{
	players.DeleteAll();
	Player = NULL;
	mainplayernum = -1;
}

// Clears the player manager (deletes all players for the current game)
void TPlayerManager::Clear()
{
	SetMainPlayer(-1);
	players.DeleteAll();
}

// Sets the main player for the game
void TPlayerManager::SetMainPlayer(int newplayernum)
{
	if (mainplayernum == newplayernum)
		return;

	mainplayernum = newplayernum;

	if ((DWORD)mainplayernum >= (DWORD)players.NumItems())
		mainplayernum = players.NumItems() - 1;  // The last player added

	if (mainplayernum < 0)
	{
		Player = NULL;

		if (CurrentScreen == &PlayScreen)
		{
		  // Set map position
			S3DPoint pos;
			MapPane.GetMapPos(pos);
			MapPane.CenterOnPos(pos, MapPane.GetMapLevel(), FALSE);

		  // Set inventory container
			Inventory.SetContainer(NULL);

		  // Setup health bars
			HealthBar.SetLevel(0);
			StaminaBar.SetLevel(0);
		}
	}
	else
	{
		Player = GetPlayer(mainplayernum);

		if (CurrentScreen == &PlayScreen)
		{
		  // Center on this player in map
			MapPane.CenterOnObj(Player, FALSE);

		  // Setup equipment pane
			Player->RefreshEquip();

		  // Setup inventory pane
			Inventory.SetContainer(Player);

		  // Set status bars
			HealthBar.SetLevel(Player->Health() * 1000 / Player->MaxHealth());
			StaminaBar.SetLevel(Player->Mana() * 1000 / Player->MaxMana());
		}
	}
}

// Sets the main player for the game
void TPlayerManager::SetMainPlayer(PTPlayer player)
{
	int newplayernum = -1;

	for (int c = 0; c < players.NumItems(); c++)
	{
		if (players[c] == player)
		{
			newplayernum = c;
			break;
		}
	}

	SetMainPlayer(newplayernum);
}

// Add player
int TPlayerManager::AddPlayer(PTPlayer newplayer)
{
	int c;
	int empty = -1;
	for (c = 0; c < players.NumItems(); c++)
	{
		if (players[c] == NULL)
			empty = c;
		else if (players[c] == newplayer)
			return c;
	}

	if (empty >= 0)
		c = players.Set(newplayer, empty);
	else
		c = players.Add(newplayer);

	if (!Player)
		SetMainPlayer(newplayer);

	return c;
}

// Remove a player
// The collapse flag allows you to choose whether you want to leave an empty space
// in the player list or not.  You need to leave empty slots when in a net game so that
// player id numbers don't change.  When setting up a game, however, you need to collapse
// the list.
void TPlayerManager::RemovePlayer(int removenum, BOOL collapse)
{
	if ((DWORD)removenum >= (DWORD)players.NumItems())
		return;

	if (collapse)
		players.Collapse(removenum, FALSE);
	else
		players.Remove(removenum);

	if (removenum == mainplayernum)
		SetMainPlayer(-1); // Set to last player in list
}

// Remove a player (given player pointer)
void TPlayerManager::RemovePlayer(PTPlayer removeplayer, BOOL collapse)
{
	int removenum;
	for (removenum = 0; removenum < players.NumItems(); removenum++)
	{
		if (players[removenum] == removeplayer)
		{
			RemovePlayer(removenum, collapse);
			return;
		}
	}
}		
// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *              playscreen.cpp - EXILE play screen object                *
// *************************************************************************

#include <windows.h>
#include <stdio.h>

#include "revenant.h"
#include "timer.h"
#include "mainwnd.h"
#include "animation.h"
#include "animimagebody.h"
#include "bitmap.h"
#include "bmsurface.h"
#include "display.h"
#include "playscreen.h"
#include "spell.h"
#include "mappane.h"
#include "automap.h"
#include "inventory.h"
#include "tile.h"
#include "editor.h"
#include "dls.h"
#include "cursor.h"
#include "equip.h"
#include "player.h"
#include "multictrl.h"
#include "spell.h"
#include "statpane.h"
#include "multi.h"
#include "textbar.h"
#include "statusbar.h"
#include "sound.h"
#include "dialog.h"
#include "savegame.h"
#include "character.h"
#include "script.h"
#include "ctrlmap.h"
#include "area.h"

extern TEditToolsPane ToolBar;

PTBitmap bitmap;
PTBitmap PointerCursor;
PTBitmap HandCursor;

int DynamicIntensity = 0;

/* Quick structure for the little bitmaps of the interface which hang over the map pane. */
#define NUMOVERHANGS	17
#define NUMMAINHANGS	13
#define STARTMULTIHANGS	NUMMAINHANGS
#define ENDMULTIHANGS	NUMOVERHANGS
struct { int x, y, w, h; } oh[NUMOVERHANGS] =
{ { 32, 16, 46, 9 }, { 32, 25, 9, 37 }, { 278, 16, 84, 30 },	// top pieces
  { 562, 16, 46, 9 }, { 599, 25, 9, 37 },		// more top pieces
  { 32, 169, 7, 14 }, { 601, 169, 7, 14 },		// middle pieces
  { 32, 294, 3, 9 }, { 32, 318, 26, 18 },		// left bottom
  { 104, 332, 233, 4 },							// middle (text bar)
  { 406, 328, 98, 8 },							// right/middle bottom
  { 582, 318, 26, 18 }, { 605, 294, 3, 9 },		// right bottom

  { 459, 346, 41, 41 }, { 586, 346, 41, 41 },	// multipane top
  { 459, 433, 41, 41 }, { 586, 433, 41, 41 }	// multipane bottom
};
PTBitmap overhang[NUMOVERHANGS];

// **********************
// * Game control codes *
// **********************

#define CTRL_NORMALMODE    1
#define CTRL_COMBATMODE    2
#define CTRL_INVENTORYMODE 4

// {"Name", "INI tag", modeflags, codes(1-3): { keys(1-3): {} }, upcode, downcode} 
SControlEntry GameControls[] = {
{"Invoke 1", "Invoke1", CTRL_NORMALMODE | CTRL_COMBATMODE, {{VK_F1}}, GAMECMD_INVOKE1, 0},
{"Invoke 2", "Invoke2", CTRL_NORMALMODE | CTRL_COMBATMODE, {{VK_F2}}, GAMECMD_INVOKE2, 0},
{"Invoke 3", "Invoke3", CTRL_NORMALMODE | CTRL_COMBATMODE, {{VK_F3}}, GAMECMD_INVOKE3, 0},
{"Invoke 4", "Invoke4", CTRL_NORMALMODE | CTRL_COMBATMODE, {{VK_F4}}, GAMECMD_INVOKE4, 0},
{"Combat Mode", "CombatMode", CTRL_NORMALMODE | CTRL_COMBATMODE, {{VK_RETURN}}, GAMECMD_COMBAT, 0},
{"Full Screen", "FullScreen", ALLMODES, {{VK_SPACE}}, GAMECMD_FULLSCREEN, 0},
{"Sneak", "Sneak", CTRL_NORMALMODE, {{'S'}}, GAMECMD_MOVEDOWN, GAMECMD_MOVEUP, CMDFLAG_SNEAK},
{"Run", "Run", CTRL_NORMALMODE, {{'R'}}, GAMECMD_MOVEDOWN, GAMECMD_MOVEUP, CMDFLAG_RUN},
{"Use", "Use", CTRL_NORMALMODE, {{'U'},{'T'}}, GAMECMD_USE, 0},
{"Get", "Get", CTRL_NORMALMODE, {{'G'}}, GAMECMD_GET, 0},
{"Jump", "Jump", CTRL_NORMALMODE, {{'J'}}, GAMECMD_JUMP, 0},
{"Inventory", "Inventory", CTRL_NORMALMODE, {{'I'}}, GAMECMD_INVENTORY, 0},
{"Inventory Use", "InvUse", CTRL_INVENTORYMODE, {{'U'}}, GAMECMD_INVUSE, 0},
{"Inventory Move", "InvMove", CTRL_INVENTORYMODE, {{'M'}}, GAMECMD_INVMOVE, 0},
{"Inventory Drop", "InvDrop", CTRL_INVENTORYMODE, {{'D'}}, GAMECMD_INVDROP, 0},
{"Inventory Exit", "InvExit", CTRL_INVENTORYMODE, {{VK_ESCAPE}}, GAMECMD_INVEXIT, 0},
{"Combat Combo1", "CombatCombo1", CTRL_COMBATMODE, {{VK_CONTROL, 'A'}}, GAMECMD_COMBO1, 0},
{"Combat Combo2", "CombatCombo2", CTRL_COMBATMODE, {{VK_CONTROL, 'S'}}, GAMECMD_COMBO2, 0},
{"Combat Combo3", "CombatCombo3", CTRL_COMBATMODE, {{VK_CONTROL, 'D'}}, GAMECMD_COMBO3, 0},
{"Combat Combo4", "CombatCombo4", CTRL_COMBATMODE, {{VK_SHIFT, 'A'}}, GAMECMD_COMBO4, 0},
{"Combat Combo5", "CombatCombo5", CTRL_COMBATMODE, {{VK_SHIFT, 'S'}}, GAMECMD_COMBO5, 0},
{"Combat Combo6", "CombatCombo6", CTRL_COMBATMODE, {{VK_SHIFT, 'D'}}, GAMECMD_COMBO6, 0},
{"Combat Block", "CombatBlock", CTRL_COMBATMODE, {{'Q'}}, GAMECMD_BLOCK, 0},
{"Combat Dodge", "CombatDodge", CTRL_COMBATMODE, {{'W'}}, GAMECMD_DODGE, 0},
{"Combat Leap", "CombatLeap", CTRL_COMBATMODE, {{'F'}}, GAMECMD_LEAPDOWN, GAMECMD_LEAPUP, CMDFLAG_LEAP},
{"Combat Swing", "CombatSwing", CTRL_COMBATMODE, {{'A'}}, GAMECMD_SWING, 0},
{"Combat Thrust", "CombatThrust", CTRL_COMBATMODE, {{'S'}}, GAMECMD_THRUST, 0},
{"Combat Chop", "CombatChop", CTRL_COMBATMODE, {{'D'}}, GAMECMD_CHOP, 0},
{"Left", "Left", ALLMODES, {{VK_LEFT},{VK_JOYLEFT}}, GAMECMD_DIRDOWN, GAMECMD_DIRUP, CMDFLAG_LEFT},
{"Right", "Right", ALLMODES, {{VK_RIGHT}, {VK_JOYRIGHT}}, GAMECMD_DIRDOWN, GAMECMD_DIRUP, CMDFLAG_RIGHT},
{"Up", "Up", ALLMODES, {{VK_UP},{VK_JOYUP}}, GAMECMD_DIRDOWN, GAMECMD_DIRUP, CMDFLAG_UP},
{"Down", "Down", ALLMODES, {{VK_DOWN},{VK_JOYDOWN}}, GAMECMD_DIRDOWN, GAMECMD_DIRUP, CMDFLAG_DOWN},
{"Up Left", "UpLeft", ALLMODES, {{VK_HOME}, {VK_JOYUPLEFT}}, GAMECMD_DIRDOWN, GAMECMD_DIRUP, CMDFLAG_UPLEFT},
{"Up Right", "UpRight", ALLMODES, {{VK_PRIOR}, {VK_JOYUPRIGHT}}, GAMECMD_DIRDOWN, GAMECMD_DIRUP, CMDFLAG_UPRIGHT},
{"Down Left", "DownLeft", ALLMODES, {{VK_END}, {VK_JOYDOWNLEFT}}, GAMECMD_DIRDOWN, GAMECMD_DIRUP, CMDFLAG_DOWNLEFT},
{"Down Right", "DownRight", ALLMODES, {{VK_NEXT}, {VK_JOYDOWNRIGHT}}, GAMECMD_DIRDOWN, GAMECMD_DIRUP, CMDFLAG_DOWNRIGHT}
};
#define NUMGAMECONTROLS sizearray(GameControls)

// *********************
// * PlayScreen Screen *
// *********************

TPlayScreen::TPlayScreen()
{
	nextscreen   = NULL;
}

BOOL TPlayScreen::Initialize()
{
	Status("Initializing TPlayScreen\n");

	// Set control/demo modes
	controlon = TRUE;
	demomode = FALSE;
	
	// Don't load a new game right off (set to FALSE when starting)
	loadnewgame = FALSE;  

	// Don't save the map
	savemap = FALSE;

	// Set game time to 0
	gameframes = 0;
	sessionstart = 0;
	lastsessionframes = 0;

	// The main game resource, where most of the interface stuff (cursors, backgrounds, buttons) is stored
	GameData = TMulti::LoadMulti("playscrn.dat");

  // Create background areas for screen
	Status("Creating background areas\n");
	CreateBackgroundAreas();

  // Setup control mapper
	ControlMap.Initialize(NUMGAMECONTROLS, GameControls);
	ControlMap.Load("Controls");

  // Initialize the script manager
	Status("Initializing game script manager\n");
	ScriptManager.Initialize();

  // Load the area def
	Status("Initializing game areas\n");
	AreaManager.Initialize();

  // Map pane
	Status("Setup up game panes in %s mode\n", FullScreen?"FULLSCREEN":"NONFULLSCREEN");
	if (FullScreen)
		MapPane.Resize(0, 0, Display->Width(), Display->Height());
	else
		MapPane.Resize(FRAMEMAPPANEX, FRAMEMAPPANEY, FRAMEMAPPANEWIDTH, FRAMEMAPPANEHEIGHT);
	if (!MapPane.Initialize())
		FatalError("Trouble initializing map pane");
	AddPane(&MapPane);

  // Init the AutoMap pane before MapPane since it allocates buffers used by MapPane
	if (!AutoMap.Initialize())
		FatalError("Trouble initializing automap pane");

  // Character inventory
	if (!Inventory.Initialize())
		FatalError("Trouble initializing inventory pane");

  // Health bar
	if (!HealthBar.Initialize())
		FatalError("Trouble initializing health bar");

	if (!StaminaBar.Initialize())
		FatalError("Trouble initializing stamina bar");

  // Quick spell buttons
	if (!QuickSpells.Initialize())
		FatalError("Trouble initializing quick spell buttons");

  // Text bar
	if (!TextBar.Initialize())
		FatalError("Trouble initializing text bar");

  // Dialog Pane
	if (!DialogPane.Initialize())
		FatalError("Trouble initializing dialog pane");

  // Various multifunction panels
	if (!EquipPane.Initialize())
		FatalError("Trouble initializing equipment pane");

  // Spell creation pane
	if (!SpellPane.Initialize())
		FatalError("Trouble initializing spell pane");

  // Character stat pane
	if (!StatPane.Initialize())
		FatalError("Trouble initializing stat pane");

  // The multicontrol button pane	
	if (!MultiCtrl.Initialize())
		FatalError("Trouble initializing multicontrol pane");

  // Set initial full screen state 
	SetFullScreen(FullScreen);

	// Mouse cursors
	PointerCursor = GameData->Bitmap("cursor");
	if (!PointerCursor)
		return FALSE;

	HandCursor = GameData->Bitmap("handcursor");
	if (!HandCursor)
		return FALSE;

	SetMouseBitmap(PointerCursor);

	// Sound system
	if (!SoundPlayer.Initialize())
		FatalError("Trouble initalizing soundplayer - is SOUND.DEF present?");

  // Load game
	Status("Loading save game\n");
	if (!Editor && !StartInEditor)
		SaveGame.ReadGame();

  // Set up editor
  	if (StartInEditor)
	{
		Status("Initializing editor\n");
		StartEditor(StartInEditor);
	}

	// Setup screen interface
	Status("Loading interface/starting game...\n");
	bitmap = TBitmap::Load(100);
	if (!bitmap)
		return FALSE;

	multidirty = FALSE;

	numpostcharanims = 0;
	numpostchartexts = 0;

	// Hang on to the parts which hang over the map pane
	for (int i = 0; i < NUMOVERHANGS; i++)
	{
		if (!(overhang[i] = TBitmap::NewBitmap(oh[i].w, oh[i].h, BM_8BIT | BM_PALETTE)))
			return FALSE;

		overhang[i]->Put(0, 0, bitmap, oh[i].x, oh[i].y, oh[i].w, oh[i].h);
		if (bitmap->palettesize)
			memcpy(overhang[i]->palette.ptr(), bitmap->palette.ptr(), bitmap->palettesize);
	}

	Display->Put(0, 0, bitmap, DM_NOCLIP | DM_BACKGROUND);
	delete bitmap;

  // Set next pane to null
	nextpane = NULL;

	return TRUE;
}

void TPlayScreen::Close()
{
	if (Editor)
	{
		ShutDownEditor();
		Editor = TRUE;			// other stuff needs to know that we were in the editor
		TObjectClass::SaveClasses(FALSE);
	}

	MapPane.Close();
	Inventory.Close();
	QuickSpells.Close();
	HealthBar.Close();
	StaminaBar.Close();
	TextBar.Close();
	AutoMap.Close();
	EquipPane.Close();
	SpellPane.Close();
	StatPane.Close();
	MultiCtrl.Close();
	SoundPlayer.Close();
	DialogPane.Close();

	for (int i = 0; i < NUMOVERHANGS; i++)
		delete overhang[i];

	SetMouseBitmap(NULL);

  // Close the area manager
	AreaManager.Close();	

  // Close the script manager
	ScriptManager.Close();

  // Close the control mapper
	ControlMap.Close();	

	delete GameData;
}

void TPlayScreen::DrawBackground()
{
	if (nextpane)
	{
		DrawOverhangs();
		nextpane->Initialize();
		nextpane = NULL;
	}

	if (dirty)
	{
		bitmap = TBitmap::Load(100);
		if (!bitmap)
			FatalError("loading interface bitmap");

		Display->Reset();
		Display->Put(0, 0, bitmap, DM_NOCLIP | DM_BACKGROUND);
		delete bitmap;
	}

	TScreen::DrawBackground();

 // Overhaning parts of multipanel if needed
	if (multidirty && !Editor && !IsFullScreen())
	{
		for (int i = STARTMULTIHANGS; i < ENDMULTIHANGS; i++)
			Display->Put(oh[i].x, oh[i].y, overhang[i], DM_TRANSPARENT | DM_BACKGROUND);

		MultiCtrl.RedrawOverhangButtons();
		MultiCtrl.SetClipRect();
		MultiCtrl.DrawBackground();		// ugly but it works

		multidirty = FALSE;
	}
}

void TPlayScreen::Pulse()
{
  // Before doing anything.. see if we should load a new game?
	if (loadnewgame)
	{
		SaveGame.ReadGame();
		loadnewgame = FALSE;
	}
	
   // Should we save the map right now before drawing the screen
	if (savemap)
	{
		MapPane.SaveAllSectors();
		MapPane.SaveCurMap();  // Copies new sector files to main game map dir
		MapPane.ClearCurMap(); // Clears all map sectors from the 'curmap' directory
		savemap = FALSE;
	}

   // Now call base class pulse function
	TScreen::Pulse();

	// Call the area pulse funciton
	AreaManager.Pulse();
}

void TPlayScreen::Animate(BOOL draw)
{
	if (dirty)
		return;

	TScreen::Animate(draw);

	// Call the area animate funciton
	AreaManager.Animate(draw);

	// Draw post-character animations (spell effects, text, etc)
	if (draw && !InCompleteExclusion())
	{
		MapPane.SetClipRect();
		for (int i = 0; i < numpostcharanims; i++)
		{
			if (postanim[i].drawmode & (DM_ZBUFFER | DM_ZSTATIC))
				Display->ZPut(postanim[i].x, postanim[i].y, postanim[i].z, postanim[i].bm, postanim[i].drawmode);
			else
				Display->PutDim(postanim[i].x, postanim[i].y, postanim[i].bm, postanim[i].drawmode, postanim[i].dim);
		}

		// This is a tad tricky - draw the mouse shadow first, then the overhangs, and then
		// (later on, in TScreen::TimerTick()) the actual cursor.  This gets the effect of
		// the mouse shadow being 'in' the map pane (underneath the interface overhangs)
		// but doesn't obscure the cursor itself.

		DrawMouseShadow();

		MapPane.SetClipRect();
		for (i = 0; i < numpostchartexts; i++)
		{
			SColor color;
			color.red = color.green = color.blue = 0;

			Display->WriteText(posttext[i].text, posttext[i].x, posttext[i].y - 1,
									99, DialogFontShadow,
									&color, DM_TRANSPARENT | DM_ALIAS,
									posttext[i].wrapwidth, 0, JUSTIFY_CENTER | JUSTIFY_CLIP);
			Display->WriteText(posttext[i].text, posttext[i].x, posttext[i].y,
									99, DialogFont,
									&posttext[i].color, DM_TRANSPARENT | DM_ALIAS,
									posttext[i].wrapwidth, 0, JUSTIFY_CENTER | JUSTIFY_CLIP);

			delete posttext[i].text;
		}

		DrawOverhangs(TRUE);
	}

	numpostcharanims = 0;
	numpostchartexts = 0;

	// Update the AutoMap
	if (!Editor)
		AutoMap.RecordTravels();

	// Now increase the game frame (don't increase game frames when paused, editor, etc.)
	if (!Editor && 
	  !MapPane.IsHidden() && MapPane.IsOpen() && !InCompleteExclusion())
	{
		gameframes++;
		gametime = 
			(int)((__int64)((__int64)GameFrame() * (__int64)100 / (__int64)FRAMERATE));
		timeofday = 
			(int)((__int64)(((__int64)gametime * (__int64)(24 * 60) / 
				(__int64)Rules.daylength) % (__int64)(24 * 60)));
	}
}

// Sets or clears fullscreen mode
void TPlayScreen::SetFullScreen(BOOL on)
{
  // Init map pane
	if (on)
	{
		MapPane.Resize(0, 0, Display->Width(), Display->Height());

		RemovePane(&Inventory);
		RemovePane(&HealthBar);
		RemovePane(&StaminaBar);
		RemovePane(&QuickSpells);
		RemovePane(&TextBar);
		RemovePane(&DialogPane);
		RemovePane(&EquipPane);
		RemovePane(&SpellPane);
		RemovePane(&StatPane);
		RemovePane(&AutoMap);
		RemovePane(&MultiCtrl);

		Redraw();
	}
	else
	{
		MapPane.Resize(FRAMEMAPPANEX, FRAMEMAPPANEY, FRAMEMAPPANEWIDTH, FRAMEMAPPANEHEIGHT);
	
		AddPane(&Inventory);
		AddPane(&HealthBar);
		AddPane(&StaminaBar);
		AddPane(&QuickSpells);
		AddPane(&TextBar);
		AddPane(&DialogPane);
		AddPane(&EquipPane);
		AddPane(&SpellPane);
		AddPane(&StatPane);
		AddPane(&AutoMap);
		AddPane(&MultiCtrl);


		Redraw();
	}

	fullscreen = FullScreen = on;
}

// Sets game to run in demo mode
void TPlayScreen::SetDemoMode(BOOL on)
{
	demomode = on;
	SetControlOn(!on);
}

// Sets game control on or off
void TPlayScreen::SetControlOn(BOOL on)
{
	controlon = on;
	if (controlon)
		demomode = FALSE;
	MapPane.SetIgnoreInput(!on);
}

void TPlayScreen::KeyPress(int key, BOOL down)
{
	BYTE *screen;

	TScreen::KeyPress(key, down);

	if (down)
	{
		switch (key)
		{
		  case VK_F5:
			if (Editor)
			{
			  SaveGame.WriteGame();
			}
			break;
		  case VK_F8:
			if (CtrlDown)
			{
				FILE *fp;
				fp = fopen("SCREEN.RAW", "wb");
				screen = (BYTE *)(Display->FrontBuffer()->Lock());
				Display->FrontBuffer()->Unlock();
				if (fp && screen)
				{
					WORD pixel;
					for (int y = 0; y < 480; y++)
						for (int x = 0; x < 640; x++)
						{
							pixel = *((WORD *)screen);
							screen += 2;
							if (Display->BitsPerPixel() == 15)
							{
								fputc(((pixel >> 10) & 0x1f) << 3, fp);
								fputc(((pixel >> 5) & 0x1f) << 3, fp);
								fputc((pixel & 0x1f) << 3, fp);
							}
							else
							{
								fputc(((pixel >> 11) & 0x1f) << 3, fp);
								fputc(((pixel >> 5) & 0x3f) << 2, fp);
								fputc((pixel & 0x1f) << 3, fp);
							}
						}

					fclose(fp);
				}
			}
			else
			{
				if (Player)
				{
					((PTCharacter)Player)->RestoreHealth();
					HealthBar.ChangeLevel(Player->Health());
				}
			}

			break;
		  case VK_F12:
			if (Editor)
			{
				ShutDownEditor();
				Redraw();
			}
			else
 				StartEditor();

			break;
		  case 'R':
			if (CtrlDown)
				MapPane.RedrawAll();
			break;
		}
	}

  // Temporary invokes!
	if (down && key >= '0' && key <= '9' && !Editor)
	{
		if(CtrlDown)
			key += 10;

		int i[2];
		i[0] = key - '0';
		i[1] = 0xff;
		Player->Invoke(i, 2);
	}

  // Gameplay Commands
	if (!Editor)
	{
		DWORD mode;
		if (Player && Player->IsFighting())
			mode = CTRL_COMBATMODE;
		else
			mode = CTRL_NORMALMODE;
		GAMECOMMAND cmd = (GAMECOMMAND)ControlMap.GetCommand(key, down, mode);
		Command(cmd);
	}
}

void TPlayScreen::Joystick(int key, BOOL down)
{
	TScreen::Joystick(key, down);

  // Gameplay Commands
	if (!Editor)
	{
		DWORD mode;
		if (Player && Player->IsFighting())
			mode = CTRL_COMBATMODE;
		else
			mode = CTRL_NORMALMODE;
		GAMECOMMAND cmd = (GAMECOMMAND)ControlMap.GetCommand(key, down, mode);
		Command(cmd);
	}
}

void TPlayScreen::MouseClick(int button, int x, int y)
{
  // Stop self running demo
	if (Player && Player->GetScript() &&  
		Player->GetScript()->Running() &&
		Player->GetScript()->GetTrigger() == TRIGGER_ALWAYS)
	{
		Player->GetScript()->End();
		if (IsDemoMode())  // If in the middle of uninterruptible part, restart game
		{
			SetDemoMode(FALSE);
			SaveGame.ReadGame();
			return;
		}
	}

	if (button == MB_LEFTDOWN || button == MB_RIGHTDOWN || button == MB_MIDDLEDOWN)
		TextBar.Clear();

	TScreen::MouseClick(button, x, y);
}

void TPlayScreen::Command(GAMECOMMAND command)
{
	int angle = -1;
	DWORD state, changed;

  // Get command flags
	ControlMap.GetCommandFlags(state, changed);

  // Stop self running demo
	if (Player && Player->GetScript() &&  
		Player->GetScript()->Running() &&
		Player->GetScript()->GetTrigger() == TRIGGER_ALWAYS)
	{
		Player->GetScript()->End();
		if (IsDemoMode())  // If in the middle of uninterruptible part, restart game
		{
			SetDemoMode(FALSE);
			SaveGame.ReadGame();
		}
	}

	if (MapPane.IsIgnoringInput())
		return;

	switch (command)
	{
	  case GAMECMD_COMBAT:
	  {
		if (Player)
		{
			if (Player->IsFighting())
				Player->EndCombat();
			else
				Player->BeginCombat();
		}
		break;
	  }
	  case GAMECMD_FULLSCREEN:
	  {
		if (IsFullScreen())
			SetFullScreen(FALSE);
		else
			SetFullScreen(TRUE);
		break;
	  }
	  case GAMECMD_USE:
	  {
		if (Player)
			Player->TryUse();
	    break;	
	  }
	  case GAMECMD_GET:
	  {
		if (Player)
			Player->TryGet();
	    break;	
 	  }
	  case GAMECMD_JUMP:
	  {
		if (Player)
			Player->Jump();
	    break;	
	  }
	  case GAMECMD_INVENTORY:
	  {
	    break;	
	  }
	  case GAMECMD_INVOKE1:
	  case GAMECMD_INVOKE2:
	  case GAMECMD_INVOKE3:
	  case GAMECMD_INVOKE4:
 	  {
		QuickSpells.Invoke(command - GAMECMD_INVOKE1 + 1);
	    break;	
	  }
	  case GAMECMD_INVUSE:
	  {
	    break;	
	  }
	  case GAMECMD_INVMOVE:
	  {
	    break;	
	  }
	  case GAMECMD_INVDROP:
	  {
	    break;	
	  }
	  case GAMECMD_INVEXIT:
	  {
	    break;	
	  }
	  case GAMECMD_SWING:
	  {
		if (Player)
			Player->Swing();
	    break;	
	  }
	  case GAMECMD_THRUST:
	  {
		if (Player)
			Player->Thrust();
	    break;	
	  }
	  case GAMECMD_CHOP:
	  {
		if (Player)
			Player->Chop();
	    break;	
	  }
	  case GAMECMD_COMBO1:
	  case GAMECMD_COMBO2:
	  case GAMECMD_COMBO3:
	  case GAMECMD_COMBO4:
	  case GAMECMD_COMBO5:
	  case GAMECMD_COMBO6:
	  {
		if (Player)
			Player->Combo(command - GAMECMD_COMBO1 + 1);
	    break;	
	  }
	  case GAMECMD_BLOCK:
	  {
		if (Player)
			Player->Block();
	    break;
	  }
	  case GAMECMD_DODGE:
	  {
		if (Player)
			Player->Dodge();
	    break;
	  }
	  case GAMECMD_DIRDOWN:
	  case GAMECMD_DIRUP:
	  {
		// Direction keys are state flags 0-7, so we can check by doing this little loop below
		int angle = 0;		// Check each key, and set angle if down
		int c;

		// Check changed	
		for (c = 1; c < (1 << 8) && !(c & (state & changed)); c <<= 1, angle += 32);
		
		// No changed key down, check rest of keys
		if (angle > 255)
		{
			angle = 0;
			for (c = 1; c < (1 << 8) && !(c & state); c <<= 1, angle += 32);

			if (angle > 255)
				angle = -1; // No direction keys down
		}

		// Now move char
		if (Player)
		{	
			if (angle >= 0)
			{
				if (Player->IsFighting() && (state & CMDFLAG_LEAP))
					Player->Leap(angle);
				else
					Player->Go(angle);
			}
			else
				Player->Stop();
		}

		break;
	  }
	  case GAMECMD_MOVEDOWN:
	  case GAMECMD_MOVEUP:
	  {
		if (Player && !Player->IsFighting())
		{
			if (state & CMDFLAG_RUN)
				Player->SetRunMode();
			else if (state & CMDFLAG_SNEAK)
				Player->SetSneakMode();
			else
				Player->SetWalkMode();
		}
	    break;
	  }
	  case GAMECMD_LEAPDOWN:
	  case GAMECMD_LEAPUP:
	  {
	    break; // Handle using 'state' below
	  }  
    } // End of switch  	

}

void TPlayScreen::CreateBackgroundAreas()
{
	if (!IsFullScreen()) // Create border background areas
	{
		Display->CreateBackgroundArea(0, 0, Display->Width(), FRAMEMAPPANEY);
			Display->CreateBackgroundArea(0, FRAMEMAPPANEY, FRAMEMAPPANEX, FRAMEMAPPANEHEIGHT);
		Display->CreateBackgroundArea(FRAMEMAPPANEX+FRAMEMAPPANEWIDTH, FRAMEMAPPANEY,
						Display->Width() - (FRAMEMAPPANEX+FRAMEMAPPANEWIDTH), FRAMEMAPPANEHEIGHT);
		Display->CreateBackgroundArea(0, FRAMEMAPPANEY+FRAMEMAPPANEHEIGHT, Display->Width(),
						Display->Height() - FRAMEMAPPANEY - FRAMEMAPPANEHEIGHT);
	}
}

void TPlayScreen::DrawOverhangs(BOOL temporary)
{
	if (IsFullScreen())
		return;

	Display->Reset();

	// Overhanging parts of interface screen to background
	for (int i = 0; i < NUMMAINHANGS; i++)
		Display->Put(oh[i].x, oh[i].y, overhang[i], DM_TRANSPARENT | (temporary ? 0 : DM_BACKGROUND));
}

void TPlayScreen::HideLowerPanes()
{
	Inventory.Hide();
	TextBar.Hide();
	QuickSpells.Hide();
	MultiCtrl.SetIgnoreInput(TRUE);
}

void TPlayScreen::ShowLowerPanes()
{
	Inventory.Show();
	TextBar.Show();
	QuickSpells.Show();
	MultiCtrl.SetIgnoreInput(FALSE);
}

void TPlayScreen::NewGame()
{
	loadnewgame = TRUE;
}

void TPlayScreen::SaveMap()
{
	savemap = TRUE;
}

// ------------------ Game Time Stuff --------------------

// Returns the number of frames elapsed since the beginning of the current game.
// This value is saved in the save game file, and restored whenever a game is loaded.
int TPlayScreen::GameFrame()
{
	return gameframes - sessionstart + lastsessionframes;
}

// This is the time in milliseconds since the beginning of the current game.  This
// gets saved and restored in the save game file as well.  This time is calculated 
// not by the system clock, but by dividing the GameFrames() value by the number 
// of frames per second.
int TPlayScreen::GameTime()
{
  // Note: use 64 bit ints so calculations don't wrap around	
	return gametime;
}

// Set the game time.  This is called from the save game/new game sytem.
void TPlayScreen::SetGameTime(int gametime)
{
	sessionstart = gameframes;
	lastsessionframes = (int)((__int64)((__int64)gametime * (__int64)FRAMERATE / (__int64)100));
	gametime = 
		(int)((__int64)((__int64)GameFrame() * (__int64)100 / (__int64)FRAMERATE));
	timeofday = 
		(int)((__int64)(((__int64)gametime * (__int64)(24 * 60) / 
			(__int64)Rules.daylength) % (__int64)(24 * 60)));
}

// Returns the time of day in minutes
int TPlayScreen::TimeOfDay()
{
	return timeofday;
}

// Returns the amount of ambient light 0-255 for the day
int TPlayScreen::Daylight()
{
	int time = TimeOfDay();
	int step;
	int morningbeg = (6 * 60) - (Rules.twilight >> 1);
	int morningend = morningbeg + Rules.twilight - 1;
	int eveningbeg = (18 * 60) - (Rules.twilight >> 1);
	int eveningend = eveningbeg + Rules.twilight - 1;

	if (time > eveningend || time < morningbeg)
		return 0;		// Night
	else if (time > morningend && time < eveningbeg)
		return 255;		// Day
	else if (time >= morningbeg && time <= morningend)
	{
		step = (time - morningbeg) * Rules.twilightsteps / Rules.twilight;
		return step * 255 / Rules.twilightsteps;
	}
	else
	{
		step = (Rules.twilight - (time - eveningbeg)) * Rules.twilightsteps / Rules.twilight;
		return step * 255 / Rules.twilightsteps;
	}
}

// Returns a DAY_MIDNIGHT, DAY_MORNING, DAY_DAYTIME, DAY_NOON, DAY_EVENING, DAY_NIGHT, flags
int TPlayScreen::DayTimeFlag()
{
	int time = TimeOfDay();
	int morningbeg = (6 * 60) - (Rules.twilight >> 1);
	int morningend = morningbeg + Rules.twilight - 1;
	int eveningbeg = (18 * 60) - (Rules.twilight >> 1);
	int eveningend = eveningbeg + Rules.twilight - 1;

	if (time == 0)
		return DAY_MIDNIGHT;
	else if (time == 12 * 60)
		return DAY_NOON;
	if (time > eveningend || time < morningbeg)
		return DAY_NIGHT;
	else if (time > morningend && time < eveningbeg)
		return DAY_DAYTIME;	
	else if (time >= morningbeg && time <= morningend)
		return DAY_MORNING;
	else
		return DAY_EVENING;
}

// Conversion function to convert game minutes (not real minutes) to frames
int ConvertFramesToMinutes(int frames)
{
	return frames * (24 * 60) / Rules.daylength; 
}

// Conversion function to convert frames to game minutes (not real minutes)
int ConvertMinutesToFrames(int time)
{
	return time * Rules.daylength / (24 * 60);
}
// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *               rangedweapon.cpp - TRangedWeapon module                 *
// *************************************************************************

#include "revenant.h"
#include "rangedweapon.h"

REGISTER_BUILDER(TRangedWeapon)
TObjectClass RangedWeaponClass("RANGEDWEAPON", OBJCLASS_RANGEDWEAPON, 0);

// Hard coded class stats
DEFSTAT(RangedWeapon, EqSlot,	EQSL, 0, 6, 0, 8)
DEFSTAT(RangedWeapon, Value,	VAL,  1, 0, 0, 1000000)


// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                resource.cpp - Resource object module                  *
// *************************************************************************

#include <stdio.h>
#include <string.h>
#include <io.h>

#include "revenant.h"

#include "bitmap.h"
#include "graphics.h"
#include "resource.h"
#include "resourcehdr.h"
//#include "box.h"

static char erropen[]    = "Couldn't open resource file %s!";
static char errnotcgs[]  = "%s is not a CGS resource file!";
static char errreading[] = "Error reading resource file %s!";
static char errwriting[] = "Error writing resource file %s!";
static char erroldver[]  = "%s has an older resource file version!";
static char errnewver[]  = "%s has a newer resource file version!";
static char erralloc[]   = "Couldn't alloc memory for %s!";

//CBox ImageryBox("c:\\exile\\nonormal\\imagery.box", BOX_READ_WRITE);

void *LoadResource(char *name, int id, DWORD *ressize)
{
	char *ptr;
	char filename[81];
	char fname[81];
	FileResHdr frh;
	DWORD *bitmaptable;

	if (id >= 0 && id <= 999)
	{
		sprintf(fname, "%s.%03d", name, id);
		strcpy(filename, ResourcePath);
		strcat(filename, fname);
	}

	else
	{
		strcpy(filename, ResourcePath);
		strcat(filename, name);
		if (!strchr(filename, '.'))
			strcat(filename, ".DAT");
	}

	strupr(filename);

	FILE *fl = fopen(filename, "rb");

	if (!fl)
		FatalError(erropen, filename);

  // Load header and check validity
	if (fread(&frh, sizeof(FileResHdr), 1, fl) < 1)
		FatalError(errreading, filename);

	if (frh.resmagic != RESMAGIC)
		FatalError(errnotcgs, filename);

	if (frh.version < RESVERSION)
		FatalError(erroldver, filename);

	if (frh.version > RESVERSION)
		FatalError(errnewver, filename);

  // Skip over header
	if (frh.hdrsize > 0)
		fseek(fl, frh.hdrsize + sizeof(FileResHdr), 0);

  // Read bitmap table
	//int here = ftell(fl);

	if (frh.topbm)
	{
		bitmaptable = (DWORD *)malloc(sizeof(DWORD) * frh.topbm);
		if (fread(bitmaptable, sizeof(DWORD), frh.topbm, fl) < frh.topbm)
			FatalError(errreading, filename);
	}

  // Read resource
	ptr = (char *)malloc(frh.objsize);

	if (!ptr)
		FatalError(erralloc, name);

	int retval = fread(ptr, frh.datasize, 1, fl);
	fclose(fl);

	if (retval < 1)
		FatalError(errreading, filename);

	// Touch resource to force vm system to keep pages loaded
	char *m = ptr;
	for (int c = 0; c < (int)frh.datasize; c += 2048, m += 2048)
	{
		int dummy = *m;
	}

	// Do runtime conversion to 16 bit, if necessary.
	if (frh.topbm)
	{
		for (int i = 0; i < frh.topbm; i++)
		{
			PTBitmap bm = (PTBitmap) (ptr + bitmaptable[i]);

			// Sanity check
			if ((DWORD)bm->width > (DWORD)8192 || (DWORD)bm->height > (DWORD)8192)
				FatalError("Corrupted bitmap list in resource %s", name);

			if (bm->flags & BM_15BIT)
				Convert15to16(bm);

			if (bm->flags & BM_8BIT)
				ConvertPal15to16(bm);
		}
		free(bitmaptable);
	}

	if (ressize)
		*ressize = frh.objsize;

	return ptr;
}

void *LoadResourceHeader(char *name, int id, DWORD *ressize)
{
	static char filename[81];
	static char fname[81];

	FileResHdr frh;

	if (id >= 0 && id <= 999)
	{
		sprintf(fname, "%s.%03d", name, id);
		strcpy(filename, ResourcePath);
		strcat(filename, fname);
	}

	else
	{
		strcpy(filename, ResourcePath);
		strcat(filename, name);
		if (!strchr(filename, '.'))
			strcat(filename, ".DAT");
	}

	strupr(filename);

	FILE *fl = fopen(filename, "rb");

	if (!fl)
	{
		Status(erropen, filename);
		return NULL;
	}

	if (fread(&frh, sizeof(FileResHdr), 1, fl) < 1)
	{
		fclose(fl);
		Status(errreading, filename);
		return NULL;
	}

	if (frh.resmagic != RESMAGIC)
	{
		fclose(fl);
		Status(errnotcgs, filename);
		return NULL;
	}

	if (frh.version < RESVERSION)
	{
		fclose(fl);
		Status(erroldver, filename);
		return NULL;
	}

	if (frh.version > RESVERSION)
	{
		fclose(fl);
		Status(errnewver, filename);
		return NULL;
	}

	char *ptr = NULL;

	if (frh.hdrsize > 0)
	{
		ptr = (char *)malloc(frh.hdrsize);

		if (!ptr)
		{
			fclose(fl);
			Status(erralloc, name);
			return NULL;
		}

		int retval = fread(ptr, frh.hdrsize, 1, fl);
		fclose(fl);

		if (retval < 1)
		{
			Status(errreading, filename);
			return NULL;
		}
	}

	if (ressize)
		*ressize = frh.hdrsize;

	return ptr;
}

// This doesn't work right now!
/*BOOL SaveResource(char *name, void *ptr, int id)
{
	static char filename[81];
	static char fname[81];
	FileResHdr frh;

	if (id >= 0)
	{
		wsprintf(fname, "%s.%03d", name, id);
		strcpy(filename, ResourcePath);
		strcat(filename, fname);
	}

	else
	{
		strcpy(filename, ResourcePath);
		strcat(filename, name);
		if (!strchr(filename, '.'))
			strcat(filename, ".dat");
	}

	FILE *fl = fopen(filename, "wb");

	if (!fl)
		FatalError(erropen, filename);

	frh.resmagic = RESMAGIC;
	frh.topbm = 0;
	frh.comptype = COMP_ZIP;
	frh.version = RESVERSION;
	frh.objsize = GlobalSize((HGLOBAL)LOWORD(GlobalHandle
								((const void *)HIWORD((DWORD)ptr))));
	frh.datasize = 0;
	frh.hdrsize = 0;

	if (fwrite(&frh, sizeof(FileResHdr), 1, fl) < 1)
		FatalError(errwriting, filename);

	if (fwrite(ptr, frh.objsize, 1, fl) < 1)
		FatalError(errwriting, filename);

	frh.datasize = ftell(fl) - sizeof(FileResHdr);
	fseek(fl, 0, 0);
	if (fwrite(&frh, sizeof(FileResHdr), 1, fl) < 1)
		FatalError(errwriting, filename);

	fclose(fl);

	return FALSETRUE;
}
*/

BOOL SaveResourceHeader(char *name, void *header, int hdrsize, int id)
{
	static char filename[81];
	static char fname[81];
	char errreading[] = "Error reading resource file %s!";

	FileResHdr frh;

	if (hdrsize == 0 || !header)
		return TRUE;

	if (id >= 0 && id <= 999)
	{
		sprintf(fname, "%s.%03d", name, id);
		strcpy(filename, ResourcePath);
		strcat(filename, fname);
	}

	else
	{
		strcpy(filename, ResourcePath);
		strcat(filename, name);
		if (!strchr(filename, '.'))
			strcat(filename, ".DAT");
	}

	strupr(filename);

	FILE *fl = fopen(filename, "rb+");

	if (!fl)
		FatalError(erropen, filename);

	if (fread(&frh, sizeof(FileResHdr), 1, fl) < 1)
		FatalError(errreading, filename);

	if (frh.resmagic != RESMAGIC)
		FatalError(errnotcgs, filename);

	if (frh.version < RESVERSION)
		FatalError(erroldver, filename);

	if (frh.version > RESVERSION)
		FatalError(errnewver, filename);

  // Load in old header
	char *oldheader = (char *)malloc(frh.hdrsize);

	if (!oldheader)
		FatalError(erralloc, name);

	if (fread(oldheader, frh.hdrsize, 1, fl) < 1)
		FatalError(errreading, filename);

  // Check to see if header is different
	if ((int)frh.hdrsize == hdrsize && memcmp(oldheader, header, hdrsize) == 0)
	{
		free(oldheader);
		fclose(fl);
		return TRUE;
	}

	free(oldheader);

  // Read bitmap table
	DWORD *bitmaptable;
	if (frh.topbm)
	{
		bitmaptable = (DWORD *)malloc(sizeof(DWORD) * frh.topbm);
		if (fread(bitmaptable, sizeof(DWORD), frh.topbm, fl) < frh.topbm)
			FatalError(errreading, filename);
	}
	else
		bitmaptable = NULL;

  // Read resource
	char *data = (char *)malloc(frh.datasize);
	if (!data)
		FatalError(erralloc, name);

	if (fread(data, 1, frh.datasize, fl) < 1)
		FatalError(errreading, filename);

  // Close and reopen file
	rewind(fl);

  // Write out NEW header block
	frh.hdrsize = hdrsize;

  // Resave resource header
	if (fwrite(&frh, sizeof(FileResHdr), 1, fl) < 1)
		FatalError(errwriting, filename);

	if (fwrite(header, frh.hdrsize, 1, fl) < 1)
		FatalError(errwriting, filename);

  // Write out old bitmap table
	if (frh.topbm > 0)
	{
		if (fwrite(bitmaptable, sizeof(DWORD), frh.topbm, fl) < frh.topbm)
			FatalError(errwriting, filename);
	}

  // Write out old resource data
	if (fwrite(data, frh.datasize, 1, fl) < 1)
		FatalError(errwriting, filename);

  // Delete allocated memory
	if (data)
		free(data);

	if (bitmaptable)
		free(bitmaptable);

	fclose(fl);

	return TRUE;
}
// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                  RevMain.cpp - System main module                     *
// *************************************************************************

#include <windows.h>
#include <io.h>
#include <stdarg.h>

// For multimonitor support
#define COMPILE_MULTIMON_STUBS
#include "multimon.h"

#include <direct.h>
#include <dos.h>
#include <dplay.h>
#include <fcntl.h>
#include <io.h>
#include <math.h>
#include <mmsystem.h>
#include <malloc.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "revenant.h"
#include "3dscene.h"
#include "bitmap.h"
#include "display.h"
#include "directinput.h"
#include "directdraw.h"
#include "graphics.h"
#include "playscreen.h"
#include "mappane.h"
#include "automap.h"
#include "inventory.h"
#include "mainwnd.h"
#include "savegame.h"
#include "screen.h"
#include "font.h"
#include "chunkcache.h"
#include "timer.h"
#include "equip.h"
#include "parse.h"
#include "player.h"
#include "multictrl.h"
#include "spell.h"
#include "statpane.h"
#include "script.h"
#include "textbar.h"
#include "statusbar.h"
#include "sound.h"
#include "editor.h"
#include "dls.h"
#include "ctrlmap.h"
#include "area.h"
#include "rules.h"

// Global Variables
HINSTANCE hInstance;
HANDLE PauseMutex;
MEMORYSTATUS StartMemory;

// Game directories
char RunPath[MAX_PATH];
char SavePath[MAX_PATH];

// Define the Editor paths
char ClassDefPath[MAX_PATH];		// Where to load / save Class.Def
char ExileRCPath[MAX_PATH];      	// Where to run ExileRC from & where
	 								// the graphics for the resources are
char ResourcePath[MAX_PATH];		// Where to read / write the resources
char BaseMapPath[MAX_PATH];			// Where the untouched version of the game map is stored
char CurMapPath[MAX_PATH];			// Where the current map is stored

// Global Structure Defines
PTScreen		CurrentScreen;		// Currently displayed screen object
PTScreen		NextScreen;			// Next Screen to be display object
TDisplay		display;			// Display object
PTDisplay		Display = &display; // Display pointer
T3DScene		Scene3D;			// Display pointer
TPlayScreen		PlayScreen;			// PlayScreen Object
TMapPane		MapPane;			// Map pane for PlayScreen
TInventory		Inventory;			// Inventory of objects
THealthBar		HealthBar;			// Character's health
TStaminaBar		StaminaBar;			// Character's fatigue
TTextBar		TextBar;			// Info line for player
TMultiCtrlPane	MultiCtrl;			// Multipane control panel (buttons)
TEquipPane		EquipPane;			// Equipment pane
TAutoMap		AutoMap;			// Automapper
TSpellPane		SpellPane;			// Talisman stuff
TQuickSpellPane	QuickSpells;		// Quick spell buttons
TStatPane		StatPane;			// Display of char's abilities
TScriptManager	ScriptManager;		// Manages all scripts in the game
TMainWindow		MainWindow;			// Windows Object
TSaveGame		SaveGame;			// SaveGame Object
TChunkCache		ChunkCache;			// Tile Cache
TTimer			Timer;				// Timer Object
PTFont			SystemFont;			// Basic utility font for game
PTFont			DialogFont;			// Dialog font
PTFont			DialogFontShadow;	// Dialog font shadow
PTFont			SmallFont;			// Small game font
PTFont			GameFont;			// Medium game font
PTFont			GoldFont;			// Medium gold font
PTFont			MetalFont;			// Small gold/metal font
PTFont			MenuFont;			// Menu font
PTPlayer		Player;				// Main player for the game
PTMulti			GameData;			// Multiresource for in game data
TSoundPlayer	SoundPlayer;		// Sound effects player
TControlMap		ControlMap;			// Contains the key/joystick mappings for game control
TAreaManager	AreaManager;		// Manages the game area system
TPlayerManager  PlayerManager;		// Manages the game player list
TRules	Rules;		// Manages global rules data (classes, chars, stats for attacks, etc.)
CRITICAL_SECTION CriticalSection;	// Controls enter critical section functions;

// Game speed variable
int GameSpeed = 4;			// Value 1-5 which determines how fast the game is running
							// Used to switch on/off processor intensive effects

// Total size of preload area (in sectors) if PreloadSectors is on
int PreloadSectorSize = -1;

// Total size of chunk cache to allocate (in MB's)
int ChunkCacheSize = -1;	// -1 is calculate based on available physical memory

// Clear before drawing update buffers?
BOOL ClearBeforeDraw = TRUE;		// Clear before drawing update buffers?
BOOL NoFrameSkip	 = FALSE;		// Disables frame skipping on slowdown
BOOL PauseFrameSkip  = FALSE;		// Set during disk loading to avoid skipping afterwards
BOOL NoScrollZBuffer = TRUE;		// Disables updating to video memory ZBuffer
BOOL WaitVertRetrace = TRUE;		// Wait vert retrace (not used)
BOOL ShowDrawing     = FALSE;		// Flips front and back buffer so you can see drawing
BOOL NoNormals		 = TRUE;		// Changes to no normals lighting mode
BOOL SmoothScroll    = TRUE;        // Do smooth scrolling
BOOL ScrollLock      = TRUE;		// Lock scrolling to the character
BOOL DrawRealtimeShadows = TRUE;	// Draw alpha shadows for 3D characters
BOOL Show3D		     = TRUE;		// Turn on the 3D system
BOOL Interpolate	 = TRUE;		// Causes 3D animations to interpolate when state changes
BOOL DoPageFlip		 = TRUE;		// Allows the PageFlip function to flip pages
BOOL PauseWhenNotActive = TRUE;		// Causes game to pause when not active
BOOL NoWideBuffers	 = FALSE;		// Doesn't allow video buffers with stides wider than their widths
BOOL UseDirect3D2	 = TRUE;		// True if you want to be able to use drawprimive stuff
BOOL UseSoftware3D	 = FALSE;		// Use software 3D (False assumes we want hardware if available)
BOOL SoftRampMode	 = TRUE;		// Use RAMP mode for software 3D (default)
BOOL SoftRGBMode	 = FALSE;		// Use RGB mode	for software 3D
BOOL UseDrawPrimitive = TRUE;		// If FALSE, 3D system does everything with Execute Buffers (always FALSE if UseDirect3D2 is FALSE)
BOOL CacheExBufs	 = TRUE;		// Attempt to cache execute buffers for chars and other animation
BOOL PreloadSectors  = TRUE;		// If true, will load a large sector cache for faster scrolling
BOOL NoPulseObjs	 = FALSE;		// Prevents the game objects from being pulsed
BOOL NoAnimateObjs	 = FALSE;		// Prevents the game objects from being animated
BOOL NoVidZBufLock   = FALSE;		// Prevents simultaneous locking of video and zbuffer (for voodoo)
BOOL NoBlitZBuffer   = FALSE;		// Card is incapable of blitting to the display ZBuffer (voodoo)
BOOL UseClearZBuffer = FALSE; 		// Use a clear z buffer for z restores (i.e. Viewport->Clear())
BOOL IsVooDoo		 = FALSE;		// True if using a voodoo card
BOOL IsMMX			 = FALSE;		// Has MMX extensions

// Multi-Monitor Variables
int MonitorNum = 0;			// Monitor game will run on (0=default (primary), 1=monitor 1, 2=monitor 2, etc.)
int MonitorX = 0;			// Relative position of monitor in desktop coordinates	
int MonitorY = 0;		
int MonitorW = 640;			// Relative position of monitor in desktop coordinates	
int MonitorH = 480;		
HMONITOR Monitor = NULL;	// Windows monitor handle
MONITORINFOEX MonitorInfo;	// Windows monitor info structure

// Game flags
BOOL Windowed = FALSE;		// Do we run the game in a window in NORMAL mode (instead of EXLUSIVE)
BOOL Borderless = FALSE;	// When windowed, cut out the border (menu, other windows garabage)?
BOOL Debug = FALSE;			// Should program be run in debug compatible mode?
BOOL Ignore3D = FALSE;		// Whether to disallow 3D imagery (to make it run on systmes without Direct3D)
BOOL Editor = FALSE;		// TRUE when in editor mode
BOOL StartInEditor = FALSE;	// Whether to start the program in editor mode
BOOL NoQuickLoad = FALSE;	// TRUE if program should not try to use IMAGERY.DAT file
BOOL Force15Bit = FALSE;	// Forces video mode to assume 15 bit
BOOL Force16Bit = FALSE;	// Forces video mode to assume 16 bit
BOOL FullScreen = FALSE;	// Full screen mode
BOOL ShowZBuffer      = FALSE;	// Show Z buffer for debugging
BOOL ShowNormalBuffer = FALSE;	// Show normal buffer for debugging
BOOL UnlockImmediately = TRUE; // Unlock DD Surf after lock (for debugging, allows stepping through draw code)

// Driver name string (allows user to select driver by just typing in name of card)
char DXDriverMatchStr[FILENAMELEN]; // Will use first DX driver who's description has the given string in it
 								    // i.e. use if string is "permidia" and driver desc is "Glint Permidia 2 3D"

// Tick Sync variable
BOOL TickOccured = FALSE;

// Disable Screen calls to timer functions
BOOL DisableTimer = FALSE;

// Last Frame Milliseconds (Do we show it?)
int LastFrameTicks;
BOOL ShowFramesPerSecond = FALSE;

// Character movement mode
BOOL GridSnap = FALSE;

// Music and sound effects
BOOL SoundSystemOn = TRUE;

// Is Control, Shift, or Alt down
BOOL CtrlDown, ShiftDown, AltDown;

// Is System Closing Down?
BOOL Closing = FALSE;

// For setting up 3D object bounding rects in the editor
BOOL UpdatingBoundingRect = FALSE;

// Is joystick available?
BOOL HasJoyStick = FALSE;
JOYINFO JoyInfo;

// Memory used by program
DWORD ImageryMemUsage = 0;

// Global Map Pane Sizes (Set to initial frame sizes to insure
int MAPPANEX, MAPPANEY, MAPPANEWIDTH, MAPPANEHEIGHT;
int SCROLLBUFWIDTH, SCROLLBUFHEIGHT;

// ************************************************************************
// *                          Support Functions                           *
// ************************************************************************

BOOL ThreadsPaused = FALSE;

void PauseThreads()
{
	ThreadsPaused = TRUE;
	TObjectImagery::PauseLoader();
	PAUSEUPDATE;
}

void ResumeThreads()
{
	ThreadsPaused = FALSE;
	TObjectImagery::ResumeLoader();
	MapPane.ResumeUpdate();
}

// *************** Simple Support Functions *****************

char *itos(int val, char *buf, int buflen)
{
	if (!buf)
		return buf;
	if (buflen < 2)
	{
		if (buf > 0)
			buf[0] = NULL;
		return buf;
	}
	if (buflen >= 12) // Twelve is big enough for anything
	{
		_itoa(val, buf, 10);
		return buf;
	}
	char b[12];
	_itoa(val, b, 10);
	strncpy(buf, b, buflen - 1);
	buf[buflen - 1] = NULL;
	return buf;
}

// Copies a file, or group of files using wildcards
int copyfiles(char *from, char *to, BOOL overwrite)
{
	if (!from || !to)
		return 0;

	struct _finddata_t data;

	char fdrive[_MAX_DRIVE];
	char fdir[_MAX_DIR];
	char fname[_MAX_FNAME];
	char fext[_MAX_EXT];

	char fromdir[MAX_PATH];
	char todir[MAX_PATH];
	char source[MAX_PATH];
	char dest[MAX_PATH];

	_splitpath(from, fdrive, fdir, fname, fext);
	sprintf(fromdir, "%s%s", fdrive, fdir);
	if (!fromdir[0])
		return 0;
	if (fromdir[strlen(fromdir) - 1] != '\\')
		strncatz(fromdir, "\\", MAX_PATH);

	_splitpath(to, fdrive, fdir, fname, fext);
	sprintf(todir, "%s%s", fdrive, fdir);
	if (!todir[0])
		return 0;
	if (todir[strlen(todir) - 1] != '\\')
		strncatz(todir, "\\", MAX_PATH);

	int copied = 0;

	long found, handle;
	found = handle = _findfirst(from, &data);
	while (found != -1)
	{
		sprintf(source, "%s%s", fromdir, data.name);
		sprintf(dest, "%s%s", todir, data.name);

		if (CopyFile(source, dest, !overwrite))
			copied++;

		found = _findnext(handle, &data);
	}

	return copied;
}

// Deletes a file, or group of files using wildcards
int deletefiles(char *name)
{
	struct _finddata_t data;

	char dir[MAX_PATH], file[MAX_PATH];

	char fdrive[_MAX_DRIVE];
	char fdir[_MAX_DIR];
	char fname[_MAX_FNAME];
	char fext[_MAX_EXT];

	_splitpath(name, fdrive, fdir, fname, fext);
	sprintf(dir, "%s%s", fdrive, fdir);

	int deleted = 0;

	long found = _findfirst(name, &data);
	while (found != -1)
	{
		strncpyz(file, dir, MAX_PATH);
		strncatz(file, data.name, MAX_PATH);
		if (DeleteFile(file))
			deleted++;

		found = _findfirst(name, &data);
	}

	return deleted;
}

// Returns system ticks in milliseconds since system was turned on
DWORD tickcount()
{
	return GetTickCount();
}

// *************** Error Functions *****************

void ThreadError(char *error, char *extra)
{
	char buf[101];
	sprintf(buf, error, extra);

	if (extra)
		_RPT1(_CRT_ERROR, error, extra);
	else
		_RPT0(_CRT_ERROR, error);

//	MSG Message;
//	while (PeekMessage(&Message, NULL, 0, 0, PM_REMOVE))
//	{
//		TranslateMessage(&Message);
//		DispatchMessage(&Message);
//	}

//	MessageBox(NULL, buf, "FATAL ERROR", MB_ICONSTOP | MB_OK);
}

void FatalError(char *error, char *extra)
{
	char buf[101];
	sprintf(buf, error, extra);

  // Write error string to display
	Status(buf);
	Status("Press any key to exit");

  // Prevent passing of windows message (input etc) to current screen
	CurrentScreen = NULL;

  // Stop timer stuff
	Timer.Close();

  // Close the display
	Display->Close();

  // Close Direct Draw
	CloseDirectDraw();

  // Close the window!	
	MainWindow.Close();

	MSG Message;
	while (PeekMessage(&Message, NULL, 0, 0, PM_REMOVE))
	{
		TranslateMessage(&Message);
		DispatchMessage(&Message);
	}

	if(!DirectDraw)
	{
		if (extra)
			_RPT1(_CRT_ERROR, error, extra);
		else
			_RPT0(_CRT_ERROR, error);
	}

//	ShowWindow(MainWindow.Hwnd(), 0);
//	MessageBox(NULL, buf, "FATAL ERROR", MB_ICONSTOP | MB_OK);

	exit(1);
}

void Error(char *error, char *extra)
{
	FatalError(error, extra);
/*
	char buf[101];
	sprintf(buf, error, extra);

  // Process windows messages (for Jong)
	MSG Message;
	while (PeekMessage(&Message, NULL, 0, 0, PM_REMOVE))
	{
		TranslateMessage(&Message);
		DispatchMessage(&Message);
	}

	MessageBox(NULL, buf, "FATAL ERROR", MB_ICONSTOP | MB_OK);

	exit(1);
*/
}

void WaitSingleErr(HANDLE obj)
{
	if (WaitForSingleObject(obj, INFINITE /*10000*/) == WAIT_TIMEOUT)
	{
		FatalError("Wait Failed");
	}
}

void WaitMultipleErr(DWORD objs, CONST HANDLE *obj, BOOL all)
{
	if (WaitForMultipleObjects(objs, obj, all, INFINITE /*10000*/) == WAIT_TIMEOUT)
	{
		FatalError("Wait Failed");
	}
}

// *************** Display Status Functions *****************

void Status(char *fmt,...)
{
	static char buf[1024]; // Temporary buf for output
	static y = 10;

	if (!DirectDraw || !SystemFont || !Display->GetSurface())
		return;

	va_list marker;
	va_start(marker, fmt);
	vsprintf(buf, fmt, marker);

	char *s = buf;
	char *p = buf;
	while (1)
	{
		if (*p == '\n' || *p == NULL)
		{
			char save = *p;
			*p = NULL;
			if (strlen(s) > 0)
			{
				Display->WriteText(s, 10, y, 1, SystemFont, NULL, DM_TRANSPARENT | DM_ALIAS);
				Display->PutToScreen(0, 0, Display->Width(), Display->Height());
				y += 10;
			}
			if (!save)
				break;
			s = p + 1;
		}
		p++;
	}
}

// *************** Critical Section Functions *****************

void BEGIN_CRITICAL()
{
	EnterCriticalSection(&CriticalSection);
}

void END_CRITICAL()
{
	LeaveCriticalSection(&CriticalSection);
}

// ****** Exit the Game - Why would anyone want to do that? ******

void ExitGame()
{
	PostQuitMessage(0);
}

// *************** Settings Functions *****************

char INIPath[RUNPATHLEN];
char INISection[64];

void INISetSection(char *newsection)
{
	strncpyz(INISection, newsection, 64);
}

void INISetPath(char *runpath)
{
	char *ininame = "Revenant.ini";

	strcpy(INIPath, SavePath);
	strcat(INIPath, ininame);

  // Make sure INI file is in writable (SavePath) directory
	if (stricmp(RunPath, SavePath) != 0) // Run/Save path are different
	{
		FILE *fp = fopen(INIPath, "r");
		if (!fp)	// INI file not in SavePath
		{
			char from[MAX_PATH];
			strcpy(from, RunPath);
			strcat(from, ininame);
			copyfiles(from, INIPath);
		}
	}
}

int INIGetInt(char *key, int def, char *format)
{
	int i = GetPrivateProfileInt(INISection, key, def, INIPath);

	INISetInt(key, i, format);

	return i;
}

void INISetInt(char *key, int i, char *format)
{
	if (!format)
		format = "%d";

	char buf[20];
	sprintf(buf, format, i);

	WritePrivateProfileString(INISection, key, buf, INIPath);
}

char *INIGetText(char *key, char *def, char *buf, int buflen)
{
	static char s[128];
	if (!buf)
	{
		buf = s;
		buflen = 128;
	}

	if (!def)
		def = "";

  // Quote the string
	char qdef[128];
	strncpyz(qdef, "\"", 128);
	strncatz(qdef, def, 128);
	strncatz(qdef, "\"", 128);

	GetPrivateProfileString(INISection, key, qdef, buf, buflen, INIPath);

	if (buf[0] == '\"')
	{
		int l = strlen(buf);
		memmove(buf, buf + 1, l - 2);
		buf[l - 2] = NULL;
	}

	INISetText(key, buf);

	return buf;
}

void INISetText(char *key, char *str)
{
  // Quote the string
	char qstr[128];
	strncpyz(qstr, "\"", 128);
	strncatz(qstr, str, 128);
	strncatz(qstr, "\"", 128);

	WritePrivateProfileString(INISection, key, qstr, INIPath);
}

char *INIGetStr(char *key, char *def, char *buf, int buflen)
{
	static char s[128];
	if (!buf)
	{
		buf = s;
		buflen = 128;
	}

	if (!def)
		def = "";

	GetPrivateProfileString(INISection, key, def, buf, buflen, INIPath);

	INISetStr(key, buf);

	return buf;
}

void INISetStr(char *key, char *str)
{
	WritePrivateProfileString(INISection, key, str, INIPath);
}

int INIGetArray(char *key, int size, int *ary, int defsize, int *defary, char *format)
{
	char buf[128];

	if (ary != defary)
		memset(ary, 0, sizeof(int) * size);

	GetPrivateProfileString(INISection, key, "", buf, 128, INIPath);

	int newsize = 0;
	if (!buf[0])
	{
		if (defary)
		{
			while (newsize < defsize && newsize < size)
			{
				ary[newsize] = defary[newsize];
				newsize++;
			}
		}
	}
	else
	{
		char *tok = NULL;
		do
		{
			tok = strtok((newsize < 1) ? buf : NULL, ",");
			if (tok)
			{
				ary[newsize] = atol(tok);
				newsize++;
			}
		} while (tok && newsize < size);
	}	

	INISetArray(key, newsize, ary, format);

	return newsize;
}

void INISetArray(char *key, int size, int ary[], char *format)
{
	char buf[128];

	if (!format)
		format = "%d";

	buf[0] = NULL;
	for (int c = 0; c < size; c++)
	{
		if (c >= 1)
			strcat(buf, ",");
		int len = strlen(buf);
		sprintf(buf + len, format, ary[c]);
	}

	WritePrivateProfileString(INISection, key, buf, INIPath);
}

BOOL INIGetBool(char *key, BOOL def, char *yes, char *no)
{
	char buf[30];
	char getyes[30], getno[30];

	if (!yes)
		strcpy(getyes,"yes on true 1");
	else
	{
		strcpy(getyes, yes);
		strlwr(getyes);
	}

	if (!no)
		strcpy(getno, "no off false 0");
	else
	{
		strcpy(getno, no);
		strlwr(getno);
	}

	GetPrivateProfileString(INISection, key, "", buf, 30, INIPath);
	strlwr(buf);

	BOOL b; 
	if (!strstr(yes, buf))
		b = TRUE;
	else if (!strstr(no, buf))
		b = FALSE;
	else
		b = def;

	INISetBool(key, b, yes, no);

	return b;
}

void INISetBool(char *key, BOOL on, char *yes, char *no)
{
	if (!yes)
		yes = "1";
	if (!no)
		no = "0";

	WritePrivateProfileString(INISection, key, on ? yes : no, INIPath);
}

BOOL INIGetYesNo(char *key, BOOL def)
{
	return INIGetBool(key, def, "Yes", "No");
}

void INISetYesNo(char *key, BOOL on)
{
	INISetBool(key, on, "Yes", "No");
}

BOOL INIGetTrueFalse(char *key, BOOL def)
{
	return INIGetBool(key, def, "True", "False");
}

void INISetTrueFalse(char *key, BOOL on)
{
	INISetBool(key, on, "True", "False");
}

BOOL INIGetOnOff(char *key, BOOL def)
{
	return INIGetBool(key, def, "On", "Off");
}

void INISetOnOff(char *key, BOOL on)
{
	INISetBool(key, on, "On", "Off");
}

// Grab the ParseAnything function from PARSE.CPP
BOOL ParseAnything(BOOL stack, TToken &t, char *format, va_list ap);

BOOL INIParse(char *key, char *def, char *format, ...)
{
	char buf[128];

	INIGetStr(key, def, buf, 128);

	va_list ap;
	va_start(ap, format);

	TStringParseStream s(buf, strlen(buf));
	TToken t(s);
	t.Get();

	BOOL retval = ParseAnything(TRUE, t, format, ap);

	va_end(ap);

	return retval;
}

void INIPrint(char *key, char *format, ...)
{
	char buf[128];

	va_list marker;
	va_start(marker, format);

	vsprintf(buf, format, marker);

	va_end(marker);

	INISetStr(key, buf);
}

// *************** Allocation Functions *****************

int TotalAllocated, MaxAllocated;

#ifdef _DEBUG

#undef malloc
#undef free
#undef realloc

void *xmalloc(int size, char *file, int line)
{
	TotalAllocated += size;
	if (TotalAllocated > MaxAllocated)
		MaxAllocated = TotalAllocated;
	void *p = _malloc_dbg(size, _NORMAL_BLOCK, file, line);
	return p;
}

void *xrealloc(void *p, int size, char *file, int line)
{
	TotalAllocated = TotalAllocated - _msize(p) + size;
	if (TotalAllocated > MaxAllocated)
		MaxAllocated = TotalAllocated;
	p = _realloc_dbg(p, size, _NORMAL_BLOCK, file, line);
	return p;
}

void xfree(void *p)
{
	if (p != NULL)
		TotalAllocated -= _msize(p);
	_free_dbg(p, _NORMAL_BLOCK);
}

void* __cdecl operator new(size_t size)
{
	void *p = xmalloc(size,"new",0);
	if (!p)
		FatalError("OUT OF MEMORY - Increase your virtual swap file size", NULL);
	else
		memset(p, 0, size);

	return p;
}

void __cdecl operator delete(void *pointer)
{
	xfree(pointer);
}

#endif

char *makepath(char *name, char *buf, int buflen)
{
  // If root path expicitly given, (i.e. "c:\", or "\" or "\\" or "..") use it
	if (name[0] == '\\' || name[1] == ':' || (name[0] == '.' && name[1] == '.'))
	{
		strncpyz(buf, name, buflen);
		return buf;
	}

  // If root path is ".", substitute SavePath or RunPath
	if (name[0] == '.')
	{
		name++;
		while (name[0] == '\\')
			name++;
	}

  // Always try SavePath first (SavePath will always be writable directory on hard drive)
	strncpyz(buf, SavePath, buflen);
	strncatz(buf, name, buflen);

	return buf;
}

FILE *popen(char *name, char *flags)
{
	char fn[MAX_PATH];
	
  // If root path expicitly given, (i.e. "c:\", or "\" or "\\" or "..") use it
	if (name[0] == '\\' || name[1] == ':' || (name[0] == '.' && name[1] == '.'))
		return fopen(name, flags);

  // If root path is ".", substitute SavePath or RunPath
	if (name[0] == '.')
	{
		name++;
		while (name[0] == '\\')
			name++;
	}

  // Always try SavePath first (SavePath will always be writable directory on hard drive)
	strncpyz(fn, SavePath, MAX_PATH);
	strncatz(fn, name, MAX_PATH);

  // If SavePath fails, and we have a different run path, try it 
  // (RunPath can be read only CD-ROM)
	FILE *fp = fopen(fn, flags);
	if (!fp && stricmp(SavePath, RunPath) != 0)
	{
		strncpyz(fn, RunPath, MAX_PATH);
		strncatz(fn, name, MAX_PATH);
		fp = fopen(fn, flags);
	}

	return fp;
}

// Random number function
int random(int min, int max)
{
	if (min == max)
		return min;

	if (max < min)
	{
		int t = min;
		min = max;
		max = t;
	}

	int r = rand() % (max - min + 1);
	r += min;
	return r;
}

// ********* Comma Delimited String Lists **********

// Comma delimited list functions (useful for strings in "abcd,defg,hijk" format)
// If dst is NULL, retuns result pointer from static internal buffer

#define LISTBUFLEN 128
static char listbuf[LISTBUFLEN];

// Get num string from comma list
char *listget(char *src, int num, char *dst, int len)
{
	if (!dst)
	{
		dst = listbuf;
		len = LISTBUFLEN;
	}

	if (len <= 0)
		return dst;

	dst[0] = NULL;

	char *p = src;
	int comma = 0;
	while (*p && comma < num)
	{
		if (*p == ',')
			comma++;
		p++;
	}

	char *d = dst;
	int l = 0;
	while (*p && *p != ',' && l < len - 1)
	{
		*d = *p;
		d++;
		p++;
		l++;
	}
	*d = NULL;

	return dst;
}

// Get total number of strings in comma list
int listnum(char *src)
{
	char *p = src;
	int comma = 0;
	while (*p)
	{
		if (*p == ',')
			comma++;
		p++;
	}

	return comma + 1;
}

// Get random string from comma list
char *listrnd(char *src, char *dst, int len)
{
	return listget(src, random(0, listnum(src) - 1), dst, len);	
}

// Returns TRUE if string is in comma list (case insensitive)
BOOL listin(char *src, char *in)
{
	char *s = src;
	char *i = in;

	while (*s)
	{
		if (*s == ',')
		{
			if (*i == NULL)
				break;
			i = in;
			s++;
		}
		else if (!*i || toupper(*i) != toupper(*s))
		{
			while (*s && *s != ',')
				s++;
			if (*s == ',')
				s++;
			i = in;
		}
		else
		{
			s++;
			i++;
		}
	}

	return *i == NULL;
}

// ********* Free Memory Functions **********

DWORD MemUsed()
{
	MEMORYSTATUS ms;
	ms.dwLength = sizeof(MEMORYSTATUS);
	GlobalMemoryStatus(&ms);
	return ms.dwMemoryLoad;
}

DWORD FreeMem()
{
	MEMORYSTATUS ms;
	ms.dwLength = sizeof(MEMORYSTATUS);
	GlobalMemoryStatus(&ms);
	return ms.dwAvailVirtual;
}

DWORD TotalMem()
{
	MEMORYSTATUS ms;
	ms.dwLength = sizeof(MEMORYSTATUS);
	GlobalMemoryStatus(&ms);
	return ms.dwTotalVirtual;
}

DWORD FreePhys()
{
	MEMORYSTATUS ms;
	ms.dwLength = sizeof(MEMORYSTATUS);
	GlobalMemoryStatus(&ms);
	return ms.dwAvailPhys;
}

DWORD TotalPhys()
{
	MEMORYSTATUS ms;
	ms.dwLength = sizeof(MEMORYSTATUS);
	GlobalMemoryStatus(&ms);
	return ms.dwTotalPhys;
}

DWORD FreePage()
{
	MEMORYSTATUS ms;
	ms.dwLength = sizeof(MEMORYSTATUS);
	GlobalMemoryStatus(&ms);
	return ms.dwAvailPageFile;
}

DWORD TotalPage()
{
	MEMORYSTATUS ms;
	ms.dwLength = sizeof(MEMORYSTATUS);
	GlobalMemoryStatus(&ms);
	return ms.dwTotalPageFile;
}

// ************************************************************************
// *                     Initialization Functions                         *
// ************************************************************************

#define cpuid __asm _emit 0x0f __asm _emit 0xa2

#define MMXBIT (1 << 23)

BOOL HasMMX()
{
	DWORD version;
	DWORD features;

	__asm
	{
		mov eax, 1
		cpuid
		mov version, eax
		mov features, edx
	}

	return (features & MMXBIT) != 0;
}

void GetProgramPaths(char *lpCmdLine, char *RunPath, char *SavePath)
{

  char *p;
  // Get The Run Path
	GetModuleFileName(hInstance, RunPath, RUNPATHLEN - 1);
	p = RunPath + strlen(RunPath) - 1;
	while (p != RunPath && *p != '\\')
		*p-- = NULL;

  // Get save path
	strcpy(SavePath, RunPath);
	char *tfname = "test.fil";
	char fname[60];
	strcpy(fname, SavePath);
	strcat(fname, tfname);
	FILE *f = fopen(fname, "wb");
	if (f)
	{
		fclose(f);
		unlink(fname);
	}
	else
	{
		strcpy(SavePath, "c:\\Revenant");
		for (int qq = 0; qq < 5; qq++)
		{
			if (mkdir(SavePath) == 0)
				break;
			strcpy(fname, SavePath);
			strcat(fname, "\\");
			strcat(fname, tfname);
			f = fopen(fname, "wb");
			if (f)
			{
				fclose(f);
				unlink(fname);
				break;
			}
			SavePath[0]++;
		}
		strcat(SavePath, "\\");
	}

	strlwr(SavePath);
	strlwr(RunPath);
}

void GetParameters(char *lpCmdLine)
{
	char *ptr;

	if (strstr(lpCmdLine, "DEBUG"))
		Debug = TRUE;						// Sets up debug compatible mode.

  	if (strstr(lpCmdLine, "FORCE15BIT"))
		Force15Bit = TRUE;					// Forces 15 bit mode

	if (strstr(lpCmdLine, "FORCE16BIT"))
		Force16Bit = TRUE;					// Forces 15 bit mode

	if (strstr(lpCmdLine, "EDITOR"))		// Start in editor mode
		StartInEditor = TRUE;

	if (strstr(lpCmdLine, "WINDOWED"))		// Run game in a window
		Windowed = TRUE;

	if (strstr(lpCmdLine, "NOQUICKLOAD"))	// Run game in a window
		NoQuickLoad = TRUE;

	if (strstr(lpCmdLine, "BORDERLESS"))	// Run game with no border
		Borderless = TRUE;

	if (strstr(lpCmdLine, "NOWIDE"))		// Prevents wide video buffers (stride > width)
		NoWideBuffers = TRUE;

	if (strstr(lpCmdLine, "FULLSCREEN"))	// Causes game map to start in full screen mode
		FullScreen = TRUE;

	if (strstr(lpCmdLine, "NOPRELOADSECTORS"))	// Causes sectors to NOT be cached
	{
		PreloadSectors = FALSE;
		PreloadSectorSize = 1;
	}

	ptr = strstr(lpCmdLine, "MONITOR=");	// Set monitor number
	if (ptr)								
		MonitorNum = atoi(ptr + 8);

	ptr = strstr(lpCmdLine, "GAMESPEED=");	// Set game speed
	if (ptr)								
	{
		GameSpeed = atoi(ptr + 10);
		if (GameSpeed < 1)
			GameSpeed = 1;
		if (GameSpeed > 5)
			GameSpeed = 5;
	}

	ptr = strstr(lpCmdLine, "PRELOADSIZE=");	// Set game speed
	if (ptr)								
	{
		PreloadSectorSize = atoi(ptr + 12);
		if (PreloadSectorSize > 4)
			PreloadSectorSize = 4;
		if (PreloadSectorSize < 1)
		{
			PreloadSectors = FALSE;
			PreloadSectorSize = 1;
		}
	}

	ptr = strstr(lpCmdLine, "CHUNKCACHESIZE=");	// Set game speed
	if (ptr)								
	{
		ChunkCacheSize = atoi(ptr + 15);
		if (ChunkCacheSize > 256)
			ChunkCacheSize = 256;
	}

	ptr = strstr(lpCmdLine, "DRIVER=");	// Set display device
	if (!ptr)
		ptr = strstr(lpCmdLine, "DEVICE=");	// Set display device (same thing)
	if (ptr)
	{
		ptr += 7;
		char *d = DXDriverMatchStr;
		while (*ptr && *ptr != ' ')
			*d++ = *ptr++;
		*d = 0;
		strlwr(DXDriverMatchStr);
	}

	if (strstr(lpCmdLine, "IGNORE3D"))		// Run game without Direct3D objects
		Ignore3D = TRUE;

	if (strstr(lpCmdLine, "OLDDIRECT3D"))	// Prevents game from using draw primitives
	{
		UseDirect3D2 = FALSE;				// Doesn't initialize Direct3D 2 stuff
		UseDrawPrimitive = FALSE;			// Forces system to use execute buffers
	}

	if (strstr(lpCmdLine, "SOFTWARE3D"))	// Causes game to use software 3D
		UseSoftware3D = TRUE;

	if (strstr(lpCmdLine, "RAMPMODE"))		// Runs software 3D in ramp emulation mode
	{
		SoftRampMode = TRUE;
		SoftRGBMode = FALSE;
	}

	if (strstr(lpCmdLine, "RGBMODE"))		// Runs software 3D in rgb mode
	{
		SoftRampMode = FALSE;
		SoftRGBMode = TRUE;
	}

	if (strstr(lpCmdLine, "NODRAWPRIM"))	// Forces system to use execute buffers
		UseDrawPrimitive = FALSE;

	if (strstr(lpCmdLine, "NOCACHEEXBUFS"))	// Prevents system from caching execute buffers
		CacheExBufs = FALSE;

	if (strstr(lpCmdLine, "NOVIDZLOCK"))	// Prevents system from simultaneously lcoking the
		NoVidZBufLock = TRUE;				// display video and z surfaces (locks the VooDoo)

	if (strstr(lpCmdLine, "CLEARZ"))		// Causes system to allocate an extra ZBuffer so 
	{										// we can use the Viewport->Clear() function to 
		UseClearZBuffer = TRUE;				// update the screen ZBuffer, and so that we can
		NoVidZBufLock = FALSE;				// draw to the ZBuffer in TDisplay (since 
	}										// it won't be the tree screen ZBuffer.

	if (strstr(lpCmdLine, "VOODOO"))		// This is a voodoo card
	{										// we can use the Viewport->Clear() function to 
		IsVooDoo = TRUE;					
		NoVidZBufLock = TRUE;	// Don't try to lock video and zbuffer at same time
		NoBlitZBuffer = TRUE;	// Can't blit to or from the zbuffer
		UseClearZBuffer = TRUE; // Use a secondary clear zbuffer for drawing instead of display zbuffer	
	}

	ptr = strstr(lpCmdLine, "FASTLOCK=");
	if (ptr)								// Sets the buffer locking mode.  If on, causes 
	{										// buffers to be unlocked immediately after locked (faster)
		UnlockImmediately = !strnicmp(ptr + 9, "on", 2) ||
							!strnicmp(ptr + 9, "1", 1);
	}
}

void GetINISettings()
{
  // ***** Get Program Paths *****

	INISetSection("Paths");
	INIGetText("ClassDefPath", ".", ClassDefPath, MAX_PATH);
	INIGetText("ExileRCPath", ".", ExileRCPath, MAX_PATH);
	INIGetText("ResourcePath", ".", ResourcePath, MAX_PATH);
	INIGetText("CurMapPath", ".", CurMapPath, MAX_PATH);
	INIGetText("BaseMapPath", ".", BaseMapPath, MAX_PATH);

	// Make sure each string ends with a backslash
	if (ClassDefPath[strlen(ClassDefPath) - 1] != '\\')
		strcat(ClassDefPath, "\\");

	if (ExileRCPath[strlen(ExileRCPath) - 1] != '\\')
		strcat(ExileRCPath, "\\");

	if (ResourcePath[strlen(ResourcePath) - 1] != '\\')
		strcat(ResourcePath, "\\");

	if (CurMapPath[strlen(CurMapPath) - 1] != '\\')
		strcat(CurMapPath, "\\");

	if (BaseMapPath[strlen(BaseMapPath) - 1] != '\\')
		strcat(BaseMapPath, "\\");
}

// This function gets called as soon as the display system finds the right driver.
// You can check the parameters of the driver and set system flags here so that things
// work correctly.
void DriverSetupCallback()
{
	char buf[DRIVERDESCLEN];
	strncpyz(buf, DirectDrawDesc, DRIVERDESCLEN);
	strlwr(buf);

	// Set special flags for VooDoo cards
	if (strstr(buf, "voodoo"))	// Only voodoo cards would match this!
	{
		NoVidZBufLock = TRUE; // Don't try to lock video and zbuffer at same time
		NoBlitZBuffer = TRUE; // Can't blit to or from the zbuffer
		UseClearZBuffer = TRUE; // Use a secondary clear zbuffer for drawing instead of display zbuffer	
	}
}

BOOL InitLanguage()
{
  // Check for language file
#if 0
   // Get Language file
	p = strstr(lpCmdLine, "LANG=");
	if (p)
		Language = atoi(p + 5);
	else
		Language = GetProfileInt("intl", "iCountry", 1);
	char buf[20];
	wsprintf(buf, "LANGUAGE.%03d", Language);
	f = fopen(buf, "rb");
	if (!f)
		Language = ENGLISH;
	else
		fclose(f);

	if (Language == ENGLISH)
		SecondLang = ENGLISH;

	if (strstr(lpCmdLine, "KOR"))
		SecondLang = KOREAN;

	LoadLanguage(Language);
#endif
	return TRUE;
}

BOOL CALLBACK MonitorEnumProc(HMONITOR hMonitor, HDC hDC, LPRECT lpRect, LPARAM)
{
	MonitorInfo.cbSize = sizeof(MonitorInfo);
	Monitor = hMonitor;
	GetMonitorInfo(hMonitor, (MONITORINFO*)&MonitorInfo);
	MonitorX = MonitorInfo.rcMonitor.left;
	MonitorY = MonitorInfo.rcMonitor.top;
	MonitorW = MonitorInfo.rcMonitor.right - MonitorInfo.rcMonitor.left;
	MonitorH = MonitorInfo.rcMonitor.bottom - MonitorInfo.rcMonitor.top;

	char *ptr = strstr(MonitorInfo.szDevice, "Display");
	if (!ptr)
		ptr = strstr(MonitorInfo.szDevice, "display");
	if (!ptr)
		ptr = strstr(MonitorInfo.szDevice, "DISPLAY");
	int dispnum = atoi(ptr + 7);

	if (MonitorNum <= 1 && ((dispnum == 1) || (dispnum == 0)))
	{
		if (MonitorNum == 0)
			strcpy(MonitorInfo.szDevice, "display");
		return FALSE;
	}

	if (MonitorNum == dispnum)
		return FALSE;

	return TRUE;
} 

BOOL InitMonitor()
{
	if (MonitorNum > GetSystemMetrics(SM_CMONITORS) || MonitorNum < 0)
		return FALSE;
	EnumDisplayMonitors(NULL, NULL, MonitorEnumProc, NULL);

	return TRUE;
}

// ************************************************************************
// *                    Initialize and Close System                       *
// ************************************************************************

BOOL InitSystem()
{
	SystemFont = TFont::LoadFont(100);
	DialogFont = TFont::LoadFont(101);
	DialogFontShadow = TFont::LoadFont(102);
	SmallFont = TFont::LoadFont(104);
	GameFont = TFont::LoadFont(105);
//	GoldFont = TFont::LoadFont(105);
	
  // Set correct imagery path
	if (NoNormals == TRUE)
		TObjectImagery::SetImageryPath(NONORMALPATH);
	else
		TObjectImagery::SetImageryPath(NORMALPATH);

  // Allocate the chunk cache as 1/4 free physical memory or 4MB
	int physmegs = TotalPhys() / (1024 * 1024);
	if (ChunkCacheSize < 1)
	{
		if (physmegs < 16)
		{
			DWORD res = MessageBox(NULL, "This game requires at least 16MB of system minimum to run well. "
							 "If you press OK the game will load normally, but game "
							 "performance will be severely degraded.",
							 "WARNING", MB_ICONSTOP | MB_OK);
			
			if (res == IDCANCEL)
				return FALSE;

			ChunkCacheSize = 2;
		}
		else if (physmegs <= 24)
			ChunkCacheSize = 3;
		else if (physmegs <= 32)
			ChunkCacheSize = 6;
		else
			ChunkCacheSize = min(physmegs - 32, 16);
	}
	if (PreloadSectorSize < 0)
	{
		if (physmegs < 16)
		{
			PreloadSectorSize = 1;
			PreloadSectors = FALSE;
		}
		else if (physmegs <= 24)
		{
			PreloadSectorSize = 1;
			PreloadSectors = TRUE;
		}
		else if (physmegs <= 32)
		{
			PreloadSectorSize = 2;
			PreloadSectors = TRUE;
		}
		else
		{
			PreloadSectorSize = 3;
			PreloadSectors = TRUE;
		}
	}
	ChunkCache.AllocCache(ChunkCacheSize);

  // Do the critical section object
	InitializeCriticalSection(&CriticalSection);

  // Create main display
	if (!Display->Initialize(WIDTH, HEIGHT, BPP))
		FatalError("Couldn't open main display", NULL);

  // Setup system color tables
	MakeColorTables();

  // Print stats
	Status("Revenant Version 0.25 Build %s %s\n"
		   "Copyright (C) Cinematix Studios, Inc. 1998\n", __DATE__, __TIME__);
	if (IsMMX)
		Status("MMX detected, using advanced lighting\n");
	else
		Status("No MMX detected, using normal lighting\n");
	Status("Physical memory %d MB\n", physmegs);
	Status("Chunk cache size %d MB\n", ChunkCacheSize);
	Status("Available display devices: %s\n", DriversAvailable);
	Status("Current display device: %s - %s\n", DirectDrawName, DirectDrawDesc);
	Status("Preload sectors %s, preload size %d\n", (PreloadSectors?"ON":"OFF"), PreloadSectorSize);

  // Initialize the timer
	Status("Initializing timers\n");
	if (!Timer.Initialize())
		FatalError("Couldn't initialize timer", NULL);

  // Capture the mouse cursor
//	SetCapture(MainWindow.Hwnd());

  // Initialize Direct Input
	Status("Initializing direct input\n");
	InitializeDirectInput();

  // Initialize Joysticks (if any)
	Status("Initializing joysticks\n");
	InitializeJoysticks();

  // Start loader thread..
	TObjectImagery::BeginLoaderThread();

  // Setup performance variables
    if (GameSpeed <= 1)
	{
		SmoothScroll = FALSE;		
	}

  // Load class.def
	Status("Loading classes with %s option\n", NoQuickLoad?"NOQUICKLOAD":"QUICKLOAD");
	TObjectClass::LoadClasses();

  // Setup player manager
	Status("Initializing multi-player manager\n");
	PlayerManager.Initialize();

  // Load rules data
	Status("Loading game rules\n");
	Rules.Initialize();

	return TRUE;
}

void CloseSystem()
{
  // Kill fonts
	delete SystemFont;
	delete DialogFont;
	delete DialogFontShadow;
	delete SmallFont;
	delete GameFont;
//	delete GoldFont;

  // Kill rules data
	Rules.Close();

  // Close player manager
	PlayerManager.Close();

  // Free all object classes in the class system
	TObjectClass::FreeClasses();

  // Resume all threads
	if (ThreadsPaused)
		ResumeThreads();		

	if (CurrentScreen)
	{
		CurrentScreen->Close();
		CurrentScreen = NULL;
	}

  // End loader thread..
	TObjectImagery::EndLoaderThread();

  // Close Sound System
	CDStop();
	CDClose();
	SoundPlayer.Close();

  // Release DirectInput (including joystick)
	CloseDirectInput();

  // Release the mouse capture
	ReleaseCapture();

  // Stop timer stuff
	Timer.Close();

  // Close the display
	Display->Close();

	MSG Message;
	while (PeekMessage(&Message, NULL, 0, 0, PM_REMOVE))
	{
		TranslateMessage(&Message);
		DispatchMessage(&Message);
	}

  // Close the main window
	MainWindow.Close();

  // Clear out any clipping rectangle
	ClipCursor(NULL);
}

// ************************************************************************
// *                   WinMain - Main Program Function                    *
// ************************************************************************

/* Pretty simple here.  Just make a main window, start its message loop
 * going, then when the message loop returns, close the program. */

int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
	LPSTR lpCmdLine, int nCmdShow)
{
    _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_DEBUG);
    _CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_WNDW);
    _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_DEBUG);

  // Preset capabilities flags
	IsMMX = HasMMX();

	StartMemory.dwLength = sizeof(MEMORYSTATUS);
	GlobalMemoryStatus(&StartMemory);

	::hInstance = hInstance;

	int size = sizeof(SObjectInfo);

  // Set windows to return fail when file not found..
 	SetErrorMode(SEM_FAILCRITICALERRORS	| SEM_NOOPENFILEERRORBOX);

  // Calls small heap alloc routine for requests < MAXSMALLHEAP
	_set_sbh_threshold( MAXSMALLHEAP );

  // Randomize!!
	srand( (unsigned)time( NULL ) );

  // Get upper case command line
	strupr(lpCmdLine);

  // Gets location of program path and save path
	GetProgramPaths(lpCmdLine, RunPath, SavePath);
	_chdir(RunPath);
	INISetPath(RunPath);

  // What version of Windows is this
	DWORD ver  = GetVersion();
	BYTE major = LOBYTE(ver);
	BYTE minor = HIBYTE(ver);

	if (major <= 3) FatalError("This game requires Windows '95/NT 4.0 (or higher)!", NULL);

  // Get INI file settings
	GetINISettings();

  // Get Program Parameters
	GetParameters(lpCmdLine);

  // Init Pause Thread Mutex
	PauseMutex = CreateMutex(NULL, FALSE, NULL);

  // Init monitor information
	if (!InitMonitor())
		FatalError("Invalid monitor selected", NULL);

  // Initialize language resources
	if (!InitLanguage());

  // Create the main window
	if (!MainWindow.Initialize(hInstance, hPrevInstance, lpCmdLine, nCmdShow))
		FatalError("Couldn't create main window", NULL);

  // Ok, now initialize the rest of the system
	if (!InitSystem())
		return 0;

  // Figure out first screen
	PTScreen NextScreen = &PlayScreen;

  // Do game screens
	while (NextScreen)
		NextScreen = TScreen::ShowScreen(NextScreen, 0);

  // Close the system down
    CloseSystem();

	return 0;
}
// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                   SaveGame.cpp - savegame objects                     *
// *************************************************************************

#include "revenant.h"
#include "playscreen.h"
#include "mappane.h"
#include "sector.h"
#include "player.h"
#include "inventory.h"
#include "automap.h"
#include "io.h"
#include "multictrl.h"
#include "statusbar.h"
#include "script.h"
#include "dls.h"
#include "savegame.h"

#define NOTHING		0
#define CONTENTS	1
#define NEXT		2

#define DATA_SLOTS		32		// number of extra data slots in the savefile

BOOL TSaveGame::WriteGame(char *name)
{
	if (!name)
		name = "game01.sav";

	if (!Player)
		return FALSE;

	if (saved != Player)
		saved = Player;

	pane = MultiCtrl.GetActivePane();
	gametime = PlayScreen.GameTime();
	version = MAP_VERSION;

	TOutputStream os(32768, 16384);

	FILE *fp;
    fp = popen("game01.sav", "wb");
	if (!fp)
		return FALSE;

	BOOL retval = TRUE;

	fseek(fp, 0, 0);

	// Write out the Auto Map data first
	if (AutoMap.WriteAutoMapData(fp) == -1)
		retval = FALSE;
	else
	{
		// Then some other random info...
		// Note there are DATA_SLOTS integers here for adding more extra info
		// to the save file without ruining any existing ones
		int data[DATA_SLOTS];
		memset(data, 0, sizeof(int) * DATA_SLOTS);
		data[0] = gametime;
		data[1] = pane;
		data[7] = version;

		if (fwrite(data, sizeof(int), DATA_SLOTS, fp) < DATA_SLOTS)
			retval = FALSE;
		else
		{
			// Finally Player himself (including all inventory and equipment)
			TObjectInstance::SaveObject(saved, os);
			if (fwrite(os.Buffer(), os.DataSize(), 1, fp) < 1)
				retval = FALSE;
		}
	}

	fclose(fp);

	return retval;
}

BOOL TSaveGame::ReadGame(char *name)
{
	if (!name)
		name = "game01.sav";

  // Kill the currently loaded map (return to original map)
	MapPane.ClearCurMap();

  // Reload initial game states
	ScriptManager.ReloadStates();

  // Clear the current player list
	PlayerManager.Clear();
	
  // Now attempt to load the game
	BOOL retval = TRUE;

	FILE *fp = popen(name, "rb");
	if (fp == NULL)
		return FALSE;

	size_t bufsize = _filelength(fileno(fp));
	BYTE *buf = NULL;

	if (bufsize > 0)
	{
		// Keep track of how big the Auto Map data is
		size_t size;

		size = AutoMap.ReadAutoMapData(fp);
		if (size == -1)
			retval = FALSE;
		else
		{
			// Read in the spare data
			bufsize -= DATA_SLOTS * sizeof(int);
			int data[DATA_SLOTS];

			if (fread(data, sizeof(int), DATA_SLOTS, fp) < DATA_SLOTS)
				retval = FALSE;
			else
			{
				// Transfer the data to the appropriate values
				gametime = data[0];
				pane = data[1];
				version = data[7];

				// Now adjust bufsize so we can read in the streamed object list
				bufsize -= size;

				buf = (BYTE *)malloc(bufsize);

				if (fread(buf, bufsize, 1, fp) < 1)
					retval = FALSE;
			}
		}
	}
	else
	{
		buf = (BYTE *)malloc(sizeof(int));
		bufsize = 4;
		*((int *)buf) = 0;
	}

	fclose(fp);

	if (version < 3)		// first version supporting recursive object writes
		FatalError("game01.sav is an old version, get rid of it please");

	if (retval)
	{
		TInputStream is(buf, bufsize);
		saved = TObjectInstance::LoadObject(is, version);
	}

	if (buf)
		free(buf);

	if (!saved)
		return FALSE;

  // Set visible pane
	MultiCtrl.ActivatePane(pane);

  // Adds the player into the player manager
	PlayerManager.AddPlayer((PTPlayer)saved);

  // Tell system this is our main player
	PlayerManager.SetMainPlayer((PTPlayer)saved);

  // Restore game time
	PlayScreen.SetGameTime(gametime);

	return retval;
}
// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                screen.cpp  - EXILE Screen Object File                 *
// *************************************************************************

#include <stdio.h>
#include <windows.h>

#include "revenant.h"
#include "bitmap.h"
#include "display.h"
#include "mainwnd.h"
#include "timer.h"
#include "cursor.h"
#include "mappane.h"
#include "screen.h"
#include "sound.h"

int cursorx = 0;		// Mouse cursor positions
int cursory = 0;
int mousebutton = 0;	// Mouse button

extern BOOL LoaderWait;

// Screen Display Functions

TScreen::TScreen()
{
	nextscreen = NULL;
}

TScreen::~TScreen()
{
}

BOOL TScreen::BeginScreen()
{
	int loop;

	Display->InitBackgroundSystem();
	firstframe = TRUE;  // Tell timer tick function not to flip a page the first time

	panes.Clear();
	screenframes = 0;
	for (loop = 0; loop < NUMEXCLUSIVEPANES; loop++)
		exclusive[loop] = 0;
	numexclusive = 0;

	BOOL ok = Initialize();
	if (!ok)
		return FALSE;

	return TRUE;
}

void TScreen::EndScreen()
{
	int loop;

	Close();

	panes.Clear();
	screenframes = 0;
	for (loop = 0; loop < NUMEXCLUSIVEPANES; loop++)
		exclusive[loop] = 0;
	numexclusive = 0;
}

// Copies contents of display's back buffer to the user's display immediately. (For
// 'loading' screens which have to update from within a single timer tick).
void TScreen::PutToScreen()
{
	Display->PutToScreen(0, 0, Display->Width(), Display->Height());
}

// *************************
// * Screen Pane Functions *
// *************************

int TScreen::FindPane(PTPane pane)
{
	for (TPaneIterator p(&panes); p; p++)
		if (pane == p.Item())
			return p.ItemNum();

	return -1;
}

int TScreen::AddPane(PTPane pane, int panenum)
{
  // Do pane list
	for (int loop = 0; loop < panes.NumItems(); loop++)
	{
		if (panes[loop] == pane)
		{
			if (panenum < 0)
				return loop;
			else
				panes.Remove(loop);
		}
	}

	int newnum;
	if (panenum < 0)
		newnum = panes.Set(pane, panes.NumItems());
	else
		newnum = panes.Set(pane, panenum);

	return newnum;
}

BOOL TScreen::RemovePane(PTPane pane)
{
	for (int loop = 0; loop < panes.NumItems(); loop++)
	{
		if (panes[loop] == pane)
		{
			panes.Remove(loop);
			return TRUE;
		}
	}

	return FALSE;
}

BOOL TScreen::SetExclusivePane(int panenum, BOOL completeexclusion)
{
	if (!panes[panenum] || numexclusive >= NUMEXCLUSIVEPANES)
		return FALSE;

	exclusive[numexclusive] = panenum;
	complete[numexclusive] = completeexclusion;
	numexclusive++;

	return TRUE;
}

void TScreen::ReleaseExclusivePane(int panenum)
{
	int pos = 0;
	for (int c = 0; c < numexclusive; c++)
	{
		if (exclusive[c] != panenum)
		{
			exclusive[pos] = exclusive[c];
			pos++;
		}
	}

	numexclusive = pos;
}

void TScreen::RedrawAllPanes()
{
	Display->Reset();

  // Do exclusive
	if (numexclusive > 0)
	{
		PTPane pane = panes[exclusive[numexclusive - 1]];
		if (pane && !pane->IsHidden())
			pane->SetDirty(TRUE);

		if (complete[numexclusive - 1])
		{
			Display->Reset();
			return;
		}
	}

  // Do pane list
	for (int loop = 0; loop < panes.NumItems(); loop++)
		if (panes.Used(loop) && !panes[loop]->IsHidden())
			panes[loop]->SetDirty(TRUE);

	Display->Reset();
}

// *****************************
// * Virtual Handler Functions *
// *****************************

void TScreen::DrawBackground()
{
	Display->Reset();

  // Do exclusive
	if (numexclusive > 0)
	{
		PTPane pane = panes[exclusive[numexclusive - 1]];
		if (pane && !pane->IsHidden())
		{
			if (dirty)
				pane->Update();

			pane->SetClipRect();
			pane->DrawBackground();
		}

		if (complete[numexclusive - 1])
		{
			dirty = FALSE;
			Display->Reset();
			return;
		}
	}

  // Do pane list
	for (int loop = 0; loop < panes.NumItems(); loop++)
	{
		if (!panes.Used(loop) || panes[loop]->IsHidden())
			continue;

		if (dirty)
			panes[loop]->Update();

		panes[loop]->SetClipRect();
		panes[loop]->DrawBackground();
	}

	dirty = FALSE;
	Display->Reset();
}

void TScreen::Pulse()
{
	Display->Reset();

  // Do exclusive
	if (numexclusive > 0)
	{
		PTPane pane = panes[exclusive[numexclusive - 1]];
		if (pane && !pane->IsHidden())
		{
			pane->SetClipRect();
			pane->Pulse();
		}

		if (complete[numexclusive - 1])
		{
			Display->Reset();
			return;
		}
	}

  // Do pane list
	for (int loop = 0; loop < panes.NumItems(); loop++)
	{
		if (!panes.Used(loop) || panes[loop]->IsHidden())
			continue;
		panes[loop]->SetClipRect();
		panes[loop]->Pulse();
	}

	Display->Reset();
}

void TScreen::Animate(BOOL draw)
{
	Display->Reset();

  // Do exclusive
	if (numexclusive > 0)
	{
		PTPane pane = panes[exclusive[numexclusive - 1]];
		if (pane && !pane->IsHidden())
		{
			pane->SetClipRect();
			pane->Animate(draw);
		}

		if (complete[numexclusive - 1])
		{
			Display->Reset();
			return;
		}
	}

  // Do pane list
	for (int loop = 0; loop < panes.NumItems(); loop++)
	{
		if (!panes.Used(loop) || panes[loop]->IsHidden())
			continue;
		panes[loop]->SetClipRect();
		panes[loop]->Animate(draw);
	}

	Display->Reset();
}

void TScreen::MouseClick(int button, int x, int y)
{
	Display->Reset();

  // Do exclusive
	if (numexclusive > 0)
	{
		PTPane pane = panes[exclusive[numexclusive - 1]];
		if (pane && !pane->IsHidden())
		{
			pane->SetClipRect();
			pane->MouseClick(button, x - pane->GetPosX(), y - pane->GetPosY());
		}
		Display->Reset();
		return;
	}

  // Do pane list
	for (int loop = 0; loop < panes.NumItems(); loop++)
	{
		if (!panes.Used(loop) || panes[loop]->IsHidden() || panes[loop]->IsIgnoringInput())
			continue;

		panes[loop]->SetClipRect();
		int nx = x - panes[loop]->GetPosX();
		int ny = y - panes[loop]->GetPosY();

	  // send mouseup buttons to all panes, not just the owner of that screen space
		if (panes[loop]->InPane(nx, ny) ||
			(button == MB_LEFTUP || button == MB_RIGHTUP || button == MB_MIDDLEUP))
			panes[loop]->MouseClick(button, nx, ny);
	}

	Display->Reset();
}

void TScreen::MouseMove(int button, int x, int y)
{
	Display->Reset();

  // Do exclusive
	if (numexclusive > 0)
	{
		PTPane pane = panes[exclusive[numexclusive - 1]];
		if (pane && !pane->IsHidden())
		{
			pane->SetClipRect();
			pane->MouseMove(button, x - pane->GetPosX(), y - pane->GetPosY());
		}
		Display->Reset();
		return;
	}

  // Do pane list
	for (int loop = 0; loop < panes.NumItems(); loop++)
	{
		if (!panes.Used(loop) || panes[loop]->IsHidden() || panes[loop]->IsIgnoringInput())
			continue;

		panes[loop]->SetClipRect();
		int nx = x - panes[loop]->GetPosX();
		int ny = y - panes[loop]->GetPosY();
		panes[loop]->MouseMove(button, nx, ny);
	}

	Display->Reset();
}

void TScreen::KeyPress(int key, BOOL down)
{
	Display->Reset();

  // Do exclusive
	if (numexclusive > 0)
	{
		PTPane pane = panes[exclusive[numexclusive - 1]];
		if (pane && !pane->IsHidden())
			pane->KeyPress(key, down);
		Display->Reset();
		return;
	}

	for (int loop = 0; loop < panes.NumItems(); loop++)
	{
		if (!panes.Used(loop) || panes[loop]->IsHidden() || panes[loop]->IsIgnoringInput())
			continue;
		panes[loop]->SetClipRect();
		panes[loop]->KeyPress(key, down);
	}

	Display->Reset();
}

void TScreen::CharPress(int key, BOOL down)
{
	Display->Reset();

  // Do exclusive
	if (numexclusive > 0)
	{
		PTPane pane = panes[exclusive[numexclusive - 1]];
		if (pane && !pane->IsHidden())
			pane->CharPress(key, down);
		Display->Reset();
		return;
	}

	for (int loop = 0; loop < panes.NumItems(); loop++)
	{
		if (!panes.Used(loop) || panes[loop]->IsHidden() || panes[loop]->IsIgnoringInput())
			continue;
		panes[loop]->SetClipRect();
		panes[loop]->CharPress(key, down);
	}

	Display->Reset();
}

void TScreen::Joystick(int key, BOOL down)
{
	Display->Reset();

  // Do exclusive
	if (numexclusive > 0)
	{
		PTPane pane = panes[exclusive[numexclusive - 1]];
		if (pane && !pane->IsHidden())
			pane->Joystick(key, down);
		Display->Reset();
		return;
	}

	for (int loop = 0; loop < panes.NumItems(); loop++)
	{
		if (!panes.Used(loop) || panes[loop]->IsHidden() || panes[loop]->IsIgnoringInput())
			continue;

		panes[loop]->SetClipRect();
		panes[loop]->Joystick(key, down);
	}

	Display->Reset();
}

// ***************************
// * Screen System Functions *
// ***************************

PTScreen TScreen::ShowScreen(PTScreen screen, int ticks)
{
	if (!screen)
		return NULL;

	CurrentScreen = screen;

	CurrentScreen->screenframes = 0;

	// clear the screen
//	Display->Clear(0, 0xffff, 0, DM_NOCLIP | DM_NORESTORE);
//	Display->FlipPage();
//	Display->Clear(0, 0xffff, 0, DM_NOCLIP | DM_NORESTORE);

	BOOL init = CurrentScreen->BeginScreen();

	if (init)
	{
		CurrentScreen->TimerLoop(ticks);
		CurrentScreen->EndScreen();
	}

	CurrentScreen = NULL;

	if (init && !Closing)
		return screen->GetNextScreen();
	else
		return NULL;
}

BOOL TScreen::TimerTick(BOOL draw)
{
	// Make sure we pick up where we left off if TimerTick() is called recursively
	// from the message handling functions!
	static BOOL washandlingmessage = FALSE;
	MSG  Message;

	HWND hwnd = MainWindow.Hwnd();

	if (hwnd == NULL || Closing || !Display->Width())
		return FALSE;

	if (!washandlingmessage)
	{
	  // Process windows messages
		washandlingmessage = TRUE;
		while (PeekMessage(&Message, hwnd, 0, 0, PM_REMOVE))
		{
			if (Message.message == WM_QUIT)
			{	
				Closing = TRUE;
				return FALSE;
			}
			if (Message.message == WM_PAINT)
				ValidateRect(hwnd, NULL);
			else
			{
				TranslateMessage(&Message);
				DispatchMessage(&Message);
			}
		}

	  // If no current screen, forget it!
		if (CurrentScreen != this || Closing)
			return FALSE;

	  // Simulate mouse messages by polling the mouse
		POINT cursorpos;
		GetCursorPos(&cursorpos);
		RECT r;
		GetClientRect(MainWindow.Hwnd(), &r);
		ClientToScreen(MainWindow.Hwnd(), (LPPOINT)&r);
		cursorpos.x -= r.left;
		cursorpos.y -= r.top;

		// only bother if it's changed
		if (cursorx != cursorpos.x || cursory != cursorpos.y)
		{
			cursorx = cursorpos.x;
			cursory = cursorpos.y;

			CurrentScreen->MouseMove(mousebutton, cursorx, cursory);
		}

	  // Get joystick state and send down to screen
		DWORD joystate, joychanged;
		GetJoystickState(0, &joystate, &joychanged);
		if (joychanged)
		{
			int joykey = -1;
			BOOL joydown = FALSE;

			while (GetJoystickKeyCode(joystate, joychanged, joykey, joydown))
				Joystick(joykey, joydown);
		}

	  // Reset clipping stuff
		Display->Reset();

	  // Resize pane before pulsing (and possibly setting new map position)
		for (int loop = 0; loop < panes.NumItems(); loop++)
		{
			if (!panes.Used(loop))
				continue;

		  // Update pane sizes
			if (panes[loop]->WasResized())
				panes[loop]->PaneResized();
		}

	  // Pulse the screen (and it's panes) before we do any drawring....
		Pulse();	

	  // Now update pane scroll position (after pulsing and possibly setting new map pos)
		for (loop = 0; loop < panes.NumItems(); loop++)
		{
			if (!panes.Used(loop))
				continue;

		  // Set panes do dirty if screen is dirty
			if (dirty)
				panes[loop]->SetDirty(TRUE);	

		  // Update the scrollpos for panes	
			panes[loop]->UpdateBackgroundScrollPos();
		}

	  // Calls the DrawBackground() function
	  // Note: All drawing is done BEFORE the dirty rectangle restore functions are called.
	  // This means that you can actually override what the restore system would do before
	  // it has a chance to do it.  Any background draws will merge their update rectangles
	  // with the restore rects in the restore system, thus reducing the total amount of the
	  // display to restore.  If you update the entire background, all restore rects are
	  // deleted (this actually happens during screen scrolling).

		if (draw)
			DrawBackground();

	  // Restores the video buffer
		if (draw)
			Display->RestoreBackgroundAreas();

	}

	washandlingmessage = FALSE;

 // Call screen's Animate() virtual function
	Display->Reset();
	Animate(draw);

 // Draw new mouse cursor
	Display->Reset();
	if (draw)
		DrawMouseCursor();	

	return TRUE;
}

BOOL TScreen::TimerLoop(long ticks)
{
	DWORD totalticks, totalframes, skipframes;
	float showrate, framerate, frameaccum;
	BOOL lastskipped;

	showrate = framerate = (float)FRAMERATE;
	frameaccum = (float)0.0;
	totalticks = totalframes = skipframes = 0;
	lastskipped = FALSE;

	while (TRUE)
	{
	  // If clock has ticked, call timertick
		if (!DisableTimer)
			Timer.WaitForTick();

		while (PauseWhenNotActive && !AppActive)
		{
		  // Process windows messages
			MSG  Message;
			HWND hwnd = MainWindow.Hwnd();

			GetMessage(&Message, hwnd, 0, 0);		// use getmessage instead of peekmessage for pause

			if (Message.message == WM_QUIT)
			{
				Closing = TRUE;
				return FALSE;
			}
			if (Message.message == WM_PAINT)
				ValidateRect(hwnd, NULL);
			else
			{
				TranslateMessage(&Message);
				DispatchMessage(&Message);
			}
		}
		
		if (CurrentScreen)
		{
			static DWORD lastcount;

			LastFrameTicks = GetTickCount() - lastcount;
			lastcount = GetTickCount();

			totalticks += LastFrameTicks;
			totalframes++;
			if (lastskipped)
				skipframes++;

			if (PauseFrameSkip)
				totalframes = totalticks = skipframes = 0;

			if (totalframes >= 5)
			{
				showrate = (float)1000.0 / (float)(totalticks / totalframes);
				int realframes = totalframes - skipframes;
				if (realframes <= 0)
					realframes = 1; 
				framerate = (float)1000.0 / (float)(totalticks / realframes);

				if (skipframes >= totalframes)
					PauseFrameSkip = TRUE;

				totalticks = 0;
				totalframes = 0;
				skipframes = 0;
			}

			if (ShowFramesPerSecond)
			{
				char buf[80];
				int usleep = MapPane.GetUpdateSleep();
				sprintf(buf, "Frame rate: %4.1f %4.1f %d - %s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s", showrate, framerate, usleep,
					(SmoothScroll)?"Scr ":"",
					(NoFrameSkip)?"NSkp ":"",
					(NoScrollZBuffer)?"NSZb ":"",
					(ShowDrawing)?"Shw ":"",
					(NoNormals)?"NNrm ":"",
					(ClearBeforeDraw)?"Clr ":"",
					(FlatShade)?"FSh ":"",
					(DitherEnable)?"Dth ":"",
					(BlendEnable)?"Bln ":"",
					(ZEnable)?"Zbf ":"",
					(SpecularEnable)?"Spc ":"",
					(UseTextures)?"Tex ":"",
					(BilinearFilter)?"Flt ":"",
					(NoUpdateRects)?"NUp ":"",
					(Show3D)?"3D ":"",
					(GridSnap)?"Grd ":"",
					(UseDrawPrimitive)?"Dpr ":"",
					(NoPulseObjs)?"NPls ":"",
					(NoAnimateObjs)?"NAni ":"",
					(Interpolate)?"":"NInt ");
				Display->Reset(); // Reset display clipping rect
				Display->WriteText(buf, 
					MapPane.GetPosX() + 10,
					MapPane.GetPosY() + 10,
					1, SystemFont, NULL, DM_TRANSPARENT | DM_ALIAS);
			}
			
			frameaccum += framerate; // Accumulator is greater than framerate to draw a frame

			if (frameaccum > (FRAMERATE - 0.5) || firstframe || PauseFrameSkip || NoFrameSkip) // Skip a frame
			{
				PauseFrameSkip = FALSE;			// resume normal frame skipping

				Timer.ResetTick();
				if (frameaccum > (float)100.0)
					frameaccum = (float)0.0;
				else
					frameaccum -= FRAMERATE;

				if (!firstframe)
					Display->FlipPage(TRUE);  // Don't flip page the first time
				firstframe = FALSE;

				if (!CurrentScreen->TimerTick(TRUE))
					return FALSE;

				screenframes++;

				lastskipped = FALSE;
			}
			else
			{
				if (!CurrentScreen->TimerTick(FALSE))
					return FALSE;

				screenframes++;

				lastskipped = TRUE;
			}
		}

		if (ticks)
		{
			ticks--;
			if (!ticks)
				return TRUE;
		}
	}

	return FALSE;
}

// *******************
// * TPane Functions *
// *******************

BOOL TPane::Initialize() 
{ 
	if (isopen)
		return TRUE;
	
	x = newx; y = newy; width = newwidth; height = newheight;

	backgroundbuffer = -1; 
	oldscrollx = scrollx = newscrollx = oldscrolly = scrolly = newscrolly = 0;
	dirty = TRUE;
	ignoreinput = FALSE;

  // Create any background buffers for this pane
	CreateBackgroundBuffers();

	isopen = TRUE;

	return TRUE; 
}

void TPane::Close()
{
  // Free all background buffers for this pane	
	FreeBackgroundBuffers();

	isopen = FALSE;
}

// Causes the pane to be immediately shown on the screen.  Useful for when
// the pane contains a status or 'loading' bar that is updated during a single
// timer tick.
void TPane::PutToScreen()
{
	Display->PutToScreen(x, y, width, height);
}

// This function can be called to draw a pane immediately (instead of waiting for the
// screen TimerTick() function to call the various draw routines.  Note that no user
// input will be processed, and only the Pulse(), DrawBackground(), and Animate() functions
// are called.  The PutToScreen() function can be called immediately after this function
// to render the results to the display.
void TPane::Draw()
{
	if (!IsOpen() || IsHidden())
		return;

	SClipState cs;
	Display->SaveClipState(cs);

	SetClipRect();

	Pulse();
	DrawBackground();
	Animate(TRUE);

	Display->RestoreClipState(cs);
}


void TPane::SetClipRect()
{
	Display->SetOrigin(x - scrollx, y - scrolly);
	Display->SetClipRect(x, y, width, height);
	Display->SetClipMode(CLIP_EDGES);
}

void TPane::UpdateBackgroundScrollPos()
{
	oldscrollx = scrollx; oldscrolly = scrolly;
	scrollx = newscrollx; scrolly = newscrolly;
	if (backgroundbuffer >= 0)
		Display->ScrollBackground(backgroundbuffer, scrollx, scrolly);
}	

void TPane::DrawRestoreRect(int x, int y, int width, int height, DWORD drawmode)
{
	Display->DrawRestoreRect(backgroundbuffer, x, y, width, height, drawmode);
}

// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                    Script.cpp - Script functions                      *
// *************************************************************************

#include <stdio.h>
#include <io.h>
#include <ctype.h>
#include <math.h>

#include "revenant.h"
#include "script.h"
#include "parse.h"
#include "object.h"
#include "command.h"
#include "mappane.h"
#include "dialog.h"
#include "file.h"
#include "exit.h"
#include "player.h"
#include "textbar.h"

#ifdef _WINDOWS_
#error WINDOWS.H shouldn't be included here!
#endif

int TScript::pauseall = FALSE;

PTObjectInstance TakenObject = NULL;
PTObjectInstance DroppedObject = NULL;

void ScriptError(char *buf, int linenum)
{
	char buf2[100];
	sprintf(buf2, "Script error at line %d: %s\n", linenum, buf);
	if (Editor)
		Output(buf2);
	else
		TextBar.Print(buf2);
}

void SkipBlock(TToken &t)
{
	if (!t.SkipBlock())
		ScriptError("BEGIN without matching END", 0);
}

// ***********
// * TScript *
// ***********

TScript::TScript(PTScriptProto prototype)
{
	proto = prototype;
	ip = NULL;
	priority = 0;
	depth = 0;
	lastpriority = 0;
	newtrigger = 0;
	newtriggerstr[0] = NULL;
	block[0].conditional = COND_UNDEF;
	block[0].loopstart = NULL;
}

TScript::~TScript()
{
}

BOOL TScript::Load(char *filename)
{
	return TRUE;
}

BOOL TScript::Save(char *filename)
{
	return TRUE;
}

void TScript::SetText(char *buf)
{
	proto->SetBuffer(buf);
	ScriptManager.SetScriptsDirty();
}
 
void TScript::Start(char *ptr, int newpriority)
{
	ip = ptr;
	lastpriority = priority = newpriority;

	// validate
	if (ip && (ip < proto->text || ip > proto->text+strlen(proto->text)))
		ip = NULL;

	if (!ip)
		priority = 0;
}

BOOL TScript::Triggered(PSScriptTrigger st, PTObjectInstance context)
{
	BOOL retval = FALSE;

  // ******************
  // !!!!!REMEMBER!!!!!
  // ******************
  
  // This function is being called often, so 
  // make sure you don't do anything to intense
  // here.  KEEP IT SIMPLE AND FAST!

	switch (st->type)
	{
	  case TRIGGER_ALWAYS:		// This trigger will always fire if it has a higherer priority
	  {
		retval = TRUE;
		break;
	  }
	  case TRIGGER_TRIGGER:		// This is the manually fired trigger (triggered by script 'trigger' command)
	  {
		if (newtrigger == TRIGGER_TRIGGER && 
		  !stricmp(st->name, newtriggerstr))
			retval = TRUE;
		break;
	  }
	  case TRIGGER_DIALOG:		// This trigger is triggered by clicking on a friendly character
	  {
		if (newtrigger == TRIGGER_DIALOG)
			retval = TRUE;
		break;
	  }
	  case TRIGGER_PROXIMITY:	// This allow you to set a floating proximity field for a character
	  {							// Slightly slow, so be careful where you use this
		if (newtrigger == TRIGGER_PROXIMITY)
			retval = TRUE;
		else 
		{
			if (Player && !stricmp(st->name, Player->GetName()))
				retval = context->Pos().InRange(Player->Pos(), st->dist);
			else
			{
//				PTObjectInstance inst = MapPane.ObjectInRange(context->Pos(), st->dist, OBJSET_CHARACTER);
//				if (st->name[0] == NULL || !stricmp(st->name, inst->GetName()))
//					retval = TRUE;
			}
		}
		break;
	  }
	  case TRIGGER_CUBE:		// Nice and fast cube trigger
	  {
		if (newtrigger == TRIGGER_CUBE)
			retval = TRUE;
		else if (!stricmp(st->name, context->GetName()))
		{
			if (st->cube.In(context->Pos()))
				retval = TRUE;
		}
		else if (Player && !stricmp(st->name, Player->GetName()))
		{
			if (st->cube.In(Player->Pos()))
				retval = TRUE;
		}
		else 
		{
			PTObjectInstance inst = MapPane.ObjectInCube(&st->cube, OBJSET_MOVING);
			if (inst && (st->name[0] == NULL || !stricmp(st->name, inst->GetName())))
				retval = TRUE;
		}
		break;
	  }
	  case TRIGGER_ACTIVATE:	// This trigger is triggered when object is activated
	  {
		if (newtrigger == TRIGGER_ACTIVATE)
			retval = TRUE;
		break;
	  }
	  case TRIGGER_USE:			// Triggered when character uses an object
	  {
		if (newtrigger == TRIGGER_USE && 
		  !stricmp(st->name, newtriggerstr))
			retval = TRUE;
		break;
	  }
	  case TRIGGER_GIVE:		// Triggered when this character give another char an object
	  {
		if (newtrigger == TRIGGER_GIVE && 
		  !stricmp(st->name, newtriggerstr))
			retval = TRUE;
		break;
	  }
	  case TRIGGER_GET:			// Triggered when this character gets an object
	  {
		if (newtrigger == TRIGGER_GET && 
		  !stricmp(st->name, newtriggerstr))
			retval = TRUE;
		break;
	  }
	  case TRIGGER_COMBAT:		// Triggered when this character enters combat mode
	  {
		if (newtrigger == TRIGGER_COMBAT)
			retval = TRUE;
		break;
	  }
	  case TRIGGER_DEAD:		// Triggered when we die (Blahhh.. uuhhhh!!)
	  {
		if (newtrigger == TRIGGER_DEAD)
			retval = TRUE;
		break;
	  }
	}

	return retval;
}

#define MAXITERATIONS	6000			// for catching endless loops

void TScript::Continue(PTObjectInstance context)
{
	if (priority & SCRIPT_PAUSED || pauseall)
		return;

  // Setup stream and token
	TStringParseStream s(proto->text, strlen(proto->text));
	TToken t(s);

	// Check Triggers For Interruption
	// *******************************

	int newpriority;						// an aribitrary large number
	for (int c = 0; c < proto->triggers.NumItems(); c++)
	{
		newpriority = 1000 - c;			// First trigger is highest priority, going down from there

		if (newpriority <= priority)	// Priority not higher than current trigger, so quit
			break;
		
		PSScriptTrigger st = &(proto->triggers[c]);

		if (Triggered(st, context))	// Check to see if script is triggered
		{
			if (lastpriority != newpriority)
			{
				Start(proto->text + st->pos, newpriority); // Start a new script for this trigger
				trigger = st->type;			// Set current trigger we're going to do
				newtrigger = 0;				// Set manual new trigger (if any) to 0
				newtriggerstr[0] = NULL;	// Set manual new trigger key (if any) to NULL
				break;
			}
		}
		else if (lastpriority == newpriority)
			lastpriority = 0;			// no longer being triggered, so clear it
	}

	// Now Continue Script
	// *******************

	// now execute the current thread
	s.SetPos((DWORD)ip);

	int iterations = MAXITERATIONS;

	while (ip && priority)
	{
	  // Prevent main char self running demo script from interrupting this script...
		if (Player && context != Player && Player->GetScript() &&
			Player->GetScript()->Running() && 
			Player->GetScript()->GetTrigger() == TRIGGER_ALWAYS)
		{
			Player->GetScript()->End();
		}

		DWORD thisline = s.GetPos();			// hang onto it in case of loop
		if (thisline > (DWORD)ip && !isspace(*((char *)thisline)) &&
									!isspace(*((char *)thisline - 1)))
			thisline--;							// token code jacks the pointer sometimes

		t.Get();
		t.SkipBlanks();

		if (t.Type() == TKN_SYMBOL && t.Code() == ':')
		{
			// label - ignore this line
			t.SkipLine();
		}
		else if (t.Type() == TKN_IDENT || t.Type() == TKN_KEYWORD)
		{
			// call the command interpreter
			int bits = CommandInterpreter(context, t);  // ****** MAIN COMMAND PROCESSOR HERE *****

			// interpret the return code(s)
			if (bits & CMD_DELETED)
				return;					// ack!

			if (bits & CMD_CONDTRUE)
			{
				block[depth].conditional = TRUE;
			}
			else if (bits & CMD_CONDFALSE)
			{
				t.LineGet();
				if (t.Is("BEGIN"))
					SkipBlock(t);
				else
					t.SkipLine();
				block[depth].conditional = FALSE;
			}

			if (bits & CMD_ELSE)
			{
				if (block[depth].conditional == COND_UNDEF)
					ScriptError("ELSE without matching IF", t.LineNum());
				else if (block[depth].conditional == TRUE)
				{
					t.LineGet();
					if (t.Is("BEGIN"))
						SkipBlock(t);
					else
						t.SkipLine();
					block[depth].conditional = COND_UNDEF;
				}
			}

			if (bits & CMD_SKIPBLOCK)
				SkipBlock(t);

			if (bits & CMD_BEGIN)
			{
				block[++depth].loopstart = NULL;
				block[depth].conditional = COND_UNDEF;
			}

			if (bits & CMD_END)
			{
				if (--depth < 0)
					ScriptError("END without matching BEGIN", t.LineNum());
			}

			if (block[depth].loopstart != NULL)
			{
				s.SetPos(block[depth].loopstart);
				block[depth].loopstart = NULL;
			}

			if (bits & CMD_LOOP)
				block[depth].loopstart = thisline;

			if (bits & CMD_WAIT)
			{
				ip = (char *)s.GetPos();
				break;
			}

			if (bits & CMD_JUMP)
			{
				s.SetPos((DWORD)ip);
			}
		}
		else
			ScriptError("Bad token in trigger block", t.LineNum());

		// skip over any extra crap on the line
		while (t.Type() != TKN_RETURN && t.Type() != TKN_EOF)
			t.Get();

		if (depth < 1 || iterations-- < 1)
		{
			if (iterations < 1)
				ScriptError("Infinite loop detected\n", t.LineNum());

			ip = NULL;
			priority = 0;
		}
	}

	// Nothing to trigger
	if (ip == NULL)	// Script done
	{
		lastpriority = 0;
		if (!DialogPane.IsHidden() &&				// Dialog pane is still up and...
		  DialogPane.GetCharacter() == context)		// This script was using the dialog pane
			DialogPane.Hide();
	}
}

void TScript::Jump(PTObjectInstance context, char *label)
{
	TStringParseStream s(proto->text, strlen(proto->text));
	TToken t(s);
	int newpriority = 1000;

	// skip down to the current trigger
	while (t.Type() != TKN_EOF && --newpriority > priority)
	{
		SkipBlock(t);
		t.SkipBlanks();
	}

	// find the label
	while (1)
	{
		t.SkipBlanks();

		if (t.Type() == TKN_EOF)
		{
			ScriptError("Jump to an unknown label attempted", t.LineNum());
			Start();		// reset the script
			return;
		}

		if (t.Type() == TKN_SYMBOL && t.Code() == ':')
		{
			t.Get();
			if (t.Is(label))
			{
				// we have a match
				t.SkipLine();
				break;
			}
		}

		t.LineGet();
	}

	ip = (char *)s.GetPos();		// save the new position
	depth = 1;			// a bit hacky - probably needs to count the begin/end pairs..
}

void TScript::Break()
{
	priority |= SCRIPT_PAUSED;
}

void TScript::Resume()
{
	priority &= ~SCRIPT_PAUSED;
}

void TScript::End()
{
	ip = NULL;
	lastpriority = priority = 0;
}

// ****************
// * TScriptProto *
// ****************

BOOL TScriptProto::FitsCriteria(PTObjectInstance inst)
{
	if (name && *name && stricmp(name, inst->GetName()) == 0)
		return TRUE;

	return FALSE;
}

void TScriptProto::SetBuffer(char *buffer)
{
	text = strdup(buffer);
}

BOOL TScriptProto::ParseCriteria(TToken &t)
{
	if (t.Is("CONTEXT") || t.Is("OBJTYPE") || t.Is("OBJECT"))
	{
		t.WhiteGet();
		if (t.Type() != TKN_IDENT && t.Type() != TKN_TEXT)
			ScriptError("Expected object context identifier", t.LineNum());
		name = strdup(t.Text());
		t.LineGet();
	}
	else
	{
		t.SkipLine();
		return FALSE;
	}

	return TRUE;
}

#define TRIGBUFGROW 512
#define MAXTRIGSIZE 256

int TScriptProto::ParseScript(TToken &t)
{
	char buf[80];
	char trigname[20];

	t.SkipBlanks();

	ParseCriteria(t);

	t.SkipBlanks();
	if (!t.Is("BEGIN"))
		ScriptError("Object block BEGIN expected", t.LineNum());
	
	while (t.Type() != TKN_RETURN && t.Type() != TKN_EOF)
		t.Get();

  // Mark line after begin as beginning of script buffer
	DWORD start = t.GetPos();
	int depth = 0;

  // Now get first trigger token
	t.LineGet();
	
  // Iterate through the triggers and setup trigger list
	while (t.Type() != TKN_EOF && !t.Is("END"))
	{
	  // Parse trigger tags now
		if (t.Type() != TKN_IDENT)
			ScriptError("Trigger identifier expected", t.LineNum());

      // Setup basic trigger structure
		SScriptTrigger st;
		memset(&st, 0, sizeof(SScriptTrigger));
		st.type = 0;

      // Tags...
		strcpy(trigname, t.Text());
		if (t.Is("ALWAYS"))					// ALWAYS trigger
		{
			t.WhiteGet();
			st.type = TRIGGER_ALWAYS;
		}
		else if (t.Is("TRIGGER"))					// ALWAYS trigger
		{
			t.WhiteGet();
			st.type = TRIGGER_TRIGGER;

			if (t.Type() == TKN_IDENT || t.Type() == TKN_TEXT)
			{
				strncpyz(st.name, t.Text(), MAXSCRIPTNAME);
				t.WhiteGet();
			}
		}
		else if (t.Is("DIALOG"))			// DIALOG trigger
		{
			t.WhiteGet();
			st.type = TRIGGER_DIALOG;
		}
		else if (t.Is("PROXIMITY"))			// CUBE trigger
		{
			t.WhiteGet();

			st.type = TRIGGER_PROXIMITY;
			st.dist = 256;

			if (t.Type() == TKN_IDENT || t.Type() == TKN_TEXT)
			{
				strncpyz(st.name, t.Text(), MAXSCRIPTNAME);
				t.WhiteGet();
			}

			if (t.Type() == TKN_NUMBER)
				Parse(t, "%i", &st.dist);
		}
		else if (t.Is("CUBE"))				// CUBE trigger
		{
			t.WhiteGet();

			st.type = TRIGGER_CUBE;

			if (t.Type() == TKN_IDENT || t.Type() == TKN_TEXT)
			{
				strncpyz(st.name, t.Text(), MAXSCRIPTNAME);
				t.WhiteGet();
			}

			int x1, y1, z1, x2, y2, z2;

			if (!Parse(t, "%i,%i,%i %i,%i,%i", &x1, &y1, &z1, &x2, &y2, &z2))
				ScriptError("Invalid cube trigger", t.LineNum());

			st.cube.beg.x = min(x1, x2);
			st.cube.beg.y = min(y1, y2);
			st.cube.beg.z = min(z1, z2);
			st.cube.end.x = max(x1, x2);
			st.cube.end.y = max(y1, y2);
			st.cube.end.z = max(z1, z2);
		}
		else if (t.Is("ACTIVATE"))			// ACTIVATE trigger
		{
			t.WhiteGet();
			st.type = TRIGGER_ACTIVATE;
		}
		else if (t.Is("USE"))				// USE trigger
		{
			t.WhiteGet();
			st.type = TRIGGER_USE;
			
			if (t.Type() == TKN_IDENT || t.Type() == TKN_TEXT)
			{
				strncpyz(st.name, t.Text(), MAXSCRIPTNAME);
				t.WhiteGet();
			}
		}
		else if (t.Is("GIVE"))				// GIVE trigger
		{
			t.WhiteGet();
			st.type = TRIGGER_GIVE;
			
			if (t.Type() == TKN_IDENT || t.Type() == TKN_TEXT)
			{
				strncpyz(st.name, t.Text(), MAXSCRIPTNAME);
				t.WhiteGet();
			}
		}
		else if (t.Is("GET"))				// GET trigger
		{
			t.WhiteGet();
			st.type = TRIGGER_GET;
			
			if (t.Type() == TKN_IDENT || t.Type() == TKN_TEXT)
			{
				strncpyz(st.name, t.Text(), MAXSCRIPTNAME);
				t.WhiteGet();
			}
		}
		else if (t.Is("COMBAT"))
		{
			t.WhiteGet();
			st.type = TRIGGER_COMBAT;
		}
		else if (t.Is("DEAD"))
		{
			t.WhiteGet();
			st.type = TRIGGER_DEAD;
		}
		else 
		{
			sprintf(buf, "Unknown trigger %s", t.Text());
			ScriptError(buf, t.LineNum());
		}

		if (t.Type() != TKN_RETURN)
		{
			sprintf(buf, "Bad parameter for %s trigger", trigname);
			ScriptError(buf, t.LineNum());
			t.SkipLine();
		}

		st.pos = t.GetPos() - start;
	
		t.SkipBlanks();

		if (st.type != 0)
			triggers.Add(st);

		if (!t.Is("BEGIN"))
		{
			ScriptError("Trigger BEGIN expected", t.LineNum());
			t.SkipLine();
		}

		t.SkipBlock();

		t.SkipBlanks();
	}

	if (!t.Is("END"))
		ScriptError("Object block END expected", t.LineNum());

	int len = (int)(t.GetPos() - start - 4); // Get length of buffer - 4 for end token (END\n)
	text = new char[len+1];
	memcpy(text, (void *)start, len);
	text[len] = 0;

	t.LineGet();

	return len;
}

BOOL TScriptProto::WriteScript(FILE *fp)
{
	if (fprintf(fp, "OBJECT \"%s\"\r\n", name) < 0)
		return FALSE;

	if (fputs("begin\r\n", fp) == EOF || fputs(text, fp) == EOF || fputs("end\r\n\r\n", fp) == EOF)
		return FALSE;

	return TRUE;
}

// **************
// * TGameState *
// **************

BOOL TGameState::Load(char *filename)
{
	char fname[MAX_PATH];
	sprintf(fname, "%s%s", ClassDefPath, filename);

	FILE *fp = fopen(fname, "rb");
	if (!fp)
		FatalError("Unable to find game state file %s", filename);

	TFileParseStream s(fp, fname);
	TToken t(s);

	t.LineGet();

	numstates = 0;

	while (t.Type() != TKN_EOF)
	{
		t.SkipBlanks();
		if (t.Type() == TKN_IDENT)
		{
			statename[numstates] = new char[strlen(t.Text()) + 1];
			strcpy(statename[numstates], t.Text());
			t.WhiteGet();

			if (t.Is("="))
				t.WhiteGet();

			if (t.Type() != TKN_NUMBER)
				FatalError("Invalid init value for game state in %s", filename);

			state[numstates] = t.Index();

			numstates++;

			t.LineGet();
		}
		else
			FatalError("Expected gamestate identifier in %s", filename);

	}

	fclose(fp);

	return TRUE;
}

BOOL TGameState::Save(char *filename)
{
	char fname[MAX_PATH];
	sprintf(fname, "%s%s", ClassDefPath, filename);

	FILE *fp = popen(fname, "wt");
	if (!fp)
		return FALSE;

	fprintf(fp, "// ********* Revenant Game States Save File ********\n"
	            "// -------------------------------------------------\n\n"
				"// Revenant - Copyright 1998 Cinematix Studios, Inc.\n\n");

	for (int c = 0; c < numstates; c++)
	{
		fprintf(fp, "%s=%d\n", statename[c], state[c]);
	}

	fclose(fp);

	return TRUE;
}

// ******************
// * TScriptManager *
// ******************

BOOL TScriptManager::Initialize()
{
	scripts.Clear();

	return (Load("master.s") && gamestate.Load("state.def"));
}

void TScriptManager::Close()
{
	if (Editor)
	{
		Save("master.s");
		gamestate.Save("state.def");
	}

	scripts.DeleteAll();
}

BOOL TScriptManager::Load(char *filename, void *owner)
{
	char fname[MAX_PATH];

	sprintf(fname, "%s%s", ClassDefPath, filename);

	FILE *fp = TryOpen(fname, "rb");
	if (fp == NULL)
		FatalError("Unable to find game master script file %s", filename);

	BOOL retval = TRUE;
	int bufsize = _filelength(fileno(fp));
	char *buffer = new char[bufsize+1];

	if (fread(buffer, 1, bufsize, fp) < (size_t)bufsize)
		retval = FALSE;
	else
	{
		buffer[bufsize] = 0;			// null-terminate it
		ParseScripts(buffer, owner);
	}

	delete buffer;
	fclose(fp);

	if (MapPane.IsOpen())
		MapPane.Notify(N_SCRIPTADDED, NULL);

	scriptsdirty = FALSE;

	return retval;
}

BOOL TScriptManager::Save(char *filename, void *owner)
{
//	if (!scriptsdirty)
		return TRUE;

	char fname[MAX_PATH];

	sprintf(fname, "%s%s", ClassDefPath, filename);

	FILE *fp = TryOpen(fname, "wb");
	if (fp == NULL)
		return FALSE;

	fprintf(fp, "// ************** Revenant Script File  ************\n"
	            "// -------------------------------------------------\n\n"
				"// Revenant - Copyright 1998 Cinematix Studios, Inc.\n\n");

	BOOL retval = TRUE;
	for (int c = 0; c < scripts.NumItems(); c++)
	{
		if (!scripts.Used(c))
			continue;

		if (scripts[c]->owner == owner)
		{
			if (!scripts[c]->WriteScript(fp))
				retval = FALSE;
		}
	}

	fclose(fp);

	scriptsdirty = FALSE;

	return retval;
}

void TScriptManager::Clear(void *owner)
{
	for (int c = 0; c < scripts.NumItems(); c++)
	{
		if (!scripts.Used(c))
			continue;

		if (scripts[c]->owner == owner)
		{
			MapPane.Notify(N_SCRIPTDELETED, scripts[c]);

			scripts.Delete(c);
		}
	}
}	

BOOL TScriptManager::ReloadStates()
{
	return gamestate.Load("state.def");
}

void TScriptManager::ParseScripts(char *buffer, void *owner)
{
	TStringParseStream s(buffer, strlen(buffer));
	TToken t(s);

	t.Get();

	while (t.Type() != TKN_EOF)
	{
		PTScriptProto script = new TScriptProto;
		script->ParseScript(t);
		script->owner = owner;
	
		for (int c = 0; c < scripts.NumItems(); c++) // Add into unused entries
		{
			if (!scripts.Used(c))  
			{
				scripts.Set(script, c);
				break;
			}
		}
		if (c >= scripts.NumItems())
			scripts.Add(script);
	}
}

// This finds all the scripts which apply to a given object instance and put pointers to
// them into the new script object (which is returned).
PTScript TScriptManager::ObjectScript(PTObjectInstance inst)
{
	for (int c = 0; c < scripts.NumItems(); c++)
	{
		if (!scripts.Used(c))
			continue;

		if (scripts[c]->FitsCriteria(inst))
		{
			PTScript newscript = new TScript(scripts[c]);
			return newscript;
		}
	}

	return NULL;
}

struct { char *name; int val; } LocalScriptVals[] =
{
	{ "Name",				0	},
	{ "IsShopObject",		0	},
	{ "Tab",				0	},

	{ NULL }		// terminator
};

int TScriptManager::FindLocalVal(char *name)
{
	for (int i = 0; LocalScriptVals[i].name; i++)
		if (stricmp(name, LocalScriptVals[i].name) == 0)
			return i;

	return -1;
}

void TScriptManager::SetLocalVal(int index, int val)
{
	if (index >= 0)
		LocalScriptVals[index].val = val;
}

int TScriptManager::GetLocalVal(int index)
{
	if (index >= 0)
		return LocalScriptVals[index].val;

	return 0;
}

int TScriptManager::GameState(char *name)
{
	// first check the constants set up by the currently executing script trigger
	int index = FindLocalVal(name);
	if (index >= 0)
		return GetLocalVal(index);

	// if it's not there, check the game state variables (globals)
	return gamestate.State(name);
}

// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                     scroll.cpp - TScroll module                       *
// *************************************************************************

#include "revenant.h"
#include "scroll.h"
#include "display.h"
#include "bitmap.h"
#include "font.h"
#include "playscreen.h"

REGISTER_BUILDER(TScroll)
TObjectClass ScrollClass("SCROLL", OBJCLASS_SCROLL, 0);

// Hard coded class stats
DEFSTAT(Scroll, Value, VAL, 0, 0, 0, 1000000)

TScrollPane ScrollPane;
TBookPane BookPane;

void TScroll::SetText(char *newtext)
{
	if (text)
		delete text;

	text = new char[strlen(newtext)+1];
	if (text)
		strcpy(text, newtext);
}

void TScroll::Load(RTInputStream is, int version, int objversion)
{
	TObjectInstance::Load(is, version, objversion);

	short len;
	is >> len;

	if (len < 1)
		text = NULL;
	else
	{
		text = new char[len+1];

		if (text)
		{
			for (int i = 0; i < len; i++)
				is >> text[i];

			text[i] = 0;
		}
	}
}

void TScroll::Save(RTOutputStream os)
{
	TObjectInstance::Save(os);

	short len = text ? strlen(text) : 0;
	os << len;

	if (len)
	{
		for (int i = 0; i < len; i++)
			os << text[i];
	}
}

BOOL TScroll::Use(PTObjectInstance user, int with)
{
	if (with < 0)
	{
		PTScrollPane pane = &ScrollPane;

		if (!strcmpi(GetTypeName(), "Book"))
			pane = (PTScrollPane)&BookPane;

		PlayScreen.SetNextPane(pane);
		pane->SetScroll(this);
	}

	return FALSE;
}

// ***************
// * TScrollPane *
// ***************

#define NUMLINES		11		// depends on font and scroll height
#define SCROLLWIDTH		430		// depends on font and scroll width

void ScrollBtnScrollUp()
{
	ScrollPane.Scroll(-NUMLINES);
}

void ScrollBtnScrollDown()
{
	ScrollPane.Scroll(NUMLINES);
}

void ScrollBtnExit()
{
	ScrollPane.Close();
}

BOOL TScrollPane::Initialize()
{
	TButtonPane::Initialize();

	line = 0;
	numlines = 0;

	scrolldata = TMulti::LoadMulti("scroll.dat");
	scrollfont = TFont::LoadFont(103);

	SetScroll(scroll);		// recompute number of lines now that font is loaded up

	if (scrolldata)
	{
		PTBitmap bitmap = scrolldata->Bitmap("scroll");
		int x = (WIDTH - bitmap->width) / 2;
		int y = (HEIGHT - bitmap->height) / 4;

		NewButton("down", x+452, y+330, 28, 31, VK_NEXT, ScrollBtnScrollDown, scrolldata->Bitmap("downdown"), scrolldata->Bitmap("downup"));
		NewButton("up", x+484, y+323, 28, 31, VK_PRIOR, ScrollBtnScrollUp, scrolldata->Bitmap("updown"), scrolldata->Bitmap("upup"));
		NewButton("exit", x+518, y+321, 28, 31, VK_ESCAPE, ScrollBtnExit, scrolldata->Bitmap("exitdown"), scrolldata->Bitmap("exitup"));

		PlayScreen.AddPane(this);
		PlayScreen.SetExclusivePane(this, TRUE);
		return TRUE;
	}

	return FALSE;
}

void TScrollPane::Close()
{
	TButtonPane::Close();

	if (scrolldata)
		delete scrolldata;

	PlayScreen.ReleaseExclusivePane(this);
	PlayScreen.RemovePane(this);
	PlayScreen.Redraw();

	scroll = NULL;
}

void TScrollPane::DrawBackground()
{
	if (IsDirty())
	{
		PTBitmap bitmap = scrolldata->Bitmap("scroll");

		int x = (WIDTH - bitmap->width) / 2;
		int y = (HEIGHT - bitmap->height) / 4;
		Display->Put(x, y, bitmap, DM_TRANSPARENT | DM_BACKGROUND);

		if (scroll && scroll->GetText())
			Display->WriteText(scroll->GetText(), x+65, y+68, NUMLINES, scrollfont, NULL, DM_USEDEFAULT, SCROLLWIDTH, line);

		// decide which buttons should be visisble
		if (line < 1)
			Button(1)->Hide();
		else
			Button(1)->Show();

		if ((line + NUMLINES - 1) >= numlines)
			Button(0)->Hide();
		else
			Button(0)->Show();

		Button(2)->Show();

		RedrawButtons();
		SetDirty(FALSE);
	}

	// buttons shouldn't draw until after the rest is placed down
	TButtonPane::DrawBackground();
}

void TScrollPane::KeyPress(int key, BOOL down)
{
	TButtonPane::KeyPress(key, down);

	if (down)
	{
		switch (key)
		{
			case VK_UP:
				Scroll(-1);
				break;
			case VK_DOWN:
				Scroll(1);
				break;
			case VK_HOME:
				Scroll(-100000);
				break;
			case VK_END:
				Scroll(100000);
				break;
		}
	}
}

void TScrollPane::SetScroll(PTScroll s)
{
	scroll = s;

	if (scroll && scroll->GetText() && scrollfont)
		numlines = scrollfont->FindNumLinesInText(scroll->GetText(), SCROLLWIDTH);
	else
		numlines = 0;
}

void TScrollPane::Scroll(int numscrolllines)
{
	int oldline = line;

	line += numscrolllines;

	if (line < 0)
		line = 0;
	else if (line > numlines)
		line = numlines;

	if (oldline != line)
		SetDirty(TRUE);
}

// *************
// * TBookPane *
// *************

#define BOOKLINES		16		// depends on font and scroll height
#define BOOKWIDTH		216		// depends on font and scroll width

void BookBtnScrollUp()
{
	BookPane.Scroll(-(BOOKLINES * 2));
}

void BookBtnScrollDown()
{
	BookPane.Scroll(BOOKLINES * 2);
}

void BookBtnExit()
{
	BookPane.Close();
}

BOOL TBookPane::Initialize()
{
	TButtonPane::Initialize();

	line = 0;
	numlines = 0;

	scrolldata = TMulti::LoadMulti("book.dat");
	scrollfont = TFont::LoadFont(103);

	SetScroll(scroll);			// recompute number of lines now that font is loaded up

	if (scrolldata)
	{
		PTBitmap bitmap = scrolldata->Bitmap("book");
		int x = (WIDTH - bitmap->width) / 2;
		int y = (HEIGHT - bitmap->height) / 3;

		NewButton("down", x+440, y+386, 28, 22, VK_NEXT, BookBtnScrollDown, scrolldata->Bitmap("downdown"), scrolldata->Bitmap("downup"));
		NewButton("up", x+472, y+379, 28, 23, VK_PRIOR, BookBtnScrollUp, scrolldata->Bitmap("updown"), scrolldata->Bitmap("upup"));
		NewButton("exit", x+505, y+377, 28, 30, VK_ESCAPE, BookBtnExit, scrolldata->Bitmap("exitdown"), scrolldata->Bitmap("exitup"));

		PlayScreen.AddPane(this);
		PlayScreen.SetExclusivePane(this, TRUE);
		return TRUE;
	}

	return FALSE;
}

void TBookPane::DrawBackground()
{
	if (IsDirty())
	{
		PTBitmap bitmap = scrolldata->Bitmap("book");

		int x = (WIDTH - bitmap->width) / 2;
		int y = (HEIGHT - bitmap->height) / 3;
		Display->Put(x, y, bitmap, DM_TRANSPARENT | DM_BACKGROUND);

		if (scroll && scroll->GetText())
		{
			char buf[80];
			for (int side = 0; side < 2; side++)
			{
				sprintf(buf, "%d", (line / BOOKLINES) + side + 1);
				Display->WriteText(buf, x+180+(side*232), y+21+(side*2), 1, scrollfont, NULL, DM_USEDEFAULT, -1, 0, JUSTIFY_CENTER);

				Display->WriteText(scroll->GetText(), x+82+(side*232), y+40+(side*2), BOOKLINES, scrollfont, NULL, DM_USEDEFAULT, BOOKWIDTH, line + (side*BOOKLINES));
			}
		}

		// decide which buttons should be visisble
		if (line < 1)
			Button(1)->Hide();
		else
			Button(1)->Show();

		if ((line + (BOOKLINES*2) - 1) >= numlines)
			Button(0)->Hide();
		else
			Button(0)->Show();

		Button(2)->Show();

		RedrawButtons();
		SetDirty(FALSE);
	}

	// buttons shouldn't draw until after the rest is placed down
	TButtonPane::DrawBackground();
}

// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                     sector.cpp - TSector object                       *
// *************************************************************************

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <io.h>
#include <math.h>

#include "revenant.h"
#include "bitmap.h"
#include "sector.h"
#include "stream.h"
#include "parse.h"
#include "textbar.h"

char sectorfilename[80] = "%d_%d_%d.DAT";
DWORD SectrorMapFCC = (('M' << 0) | ('A' << 8) | ('P' << 16) | (' ' << 24));
#define STARTSIZE 32768
#define GROWSIZE 16284

// ******************************
// * Constructor and Destructor *
// ******************************

TSector::TSector(int newlevel, int newsectorx, int newsectory)
{
	level = newlevel;
	sectorx = newsectorx;
	sectory = newsectory;
	objects.Clear();
	for (int c = 1; c < NUMOBJSETS; c++)
		objsets[c-1].Clear();

	walkmap = new WORD[WALKMAPSIZE];

	memset(walkmap, 0, sizeof(WORD) * WALKMAPSIZE);

	sprintf(filename, sectorfilename, level, sectorx, sectory);
}

TSector::~TSector()
{
	if (walkmap)
		delete walkmap;

	for (int c = 1; c < NUMOBJSETS; c++)
		objsets[c-1].Clear();

	for (TObjectIterator i(&objects); i; i++)
	{
		PTObjectInstance inst = i.Item();

		if (!inst)
			continue;

		inst->ForceSector(NULL);

		objects.Remove(i);

		if (inst->Flags() & OF_NONMAP) // Don't delete NONMAP objects
			continue;
		else
			delete inst;
	}
}

// ************************
// * Load and Save Sector *
// ************************

// Loads the sector.. keeps file open so sector is locked
PTSector TSector::LoadSector(int newlevel, int newsectorx, int newsectory, BOOL preload)
{
	PTSector sector;

	if (preload)
	{
		sector = FindPreloadSector(newlevel, newsectorx, newsectory);
		if (sector)
			return sector;
	}

	sector = new TSector(newlevel, newsectorx, newsectory);
	sector->Load(); // Assume this works

	return sector;
}

// Save and delete the sector (doesn't really delete it if sector is preload)
void TSector::CloseSector(PTSector sector)
{
	if (!sector->preloaded)
	{
		sector->Save();
		delete sector;
	}
}

// Straight (no preloaded sectors) load/save functions

#define MAKEINDEX(level, sx, sy, item)	((level<<24) | (sx<<18) | (sy<<12) | (item & 0xFFF))

BOOL TSector::Load(BOOL lock)
{
	int version = 0;
	FILE *fp;

	char mappath[MAX_PATH];

	strcpy(mappath, CurMapPath);
	strcat(mappath, CURMAPDIR "\\");
	strcat(mappath, filename);
	fp = popen(mappath, "rb"); // Path open (uses program path)

	if (!fp)
	{
		strcpy(mappath, BaseMapPath);
		strcat(mappath, BASEMAPDIR "\\");
		strcat(mappath, filename);
		fp = popen(mappath, "rb"); // Path open (uses program path)
	
		if (!fp)
			return FALSE;
	}

	fseek(fp, 0, SEEK_SET);

	int bufsize = _filelength(fileno(fp));
	BYTE *buf;

	if (bufsize > 0)
	{
		buf = (BYTE *)malloc(bufsize);
		fread(buf, bufsize, 1, fp);
	}
	else
	{
		buf = (BYTE *)malloc(sizeof(int));
		bufsize = 4;
		*((int *)buf) = 0;
	}

	//if (!lock)
	{
		fclose(fp);
		fp = NULL;
	}

	TInputStream is(buf, bufsize);

	int numobjects;
	is >> numobjects;

	// See if this is a sector map with header information
	if ((DWORD)numobjects == SectrorMapFCC)
	{
		// Get which sector map version this is
		is >> version;
		is >> numobjects;
	}

	for (int c = 0; c < numobjects; c++)
	{
		PTObjectInstance inst = TObjectInstance::LoadObject(is, version, TRUE);
		// Note: inst can be NULL here if a placeholder (-1) was saved for the obj class id

		if (inst)
		{
			inst->ForceSector(this);
			inst->ForceLevel(level); // Directly sets the inst's level variable
		}

		objects.Set(inst, c); 

		if (inst)
		{
			for (int d = 1; d < NUMOBJSETS; d++)
			{
				if (InObjSet(inst, d))
					objsets[d-1].Set(c, objsets[d-1].NumItems());
			}
		}
	
		if (version < 3 && inst) // This is nolonger used (indexes are now unique id's)
			inst->SetMapIndex(MAKEINDEX(level, sectorx, sectory, c));
	}

	return TRUE;
}

void TSector::Save()
{
	int version = MAP_VERSION; // Current sector map version #

	if (objects.NumItems() == 0)
	{
		// don't save empty sectors, and clear out old save file
		unlink(filename);
		return;
	}

	BOOL closeit = FALSE;
	TOutputStream os(STARTSIZE, GROWSIZE);
	TPointerIterator<TObjectInstance> i(&objects);

	// Write out the "header" with "MAP " followed by the version #
	os << SectrorMapFCC;
	os << version;

	os << objects.NumItems();

	for ( ; i; i++)
	{
		TObjectInstance::SaveObject(i.Item(), os, TRUE);
	}

	char mappath[MAX_PATH];

	strcpy(mappath, CurMapPath);
	strcpy(mappath, CURMAPDIR "\\");
	strcat(mappath, filename);

	FILE *fp = popen(mappath, "wb");	// Path open (uses program path)
	if (!fp)
		return;

	fseek(fp, 0, 0);
	fwrite(os.Buffer(), os.DataSize(), 1, fp);
	fclose(fp);
}

// ****************************
// * Rectangles for Intersect *
// ****************************

// Added to the basic sector screen rect to include tiles which extend outside the sector rect
#define SECTORLREDGE	512				// Left/right edge
#define SECTORUEDGE		1024			// Upper edge
#define SECTORLEDGE		1024			// Lower edge

void TSector::GetMaxScreenRect(RSRect r)
{
	SRect maprect;
	GetMaxMapRect(maprect);

	S3DPoint p1, p2;

	p1.x = maprect.left;
	p1.y = maprect.top;
	p1.z = 0;

	p2.x = maprect.right;
	p2.y = maprect.bottom;
	p2.z = 0;

	WorldToScreen(p1, r.left, r.top);
	WorldToScreen(p2, r.right, r.bottom);
	r.left -= SECTORWIDTH;
	r.right += SECTORWIDTH;

  // Widen sector screen rect to include EVERYTHING that might overlap the sector boundries
	r.left -= SECTORLREDGE;
	r.right += SECTORLREDGE;
	r.top -= SECTORUEDGE;
	r.bottom += SECTORLEDGE;
}

void TSector::GetMaxMapRect(RSRect r)
{
	if ((DWORD)sectorx >= MAXSECTORX || (DWORD)sectory >= MAXSECTORY)
		r.left = r.top = r.right = r.bottom = 0;
	else
	{
		r.left = sectorx << SECTORWSHIFT;
		r.top = sectory << SECTORHSHIFT;
		r.right = r.left + SECTORWIDTH - 1;
		r.bottom = r.top + SECTORHEIGHT - 1;
	}
}

// ********************
// * Sector Utilities *
// ********************

// Adds an object to the sector
int TSector::AddObject(PTObjectInstance oi, int item)
{
	if (!oi)
		return -1;

	oi->ForceSector(this);
	oi->ForceLevel(level);

	if (item < 0)
		item = objects.Add(oi);
	else
		item = objects.Set(oi, item);

	for (int d = 1; d < NUMOBJSETS; d++)
	{
		if (InObjSet(oi, d))
			objsets[d-1].Set(item, objsets[d-1].NumItems());
	}

	return item;
}

// Sets an object into the sector at the given item index
int TSector::SetObject(PTObjectInstance oi, int item)
{
	item = objects.Set(oi, item);

	if (oi)
	{
		oi->ForceSector(this);
		oi->ForceLevel(level);

		for (int d = 1; d < NUMOBJSETS; d++)
		{
			if (InObjSet(oi, d))
				objsets[d-1].Set(item, objsets[d-1].NumItems());
		}
	}

	return item;
}

// Removes an object from the sector
PTObjectInstance TSector::RemoveObject(int item)
{
	PTObjectInstance oi = objects[item];
	objects.Remove(item);
	oi->ForceSector(NULL);

  // Remove object from sets
	for (int d = 1; d < NUMOBJSETS; d++)
	{
		TObjSetArray &set = objsets[d-1];

		for (int c = 0; c <	set.NumItems(); c++)
		{
			if (set[c] == item)
			{
				set.Collapse(c);
				break;
			}
		}
	}

	return oi;
}

// *****************
// * Walkmap Stuff *
// *****************

void TSector::WalkmapHandler(int mode, BYTE *walk, int zpos, int x, int y, int width, int length, int stride, BOOL override)
{
	if (!walkmap || !walk)
		return;

	// first clip vars to be relative to the sector
	x -= (sectorx << SECTORWSHIFT) >> WALKMAPSHIFT;
	y -= (sectory << SECTORHSHIFT) >> WALKMAPSHIFT;

	int cx = 0, cy = 0, w = width, l = length;

	// now clip
	if (x < 0)
	{
		w += x;
		cx = -x;
		x = 0;
	}

	if (y < 0)
	{
		l += y;
		cy = -y;
		y = 0;
	}

	if ((x + w) > (SECTORWIDTH >> WALKMAPSHIFT))
		w = (SECTORWIDTH >> WALKMAPSHIFT) - x;

	if ((y + l) > (SECTORHEIGHT >> WALKMAPSHIFT))
		l = (SECTORHEIGHT >> WALKMAPSHIFT) - y;

	// cliped out completely?
	if (!w && !l)
		return;

	// Just Do It(tm)
	WORD *start = walkmap + (y * (SECTORWIDTH >> WALKMAPSHIFT)) + x;
	walk += (cy * stride) + cx;

	int srcstride = stride - w;
	int dststride = (SECTORWIDTH >> WALKMAPSHIFT) - w;

	for (int outerloop = 0; outerloop < l; outerloop++)
	{
		for (int innerloop = 0; innerloop < w; innerloop++)
		{
			if (mode == WALK_TRANSFER)
			{
				if (*walk)
				{
					int walkval = *walk + zpos;

					walkval = min(0xffff, max(1, walkval));

					if (*start < walkval || override)
						*start = walkval;
				}
			}
			else if (mode == WALK_CAPTURE)
			{
				if (*start == 0)
					*walk = 0;
				else
					*walk = min(255, max(1, *start - zpos));
			}
			else if (mode == WALK_CLEAR)
			{
				*start = 0;
			}

			start++;
			walk++;
		}

		walk += srcstride;
		start += dststride;
	}
}

// ----------------------- Preload Sector System -------------------

TSectorArray TSector::preloads;
int TSector::preloadlevel = -1;
int TSector::numpreloadrects = 0;
SRect TSector::preloadrects[MAXPRELOADRECTS];

// Preload sectors in this area (takes an area rectangle array from the area system)
BOOL TSector::LoadPreloadSectors(int level, int numrects, SRect *rects)
{
	ClearPreloadSectors();
	preloadlevel = level;

	SRect srect;

	if (numrects > MAXPRELOADRECTS)
		numrects = MAXPRELOADRECTS;

	numpreloadrects = numrects;

	int maxcount = 0;
	int count = 0;

	for (int c = 0; c < numrects; c++)
	{
      // Copy to rect list
		memcpy(&(preloadrects[c]), &(rects[c]), sizeof(SRect));

	  // convert map coords to sector coords
		srect.left = rects[c].left >> SECTORWSHIFT;
		srect.top = rects[c].top >> SECTORHSHIFT;
		srect.right = (rects[c].right + (SECTORWIDTH - 1)) >> SECTORWSHIFT;
		srect.bottom = (rects[c].bottom + (SECTORHEIGHT - 1)) >> SECTORHSHIFT;

	  // sanity check
		srect.left = max(0, min(srect.left, MAXSECTORX - 1));
		srect.top = max(0, min(srect.top, MAXSECTORY - 1));
		srect.right = max(0, min(srect.right, MAXSECTORX - 1));
		srect.bottom = max(0, min(srect.bottom, MAXSECTORY - 1));

		maxcount = srect.w() * srect.h() * 2;
		
	  // Preload sectors here		
		for (int y = srect.top; y <= srect.bottom; y++)
		{
		  for (int x = srect.left; x <= srect.right; x++)
		  {
			PTSector sector = new TSector(level, x, y);
			if (sector)
			{
				sector->Load();
				sector->preloaded = TRUE;
				preloads.Add(sector);

			  // Show levels in textbar
				if (TextBar.IsOpen() && !TextBar.IsHidden() && CurrentScreen->FrameCount() > 0)
				{
					int level = 300 * count / (maxcount * 2);
					TextBar.SetLevels(level, level);
					TextBar.Draw();
					TextBar.PutToScreen();
				}
				count++;
			}
		  }
		}

	  // Cache object graphics here 
	  // (telescope in from outer sector borders to inner sectors so that the 
	  // center sectors are the ones most likely to have cached graphics!)
		SRect b = srect;

		while (b.left < b.right && b.top < b.bottom)
		{
			for (int c = 0; c < preloads.NumItems(); c++)
			{
				PTSector s = preloads[c];
				if (s->sectorx == b.left || s->sectorx == b.right || // On borders of rect
					s->sectory == b.top || s->sectory == b.bottom)
				{
					TObjectArray &objects = s->objects;
					for (int c = 0; c < objects.NumItems(); c++)
					{
						if (objects[c])
							objects[c]->GetImagery()->CacheImagery();
					}

				  // Show levels in textbar
					if (TextBar.IsOpen() && !TextBar.IsHidden() && CurrentScreen->FrameCount() > 0)
					{
						int level = 300 * count / (maxcount * 2);
						TextBar.SetLevels(level, level);
						TextBar.Draw();
						TextBar.PutToScreen();
					}
					count++;
				}
			}

			b.left++;
			b.right--;
			b.top++;
			b.bottom--;

		}
	}

	return TRUE;
}

// Clear preload sectors
void TSector::ClearPreloadSectors()
{
	for (int c = 0; c < preloads.NumItems(); c++)
		preloads[c]->Save();

	numpreloadrects = 0;
	preloadlevel = -1;

	preloads.DeleteAll();
}

// Returns a preload sector
PTSector TSector::FindPreloadSector(int level, int sectorx, int sectory)
{
	for (int c = 0; c < preloads.NumItems(); c++)
	{
		if (preloads[c]->level == level &&
		    preloads[c]->sectorx == sectorx &&
			preloads[c]->sectory == sectory)
				return preloads[c];
	}

	return NULL;
}

// Are we in the preload area?
BOOL TSector::InPreloadArea(RS3DPoint p, int level)
{
	if (level != preloadlevel)
		return FALSE;

	SPoint a;
	a.x = p.x;
	a.y = p.y;

	for (int c = 0; c < numpreloadrects; c++)
	{
		if (preloadrects[c].In(a))
			return TRUE;
	}

	return FALSE;
}

#ifdef _MAPPANE_H
#error If you need to access TMapPane from this file, you're doing something wrong... BEN
#endif

// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                     shadow.cpp - TShadow module                       *
// *************************************************************************

#include "revenant.h"
#include "shadow.h"

REGISTER_BUILDER(TShadow)

TObjectClass ShadowClass("SHADOW", OBJCLASS_SHADOW, 0);

// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                  sound.cpp - Music and sound module                   *
// *************************************************************************

#include <windows.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <stdio.h>
#include <dsound.h>

#include "revenant.h"
#include "mainwnd.h"
#include "resource.h"
#include "parse.h"
#include "file.h"
#include "sound.h"
#include "wavedata.h"

// *****************************
// * CD Sound System Functions *
// *****************************

static bool isopen;
static long cdstartticks;
static long cdtracklen;
static long cdtrackpos;

void CDOpen()
{
	char err[120];
	DWORD res = mciSendString("open cdaudio shareable", NULL, 0, 0L);
	mciGetErrorString(res, err, 120);

	isopen = TRUE;
}

void CDClose()
{
	char err[120];
	DWORD res = mciSendString("close cdaudio", NULL, 0, 0L);
	mciGetErrorString(res, err, 120);

	isopen = FALSE;
}

void CDPlayTrack(int track)
{
	char err[120];
	if (!SoundSystemOn)
		return;

	if (!isopen)
		CDOpen();

	char ret[40];
	char buf[40];

	DWORD res = mciSendString("stop cdaudio", NULL, 0, 0L);
	mciGetErrorString(res, err, 120);

	res = mciSendString("set cdaudio time format ms", NULL, 0, 0L);
	mciGetErrorString(res, err, 120);

	wsprintf(buf, "status cdaudio position track %d", track);
	res = mciSendString(buf, ret, 39, 0L);
	mciGetErrorString(res, err, 120);

	cdtrackpos = atol(ret);

	wsprintf(buf, "status cdaudio length track %d", track);
	res = mciSendString(buf, ret, 39, 0L);
	mciGetErrorString(res, err, 120);

	cdtracklen = atol(ret);

	wsprintf(buf, "play cdaudio from %ld to %ld", cdtrackpos, cdtrackpos + cdtracklen - 1);

	cdstartticks = GetTickCount();

	res = mciSendString(buf, NULL, 0, 0L);
	mciGetErrorString(res, err, 120);
}

DWORD CDTrackLength(int track)
{
	if (!SoundSystemOn)
		return 0;

	if (!isopen)
		CDOpen();

	char ret[40];
	char buf[40];

	mciSendString("set cdaudio time format ms", NULL, 0, 0L);

	wsprintf(buf, "status cdaudio length track %d", track);
	mciSendString(buf, ret, 39, 0L);

	return atol(ret);
}



void CDPlayRandomTrack()
{
	if (!SoundSystemOn)
		return;

	if (!isopen)
		CDOpen();

	char ret[40];
	int first = 1;
	int last;

	mciSendString("status cdaudio number of tracks", ret, 39, 0L);
	last = atoi(ret);

	mciSendString("status cdaudio type track 1", ret, 39, 0L);
	if (!stricmp(ret, "audio"))
		first = 1;
	else
		first = 2;

  // Check if this is our CD
/*	char buf[40];
	mciSendString("set cdaudio time format ms", NULL, 0, 0L);
	wsprintf(buf, "status cdaudio length track %d", 2);
	mciSendString(buf, ret, 39, 0L);
	long tracklen = atol(ret);
	if (tracklen > 1000L && tracklen < 1000L)
		first = 2;
*/

	static int played[20];
	int numplayed = min(20, last - first);
	int play;

	BOOL wasplayed;
	do
	{
		wasplayed = FALSE;
		play = random(first, last);
		for (int c = 0; c < numplayed; c++)
		{
			if (play == played[c])
			{
				wasplayed = TRUE;
				break;
			}
		}
	} while (wasplayed);

	CDPlayTrack(play);

	for (int c = 0; c < numplayed - 1; c++)
		played[c] = played[c + 1];
	played[numplayed - 1] = play;
}

void CDStop()
{
	if (!isopen)
		CDOpen();

	if (!SoundSystemOn)
		return;

	mciSendString("stop cdaudio", NULL, 0, 0L);
}

BOOL CDPlaying()
{
	if (!isopen)
		CDOpen();

	if (cdtracklen == 0)
		return FALSE;

	if (GetTickCount() - cdstartticks < (DWORD)cdtracklen)
		return TRUE;

	return FALSE;
}

void CDSetVolume(WORD volume)
{
	if (!isopen)
		CDOpen();

	int devs = auxGetNumDevs();

	AUXCAPS caps;

	for (int c = 0; c < devs; c++)
	{
		auxGetDevCaps(c, &caps, sizeof(AUXCAPS));
		if (caps.wTechnology == AUXCAPS_CDAUDIO)
		{
			auxSetVolume(c, MAKELONG(volume,volume));
			return;
		}
	}
}

// *****************
// * Sound Effects *
// *****************

TSound::TSound()
{
	SoundBuffer = NULL;
	looping = FALSE;
}

TSound::~TSound()
{
	if (SoundBuffer)
	{
		SoundBuffer->Release();
		SoundBuffer = NULL;
	}
	if (next)
		delete next;
}

BOOL TSound::IsPlaying()
{
	return (GetStatus() & DSBSTATUS_PLAYING);
}

BOOL TSound::IsLooping()
{
	return (GetStatus() & DSBSTATUS_LOOPING);
}

PTSound TSound::Load(int resource)
{
	PTWaveData rawdata = (PTWaveData)LoadResource("sound\\wave", resource);
	return Load(rawdata);
}

PTSound TSound::Load(PTWaveData wave)
{
	if (!SoundPlayer.Functioning())
		return NULL;

	if (!wave)
		return NULL;

	PTSound sound = new TSound;

	DSBUFFERDESC desc;
	memset(&desc, 0, sizeof(DSBUFFERDESC));
	desc.dwSize = sizeof(DSBUFFERDESC);
	desc.dwFlags = DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLPAN | DSBCAPS_STATIC;
	desc.dwBufferBytes = wave->size;
	desc.lpwfxFormat = &wave->format;

	HRESULT res = SoundPlayer.DirectSound->CreateSoundBuffer(&desc, &(sound->SoundBuffer), NULL);
	if (res != DS_OK)
	{
		delete wave;
		delete sound;
		return NULL;
	}

	LPVOID buffer;
	res = sound->SoundBuffer->Lock(0, wave->size, &buffer, &wave->size, NULL, NULL, 0);
	if (res == DS_OK)
	{
		memcpy(buffer, wave->data, wave->size);
		sound->SoundBuffer->Unlock(&buffer, wave->size, NULL, 0);
	}

	if ((wave->loopend - wave->loopstart) > 0)
		sound->looping = TRUE;

	delete wave;
	return sound;
}

PTSound TSound::Duplicate()
{
	if (!SoundPlayer.Functioning())
		return NULL;

	PTSound sound = new TSound;

	HRESULT res = SoundPlayer.DirectSound->DuplicateSoundBuffer(SoundBuffer, &sound->SoundBuffer);
	if (res != DS_OK)
	{
		delete sound;
		return NULL;
	}

	return sound;
}

void TSound::Play(int volume, int freq)
{
	if (!SoundPlayer.Functioning() || SoundBuffer == NULL)
		return;

	if (volume != 0)
		SoundBuffer->SetVolume(volume);

	SoundBuffer->SetFrequency(freq);

	SoundBuffer->SetCurrentPosition(0);
	SoundBuffer->Play(0, 0, looping ? DSBPLAY_LOOPING : 0);

	if (volume != 0)
		SoundBuffer->SetVolume(0);
}

void TSound::Stop()
{
	if (!SoundPlayer.Functioning() || SoundBuffer == NULL)
		return;

	SoundBuffer->Stop();
}

DWORD TSound::GetStatus()
{
	if (!SoundPlayer.Functioning() || SoundBuffer == NULL)
		return 0;

	DWORD status;
	SoundBuffer->GetStatus(&status);

	return status;
}

// ***********************
// * Sound Effect Player *
// ***********************

BOOL TSoundPlayer::Initialize()
{
	if (!ReadSoundList())
		return FALSE;

	// Note that the soundplayer returns TRUE even when directsound fails
	// to initialize: this is because we don't want to fail out of the
	// game if they don't have a soundcard...

	HRESULT res = DirectSoundCreate(NULL, &DirectSound, NULL);
	if (res != DS_OK)
		return TRUE;

	res = DirectSound->SetCooperativeLevel(MainWindow.Hwnd(), DSSCL_EXCLUSIVE);
	if (res != DS_OK)
	{
		DirectSound = NULL;
		return TRUE;
	}

	DSBUFFERDESC desc;
	memset(&desc, 0, sizeof(DSBUFFERDESC));
	desc.dwSize = sizeof(DSBUFFERDESC);
	desc.dwFlags = DSBCAPS_PRIMARYBUFFER;
	desc.dwBufferBytes = 0;
	desc.lpwfxFormat = NULL;

	res = DirectSound->CreateSoundBuffer(&desc, &PrimaryBuffer, NULL);
	if (res != DS_OK)
	{
		DirectSound->Release();
		DirectSound = NULL;
		return TRUE;
	}

	PrimaryBuffer->Play(0, 0, DSBPLAY_LOOPING);

	return TRUE;
}

void TSoundPlayer::Close()
{
	if (PrimaryBuffer)
	{
		PrimaryBuffer->Release();
		PrimaryBuffer = NULL;
	}

	if (DirectSound)
	{
		DirectSound->Release();
		DirectSound = NULL;
	}

	DestroySoundList();
}

void TSoundPlayer::Pause()
{
	if (Functioning())
		PrimaryBuffer->Stop();
}

void TSoundPlayer::Unpause()
{
	if (Functioning())
		PrimaryBuffer->Play(0, 0, DSBPLAY_LOOPING);
}

void TSoundPlayer::SetVolume(int volume)
{
	if (Functioning())
		PrimaryBuffer->SetVolume(volume);
}

// The sound system high-level (easy-interface) functions

PSSoundRef TSoundPlayer::FindSound(char *soundname, int nr)
{
	if (nr >= 0)
	{
		char buf[80];
		sprintf(buf, "%s%d", soundname, nr);
		return FindSound(buf, -1);
	}

	PSSoundRef next, prev = NULL;

	for (PSSoundRef ref = soundlist; ref; prev = ref, ref = next)
	{
		next = ref->next;

		if (stricmp(ref->name, soundname) == 0)
		{
			if (prev)
			{
				// move it to the head of the list
				prev->next = ref->next;
				ref->next = soundlist;
				soundlist = ref;
			}

			return ref;
		}
	}

	return NULL;
}

void TSoundPlayer::UpdateDying()
{
	PSSoundRef ref;
	for (ref = soundlist; ref; ref = ref->next)
	{
		if (ref->sound && ref->sound->Next())
		{
			PTSound prev, snd, next;

			prev = ref->sound;
			next = prev->Next();

			while ((snd = next))
			{
				next = snd->Next();

				if (snd->IsPlaying())
					prev = snd;
				else
				{
					prev->SetNext(snd->Next());
					snd->SetNext(NULL);
					delete snd;
				}
			}
		}

		if (ref->flags & SOUND_DYING)
		{
			if (ref->sound && (!ref->sound->IsPlaying() || ref->sound->IsLooping()))
			{
				delete ref->sound;
				ref->sound = NULL;
				ref->flags &= ~SOUND_DYING;
			}
		}
	}
}

void TSoundPlayer::Mount(char *soundname, int nr)
{
	if (!Functioning())
		return;

	PSSoundRef ref = FindSound(soundname, nr);
	if (!ref)
		return;

	if (ref->usecount < 1)
	{
		if (ref->flags & SOUND_DYING)
			ref->flags &= ~SOUND_DYING;
		else
			ref->sound = TSound::Load(ref->resid);

		ref->usecount = 1;
	}
	else
		ref->usecount++;

	UpdateDying();
}

void TSoundPlayer::Unmount(char *soundname, int nr)
{
	if (!Functioning())
		return;

	PSSoundRef ref = FindSound(soundname, nr);
	if (!ref)
		return;

	ref->usecount--;

	if (ref->usecount < 1)
	{
		if (ref->sound)
		{
			if (ref->sound->IsPlaying() && !ref->sound->IsLooping())
				ref->flags |= SOUND_DYING;
			else
			{
				delete ref->sound;
				ref->sound = NULL;
			}
		}

		ref->usecount = 0;
	}

	UpdateDying();
}

void TSoundPlayer::Play(char *soundname, int nr, int volume, int freq)
{
	if (!Functioning())
		return;

	PSSoundRef ref = FindSound(soundname, nr);
	if (!ref)
		return;

	if (ref && ref->sound)
	{
		if (!ref->sound->IsPlaying())
			ref->sound->Play(volume, freq);
		else
		{
			// create a duplicate of the buffer to play seperately
			PTSound newsound = ref->sound->Duplicate();
			if (!newsound)
				return;

			newsound->SetNext(ref->sound->Next());
			ref->sound->SetNext(newsound);
			newsound->Play(volume);
		}
	}

	UpdateDying();
}

void TSoundPlayer::Stop(char *soundname)
{
	if (!Functioning())
		return;

	PSSoundRef ref = FindSound(soundname);

	if (ref && ref->sound)
		ref->sound->Stop();
}

BOOL TSoundPlayer::ReadSoundList()
{
	soundlist = NULL;

	char fname[MAX_PATH];
	sprintf(fname, "%ssound.def", ClassDefPath);

	FILE *fp = TryOpen(fname, "rb");
	if (fp == NULL)
		return FALSE;

	TFileParseStream s(fp, fname);
	TToken t(s);

	t.Get();

	PSSoundRef ref;
	char name[128];
	int resid;

	do
	{
		if (t.Type() == TKN_RETURN || t.Type() == TKN_WHITESPACE)
			t.LineGet();

		if (t.Type() == TKN_EOF)
			break;

		if (!Parse(t, "%s %d", name, &resid))
			return FALSE;

		ref = new SSoundRef;
		ref->name = strdup(name);
		ref->resid = resid;
		ref->usecount = 0;
		ref->sound = NULL;
		ref->next = soundlist;
		soundlist = ref;

	} while (t.Type() != TKN_EOF);

	fclose(fp);
	return TRUE;
}

void TSoundPlayer::DestroySoundList()
{
	PSSoundRef next;

	for (PSSoundRef ref = soundlist; ref; ref = next)
	{
		next = ref->next;
		delete ref;
	}

	soundlist = NULL;
}



// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                       Spell.cpp - Spell Pane                          *
// *************************************************************************

#include "revenant.h"
#include "bitmap.h"
#include "character.h"
#include "display.h"
#include "mappane.h"
#include "multi.h"
#include "player.h"
#include "playscreen.h"
#include "spell.h"
#include "font.h"

char *Talismans[] =
{ "Sun", "Life", "Ocean", "Law", "Soul", "Stars", "Death", "Chaos", "Sky", "Earth", "Ward", "Moon", NULL };

// *******************
// * TTalismanButton *
// *******************

void TTalismanButton::Draw()
{
	TButton::Draw();

	if (hidden)
		return;

	int start = x + xoffset + ((SPELLSIZE - len) * 11) + 14;

	for (int i = 0; i < len; i++)
		Display->Put(start + (i*23), y + 3 + (down ? 1 : 0), GameData->Bitmap(Talismans[spell[i]]), DM_BACKGROUND | DM_TRANSPARENT);
}

void TTalismanButton::AddTalisman(int t)
{
	if (len < SPELLSIZE)
	{
		spell[len++] = t;
		SetDirty();
	}
}

void TTalismanButton::Backspace()
{
	if (len > 0)
	{
		len--;
		SetDirty();
	}
}

void TTalismanButton::Clear()
{
	if (len > 0)
	{
		len = 0;
		SetDirty();
	}
}

void TTalismanButton::Invoke()
{
	if (Player && len > 0)
		Player->Invoke(spell, len);
}

// **************
// * TSpellPane *
// **************

void BtnSpellPane()
{
	SpellPane.Invoke();
}

void BtnSpellBook()
{
}

void BtnSpellAdd()
{
}

void BtnSpellBack()
{
	SpellPane.RemoveTal();
}

void BtnSpellDown()
{
	SpellPane.Scroll(1);
}

void BtnSpellUp()
{
	SpellPane.Scroll(-1);
}

void BtnSpellMin()
{
	SpellPane.ToggleTalismanNames();
}

#define REPEATRATE		8

BOOL TSpellPane::Initialize()
{
	TButtonPane::Initialize();

	NewButton(new TTalismanButton("spell",	24,	 95, 120, 34, VK_RETURN, BtnSpellPane, GameData->Bitmap("spellinvokedown"), GameData->Bitmap("spellinvokeup"), FALSE, FALSE, TRUE));
	NewButton("book",	3,	 62, 16, 14, 0, BtnSpellBook, GameData->Bitmap("spellbookdown"), GameData->Bitmap("spellbookup"));
	NewButton("add",	3,	 84, 16, 14, 0, BtnSpellAdd, GameData->Bitmap("spelladddown"), GameData->Bitmap("spelladdup"));
	NewButton("back",	142, 94, 12, 11, VK_BACK, BtnSpellBack, GameData->Bitmap("spellbackdown"), GameData->Bitmap("spellbackup"));
	NewButton("down",	149, 83, 16, 14, 0, BtnSpellDown, GameData->Bitmap("spelldowndown"), GameData->Bitmap("spelldownup"), FALSE, FALSE, FALSE, -1, REPEATRATE);
	NewButton("up",		149, 66, 16, 14, 0, BtnSpellUp, GameData->Bitmap("spellupdown"), GameData->Bitmap("spellupup"), FALSE, FALSE, FALSE, -1, REPEATRATE);
	NewButton("min",	149, 45, 16, 14, 0, BtnSpellMin, GameData->Bitmap("spellmindown"), GameData->Bitmap("spellminup"));

	shownames = TRUE;
	startline = 0;
	clickedtal = -1;

	Update();

	return TRUE;
}

#define TAL_STARTX		25
#define TAL_STARTY		9
#define TAL_WIDTH		30
#define TAL_HEIGHT		30
#define TAL_WRAPWIDTH	130
#define TAL_WRAPHEIGHT	76
#define TAL_NONAMEGAP	30

void TSpellPane::DrawBackground()
{
	BOOL wasdirty = IsDirty();

	if (wasdirty)
	{
		Display->Put(0, 0, GameData->Bitmap("spell"), DM_BACKGROUND);

		RedrawButtons();

		if (Player)
		{
			// find their spell pouch
			PTObjectInstance pouch = Player->FindObjInventory("Spell Pouch");
			if (pouch)
			{
				int x = TAL_STARTX, y = TAL_STARTY;

				SColor color = { 0, 0, 0 };

				int line = 0;
				for (int i = 0; Talismans[i]; i++)
					if (pouch->FindObjInventory(Talismans[i]))
					{
						if ((line++ >= startline || !ShowTalismanNames()) && y < TAL_WRAPHEIGHT)
						{
							int add = 0;
							if (onclickedtal && i == clickedtal)
								add = 1;

							char buf[80];
							sprintf(buf, "%scandy", Talismans[i]);
							Display->Put(x+2, y-2+2, GameData->Bitmap(buf), DM_BACKGROUND | DM_TRANSPARENT, &color);
							Display->Put(x+add, y-2+add, GameData->Bitmap(buf), DM_BACKGROUND | DM_TRANSPARENT);
							Display->Put(x+2+1, y+1+1, GameData->Bitmap(Talismans[i]), DM_BACKGROUND | DM_TRANSPARENT, &color);
							Display->Put(x+2+add, y+1+add, GameData->Bitmap(Talismans[i]), DM_BACKGROUND | DM_TRANSPARENT);

							if (ShowTalismanNames())
								Display->WriteTextShadow(Talismans[i], x + TAL_WIDTH - 1, y, 1, GameData->Font("goldfont"));

							x += TAL_WIDTH;
							if (ShowTalismanNames())
								x += TAL_NONAMEGAP;

							if (x > TAL_WRAPWIDTH)
							{
								x = TAL_STARTX;
								y += TAL_HEIGHT;
							}
						}
					}

				//color.red = 255;
				//Display->WriteTextShadow("Greater Slurpee", 32, 79, 1, GameData->Font("tinyfont"), &color);

				// set up button visibility
				if (!ShowTalismanNames() || startline < 1)
				{
					Button(5)->SetState(FALSE);
					Button(5)->Hide();
				}
				else
					Button(5)->Show();

				if (!ShowTalismanNames() || (line - startline) <= 6)
				{
					Button(4)->SetState(FALSE);
					Button(4)->Hide();
				}
				else
					Button(4)->Show();
			}
		}

		if (shownames)
		{
			Button(6)->SetUpBitmap(GameData->Bitmap("spellminup"));
			Button(6)->SetDownBitmap(GameData->Bitmap("spellmindown"));
		}
		else
		{
			Button(6)->SetUpBitmap(GameData->Bitmap("spellmaxup"));
			Button(6)->SetDownBitmap(GameData->Bitmap("spellmaxdown"));
		}

		PlayScreen.MultiUpdate();
		SetDirty(FALSE);
	}


	if (wasdirty)
		TButtonPane::DrawBackground();
}

void TSpellPane::MouseClick(int button, int x, int y)
{
	TButtonPane::MouseClick(button, x, y);

	if (button == MB_LEFTDOWN)
	{
		clickedtal = OnTal(x, y);
		if (clickedtal >= 0)
		{
			onclickedtal = TRUE;
			Update();
		}
	}
	else if (button == MB_LEFTUP && clickedtal >= 0)
	{
		if (onclickedtal)
			AddTal(clickedtal);

		clickedtal = -1;
		Update();
	}
}

void TSpellPane::MouseMove(int button, int x, int y)
{
	TButtonPane::MouseMove(button, x, y);

	if (button == MB_LEFTDOWN && clickedtal >= 0)
	{
		BOOL oldonclickedtal = onclickedtal;

		if (OnTal(x, y) == clickedtal)
			onclickedtal = TRUE;
		else
			onclickedtal = FALSE;

		if (oldonclickedtal != onclickedtal)
			Update();
	}
}

int TSpellPane::OnTal(int x, int y)
{
	if (x < TAL_STARTX || x >= (TAL_STARTX + TAL_WRAPWIDTH) ||
		y < TAL_STARTY || y >= (TAL_STARTY + TAL_WRAPHEIGHT))
		return -1;

	if (Player)
	{
		PTObjectInstance pouch = Player->FindObjInventory("Spell Pouch");
		if (pouch)
		{
			int x0 = TAL_STARTX, y0 = TAL_STARTY;

			int line = 0;
			for (int i = 0; Talismans[i]; i++)
				if (pouch->FindObjInventory(Talismans[i]))
					if ((line++ >= startline || !ShowTalismanNames()) && y0 < TAL_WRAPHEIGHT)
					{
						if (x >= x0 && x < (x0 + TAL_WIDTH) && y >= y0 && y < (y0 + TAL_HEIGHT))
							return i;

						x0 += TAL_WIDTH;
						if (ShowTalismanNames())
							x0 += TAL_NONAMEGAP;

						if (x0 > TAL_WRAPWIDTH)
						{
							x0 = TAL_STARTX;
							y0 += TAL_HEIGHT;
						}
					}
		}
	}

	return -1;
}

void TSpellPane::Scroll(int numlines)
{
	int oldstartline = startline;

	startline += numlines * 2;		// two talismans on a line

	if (startline < 0)
		startline = 0;

	if (startline != oldstartline)
		SetDirty(TRUE);
}

void TSpellPane::ToggleTalismanNames()
{
	shownames = !shownames;
	SetDirty(TRUE);
}

BOOL TSpellPane::AddTal(int tal)
{
	((PTTalismanButton)Button(0))->AddTalisman(tal);
	return FALSE;
}

BOOL TSpellPane::RemoveTal(int numtals)
{
	for (int i = 0; i < numtals; i++)
		((PTTalismanButton)Button(0))->Backspace();

	return TRUE;
}

void TSpellPane::Invoke()
{
	((PTTalismanButton)Button(0))->Invoke();
}

// ******************
// * QuickSpellPane *
// ******************

void BtnSpellOne()
{
	QuickSpells.Invoke(1);
}

void BtnSpellTwo()
{
	QuickSpells.Invoke(2);
}

void BtnSpellThree()
{
	QuickSpells.Invoke(3);
}

void BtnSpellFour()
{
	QuickSpells.Invoke(4);
}

BOOL TQuickSpellPane::Initialize()
{
	TButtonPane::Initialize();

	NewButton(new TTalismanButton("1", 0, 0, 120, 28, '1', BtnSpellOne, GameData->Bitmap("spell1down"), GameData->Bitmap("spell1up"), FALSE, FALSE, TRUE, -4));
	NewButton(new TTalismanButton("2", 99, 7, 120, 28, '2', BtnSpellTwo, GameData->Bitmap("spell2down"), GameData->Bitmap("spell2up"), FALSE, FALSE, TRUE, 4));
	NewButton(new TTalismanButton("3", 218, 7, 120, 28, '3', BtnSpellThree, GameData->Bitmap("spell3down"), GameData->Bitmap("spell3up"), FALSE, FALSE, TRUE, -4));
	NewButton(new TTalismanButton("4", 317, 0, 120, 28, '4', BtnSpellFour, GameData->Bitmap("spell4down"), GameData->Bitmap("spell4up"), FALSE, FALSE, TRUE, 4));

	((PTTalismanButton)Button(0))->AddTalisman(8);

	((PTTalismanButton)Button(1))->AddTalisman(2);

	((PTTalismanButton)Button(2))->AddTalisman(3);

	((PTTalismanButton)Button(3))->AddTalisman(4);

	return TRUE;
}

void TQuickSpellPane::DrawBackground()
{
	TButtonPane::DrawBackground();
}

void TQuickSpellPane::Invoke(int button)
{
	// James - Was <, but button is one based and NUMBUTTONS is 4
	if (button > 0 && button <= NUMBUTTONS)
		((PTTalismanButton)Button(button - 1))->Invoke();
}

// ************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                   statpane.cpp - FORSAKEN Stat Pane                   *
// *************************************************************************

#include "revenant.h"
#include "statpane.h"
#include "display.h"
#include "playscreen.h"
#include "player.h"
#include "multi.h"
#include "font.h"

void BtnStatStats()
{
	StatPane.Update();
}

void BtnStatSkills()
{
	StatPane.Update();
}

void BtnStatMin()
{
	StatPane.ContractAll();
	StatPane.Scroll(-10000);
}

void BtnStatMax()
{
	StatPane.ExpandAll();
}

void BtnStatUp()
{
	StatPane.Scroll(-1);
}

void BtnStatDown()
{
	StatPane.Scroll(1);
}

#define NUMLINES	6
#define SCROLLRATE	8
#define TEXT_POS_Y	23

BOOL TStatPane::Initialize()
{
	TButtonPane::Initialize();

	NewButton("stats", 19, 5, 64, 19, VK_RETURN, BtnStatStats, GameData->Bitmap("statsdown"), GameData->Bitmap("statsup"), FALSE, TRUE, FALSE, 1);
	NewButton("skills", 84, 5, 64, 19, VK_RETURN, BtnStatSkills, GameData->Bitmap("skillsdown"), GameData->Bitmap("skillsup"), FALSE, TRUE, FALSE, 1);

	NewButton("up", 149, 66, 16, 14, 0, BtnStatUp, GameData->Bitmap("spellupdown"), GameData->Bitmap("spellupup"), FALSE, FALSE, FALSE, -1, SCROLLRATE);
	NewButton("down", 149, 83, 16, 14, 0, BtnStatDown, GameData->Bitmap("spelldowndown"), GameData->Bitmap("spelldownup"), FALSE, FALSE, FALSE, -1, SCROLLRATE);

	NewButton("min", 149, 49, 16, 14, 0, BtnStatMin, GameData->Bitmap("statmindown"), GameData->Bitmap("statminup"));
	NewButton("max", 149, 34, 16, 14, 0, BtnStatMax, GameData->Bitmap("statmaxdown"), GameData->Bitmap("statmaxup"));

	startline = 0;
	memset(&expanded, 0, sizeof(BOOL) * NUM_SKILLS);

	Button(0)->SetState(TRUE);

	return TRUE;
}

void TStatPane::Close()
{
	TButtonPane::Close();
}

#define GEM			(char)('~' + 13)
#define GEM_LINE	(char)(GEM + 1)
#define LINE		(char)(GEM_LINE + 1)
#define LINE_BRANCH	(char)(LINE + 1)
#define LINE_END	(char)(LINE_BRANCH + 1)

void TStatPane::DrawBackground()
{
	if (IsDirty())
	{
		Display->Put(0, 0, GameData->Bitmap("statpane"), DM_BACKGROUND);

		RedrawButtons();

		char buf1[512] = "";
		char buf2[512] = "";

		BOOL showdownbutton = TRUE;

		if (Button(0)->GetState() == TRUE)
		{
			for (int i = 0; i < NUM_PLRSTATS; i++)
				sprintf(buf1, "%s   %s\n", buf1, Player->ObjStatName(PLRSTAT_FIRST + i));

			if (Player)
				for (int i = 0; i < NUM_PLRSTATS; i++)
					sprintf(buf2, "%s%d\n", buf2, Player->GetObjStat(PLRSTAT_FIRST + i));

			showdownbutton = FALSE;
		}
		else
		{
			int line = 0;
			for (int i = 0; i < NUM_SKILLS; i++, line++)
			{
				BOOL isline = TRUE;

				if (SkillTree[i].ancestor < 0)
				{
					if (line >= startline)
					{
						if (!SkillTree[i].children)
							sprintf(buf1, "%s   %s\n", buf1, SkillTree[i].name);
						else
						{
							if (expanded[i])
								sprintf(buf1, "%s%c %s\n", buf1, GEM_LINE, SkillTree[i].name);
							else
								sprintf(buf1, "%s%c %s\n", buf1, GEM, SkillTree[i].name);
						}
					}
				}
				else
				{
					int lastlen = strlen(buf1);

					// check for ancestor of the ancestor...
					int grandparent = SkillTree[i].ancestor;
					while (grandparent >= 0)
					{
						if (!expanded[grandparent])
						{
							isline = FALSE;
							break;
						}

						char fillchar;

						if (SkillTree[grandparent].lastchild)
							fillchar = ' ';
						else
							fillchar = LINE;

						grandparent = SkillTree[grandparent].ancestor;
						if (grandparent < 0)
							break;

						if (fillchar == ' ')
							sprintf(buf1, "%s  ", buf1);
						else
							sprintf(buf1, "%s%c", buf1, fillchar);
					}

					if (!isline || line < startline)
						buf1[lastlen] = 0;
					else
					{
						if (!SkillTree[i].children)
						{
							if (SkillTree[i].lastchild)
								sprintf(buf1, "%s%c %s\n", buf1, LINE_END, SkillTree[i].name);
							else
								sprintf(buf1, "%s%c %s\n", buf1, LINE_BRANCH, SkillTree[i].name);
						}
						else
						{
							int gemchar = expanded[i] ? GEM_LINE : GEM;

							if (SkillTree[i].lastchild)
								sprintf(buf1, "%s%c%c %s\n", buf1, LINE_END, gemchar, SkillTree[i].name);
							else
								sprintf(buf1, "%s%c%c %s\n", buf1, LINE_BRANCH, gemchar, SkillTree[i].name);
						}
					}
				}

				if (!isline)
					line--;		// the line is hidden, don't count it
				else if (line >= startline && Player)
					sprintf(buf2, "%s%d\n", buf2, Player->Skill(i));
			}

			if ((line - startline) <= NUMLINES)
				showdownbutton = FALSE;
		}

		Display->WriteTextShadow(buf1, 12, TEXT_POS_Y, NUMLINES, GameData->Font("goldfont"));

		if (Player)
			Display->WriteTextShadow(buf2, 138, TEXT_POS_Y, NUMLINES, GameData->Font("goldfont"), NULL, FONT_DRAWMODE, -1, 0, JUSTIFY_RIGHT);

		// determine which scroll buttons are showing
		if (startline < 1 || Button(0)->GetState())
		{
			ScrollUpButton()->SetState(FALSE);
			ScrollUpButton()->Hide();
		}
		else
			ScrollUpButton()->Show();

		if (showdownbutton)
			ScrollDownButton()->Show();
		else
		{
			ScrollDownButton()->SetState(FALSE);
			ScrollDownButton()->Hide();
		}
		
		SetDirty(FALSE);
		PlayScreen.MultiUpdate();
	}

	TButtonPane::DrawBackground();
}

void TStatPane::MouseClick(int button, int x, int y)
{
	TButtonPane::MouseClick(button, x, y);

	if (button == MB_LEFTDOWN)
	{
		int slot = OnSlot(x, y);
		if (slot >= 0 && SkillTree[slot].children)
		{
			expanded[slot] = !expanded[slot];
			SetDirty(TRUE);
		}
	}
}

void TStatPane::MouseMove(int button, int x, int y)
{
	TButtonPane::MouseMove(button, x, y);
}

void TStatPane::Scroll(int numlines)
{
	int oldstartline = startline;

	startline += numlines;

	if (startline < 0)
		startline = 0;
	if ((startline + NUMLINES) > NUM_SKILLS)
		startline = NUM_SKILLS - NUMLINES;

	if (startline != oldstartline)
		SetDirty(TRUE);
}

void TStatPane::SetAllExpanded(BOOL value)
{
	BOOL changed = FALSE;

	for (int i = 0; i < NUM_SKILLS; i++)
		if (SkillTree[i].children)
			if (expanded[i] != value)
			{
				expanded[i] = value;
				changed = TRUE;
			}

	if (changed)
		SetDirty(TRUE);
}

int TStatPane::OnSlot(int x, int y)
{
	if (x > 113)			// buttons are to the right of this value
		return -1;

	y -= TEXT_POS_Y + 4;
	if (y < 0)
		return -1;

	int slot = y / GameData->Font("goldfont")->height;
	if (slot < 0 || slot >= NUMLINES)
		return -1;

	slot += startline;

	int line = 0;
	for (int i = 0; i < NUM_SKILLS; i++)
	{
		BOOL isline = TRUE;
		int grandparent = SkillTree[i].ancestor;
		while (grandparent >= 0)
		{
			if (!expanded[grandparent])
			{
				isline = FALSE;
				break;
			}
			grandparent = SkillTree[grandparent].ancestor;
		}

		if (isline && line++ == slot)
			return i;
	}

	return -1;
}
// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *           statusbar.cpp - Status bars (health, stamina)               *
// *************************************************************************

#include "revenant.h"
#include "statusbar.h"
#include "display.h"

// **************
// * TStatusBar *
// **************

BOOL TStatusBar::Initialize()
{
	tubedata = NULL;
	level = targetlevel = 1000;
	animating = FALSE;
	SetDirty(TRUE);
	return TRUE;
}

void TStatusBar::Close()
{
	if (tubedata)
		delete tubedata;
}

#define HEALTH_INCREMENT	4

void TStatusBar::DrawBackground()
{
	if (animating || level != targetlevel || IsDirty())
	{
		if (absval(level - targetlevel) <= HEALTH_INCREMENT)
			level = targetlevel;
		else if (level < targetlevel)
			level += HEALTH_INCREMENT;
		else if (level > targetlevel)
			level -= HEALTH_INCREMENT;

		BOOL drawmode = 0;

		if (level != targetlevel)
		{
			animating = TRUE;
			drawmode |= DM_NORESTORE;
		}
		else
		{
			animating = FALSE;
			drawmode |= DM_BACKGROUND;
		}

		Display->PutHue(0, -(176 * level / 1000), tubedata->Bitmap("tube"), drawmode, GetHue());

		drawmode |= DM_TRANSPARENT;

		Display->Put(0, 0, tubedata->Bitmap("topoverlay"), drawmode);
		Display->Put(0, 59, tubedata->Bitmap("middleoverlay"), drawmode);
		Display->Put(0, 161, tubedata->Bitmap("bottomoverlay"), drawmode);

		SetDirty(FALSE);
	}
}

// **************
// * THealthBar *
// **************

BOOL THealthBar::Initialize()
{
	TStatusBar::Initialize();

	tubedata = TMulti::LoadMulti("health.dat");

	return tubedata != NULL;
}

int THealthBar::GetHue()
{
	int hue = level * 155 / 1000;
	if (hue > 16)
		hue -= 16;
	else
		hue = 0;

	return hue;
}

// ***************
// * TStaminaBar *
// ***************

BOOL TStaminaBar::Initialize()
{
	TStatusBar::Initialize();

	tubedata = TMulti::LoadMulti("stamina.dat");

	return tubedata != NULL;
}

int TStaminaBar::GetHue()
{
	return ((1000 - level) * 65 / 1000) + 240;
}

// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                     stream.cpp - TStream object                       *
// *************************************************************************

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <memory.h>

#include "revenant.h"
#include "stream.h"
#pragma hdrstop

// ******************************
// * Constructor and Destructor *
// ******************************

TOutputStream::TOutputStream(int startsize, int grwsize)
{
	buf = (BYTE *)malloc(startsize);
	bufsize = startsize;
	growsize = grwsize;
	Reset();
}

TOutputStream::~TOutputStream()
{
	delete buf;
}

void TOutputStream::MakeFreeSpace(int freespace)
{
	int datasize = DataSize();
	if (bufsize - datasize < freespace)
	{
		buf = (BYTE *)realloc(buf, bufsize + growsize);
		ptr = buf + datasize;
		bufsize = bufsize + growsize;
	}
}

// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                stripeffect.cpp - TStripEffect module                  *
// *************************************************************************

#include <ddraw.h>
#include <d3d.h>
#include <d3drmwin.h>
#include <math.h>
#include "d3dmacs.h"
#include "d3dmath.h"

#include "revenant.h"
#include "stripeffect.h"
#include "effect.h"
#include "character.h"
#include "3dscene.h"

// ******************
// * TStripEffect   *
// ******************

DEFINE_BUILDER("LIGHTSTRIP", TStripEffect)
REGISTER_BUILDER(TStripEffect)

void TStripEffect::Initialize()
{
    SetState( STRIP_LAUNCH);
	duration = 20;
	targetrange = -1;
}

void TStripEffect::Pulse()
{
    switch (state)
    {
        case STRIP_LAUNCH:
        { 
			PTObjectInstance invoker = spell->GetInvoker();
			S3DPoint newpos, vel;
			int pnt, block;

			invoker->GetPos( newpos);
			ConvertToVector( facing, 10, vel);

			for (pnt = 0; pnt < 16; pnt++)
			{
				newpos.x += vel.x;
				newpos.y += vel.y;
				block = MapPane.GetWalkHeight( newpos);
				if ((block == 0) || ((PTCharacter)Player)->CharBlocking( ((PTObjectInstance)Player), newpos))
				{
					// Either a character or a wall
					targetrange = (pnt + 2);
					break;
				}
			}
		
			SetState( STRIP_FLY);
            break;
        }
        case STRIP_FLY:
        {
			duration--;
			if (duration <= 0)
				SetState(STRIP_EXPLODE);
            break;
        }
		case STRIP_EXPLODE:
			break;
	}

	TEffect::Pulse();
}

void TStripEffect::OffScreen()
{
	if (animator && (state == STRIP_EXPLODE) && commanddone)
		TObjectInstance::OffScreen();
}


// **********************
// * Lightning Animator *
// **********************

REGISTER_3DANIMATOR("LightStrip", TLightningAnimator)

void TLightningAnimator::Initialize()
{
	T3DAnimator::Initialize();

	PLAY("lightning sound");

	// get effect position
	S3DPoint effect;
	((PTEffect)inst)->GetPos(effect);

	// init the sparks
	PS3DAnimObj o = GetObject(2);
	spark.Init(this, o);
	impact_spark.Init(this, o);

	// set the parameters
	SSubParticleParams params;

	params.particles = 20;
	params.chance = 25;
	params.velocity_dir.x = 0;
	params.velocity_dir.y = 0;
	params.velocity_dir.z = 0;
	params.pos.x = (float)effect.x;
	params.pos.y = (float)effect.y;
	params.pos.z = (float)effect.z;
	params.pos_spread.x = params.pos_spread.y = params.pos_spread.z = 0.0f;
	params.scale.x = params.scale.y = params.scale.z = 6.0f;
	params.scale_dec.x = params.scale_dec.y = params.scale_dec.z = .90f;
	params.scale_spread.x = params.scale_spread.y = params.scale_spread.z = 0.0f;
	params.velocity.x = params.velocity.y = params.velocity.z = 0.0f;
	params.velocity_spread.x = params.velocity_spread.y = 2.0f;
	params.velocity_spread.z = 1.0f;
	params.gravity = .18f;
	params.min_life = 25;
	params.max_life = 35;
	params.flicker = TRUE;
	params.flicker_size = 2.5f;

	// set them!
	spark.Set(&params);
	params.particles = 0;
	params.pos = end_p;
	impact_spark.Set(&params);

	glow_scale = 3.8f;
	total_offset = 0;
}

void TLightningAnimator::SetupObjects()
{
	D3DVECTOR p;
	int	i;

	// LightStrip
	PS3DAnimObj o = NewObject( 0);

	showangle = 0;
	rotdegree = 0;
	morrotdegree = 0;
	maxsize = FALSE;
	down = TRUE;
	damage_flag = FALSE;

	numpoints = 2;
	//maxpoints = (((PTStripEffect)inst)->targetrange == -1) ? 40 : ((PTStripEffect)inst)->targetrange;

	// code for figure the maxpoints
	float r = 10.0f;
	float dx = r * (float)sin((float)TORADIAN * (((float)inst->GetFace() * 360.0f) / 256.0f));
	float dy = -r * (float)cos((float)TORADIAN * (((float)inst->GetFace() * 360.0f) / 256.0f));
	S3DPoint effect;
	((PTEffect)inst)->GetPos(effect);
	D3DVECTOR point;
	point.x = (float)effect.x;
	point.y = (float)effect.y;
	point.z = (float)effect.z;
	maxpoints = 1;
	float zheight;
	int num;
	BOOL flag = FALSE;
	S3DPoint new_pos;
	do
	{
		point.x += dx;
		point.y += dy;

		effect.x = (int)point.x;
		effect.y = (int)point.y;
		effect.z = (int)point.z;

		zheight = (float)MapPane.GetWalkHeight(effect);

		int targets[MAXFOUNDOBJS];

		new_pos.x = (int)point.x;
		new_pos.y = (int)point.y;
		new_pos.z = (int)point.z - 100;

        // See if we've hit a character
        num = MapPane.FindObjectsInRange(new_pos, targets, 1, 0, OBJCLASS_CHARACTER);

		for(int i = 0; i < num; ++i) 
		{
			PTObjectInstance inst = MapPane.GetInstance(targets[i]);
            if (inst && inst != ((PTEffect)inst)->GetSpell()->GetInvoker())
				flag = TRUE;
		}

		++maxpoints;
	}
	while(point.z > zheight && flag == FALSE && maxpoints < MAX_MAXPOINTS);

	end_p.x = point.x;
	end_p.y = point.y;
	end_p.z = point.z - 20.0f;

	maxpoints = min(100, maxpoints);

	// if true = used for doing demos
	if(!TARGET_POS)
		maxpoints *= SMOOTH_SIZE;

	mystrip = new TStripAnimator( o, maxpoints);
//	mystrip->SetTextureRange( D3DVALUE( 0.0), D3DVALUE( 1.0));

	mystrip->SetWidth((LIGHTNING_SCALE_N * 16) / LIGHTNING_SCALE_D, (LIGHTNING_SCALE_N * 10) / LIGHTNING_SCALE_D);

	// Set our first segment
    for (i = 0; i < numpoints; i++)
    {
		p.x = 0;
		p.y = (D3DVALUE)(i * -10);
		p.z = 0;
		mystrip->AddPoint( &p);
	}

	AddObject( o);

	// Glow
	o = NewObject( 1);
	AddObject( o);

	// Spark
	o = NewObject( 2);
	AddObject( o);
}

void TLightningAnimator::Animate( BOOL draw) 
{
	int	i;
	D3DVECTOR *p;

	T3DAnimator::Animate( draw);
	inst->SetCommandDone( FALSE);

	SSubParticleParams params;
	if(mystrip->curpoints == mystrip->maxpoints)
	{
		impact_spark.Get(&params);
		params.particles = 20;
		impact_spark.Set(&params);
		if(!damage_flag)
		{
			damage_flag = TRUE;
			S3DPoint new_pos;
			new_pos.x = (int)end_p.x;
			new_pos.y = (int)end_p.y;
			new_pos.z = (int)end_p.z - 80;
			DamageCharactersInRange(((PTEffect)inst)->GetSpell()->GetInvoker(), new_pos, 1, 15, 25, DAMAGE_FIRE);
		}
	}
	else
	{
		impact_spark.Get(&params);
		params.particles = 0;
		impact_spark.Set(&params);
	}
	
	if(inst->GetState() == STRIP_EXPLODE)
	{		

		params.particles = 0;
		spark.Set(&params);
		impact_spark.Set(&params);

		glow_scale *= .8f;

		for(i = 0; i < ADD_FACTOR; ++i)
			mystrip->DelEndPoint();
		total_offset += (ADD_FACTOR * -10);
	}

	if(numpoints < maxpoints)
	{
		for(i = 0; i < ADD_FACTOR && numpoints < maxpoints; ++i)
		{
			D3DVECTOR p;

			p.x = 0;
			p.y = D3DVAL( numpoints * -10);
			p.z = 0;

			numpoints++;
			if (numpoints == maxpoints)	// The last point is left on target
				maxsize = TRUE;

			mystrip->AddPoint( &p);
		}
	}
	spark.Animate();
	impact_spark.Animate();

	// smoothing calculations
	float *px = new float[numpoints + SMOOTH_SIZE];
	float *pz = new float[numpoints + SMOOTH_SIZE];
	
	// init beginnings and endings
	for(i = 0; i < numpoints + SMOOTH_SIZE; ++i)
		px[i] = pz[i] = 0;

	// make the standard points
	for (i = 1; i < numpoints; i++)
	{
		if(!(i % SMOOTH_SIZE))
		{
			px[i] = (float)random(-13, 13);
			pz[i] = (float)random(-13, 13);
		}
	}

	int last_point = 0;
	int next_point = SMOOTH_SIZE;
	
	// make the smoothing points
	for (i = 1; i < numpoints; i++)
	{
		if(i == next_point)
		{
			last_point = next_point;
			next_point += SMOOTH_SIZE;
		}

		int mod = i % SMOOTH_SIZE;
		if(mod)
		{
			if(mod == 1)
			{
				px[i] = ((px[next_point] - px[last_point]) * .5f) / (float)SMOOTH_SIZE;
				pz[i] = ((pz[next_point] - pz[last_point]) * .5f) / (float)SMOOTH_SIZE;
			}
			else if(mod == 2)
			{
				px[i] = ((px[next_point] - px[last_point]) * 2.0f) / (float)SMOOTH_SIZE;
				pz[i] = ((pz[next_point] - pz[last_point]) * 2.0f) / (float)SMOOTH_SIZE;
			}
			else if(mod == 3)
			{
				px[i] = ((px[next_point] - px[last_point]) * 3.5f) / (float)SMOOTH_SIZE;
				pz[i] = ((pz[next_point] - pz[last_point]) * 3.5f) / (float)SMOOTH_SIZE;
			}

			px[i] += px[last_point];
			pz[i] += pz[last_point];
		}
	}

	// Randomize points - Should probably be relative to the strip size
	// skip every other point to average the stuff out
    for (i = 1; i < numpoints; i++)
	{
		p = &mystrip->operator[]( i);
		p->x = 0;
		p->z = 0;
		if (down)
			p->z = -D3DVAL( ((i - 1) * 20) / (maxpoints - 1));
		if (i < (maxpoints - 1))
		{
			p->x = px[i];
			p->z += pz[i];
		}
	}

	delete [] px;
	delete [] pz;

//	showangle = ((showangle + 1) % 256);	// Demo Mode
	rotdegree = ((rotdegree + 12) % 360);
	morrotdegree = ((morrotdegree + 16) % 360);

//* Test for reducing the strip
	if (maxsize)
	{
//		((PTCharacter)Player)->EffectBurst( "sparks", 50);
//		if (random( 0, 10) > 7)
//		{
//			mystrip->SetTexture( random( 0, 1));
//			mystrip->DelStartPoint();
//			mystrip->DelEndPoint();
//			if (mystrip->curpoints == 2)
//			{
//				maxsize = FALSE;
//				numpoints = 2;
//			}
//		}
	}

//* Tests for scrolling the texture or advancing the strip
	mystrip->ScrollTexture( D3DVALUE( -0.1));
//	mystrip->AdvanceStrip();
//	mystrip->ReverseStrip();
	if(inst->GetState() == STRIP_EXPLODE && !spark.GetCount() && !impact_spark.GetCount())
		inst->SetCommandDone(TRUE);
}

BOOL TLightningAnimator::Render()
{
	DWORD savedcull;

    SaveBlendState();
    SetBlendState();

	// So I can render any face
	TRY_D3D(Device2->GetRenderState( D3DRENDERSTATE_CULLMODE, &savedcull));
	TRY_D3D(Device2->SetRenderState( D3DRENDERSTATE_CULLMODE, D3DCULL_NONE));

	PS3DAnimObj obj;

// LightStrip
	if(inst->GetState() != STRIP_EXPLODE)
	{
		// Reset render extents
		ResetExtents();

		// Face strip to our absolute angle	
		mystrip->GenerateStrip( inst->GetFace() + showangle);

		obj = mystrip->GetStripObj();

		// But rotate strip to its own angle
		if (showangle)
			D3DMATRIXRotateZ( &obj->matrix, D3DVAL( ((showangle * 360) / 256) * TORADIAN));

		//RenderObject( obj);
		RenderObject( obj);

		// I don't know how to get the right rectangles
		//	GetExtents( &extents);
		//	mystrip->AddUpdateRects( &extents);

		// Update bounding rect and screen rect
		UpdateExtents();
	}
// End LightStrip

	if(glow_scale > .25f)
	{
// Glow
		obj = GetObject( 1);

		// Reset render extents
		ResetExtents();

		// Set the scale and position of the object
		obj->flags = OBJ3D_MATRIX;
		obj->scl.x = obj->scl.y = obj->scl.z = D3DVAL( glow_scale + (random( 0, 4) / 10.0));

		D3DMATRIXClear( &obj->matrix);

		D3DMATRIXRotateZ( &obj->matrix, D3DVAL( -rotdegree * TORADIAN));
		D3DMATRIXRotateX( &obj->matrix, D3DVAL( -30 * TORADIAN));
		D3DMATRIXRotateY( &obj->matrix, D3DVAL( 60 * TORADIAN));

		// Offset for our base rotation
		D3DMATRIXRotateZ( &obj->matrix, D3DVAL( -((inst->GetFace() * 360) / 256) * TORADIAN));

		D3DMATRIXTranslate( &obj->matrix, &obj->pos);
		D3DMATRIXScale( &obj->matrix, &obj->scl);

		RenderObject( obj);

		D3DMATRIXClear( &obj->matrix);

		D3DMATRIXRotateZ( &obj->matrix, D3DVAL( morrotdegree * TORADIAN));
		D3DMATRIXRotateX( &obj->matrix, D3DVAL( -30 * TORADIAN));
		D3DMATRIXRotateY( &obj->matrix, D3DVAL( 60 * TORADIAN));

		// Offset for our base rotation
		D3DMATRIXRotateZ( &obj->matrix, D3DVAL( -((inst->GetFace() * 360) / 256) * TORADIAN));

		D3DMATRIXTranslate( &obj->matrix, &obj->pos);
		D3DMATRIXScale( &obj->matrix, &obj->scl);

		RenderObject( obj);

		UpdateExtents();

	}
// End Glow

// Sparks	
	spark.Render();
	impact_spark.Render();
// End Sparks

	TRY_D3D(Device2->SetRenderState(D3DRENDERSTATE_CULLMODE, savedcull));

    RestoreBlendState();

	return TRUE;
}

void TLightningAnimator::RefreshZBuffer()
{
	S3DPoint screen_pos;
	S3DPoint map_pos;

	S3DPoint effect_pos;

	((PTEffect)inst)->GetPos(effect_pos);

	WorldToScreen(effect_pos, screen_pos);

	S3DPoint size;
	size.x = 620;
	size.y = 400;

	RestoreZ(screen_pos.x - (size.x / 2), screen_pos.y - (size.y / 2), size.x, size.y);

	
	// SPARKS
	//spark.RefreshZBuffer(4, 4);

	// LIGHTNING STRIP
	/*
	for(int i = 0; i <= numpoints; ++i)
	{
		D3DVECTOR *p;

		p = &mystrip->operator[](i);
		
		map_pos.x = (int)p->x + effect_pos.x;
		map_pos.y = (int)p->y + effect_pos.y;
		// change this to be good stuff, like the rotation use ((PTEffect)inst)->GetAngle() =:)
		map_pos.z = (int)(((float)p->z * 360) / 256) * TORADIAN) + effect_pos.z;

		WorldToScreen(map_pos, screen_pos);

		MapPane.DrawRestoreRect((int)screen_pos.x - 15, (int)screen_pos.y - 15, 30, 30,
			DM_WRAPCLIPSRC | DM_NORESTORE | DM_ZBUFFER | DM_NODRAW);
	}
	*/

	// GLOW
	//map_pos.x = effect_pos.x;
	//map_pos.y = effect_pos.y;
	//map_pos.z = effect_pos.z;

	//WorldToScreen(map_pos, screen_pos);
	//MapPane.DrawRestoreRect((int)screen_pos.x - 25, (int)screen_pos.y - 18, 50, 50,
	//	DM_WRAPCLIPSRC | DM_NORESTORE | DM_ZBUFFER | DM_NODRAW);
}

// ********************
// * WindStrip Effect *
// ********************

DEFINE_BUILDER("WindStrip", TWindStripEffect)
REGISTER_BUILDER(TWindStripEffect)

void TWindStripEffect::Initialize()
{
}

void TWindStripEffect::Pulse()
{
	TEffect::Pulse();
}

// **********************
// * WindStrip Animator *
// **********************

REGISTER_3DANIMATOR("WindStrip", TWindStripAnimator)

#define WINDSTRIP_POINTS		20
#define WINDSTRIP_WIDTH			15
#define WINDSTRIP_WIDTH2		15
#define WINDSTRIP_DURATION		250
#define WINDSTRIP_FADEOUT		100
#define WINDSTRIP_MODIFIER		5
#define WINDSTRIP_MODIFIERV		15
#define WINDSTRIP_RADIUS		2
#define WINDSTRIP_NUMSPARKS		(20 * 20)
#define WINDSTRIP_SPARKSCALE	0.4
#define WINDSTRIP_SPARKDSCALE	0.005
#define WINDSTRIP_SPARKGRAV		0.2
#define WINDSTRIP_SPARKFALL		0.5
#define WINDSTRIP_HALOSTEP		0.04

void TWindStripAnimator::Initialize()
{
	T3DAnimator::Initialize();

	// get effect position
	S3DPoint effect;
	((PTEffect)inst)->GetPos(effect);
	subspell = ((PTEffect)inst)->GetSubSpell();

	center.x = (float)0;
	center.y = (float)0;
	center.z = (float)0;

	realpos.x = (float)0;
	realpos.y = (float)0;
	realpos.z = (float)0;

	centerang = 0;
	haloscale = (float)0;
	frameon = 0;

	//PS3DAnimObj o = GetObject(1);
	for (int i = 0; i < WINDSTRIP_MAX_STRIPS; i++)
	{
		r[i] = (float)random(0, 6);
		th[i] = (float)random(0, 6);
		h[i] = (float)random(0, 6);
		dr[i] = (float)(random(1, 20) / 100.0);
		dth[i] = (float)(random(15, 20) / 100.0);
		dh[i] = (float)(random(1, 20) / 100.0);
		ac[i] = (float)(0.0);
		dac[i] = (float)(random(5, 10) / 100.0);
	
		//mystrip[i] = new TStripAnimator(o, WINDSTRIP_POINTS);
		//mystrip[i]->SetWidth(WINDSTRIP_WIDTH, WINDSTRIP_WIDTH2);
		//mystrip[i]->SetTextureRange((float)-1, (float)1);
	}
	InitDrops();
}

void TWindStripAnimator::SetupObjects()
{
	//D3DVECTOR p;
	//int	i;

	PS3DAnimObj o;
	// sparks
	o = NewObject(0, OBJ3D_COPYVERTS | OBJ3D_COPYFACES);
	AddObject(o);

	// halo
	o = NewObject(1, OBJ3D_COPYVERTS | OBJ3D_COPYFACES);
	AddObject(o);

	// strips
	o = NewObject(0);
	AddObject(o);

	for (int i = 0; i < WINDSTRIP_MAX_STRIPS; i++)
	{
		mystrip[i] = new TStripAnimator(o, WINDSTRIP_POINTS);
		mystrip[i]->SetWidth(WINDSTRIP_WIDTH, WINDSTRIP_WIDTH2);
		mystrip[i]->SetTextureRange((float)-1, (float)1);
	}
	//PS3DAnimObj me = GetObject(0);
	//PS3DAnimObj metoo = GetObject(1);
	//int ok = 2;
}

void TWindStripAnimator::Animate(BOOL draw) 
{
	int	j, i;
	D3DVECTOR p;
	
	T3DAnimator::Animate(draw);
	inst->SetCommandDone(FALSE);

	/*if(inst->GetState() == STRIP_EXPLODE)
	{		
		for(i = 0; i < ADD_FACTOR; ++i)
			mystrip->DelEndPoint();
	}*/

	if (drops == NULL)
		return;

	for (j = 0; j < WINDSTRIP_MAX_STRIPS; j++)
	{
		if (frameon == 0)
		{
			for (i = 0; i < WINDSTRIP_POINTS / 2; i++)
			{
				p.x = (float)((cos(r[j]) + 2) * cos(th[j]) * WINDSTRIP_MODIFIER * ac[j] * (sin(h[j]) + 1));
				p.y = (float)((cos(r[j]) + 2) * sin(th[j]) * WINDSTRIP_MODIFIER * ac[j] * (sin(h[j]) + 1));
				p.z = (float)(sin(h[j]) * WINDSTRIP_MODIFIERV * ac[j]);
				mystrip[j]->AddPoint(&p);
				th[j] += (float)dth[j];
				r[j] += (float)dr[j];
				h[j] += (float)dh[j];
				ac[j] += (float)dac[j];
				if (ac[j] > 5.0)
					ac[j] = (float)5.0;
			}
		}
		else
		{
			mystrip[j]->DelStartPoint();
			p.x = (float)((cos(r[j]) + 2) * cos(th[j]) * WINDSTRIP_MODIFIER * ac[j] * (sin(h[j]) + 1));
			p.y = (float)((cos(r[j]) + 2) * sin(th[j]) * WINDSTRIP_MODIFIER * ac[j] * (sin(h[j]) + 1));
			p.z = (float)(sin(h[j]) * WINDSTRIP_MODIFIERV * ac[j]);
			mystrip[j]->AddPoint(&p);
			th[j] += (float)dth[j];
			r[j] += (float)dr[j];
			h[j] += (float)dh[j];
			p.x += center.x;
			p.y += center.y;
			p.z += center.z;
			AddDrop(p);
			if (frameon < WINDSTRIP_FADEOUT)
			{
				ac[j] += (float)dac[j];
				if (ac[j] > 5.0)
					ac[j] = (float)5.0;
			}
			else
			{
				ac[j] -= (float)dac[j];
				if (ac[j] < 0.0)
					ac[j] = (float)0.0;
			}
			if (frameon < WINDSTRIP_FADEOUT / 2)
				haloscale += (float)WINDSTRIP_HALOSTEP;
			if (frameon > (WINDSTRIP_FADEOUT * 3) / 2)
				haloscale -= (float)WINDSTRIP_HALOSTEP;
		}
	}
	for (i = 0; i < WINDSTRIP_NUMSPARKS; i++)
	{
		if (!drops[i].used)
			continue;
		drops[i].pos.x += drops[i].vel.x;
		drops[i].pos.y += drops[i].vel.y;
		drops[i].pos.z += drops[i].vel.z;
		drops[i].vel.z -= (float)WINDSTRIP_SPARKGRAV;
		drops[i].scl -= (float)WINDSTRIP_SPARKDSCALE;
		if (drops[i].scl <= 0 || drops[i].pos.z < 20)
			drops[i].used = FALSE;
	}
	if(inst->GetState() == STRIP_EXPLODE || frameon > WINDSTRIP_DURATION)
	{
		delete drops;
		drops = NULL;
		inst->SetCommandDone(TRUE);
	}
	frameon++;
	PTObjectInstance invoker = ((PTEffect)inst)->GetSpell()->GetInvoker();
	S3DPoint vel;
	ConvertToVector(centerang, WINDSTRIP_RADIUS, vel);
	center.x += (float)vel.x;
	center.y += (float)vel.y;
	ConvertToVector(centerang + invoker->GetFace(), WINDSTRIP_RADIUS, vel);
	realpos.x += vel.x;
	realpos.y += vel.y;
	centerang = (centerang + random(-2, 2)) & 255;

	if (!(frameon % 5))
	{					
		S3DPoint pos, thepos;
		((PTEffect)inst)->GetPos(thepos);
		pos.x = (int)(thepos.x + realpos.x);
		pos.y = (int)(thepos.y + realpos.y);
		pos.z = (int)(thepos.z + realpos.z - 70);
		DamageCharactersInRange(invoker, pos, 50, 5, 10, DAMAGE_SLASHING);
	}
}

BOOL TWindStripAnimator::Render()
{

	if (drops == NULL)
		return TRUE;
	
	int i, j;
	PS3DAnimObj obj, o;

    SaveBlendState();
    SetBlendState();

	// So I can render any face
	// vars for rendering
	DWORD oldcullmode;
	DWORD oldsrcmode;
	DWORD olddestmode;
	DWORD oldblendstate;

	// save the render state
	Device2->GetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, &oldblendstate);
	Device2->GetRenderState(D3DRENDERSTATE_CULLMODE, &oldcullmode);
	Device2->GetRenderState(D3DRENDERSTATE_SRCBLEND, &oldsrcmode);
	Device2->GetRenderState(D3DRENDERSTATE_DESTBLEND, &olddestmode);

	// set the new render flags
	Device2->SetRenderState(D3DRENDERSTATE_CULLMODE, D3DCULL_NONE);
	Device2->SetRenderState(D3DRENDERSTATE_SRCBLEND, D3DBLEND_SRCALPHA);
	Device2->SetRenderState(D3DRENDERSTATE_DESTBLEND, D3DBLEND_INVSRCALPHA);
	Device2->SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, TRUE);

// WindStrip
	if(inst->GetState() != STRIP_EXPLODE)
	{
		// Reset render extents
		for (j = 0; j < WINDSTRIP_MAX_STRIPS; j++)
		{
			ResetExtents();
			// Face strip to our absolute angle	
			
			mystrip[j]->GenerateStrip(0);//inst->GetFace());
			obj = mystrip[j]->GetStripObj();

			obj->flags |= OBJ3D_MATRIX;
			D3DMATRIXClear(&obj->matrix);		
		
			// translate to place should be
			obj->pos.x = (D3DVALUE)center.x;
			obj->pos.y = (D3DVALUE)center.y;
			obj->pos.z = (D3DVALUE)center.z;
			D3DMATRIXTranslate(&obj->matrix, &obj->pos);

			//for (i = 0; i < obj->numverts; i++)
				//obj->lverts[i].color = D3DRGBA(0.0, 0.0, 1.0, (obj->numverts - i - 1) / obj->numverts);

			RenderObject(obj);
			// Update bounding rect and screen rect
			UpdateExtents();
		}
		
		o = GetObject(0);
		for (i = 0; i < WINDSTRIP_NUMSPARKS; i++)
		{
			if (!drops[i].used || random(0, 1))
				continue;

			o->flags = OBJ3D_MATRIX;
			D3DMATRIXClear(&o->matrix);		
					
			o->scl.x = (D3DVALUE)(drops[i].scl);
			o->scl.y = (D3DVALUE)(drops[i].scl);
			o->scl.z = (D3DVALUE)(drops[i].scl);
			D3DMATRIXScale(&o->matrix, &o->scl);
			// rotate to face screen
			D3DMATRIXRotateX(&o->matrix, -(float)(M_PI / 2.0));
			//D3DMATRIXRotateX(&o->matrix, -(float)(M_PI / 6.0));
			D3DMATRIXRotateZ(&o->matrix, -(float)(M_PI / 4.0));
			D3DMATRIXRotateZ(&o->matrix, D3DVAL(-((inst->GetFace() * 360) / 256) * TORADIAN));
			// translate to place should be
			o->pos.x = (D3DVALUE)drops[i].pos.x;
			o->pos.y = (D3DVALUE)drops[i].pos.y;
			o->pos.z = (D3DVALUE)drops[i].pos.z;
			D3DMATRIXTranslate(&o->matrix, &o->pos);

			ResetExtents();
			RenderObject(o);
			UpdateExtents();						
		}

		SetAddBlendState();
		obj = GetObject(1);
		if (haloscale > 0)
		{
			ResetExtents();
			// clear matrix and get ready to transform and render
			D3DMATRIXClear(&obj->matrix);
			obj->flags = OBJ3D_MATRIX;
			// scale to size of spark
			obj->scl.x = obj->scl.y = obj->scl.z = (D3DVALUE)haloscale;
			D3DMATRIXScale(&obj->matrix, &obj->scl);
			// rotate to face screen
			D3DMATRIXRotateX(&obj->matrix, -(float)(M_PI / 2.0));
			//D3DMATRIXRotateX(&obj->matrix, -(float)(M_PI / 6.0));
			D3DMATRIXRotateZ(&obj->matrix, -(float)(M_PI / 4.0));
			D3DMATRIXRotateZ(&obj->matrix, D3DVAL(-((inst->GetFace() * 360) / 256) * TORADIAN));
			// translate to place should be
			obj->pos.x = (D3DVALUE)center.x;
			obj->pos.y = (D3DVALUE)center.y;
			obj->pos.z = (D3DVALUE)(center.z + haloscale);
			D3DMATRIXTranslate(&obj->matrix, &obj->pos);
			RenderObject(obj);
			UpdateExtents();
		}
	}
// End WindStrip

	// restore the old render flags
	Device2->SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, oldblendstate);
	Device2->SetRenderState(D3DRENDERSTATE_CULLMODE, oldcullmode);
	Device2->SetRenderState(D3DRENDERSTATE_SRCBLEND, oldsrcmode);
	Device2->SetRenderState(D3DRENDERSTATE_DESTBLEND, olddestmode);

    RestoreBlendState();

	return TRUE;
}

void TWindStripAnimator::RefreshZBuffer()
{
	S3DPoint screen_pos;
	S3DPoint map_pos;

	S3DPoint effect_pos;

	((PTEffect)inst)->GetPos(effect_pos);

	WorldToScreen(effect_pos, screen_pos);

	S3DPoint size;
	size.x = 620;
	size.y = 400;

	RestoreZ(screen_pos.x - (size.x / 2), screen_pos.y - (size.y / 2), size.x, size.y);
}

void TWindStripAnimator::InitDrops()
{
	drops = new SDropSparkSystem[WINDSTRIP_NUMSPARKS];
	for (int i = 0; i < WINDSTRIP_NUMSPARKS; i++)
	{
		drops[i].used = FALSE;
	}
}

void TWindStripAnimator::AddDrop(D3DVECTOR pos)
{
	int p = -1, i;
	for (i = 0; i < WINDSTRIP_NUMSPARKS; i++)
	{
		if (drops[i].used)
			continue;
		p = i;
	}
	if (p > -1)
	{
		drops[p].pos.x = pos.x;
		drops[p].pos.y = pos.y;
		drops[p].pos.z = pos.z;
		drops[p].vel.x = (float)0;
		drops[p].vel.y = (float)0;
		drops[p].vel.z = (float)-WINDSTRIP_SPARKFALL;
		drops[p].scl = (float)WINDSTRIP_SPARKSCALE;
		drops[p].used = TRUE;
	}
}
// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                   Surface.cpp - TSurface Object                       *
// *************************************************************************

#include "revenant.h"
#include "surface.h"
#include "font.h"
#include "display.h"

// If this is TRUE, surfaces are unlocked as soon as we have the pointer.  This is great for
// debugging, and seems to work fine on every video card except for the VooDoo and VooDoo 2
//
// If you notice graphics getting screwed up, try setting this to FALSE..  This should always
// be false if _DEBUG is not defined.

TSurface::TSurface()
{
	locked	   = NULL;
	width      = height = stride = 0;
	clipx      = clipy  = 0;
	clipwidth  = width;
	clipheight = height;
	
	clipmode   = CLIP_EDGES; 
}

TSurface::~TSurface()
{
}

void TSurface::Reset()
{
	SetOrigin(0, 0);
	SetClipRect(0, 0, width, height);
	SetClipMode(CLIP_EDGES);
}

// This function sets up the ParamDraw DrawParam structure.  This function is also
// called in higher level surfaces before being called here, so MAKE SURE that it
// can be called multiple times without continuously adding values like registration
// offsets each time.

BOOL TSurface::ParamDrawSetup(RSDrawParam dpv, PTBitmap bitmap)
{
  // Set drawmode to bitmap drawmode if DM_USEDEFAULT
	if (dpv.drawmode == DM_USEDEFAULT)
	{
		if (bitmap != NULL)
			dpv.drawmode = bitmap->drawmode;
		else
			dpv.drawmode = DM_DEFAULT;
	}

  // If surface is wrap clipping and drawmode isn't, set drawmode
	if ((clipmode == CLIP_WRAP) &&
	  !(dpv.drawmode & (DM_WRAPCLIP | DM_WRAPCLIPSRC | DM_NOWRAPCLIP)))
		dpv.drawmode |= DM_WRAPCLIP;

  // Adjust for registration point
	if (bitmap && (dpv.drawmode & DM_USEREG))
	{
		dpv.dx -= bitmap->regx;
		dpv.dy -= bitmap->regy;
		dpv.drawmode &= ~DM_USEREG; // Don't do USERGEG again
	}

  // Set up highlight color for selecting
	if (dpv.drawmode & DM_SELECTED)
	{
		SColor color = { 220, 10, 30 };
		dpv.color = TranslateColor(color);
	}

  // Set up cliping and origin
	dpv.originx		= originx;
	dpv.originy		= originy;

	dpv.clipx       = clipx;
	dpv.clipy       = clipy;
	dpv.clipwidth   = clipwidth;
	dpv.clipheight  = clipheight;

	dpv.callback	= GetDrawCallBack();

  // Do a quick clip check before we go to the trouble to lock the buffers
	int dx = dpv.dx + originx;
	int dy = dpv.dy + originy;
	if (dx + dpv.dwidth <= clipx || dy + dpv.dheight <= clipy ||
		dx >= clipx + clipwidth || dy >= clipy + clipheight)
			return FALSE;

	return TRUE;
}

// This function calls the low level graphics Draw function.. It takes care
// of wrap clipping, clipping, and decoding the DrawMode flags and DrawPrimitive
// commands.  This is THE central low level asm code drawing function for all
// graphics.  All low level graphics calls MUST go through this function or they
// WILL NOT WORK on all surface classes!

BOOL TSurface::ParamDraw(PSDrawParam dp, PTBitmap bitmap)
{
	SDrawParam dpv = *dp;  // Don't mess up the draw param struct passed to us

	if (!ParamDrawSetup(dpv, bitmap))
		return FALSE;

  // Setup drawblock and lock surfaces
	SDrawBlock  db;
	db.dstbitmapflags = flags;

  // If we have a bitmap.. use it
 	if (bitmap)  // Get bitmap for blit
	{
		db.sbufwidth      = bitmap->width;
		db.sbufheight     = bitmap->height;
		db.sstride        = bitmap->width;
		db.keycolor       = bitmap->keycolor;

      // Return now if we don't draw anything
		if (dpv.sx >= db.sbufwidth || dpv.sy >= db.sbufheight ||
			dpv.sx + dpv.swidth < 0 || dpv.sy + dpv.sheight < 0)
				return FALSE;

		db.srcbitmapflags = bitmap->flags;
		db.source         = &bitmap->data16;
		db.szbuffer		  = (WORD *)bitmap->zbuffer.ptr();
		db.szstride		  = bitmap->width;

		if (!db.szbuffer)
			db.srcbitmapflags  &= ~BM_ZBUFFER;

		db.snormals		  = (WORD *)bitmap->normal.ptr();

		if (!db.snormals)
			db.srcbitmapflags  &= ~BM_NORMALS;

		db.alpha          = (BYTE *)bitmap->alpha.ptr();

		if (!db.alpha)
			db.srcbitmapflags  &= ~BM_ALPHA;

		db.palette		  = (WORD *)bitmap->palette.ptr();
	    db.alias          = (BYTE *)bitmap->alias.ptr();

		if (!db.alias)
			db.srcbitmapflags  &= ~BM_ALIAS;
	}

	else 
	{
		db.srcbitmapflags = 0;
		db.source         = NULL;
		db.szbuffer	      = NULL; 
		db.snormals       = NULL; 
		db.palette		  = NULL;
		db.alpha		  = NULL;
	    db.alias          = NULL;
		db.sbufwidth      = 0;
		db.sbufheight     = 0;
		db.sstride        = 0;
		db.szstride       = 0;
		db.keycolor       = 0;
	}

  // Lock graphics buffer!!
	db.dest = Lock();
	if (db.dest == NULL) 
		return FALSE;  // Duh!
	if (UnlockImmediately)
		Unlock();

  // Lock z buffer
	if (GetZBuffer() == NULL || !(dp->drawmode & (DM_ZBUFFER | DM_ZSTATIC)) || 
		(bitmap && !(bitmap->flags & BM_ZBUFFER) && !(dp->drawmode & DM_ZSTATIC)))
	{
		db.dzbuffer = NULL;
		db.dzstride = 0;
		db.dstbitmapflags  &= ~BM_ZBUFFER;
	}
	else
	{
		// NoVidZBufLock - Means you can't lock the display video surface and the 
		//                 display zbuffer at the same time (voodoo cards can't do this).
		// UseClearZBuffer - Means we are using a sneaky alternate fake ZBuffer for
		//                 the Display object.  An app can get the real zbuffer surface
		//                 in this mode by calling GetRealZBuffer() for the display.
		//				   We use this sneaky buffer so we can get around the simultaneous
		//                 access problems below, and to eliminate any read/write/lock
		//                 problems a non cooperative zbuffer (i.e. voodoo) may have.
		//
		// We can get a simultaneous zbuffer/video buffer if NoVidZBufLock is FALSE,
		// or if UseClearZBuffer is TRUE, or we're not drawing to the display.

		if ((void *)this == (void *)Display && NoVidZBufLock && !UseClearZBuffer)
			db.dzbuffer = NULL;
		else
			db.dzbuffer  = (WORD *)(GetZBuffer()->Lock());

		if (db.dzbuffer == db.dest)	// Video card can only lock one buffer at a time (voodoo)
			db.dzbuffer = NULL;		// If can't lock it, don't do zbuffer draw

		if (UnlockImmediately)
			GetZBuffer()->Unlock();

		if (db.dzbuffer)
		{
			db.dstbitmapflags  |= BM_ZBUFFER;
			db.dzstride = GetZBuffer()->Stride();
		}
		else
		{
			db.dstbitmapflags  &= ~BM_ZBUFFER;
			db.dzstride = 0;
		}
	}

  // Lock normal buffer
/*	if (GetNormalBuffer() == NULL || !(dp->drawmode & DM_NORMALS) ||
		(bitmap && !(bitmap->flags & BM_NORMALS)))
	{
		db.dnormals = NULL;
		db.dstbitmapflags  &= ~BM_NORMALS;
	}
			
	else
	{
		db.dnormals	 = (WORD *)GetNormalBuffer()->Lock();
		GetNormalBuffer()->Unlock();
		if (db.dnormals)
			db.dstbitmapflags  |= BM_NORMALS;	

		else
			db.dstbitmapflags  &= ~BM_NORMALS;	
	} */
	db.dnormals = NULL;

  // Set width/height stuff
    db.dbufwidth  = width;
    db.dbufheight = height;
	db.dstride    = stride;

  // Okay baby, now do it!
	BOOL result = Draw(&db, &dpv);

	if (IsLocked())
		Unlock();
	if (GetZBuffer() && GetZBuffer()->IsLocked())
		GetZBuffer()->Unlock();

	return result;
}

BOOL TSurface::ParamBlitSetup(RSDrawParam tmpdp, PTSurface srcsurface, int flags, LPDDBLTFX fx)
{
  // Set defaults
	if (tmpdp.drawmode == DM_USEDEFAULT)
		tmpdp.drawmode = DM_DEFAULT;

  // If surface is wrap clipping and drawmode isn't, set drawmode
	if ((clipmode == CLIP_WRAP) &&
	  !(tmpdp.drawmode & (DM_WRAPCLIP | DM_WRAPCLIPSRC | DM_NOWRAPCLIP)))
		tmpdp.drawmode |= DM_WRAPCLIP;

	int sox, soy;
	if (srcsurface)
		srcsurface->GetOrigin(sox, soy);
	else
		sox = soy = 0;
	tmpdp.sx += sox;
	tmpdp.sy += soy;

	tmpdp.originx    = originx;
	tmpdp.originy    = originy;

	tmpdp.clipx      = clipx;
	tmpdp.clipy      = clipy;
	tmpdp.clipwidth  = clipwidth;
	tmpdp.clipheight = clipheight;
	
	tmpdp.callback	 = GetDrawCallBack();

	return TRUE;
}

BOOL TSurface::BlitHandler(PSDrawParam dp, PTSurface srcsurface, int flags, LPDDBLTFX fx)
{
	SDrawParam  tmpdp = *dp;
    SDrawBlock  tmpdb;

	if (!ParamBlitSetup(tmpdp, srcsurface, flags, fx))
		return FALSE;

    tmpdb.dbufwidth  = width;
    tmpdb.dbufheight = height;
	tmpdb.dstride = stride;
	tmpdb.dstbitmapflags = flags;

	if (srcsurface)
	{
	  // Voodoo can't use zbuffer as a source surface
//		if (NoVidZBufLock && srcsurface == Display->GetZBuffer())
//			return TRUE;

		tmpdb.srcbitmapflags = srcsurface->flags;
		tmpdb.keycolor   = srcsurface->KeyColor();
		tmpdb.sbufwidth  = srcsurface->Width();
		tmpdb.sbufheight = srcsurface->Height();
		tmpdb.sstride = srcsurface->Stride();

	  // Clip source
		if (!(tmpdp.drawmode & DM_WRAPCLIPSRC) &&
		   (tmpdp.sx >= tmpdb.sbufwidth || tmpdp.sy >= tmpdb.sbufheight ||
			tmpdp.sx + tmpdp.swidth < 0 || tmpdp.sy + tmpdp.sheight < 0))
				return FALSE;

		tmpdb.source = srcsurface->Lock();
		if (!tmpdb.source)
			return FALSE;
		if (UnlockImmediately)
			srcsurface->Unlock();
	}
	else
	{	
		tmpdb.srcbitmapflags = 0;
		tmpdb.sbufwidth = tmpdb.sbufheight = tmpdb.dstride = 0;
		tmpdb.source = NULL;
		tmpdb.keycolor = 0;
	}

	tmpdb.dest = Lock();
	if (!tmpdb.dest)
		return FALSE;
	if (UnlockImmediately)
		Unlock();

	if (!tmpdb.dest)
	{
		if (srcsurface && srcsurface->IsLocked())
			srcsurface->Unlock();
		return FALSE;
	}

	tmpdb.szbuffer = tmpdb.dzbuffer = NULL;
	tmpdb.szstride = tmpdb.dzstride = 0;
	tmpdb.snormals = tmpdb.dnormals = NULL;

	tmpdb.palette  = NULL;
	tmpdb.alias    = tmpdb.alpha    = NULL;

	tmpdp.drawmode &= ~(DM_ZBUFFER | DM_NORMALS | DM_ALPHA | DM_ALIAS);

	BOOL result = Draw(&tmpdb, &tmpdp);

	if (IsLocked())
		Unlock();
	if (srcsurface && srcsurface->IsLocked())
		srcsurface->Unlock();

	return result;
}

BOOL TSurface::ParamBlit(PSDrawParam dp, PTSurface surface, int flags, LPDDBLTFX fx)
{
	if (surface && surface->UseGetBlit())  // If source surface is complex, call its Get function instead
	{
		return surface->ParamGetBlit(dp, this, flags, fx);
	}

	if (!(dp->drawmode & DM_NODRAW))
	{
		if (!BlitHandler(dp, surface, flags, fx))
			return FALSE;
	}
	if (GetZBuffer() && 
		(!surface || surface->GetZBuffer()) && 
		(surface && (GetZBuffer() != surface->GetZBuffer())) &&
		(dp->drawmode & DM_ZBUFFER))
	{
		PTSurface zbuffer = NULL;
		if (surface)
			zbuffer = surface->GetZBuffer();
//		if ((void *)this == (void *)Display && NoVidZBufLock)
//		{
//			dp->drawmode |= DM_NOHARDWARE;
//		}
		if (!GetZBuffer()->BlitHandler(dp, zbuffer, flags, fx))
			 return FALSE;
	}
	if (GetNormalBuffer() && 
		(!surface || surface->GetNormalBuffer()) &&
		(surface && (GetNormalBuffer() != surface->GetNormalBuffer())) &&
		(dp->drawmode & DM_NORMALS))
	{
		PTSurface normals = NULL;
		if (surface)
			normals = surface->GetNormalBuffer();
		if (!GetNormalBuffer()->BlitHandler(dp, normals, flags, fx))
			return FALSE;
	}

	return TRUE;
}

BOOL TSurface::ParamGetBlit(PSDrawParam dp, PTSurface surface, int flags, LPDDBLTFX fx)
{
	return surface->ParamBlit(dp, this, flags, fx);
}

BOOL TSurface::Put(int x, int y, PTBitmap bitmap, DWORD drawmode, PSColor color)
{ 
	if (!bitmap)
		return FALSE;

	SDrawParam dp;
	MakeDP(dp, x, y, 0, 0, bitmap->width, bitmap->height, drawmode);

	if (color)
	{
		dp.color = TranslateColor(*color);
		dp.drawmode |= DM_CHANGECOLOR;
	}

    return ParamDraw(&dp, bitmap); 
}

BOOL TSurface::PutHue(int x, int y, PTBitmap bitmap, DWORD drawmode, int hue)
{ 
	if (!bitmap)
		return FALSE;

	SDrawParam dp;
	MakeDP(dp, x, y, 0, 0, bitmap->width, bitmap->height, drawmode);

	dp.color = hue;
	dp.drawmode |= DM_CHANGEHUE;

    return ParamDraw(&dp, bitmap); 
}

BOOL TSurface::PutSV(int x, int y, PTBitmap bitmap, DWORD drawmode, int saturation, int brightness)
{ 
	if (!bitmap)
		return FALSE;

	SDrawParam dp;
	MakeDP(dp, x, y, 0, 0, bitmap->width, bitmap->height, drawmode);

	saturation &= 0xFF;
	brightness &= 0xFF;

	dp.color = (saturation << 8) | brightness;
	dp.drawmode |= DM_CHANGESV;

    return ParamDraw(&dp, bitmap); 
}

BOOL TSurface::PutDim(int x, int y, PTBitmap bitmap, DWORD drawmode, int dim)
{ 
	if (!bitmap)
		return FALSE;

	SDrawParam dp;
	MakeDP(dp, x, y, 0, 0, bitmap->width, bitmap->height, drawmode);

	dp.intensity = 31 - min(31, dim);

    return ParamDraw(&dp, bitmap);
}

BOOL TSurface::ZPut(int x, int y, int z, PTBitmap bitmap, DWORD drawmode)
{ 
	SDrawParam dp; 
	MakeDP(dp, x, y, 0, 0, bitmap->width, bitmap->height, drawmode);
	dp.zpos = (WORD)z;
    return ParamDraw(&dp, bitmap); 
}

BOOL TSurface::ZPutDim(int x, int y, int z, PTBitmap bitmap, DWORD drawmode, int dim, PSColor color)
{ 
	SDrawParam dp; 
	MakeDP(dp, x, y, 0, 0, bitmap->width, bitmap->height, drawmode);
	dp.zpos = (WORD)z;
	dp.intensity = 31 - min(31, dim);
	if (color)
		dp.color = TranslateColor(*color);
	else
		dp.color = 0xffff;

    return ParamDraw(&dp, bitmap); 
}

DWORD TSurface::ZFind(int x, int y, int z, PTBitmap bitmap, DWORD drawmode)
{ 
	SDrawParam dp; 
	MakeDP(dp, x, y, 0, 0, bitmap->width, bitmap->height, drawmode);
	dp.func = ::ZFind;
	dp.zpos = (WORD)z;

	return ParamDraw(&dp, bitmap);
}

BOOL TSurface::Box(int dx, int dy, int dwidth, int dheight, 
	 DWORD color, WORD zpos, WORD normal, DWORD drawmode)
{ 
	if (drawmode & DM_USEDEFAULT)
		drawmode = DM_ZBUFFER | DM_NORMALS;

	SDrawParam dp; 
	MakeDP(dp, dx, dy, 0, 0, dwidth, dheight, drawmode);

	dp.func = ::Box;
	
	dp.zpos      = zpos;
	dp.normal    = normal;
	dp.color	 = color;

	return ParamDraw(&dp);
}

BOOL TSurface::Line(int x1, int y1, int x2, int y2, SColor &color, DWORD drawmode)
{
		SDrawParam dp;
		SLineParam lp;

		MakeDP(dp, x1, y1, x1, y1, x2 - x1 + 1, y2 - y1 + 1, drawmode);
		dp.func = LineDraw;
		dp.color = TranslateColor(color);
		dp.data = (void *)&lp;
		lp.x1 = x1;
		lp.y1 = y1;
		lp.x2 = x2;
		lp.y2 = y2;

	    return ParamDraw(&dp); 
}

BOOL TSurface::Rect(int x, int y, int w, int h, SColor &color, DWORD drawmode)
{
	if (!Line(x, y, x + w - 1, y, color, drawmode))
		return FALSE;
	if (!Line(x, y + 1, x, y + h - 2, color, drawmode))
		return FALSE;
	if (!Line(x + w - 1, y + 1, x + w - 1, y + h - 2, color, drawmode))
		return FALSE;
	if (!Line(x, y + h - 1, x + w - 1, y + h - 1, color, drawmode))
		return FALSE;
	return TRUE;
}

int TSurface::WriteText(char *text, int x, int y, int numlines, PTFont font, PSColor color,
						 DWORD drawmode, int wrapwidth, int startline, int justify, int hue, int linespace)
{
	if (!text || !*text)
		return TRUE;

	SDrawParam dp; 
	STextParam tp;

	MakeDP(dp, x, y, 0, 0, width, height, drawmode);
	if (drawmode == DM_USEDEFAULT)
		dp.drawmode = FONT_DRAWMODE;
	else
		dp.drawmode = drawmode;
	dp.dx = x;
	dp.dy = y;
	dp.dwidth  = width;
	dp.dheight = height;
	dp.func = TextDraw;
	dp.data = (void *)&tp;

	tp.text = text;
	tp.numlines = numlines;
	tp.font = font;
	tp.wrapwidth = wrapwidth;
	tp.startline = startline;
	tp.justify = justify;
	tp.draw = TRUE;
	tp.length = 0; // Length of text drawn
	tp.noclip = drawmode & DM_NOCLIP;		// save noclip value
	tp.linespace = linespace;
	dp.drawmode |= DM_NOCLIP;				// then set it temporarily

	if (color)
	{
		dp.drawmode |= DM_CHANGECOLOR;
		dp.color = TranslateColor(*color);
	}
	else if (hue >= 0)
	{
		dp.drawmode |= DM_CHANGEHUE;
		dp.color = hue;
	}
	else
		dp.color = 0;

	ParamDraw(&dp);

	return tp.length;
};

int TSurface::WriteTextShadow(char *text, int x, int y, int numlines, PTFont font, PSColor color,
							   DWORD drawmode, int wrapwidth, int startline, int justify, int hue, int linespace)
{
	SColor black = { 0, 0, 0 };
	WriteText(text, x + 1, y + 1, numlines, font, &black, drawmode, wrapwidth, startline, justify, linespace);
	int len = WriteText(text, x, y, numlines, font, color, drawmode, wrapwidth, startline, justify, hue, linespace);

	return len;
}
// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                   talisman.cpp - TTalisman module                     *
// *************************************************************************

#include "revenant.h"
#include "talisman.h"
#include "spell.h"

REGISTER_BUILDER(TTalisman)

TObjectClass TalismanClass("TALISMAN", OBJCLASS_TALISMAN, 0);

DEFSTAT(Talisman, Value,		VAL,  0, 0, 0, 1000000)
DEFSTAT(Talisman, Order,		ORDR, 1, 0, -10, 10)
DEFSTAT(Talisman, Power,		POWR, 2, 0, -10, 10)
DEFSTAT(Talisman, Earth,		ERTH, 3, 0, -10, 10)
DEFSTAT(Talisman, Fire,			FIRE, 4, 0, -10, 10)
DEFSTAT(Talisman, Lightning,	LITN, 5, 0, -10, 10)
DEFSTAT(Talisman, Ice,			ICE,  6, 0, -10, 10)
DEFSTAT(Talisman, Destruction,	DEST, 7, 0, -10, 10)
DEFSTAT(Talisman, Healing,		HEAL, 8, 0, 0, 1)

void TTalisman::AddToInventory(PTObjectInstance oi)
{
	TObjectInstance::AddToInventory(oi);

	if (strcmp(oi->GetTypeName(), "Spell Pouch") == 0)
		SpellPane.Update();
}

// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *           template.cpp - FORSAKEN terrain template routines           *
// *************************************************************************

#include <stdio.h>

#include "revenant.h"
#include "template.h"
#include "parse.h"
#include "object.h"
#include "sector.h"
#include "mappane.h"

extern TObjectClass TileClass;

TTerrainTemplate::TTerrainTemplate()
{
	memset(templates, 0, sizeof(STemplate) * MAXTEMPLATES);
	numtemplates = 0;
	Load();
}

TTerrainTemplate::~TTerrainTemplate()
{
	Save();
}

BOOL TTerrainTemplate::Load()
{
	FILE *fp = popen(TEMPLATEFILENAME, "rb");
	if (!fp)
		return FALSE;

	TFileParseStream s(fp, TEMPLATEFILENAME);
	TToken t(s);
	t.Get();

	while (t.Type() != TKN_EOF)
	{
		if (t.Type() != TKN_IDENT || !t.Is("template"))
			FatalError("'template' identifier expected");
		else
		{
			if (numtemplates >= MAXTEMPLATES)
				break;

			// get the tile names
			t.WhiteGet();
			if (t.Type() != TKN_TEXT)
				FatalError("expected tile name following template identifier");

			do
			{
				if (templates[numtemplates].numnames >= MAXTERRAINNAMES)
					break;

				strcpy(templates[numtemplates].names[templates[numtemplates].numnames++], t.Text());
				t.WhiteGet();
				if (t.Type() == TKN_SYMBOL && t.Code() == ',')
					t.WhiteGet();
			} while (t.Type() == TKN_TEXT);

			t.LineGet();
			t.DoBegin();

			// get the objects for the template
			while ((t.Type() != TKN_KEYWORD || t.Code() != KEY_END) && t.Type() != TKN_EOF)
			{
				if (templates[numtemplates].numobjects >= MAXOBJECTREFS)
					break;

				if (t.Type() != TKN_TEXT)
					FatalError("expected tile name in template object list");

				strcpy(templates[numtemplates].objects[templates[numtemplates].numobjects].name, t.Text());

				t.WhiteGet();
				if (t.Type() != TKN_NUMBER)
					FatalError("expected tile x offset in template object list");
				templates[numtemplates].objects[templates[numtemplates].numobjects].offset.x = t.Index();

				t.WhiteGet();
				if (t.Type() == TKN_SYMBOL && t.Code() == ',')
					t.WhiteGet();
				if (t.Type() != TKN_NUMBER)
					FatalError("expected tile y offset in template object list");
				templates[numtemplates].objects[templates[numtemplates].numobjects].offset.y = t.Index();

				t.WhiteGet();
				if (t.Type() == TKN_SYMBOL && t.Code() == ',')
					t.WhiteGet();
				if (t.Type() != TKN_NUMBER)
					FatalError("expected tile z offset in template object list");
				templates[numtemplates].objects[templates[numtemplates].numobjects].offset.z = t.Index();

				templates[numtemplates].numobjects++;
				t.LineGet();
			}

			numtemplates++;

			t.DoEnd();
		}
	}

	fclose(fp);
	return TRUE;
}

BOOL TTerrainTemplate::Save()
{
	FILE *fp = popen(TEMPLATEFILENAME, "wb");
	if (!fp)
		return FALSE;

	for (int t = 0; t < numtemplates; t++)
	{
		fprintf(fp, "template ");
		for (int n = 0; n < templates[t].numnames; n++)
		{
			if (n > 0)
				fprintf(fp, ", ");

			fprintf(fp, "\"%s\"", templates[t].names[n]);
		}

		fprintf(fp, "\r\nbegin\r\n");

		for (int o = 0; o < templates[t].numobjects; o++)
		{
			fprintf(fp, "\t\"%s\" %d, %d, %d\r\n", templates[t].objects[o].name,
					templates[t].objects[o].offset.x, templates[t].objects[o].offset.y,
					templates[t].objects[o].offset.z);
		}

		fprintf(fp, "end\r\n\r\n");
	}

	fclose(fp);

	return TRUE;
}

int TTerrainTemplate::NewTemplate(char *tilename)
{
	if (numtemplates >= MAXTEMPLATES)
		return -1;

	strcpy(templates[numtemplates].names[0], tilename);
	templates[numtemplates].numnames = 1;
	templates[numtemplates].numobjects = 0;

	return numtemplates++;
}

int TTerrainTemplate::AddObject(int index, PTObjectInstance inst, S3DPoint offset)
{
	if ((DWORD)index >= MAXTEMPLATES ||
		templates[index].numobjects >= MAXOBJECTREFS)
		return -1;

	strcpy(templates[index].objects[templates[index].numobjects].name, inst->GetTypeName());
	templates[index].objects[templates[index].numobjects].offset = offset;

	return templates[index].numobjects++;
}

#define MAXFOUND	32

void TTerrainTemplate::ApplyTemplate(PTObjectInstance inst, PTSector sect, int density)
{
	if (!inst || !sect)
		return;

	char *name = inst->GetTypeName();
	int foundlist[MAXFOUND];
	int numfound = 0;

	BOOL found = FALSE;
	for (int t = 0; t < numtemplates && numfound < MAXFOUND; t++)
		for (int n = 0; n < templates[t].numnames && numfound < MAXFOUND; n++)
			if (stricmp(templates[t].names[n], name) == 0)
				foundlist[numfound++] = t;

	if (numfound < 1)
		return;

	t = foundlist[random(0, numfound - 1)];

	S3DPoint pos;
	inst->GetPos(pos);

	for (int i = 0; i < templates[t].numobjects; i++)
	{
		if (random(1, MAXDENSITY) > density)
			continue;

		SObjectDef def;
		memset(&def, 0, sizeof(SObjectDef));

		def.objclass = OBJCLASS_TILE;
		def.objtype = TileClass.FindObjType(templates[t].objects[i].name);
		def.flags = OF_GENERATED;
		def.pos.x = pos.x + templates[t].objects[i].offset.x;
		def.pos.y = pos.y + templates[t].objects[i].offset.y;
		def.pos.z = pos.z + templates[t].objects[i].offset.z;
		def.level = MapPane.GetMapLevel();

		inst = TileClass.NewObject(&def);
		if (inst)
			sect->AddObject(inst);
	}
}
// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                     textbar.cpp - Text Bar Pane                       *
// *************************************************************************

#include <stdlib.h>
#include <stdarg.h>

#include "revenant.h"
#include "textbar.h"
#include "display.h"
#include "multi.h"
#include "object.h"

BOOL TTextBar::Initialize()
{
	TPane::Initialize();

	text[0] = 0;
	name[0] = 0;
	animating = FALSE;
	SetDirty(TRUE);
	return TRUE;
}

void TTextBar::Close()
{
}

#define HEALTH_INCREMENT	4

void TTextBar::DrawBackground()
{
	BOOL drawhealth = name[0];

	if (animating || (drawhealth && targetlevel != level) || IsDirty())
	{
		DWORD drawmode;

		if (drawhealth)
		{
			if (absval(targetlevel - level) <= HEALTH_INCREMENT)
				level = targetlevel;
			else if (targetlevel > level)
				level += HEALTH_INCREMENT;
			else if (level > targetlevel)
				level -= HEALTH_INCREMENT;
		}

		if (drawhealth && targetlevel != level)
		{
			animating = TRUE;
			drawmode = DM_NORESTORE;
		}
		else
		{
			animating = FALSE;
			drawmode = DM_BACKGROUND;
		}

		Display->Box(0, 0, GetWidth(), GetHeight(), 0, 0xffff, 0, drawmode);

		if (drawhealth)
		{
			int hue = (level * 155) / 176;
			if (hue > 16)
				hue -= 16;
			else
				hue = 0;

			Display->PutHue(-(186 - level), 1, GameData->Bitmap("texthealthbar"), drawmode, hue);
			Display->WriteTextShadow(name, 2, -6, 1, GameData->Font("silverfont"), NULL, drawmode | DM_TRANSPARENT);
		}
		else
			Display->WriteText(text, 2, -6, 1, GameData->Font("silverfont"));

		SetDirty(FALSE);
	}

	if (pulsecheck)
		pulsecheck = FALSE;
	else
		ClearHealthDisplay();
}

void TTextBar::Print(char *txt, ...)
{
	va_list marker;
	va_start(marker, txt);

	name[0] = NULL;
	vsprintf(text, txt, marker);
	SetDirty(TRUE);
}

void TTextBar::SetHealthDisplay(char *n, int l)
{
	pulsecheck = TRUE;

	if (strcmp(name, n) == 0)
		targetlevel = l;
	else
	{
		strcpy(name, n);
		level = targetlevel = l;
		SetDirty(TRUE);
	}
}

void TTextBar::SetLevels(int newlevel, int newtargetlevel)
{
	if (!name[0])
		strcpy(name, text);
	level = newlevel;
	targetlevel = newtargetlevel;
}

void TTextBar::ClearHealthDisplay()
{
	if (name[0])
	{
		name[0] = 0;
		SetDirty(TRUE);
	}
}

// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                       tile.cpp - TTile module                         *
// *************************************************************************

#include "revenant.h"
#include "tile.h"

REGISTER_BUILDER(TTile)

TObjectClass TileClass("TILE", OBJCLASS_TILE, 0);

DEFSTAT(Tile, Code,			CODE, 0, -1, 0, -1)
DEFSTAT(Tile, Extra,		EXTR, 1, -1, 0, -1)
DEFSTAT(Tile, Supertile,	SUPR, 2, 0, 0, 1)
DEFSTAT(Tile, Width,		WDTH, 3, 0, 0, 16)
DEFSTAT(Tile, Height,		HGHT, 4, 0, 0, 16)
// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                   timer.cpp - Timer oject module                      *  
// *************************************************************************

#include <windows.h>
#include <mmsystem.h>

#include "revenant.h"
#include "screen.h"
#include "timer.h"

DWORD TTimer::clockticks;
DWORD period = (DWORD)(1000 / FRAMERATE);
HANDLE tickevent;

void WINAPI TTimer::TimerCallback(UINT wTimerID, UINT msg, DWORD dwUser, DWORD dw1, DWORD dw2)
{
	clockticks++;
	TickOccured = TRUE;
	PulseEvent(tickevent);
}

TTimer::TTimer()
{
	clockticks = 0;
	timerID = NULL;
}

TTimer::~TTimer()
{
	if (timerID) 
	{
		timeEndPeriod(period);
		DWORD Result = timeKillEvent(timerID);
	}
}

BOOL TTimer::Initialize()
{
	TIMECAPS tc;
	DWORD period = 1000 / FRAMERATE;

	tickevent = CreateEvent(NULL, FALSE, FALSE, NULL);

	if (timerID) return TRUE;

	if (timeGetDevCaps(&tc, sizeof(TIMECAPS)) != TIMERR_NOERROR)
		return FALSE;

	period = min(max(tc.wPeriodMin, period), tc.wPeriodMax);

	timeBeginPeriod(period);

	timerID = timeSetEvent(period, RESOLUTION, TimerCallback, NULL, TIME_PERIODIC);

	if (!timerID) return FALSE;

	return TRUE;
}

void TTimer::Close()
{
	if (timerID == NULL) 
		return;
	
	timeEndPeriod(period);
	timeKillEvent(timerID);
	timerID = NULL;
	CloseHandle(tickevent);
}
  
void TTimer::WaitForTick()
{
	if (TickOccured)
		return;

	WaitForSingleObject(tickevent, INFINITE);
}

void TTimer::ResetTick()
{
	TickOccured = FALSE;
}
// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                       tool.cpp - TTool module                         *
// *************************************************************************

#include "revenant.h"
#include "tool.h"
#include "exit.h"
#include "container.h"
#include "mappane.h"

REGISTER_BUILDER(TTool)
TObjectClass ToolClass("TOOL", OBJCLASS_TOOL, 0);

// Hard coded class stats
DEFSTAT(Tool, Value, VAL, 0, 0, 0, 1000000)
DEFSTAT(Tool, Pick, PICK, 1, 0, 0, 100)

BOOL TTool::Use(PTObjectInstance user, int with)
{
	return FALSE;
}

int TTool::CursorType(PTObjectInstance with)
{
	return CURSOR_NONE;
}

// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                       trap.cpp - TTrap module                         *
// *************************************************************************

#include "revenant.h"
#include "trap.h"
#include "mappane.h"
#include "sound.h"

REGISTER_BUILDER(TTrap)

TObjectClass TrapClass("TRAP", OBJCLASS_TRAP, 0);

// **************
// * TArrowWall *
// **************

_CLASSDEF(TArrowWall)
class TArrowWall : public TTrap
{
  public:
	TArrowWall(PTObjectImagery newim) : TTrap(newim) { Init(); }
	TArrowWall(PSObjectDef def, PTObjectImagery newim) : TTrap(def, newim) { Init(); }

	void Init();

	virtual BOOL Use(PTObjectInstance user, int with);
	virtual int CursorType(PTObjectInstance with = NULL) { return CURSOR_NONE; }

	virtual void Pulse();

  protected:
	int frame;					// what frame of fire sequence
	int lastshot;				// last frame shot was fired
	int wallfacing;				// which way to fire arrows
};

DEFINE_BUILDER("ArrowWallS", TArrowWall)
REGISTER_BUILDER(TArrowWall)

_CLASSDEF(TArrowWall2)
class TArrowWall2 : public TArrowWall
{
  public:
	TArrowWall2(PTObjectImagery newim) : TArrowWall(newim) { }
	TArrowWall2(PSObjectDef def, PTObjectImagery newim) : TArrowWall(def, newim) { }
};

DEFINE_BUILDER("ArrowWallE", TArrowWall2)
REGISTER_BUILDER(TArrowWall2)


void TArrowWall::Init()
{
	if (stricmp(GetName(), "ArrowWallS") == 0)
		wallfacing = 128;
	else
		wallfacing = 64;

	frame = -1;
}


BOOL TArrowWall::Use(PTObjectInstance user, int with)
{
	if (user == this && with == -1)
	{
		frame = 0;
		lastshot = -1;
		SoundPlayer.Mount("arrow");
	}

	return FALSE;
}

#define ARROW_FREQUENCY		12
#define ARROW_RANDOMNESS	5
#define ARROW_SPEED			(20 * ROLLOVER)
#define MAX_ARROWS			7

void TArrowWall::Pulse()
{
	extern TObjectClass AmmoClass;

	if (frame >= 0)
	{
		if (frame++ > (MAX_ARROWS * ARROW_FREQUENCY))
		{
			SoundPlayer.Unmount("arrow");
			frame = -1;
		}
		else
		{
			if ((frame + random(0, ARROW_RANDOMNESS)) > (lastshot + ARROW_FREQUENCY))
			{
				lastshot = frame;

				// generate a new arrow and fire it
				SObjectDef def;
				memset(&def, 0, sizeof(SObjectDef));
				def.objclass = OBJCLASS_AMMO;
				def.objtype = AmmoClass.FindObjType("Arrow3D");
				def.flags = OF_WEIGHTLESS;

				GetPos(def.pos);
				def.pos.x += random(-50, 50);
				def.pos.y += random(-50, 50);
				def.pos.z += 50 + random(-30, 30);
				def.level = MapPane.GetMapLevel();
				ConvertToVector(wallfacing, ARROW_SPEED, def.vel);
				def.facing = wallfacing;

				MapPane.NewObject(&def);

				SoundPlayer.Play("arrow");
			}
		}
	}
}

// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                     weapon.cpp - TWeapon module                       *
// *************************************************************************

#include "revenant.h"
#include "weapon.h"
#include "mappane.h"
#include "textbar.h"

REGISTER_BUILDER(TWeapon)
TObjectClass WeaponClass("WEAPON", OBJCLASS_WEAPON, 0);

DEFSTAT(Weapon, EqSlot,				EQSL, 0, 3, 0, 9)
DEFSTAT(Weapon, Type,				TYPE, 1, WT_HAND, WT_HAND, WT_LAST)
DEFSTAT(Weapon, Damage,				DMG,  2, 0, 0, 10000)
DEFSTAT(Weapon, Combining,			COMB, 3, 0, 0, 16)
DEFSTAT(Weapon, Poison,				PSN,  4, 0, 0, 32)
DEFSTAT(Weapon, Value,				VAL,  5, 0, 0, 1000000)

#define VIAL_STATE_FULL		0
#define VIAL_STATE_EMPTY	1

void TWeapon::ClearWeapon()
{
}

BOOL TWeapon::Use(PTObjectInstance user, int with)
{
	PTObjectInstance inst = MapPane.GetInstance(with);

	if (inst && strcmp(inst->GetName(), "Poison Vial") == 0 &&
		inst->GetState() == VIAL_STATE_FULL && Type() == WT_SHORTBLADE)
	{
		inst->SetState(VIAL_STATE_EMPTY);
		TextBar.Print("%s envenomed.", GetName());

		return TRUE;
	}

	return FALSE;
}

int TWeapon::CursorType(PTObjectInstance with)
{
	if (with && strcmp(with->GetName(), "Poison Vial") == 0 &&
		with->GetState() == VIAL_STATE_FULL && Type() == WT_SHORTBLADE)
		return CURSOR_HAND;

	return CURSOR_NONE;
}

void TWeapon::Load(RTInputStream is, int version, int objversion)
{
	TObjectInstance::Load(is, version, objversion);

	is >> poison;
}

void TWeapon::Save(RTOutputStream os)
{
	TObjectInstance::Save(os);

	os << poison;
}

// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                  Rules.cpp - TRules object module                     *
// *************************************************************************

#include "revenant.h"
#include "parse.h"
#include "character.h"
#include "player.h"
#include "weapon.h"
#include "playscreen.h"
#include "rules.h"

extern TObjectClass CharacterClass;
extern TObjectClass PlayerClass;

static char errorparsingtag[] = "Error parsing tag %s";

// Tag is tester
#define TAGIS(t) (!stricmp(tag, t))

// *********************
// * SClassData Object *
// *********************

// Loads the character from the "CHAR.DEF" file
BOOL SClassData::Load(char *aname, TToken &t)
{
	strncpyz(name, aname, RESNAMELEN);

	t.SkipBlanks();
	if (!t.Is("BEGIN"))
		t.Error("Char block BEGIN expected");
	
  // Now get first trigger token
	t.LineGet();
	
  // Iterate through the triggers and setup trigger list
	BOOL ok;
	while (t.Type() != TKN_EOF && !t.Is("END"))
	{
	  // Parse trigger tags now
		if (t.Type() != TKN_IDENT)
			t.Error("Class data keyword expected");

		char tag[40];
		strncpyz(tag, t.Text(), 40);

		t.WhiteGet();
		ok = TRUE;

      // Tags...
		if (TAGIS("STATREQS"))
		{
			for (int c = 0; c < NUM_PLRSTATS; c++)
			{
				if (c > 0)
				{
					if (!t.Is(","))
						t.Error("',' Expected");

					t.WhiteGet();
				}
			
				if (t.Type() != TKN_NUMBER)
					t.Error("Stat requirement value expected");

				statreqs[c] = t.Index();

				t.WhiteGet();
			}
		}
		else if (TAGIS("SKILLMODS"))
		{
			for (int c = 0; c < NUM_SKILLS; c++)
			{
				if (c > 0)
				{
					if (!t.Is(","))
						t.Error("',' Expected");

					t.WhiteGet();
				}
			
				if (t.Type() != TKN_NUMBER)
					t.Error("Skill modifier expected");

				skillmods[c] = t.Index();

				t.WhiteGet();
			}
		}
		else if (TAGIS("HEALTHMOD"))
		{
			ok = Parse(t, "%i", &healthmod);
		}
		else if (TAGIS("FATIGUEMOD"))
		{
			ok = Parse(t, "%i", &fatiguemod);
		}
		else if (TAGIS("MANAMOD"))
		{
			ok = Parse(t, "%i", &manamod);
		}
		else
			t.Error("Invalid class tag %s", t.Text());

		if (!ok)
			t.Error(errorparsingtag, tag);

		if (t.Type() != TKN_RETURN)
			t.Error("Return expected");

		t.LineGet();
	}

	if (!t.Is("END"))
		t.Error("Class block END expected");
	t.Get();

	return TRUE;
}

// ********************
// * SCharData Object *
// ********************

// Construct SCharData
SCharData::SCharData()
{
	objtype = -1;
	objclass = OBJCLASS_CHARACTER;

	flags = 0;
	for (int c = 0; c < NUMDAMAGETYPES; c++)
		damagemods[0] = 0;

	blockfreq = 10;
	blockmin = 5;
	blockmax = 15;

	playerblockmin = 10;
	playerblockstep = 5;
	playerblockinc = 10;

	strcpy(blocksounds, "clang1,clang2,clang3");
	strcpy(misssounds, "");

	weapontype = WT_HAND;
	weapondamage = 2;
	armorvalue = 1;
	defensemod = 0;
	attackmod = 0;

	sightmin = 30; sightmax = 100; sightrange = 64 * 5; sightangle = 64;
	hearingmin = 10; hearingmax = 50; hearingrange = 64 * 5;
}

// Destroy SCharData
SCharData::~SCharData()
{
	attacks.Clear();
}

// Loads the character from the "CHAR.DEF" file
BOOL SCharData::Load(char *aname, TToken &t)
{
	strncpyz(name, aname, RESNAMELEN);

	if (!stricmp(name, "Default"))
	{
		objtype = -1; objclass = -1;
	}
	else
	{
		objtype = CharacterClass.FindObjType(name);
		if (objtype < 0)
		{
			objtype = PlayerClass.FindObjType(name);
			if (objtype < 0)
				t.Error("Invalid character type %s", name);
			else
				objclass = OBJCLASS_PLAYER;
		}
		else
			objclass = OBJCLASS_CHARACTER;
	}

	t.SkipBlanks();
	if (!t.Is("BEGIN"))
		t.Error("Char block BEGIN expected");
	
  // Now get first trigger token
	t.LineGet();
	
  // Iterate through the triggers and setup trigger list
	BOOL ok;
	while (t.Type() != TKN_EOF && !t.Is("END"))
	{
	  // Parse trigger tags now
		if (t.Type() != TKN_IDENT)
			t.Error("Char data keyword expected");

		char tag[40];
		strncpyz(tag, t.Text(), 40);

		t.WhiteGet();
		ok = TRUE;

      // Tags...
		if (TAGIS("ATTACK"))
		{
			SCharAttackData ad;

			ok = Parse(t, "%30s, %i, %i, %30s, %30s, %30s, %30s, %30s, "
				"%i, %i, %i, %i, %i, %i, %i, %i, %i, %i, %i, %i, %i, %i, %i, %i, %i",
				ad.attackname, &ad.flags, &ad.button, ad.responsename,
				ad.impactname, ad.blockname, ad.missname, ad.deathname, 
				&ad.blocktime, &ad.impacttime, &ad.waittime, &ad.stunwait, &ad.combowait, 
				&ad.mindist, &ad.maxdist, &ad.snapdist, &ad.hitminrange, &ad.hitmaxrange,
				&ad.hitangle, &ad.damagemod, &ad.fatigue, &ad.attackskill, 
				&ad.weaponmask, &ad.weaponskill, &ad.attackpcnt);

			if (ok)
			{
				if (ad.responsename[0] != NULL)
					ad.flags |= CA_RESPONSE;

				attacks.Add(ad);
			}
		}
		else if (TAGIS("CLASS"))
		{
			if (objclass == OBJCLASS_CHARACTER)
				t.Error("Monsters/NPC's do not have character classes");

			char classname[RESNAMELEN];
			ok = Parse(t, "%30s", classname);
			if (ok)
				classdata = Rules.GetClass(classname);
		}
		else if (TAGIS("DAMAGEMODS"))
		{
			for (int c = 0; c < NUMDAMAGETYPES; c++)
			{
				if (c > 0)
				{
					if (!t.Is(","))
						t.Error("',' Expected");

					t.WhiteGet();
				}
			
				if (t.Type() != TKN_NUMBER)
					t.Error("Damage type modifier expected");

				damagemods[c] = t.Index();

				t.WhiteGet();
			}
		}
		else if (TAGIS("FLAGS"))
		{
			ok = Parse(t, "%i", flags);
		}
		else if (TAGIS("BLOCK"))
		{
			ok = Parse(t, "%i, %i, %i", &blockfreq, &blockmin, &blockmax);
		}
		else if (TAGIS("PLAYERBLOCK"))
		{
			ok = Parse(t, "%i, %i, %i", &playerblockmin, &playerblockstep, &playerblockinc);
		}
		else if (TAGIS("ARMOR"))
		{
			ok = Parse(t, "%i", &armorvalue);
		}
		else if (TAGIS("DEFENSEMOD"))
		{
			ok = Parse(t, "%i", &defensemod);
		}
		else if (TAGIS("ATTACKMOD"))
		{
			ok = Parse(t, "%i", &attackmod);
		}
		else if (TAGIS("ATTACKFREQ"))
		{
			ok = Parse(t, "%i, %i", &minattackfreq, &maxattackfreq);
		}
		else if (TAGIS("WEAPONTYPE"))
		{
			ok = Parse(t, "%i", &weapontype);
		}
		else if (TAGIS("WEAPONDAMAGE"))
		{
			ok = Parse(t, "%i", &weapondamage);
		}
		else if (TAGIS("BLOCKSOUNDS"))
		{
			ok = Parse(t, "%31s", blocksounds);
		}
		else if (TAGIS("MISSSOUNDS"))
		{
			ok = Parse(t, "%31s", misssounds);
		}
		else if (TAGIS("GROUPS"))
		{
			ok = Parse(t, "%48s", groups);
		}
		else if (TAGIS("ENEMIES"))
		{
			ok = Parse(t, "%48s", enemies);
		}
		else if (TAGIS("SIGHT"))
		{
			ok = Parse(t, "%i, %i, %i, %i", &sightmin, &sightmax, &sightrange, &sightangle);
		}
		else if (TAGIS("HEARING"))
		{
			ok = Parse(t, "%i, %i, %i", &hearingmin, &hearingmax, &hearingrange);
		}
		else if (TAGIS("MANA"))
		{
			ok = Parse(t, "%i", &mana);
		}
		else if (TAGIS("FATIGUE"))
		{
			ok = Parse(t, "%i", &fatigue);
		}
		else if (TAGIS("HEALTH"))
		{
			ok = Parse(t, "%i", &health);
		}
		else if (TAGIS("COMBATRANGE"))
		{
			ok = Parse(t, "%i", &combatrange);
		}
		else
			t.Error("Invalid character tag %s", t.Text());

		if (!ok)
			t.Error(errorparsingtag, tag);

		if (t.Type() != TKN_RETURN)
			t.Error("Return expected");

		t.LineGet();
	}

	if (objclass == OBJCLASS_PLAYER && !classdata)
		t.Error("Class required for player characters");

	if (!t.Is("END"))
		t.Error("Char block END expected");
	t.Get();

	return TRUE;
}

// *****************
// * TRules Object *
// *****************

// Initializes character data stuff
BOOL TRules::Initialize()
{
	if (initialized)
		return TRUE;

	chardata.DeleteAll();
	classdata.DeleteAll();
	def = NULL;

	if (!Load())
		return FALSE;

	initialized = TRUE;

	return TRUE;
}

// Closes the area manager
void TRules::Close()
{
	chardata.DeleteAll();
	classdata.DeleteAll();
}

// Loads all areas from the "RULES.DEF" file
BOOL TRules::Load()
{
	char fname[MAX_PATH];
	sprintf(fname, "%s%s", ClassDefPath, "rules.def");

	FILE *fp = popen(fname, "rb");
	if (!fp)
		FatalError("Unable to find character info file RULES.DEF");

	TFileParseStream s(fp, fname);
	TToken t(s);

	if (!t.DefineGet())
		t.Error("Syntax error in header");

  // Do block loop
	BOOL ok;
	while (t.Type() != TKN_EOF)
	{
	  // Parse trigger tags now
		if (t.Type() != TKN_IDENT)
			t.Error("Rules block name or tag expected");

		char tag[40];
		strncpyz(tag, t.Text(), 40);

		t.WhiteGet();
		ok = TRUE;

      // Tags...
		if (TAGIS("DAYLENGTH"))
		{
			ok = Parse(t, "%i", &daylength);
		}
		else if (TAGIS("TWILIGHT"))
		{
			ok = Parse(t, "%i, %i", &twilight, &twilightsteps);
			if (GameSpeed == 5)
				twilightsteps = ConvertMinutesToFrames(twilight); // Smooth ambient fading
		}
		else if (TAGIS("HEALTHDATA"))
		{
			ok = Parse(t, "%i, %i, %i", &healthperlevel, &healthrecovval, &healthrecovrate);
		}
		else if (TAGIS("FATIGUEDATA"))
		{
			ok = Parse(t, "%i, %i, %i", &fatigueperlevel, &fatiguerecovval, &fatiguerecovrate);
		}
		else if (TAGIS("MANADATA"))
		{
			ok = Parse(t, "%i, %i, %i", &manaperlevel, &manarecovval, &manarecovrate);
		}
		else if (TAGIS("STEALTH"))
		{
			ok = Parse(t, "%i, %i, %i", &maxstealth, &sneakstealth, &minstealth);
		}
		else if (TAGIS("CHARACTER"))
		{

			char charname[MAXNAMELEN];
			ok = Parse(t, "%s\n", charname);
			
			if (ok)
			{
				PSCharData data = new SCharData;

				if (!data->Load(charname, t))
					t.Error("Error loading char data");
				
				chardata.Add(data);

			  // Set default char data object (-1 for objtype)	
				if (data->objtype < 0)
					def = data; 

				t.Get();
			}
		}
		else if (TAGIS("CLASS"))
		{
			char classname[RESNAMELEN];
			ok = Parse(t, "%s\n", classname);

			if (ok)
			{
				PSClassData cl = new SClassData;

				if (!cl->Load(classname, t))
					t.Error("Error loading class data");
				
				classdata.Add(cl);

				t.Get();
			}
		}
		else
			t.Error("Invalid RULES.DEF block or tag %s", t.Text());

		if (!ok)
			t.Error(errorparsingtag, tag);

		if (t.Type() != TKN_RETURN && t.Type() != TKN_EOF)
			t.Error("Return expected");
			
		if (!t.DefineGet())
			t.Error("RULES.DEF syntax error");
	}
	
	fclose(fp);

	return TRUE;
}

PSClassData TRules::GetClass(char *name)
{
	for (int c = 0; c < classdata.NumItems(); c++)
	{
		if (!stricmp(classdata[c]->name, name))
			return classdata[c];
	}

	return NULL;
}

PSCharData TRules::GetCharData(int objtype, int objclass)
{
	if (!initialized)
		return NULL;

	for (int c = 0; c < chardata.NumItems(); c++)
	{
		if (chardata[c]->objtype == objtype && chardata[c]->objclass == objclass)
			return chardata[c];
	}
	
	return def;
}
// *************************************************************************
// *                         Cinematix Revenant                            *
// *                    Copyright (C) 1998 Cinematix                       *
// *                 charanimator.cpp - TCharAnimator module               *
// *************************************************************************

#include <windows.h>

#include "character.h"
#include "charanimator.h"

TCharAnimator::TCharAnimator(PTObjectInstance oi) : T3DAnimator(oi)
{
	origmatred = new float[MAXMATERIALS];
	origmatgreen = new float[MAXMATERIALS];
	oldpoison = 0;

	S3DMat mat;
	for (int i = 0; i < Get3DImagery()->NumMaterials(); i++)
	{
		memset(&mat, 0, sizeof(S3DMat));
		Get3DImagery()->GetMaterial(i, &mat);

		D3DMATERIAL &m = mat.matdesc;
		origmatred[i] = m.ambient.r;
		origmatgreen[i] = m.ambient.g;
	}
}

TCharAnimator::~TCharAnimator()
{
	S3DMat mat;
	for (int i = 0; i < Get3DImagery()->NumMaterials(); i++)
	{
		memset(&mat, 0, sizeof(S3DMat));
		Get3DImagery()->GetMaterial(i, &mat);

		D3DMATERIAL &m = mat.matdesc;
		m.ambient.r = D3DVAL(origmatred[i]);
		m.ambient.b = D3DVAL(origmatgreen[i]);

		Get3DImagery()->SetMaterial(i, &mat);
	}

	delete [] origmatred;
	delete [] origmatgreen;

	Close();
}

void TCharAnimator::Animate(BOOL draw)
{
	T3DAnimator::Animate(draw);
}

BOOL TCharAnimator::Render()
{
	int poison = 9 * ((PTCharacter)inst)->Poisoned();

	if (poison != oldpoison)
	{
		S3DMat mat;

		float amount = ((float)10.0 - (float)poison) / (float)10.0;

		if (poison > 10)
			amount = 0.0;
		else if (poison < 0)
			amount = 1.0;

		for (int i = 0; i < Get3DImagery()->NumMaterials(); i++)
		{
			memset(&mat, 0, sizeof(S3DMat));
			Get3DImagery()->GetMaterial(i, &mat);

			D3DMATERIAL &m = mat.matdesc;

			if (amount < 0.1)
			{
				m.ambient.r = D3DVAL(origmatred[i]);
				m.ambient.b = D3DVAL(origmatgreen[i]);
			}
			else
			{
				m.ambient.r = D3DVAL(origmatred[i] * amount);
				m.ambient.b = D3DVAL(origmatgreen[i] * amount);
			}

			Get3DImagery()->SetMaterial(i, &mat);
		}
	}

	T3DAnimator::Render();

	return TRUE;
}

REGISTER_3DANIMATOR("CHARACTER", TCharAnimator)
REGISTER_3DANIMATOR("PLAYER", TPlayerAnimator)

#error chardata.cpp is now rules.cpp
